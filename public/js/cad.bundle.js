/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 24);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
function ajax() {
  var path = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var fullResponse = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  var xhr = new XMLHttpRequest();
  xhr.open(options.method || 'GET', path, true);
  if (options.headers) {
    setXHRHeaders(xhr, options.headers);
  }
  xhr.send(options.data);

  return new Promise(function (resolve, reject) {
    xhr.onreadystatechange = function () {
      if (xhr.readyState == 4) {
        if (xhr.status == 200) {
          if (fullResponse) {
            resolve(xhr);
          } else {
            resolve(xhr.responseText);
          }
        } else {
          reject(xhr.statusText);
        }
      }
    };
  });
}

function setXHRHeaders(xhr, headers) {
  for (var header in headers) {
    xhr.setRequestHeader(header, headers[header]);
  }
}

exports.default = ajax;

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var pubsub = function () {

  var topics = {};

  return {
    subscribe: function subscribe(topic, listener) {
      if (!topics[topic]) topics[topic] = { queue: [] };

      var index = topics[topic].queue.push(listener) - 1;
      // function to delete topic
      return {
        remove: function remove() {
          delete topics[topic].queue[index];
        }
      };
    },

    publish: function publish(topic, info) {
      // no theme or no listeners
      if (!topics[topic] || !topics[topic].queue.length) return;

      var items = topics[topic].queue;
      items.forEach(function (item) {
        item(info || {});
      });
    }
  };
}();

exports.default = pubsub;

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var nodeFactory = function nodeFactory() {
  var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'div';
  var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var node = document.createElement(type);

  appendClasses(node, params);
  appendAttrs(node, params);
  insertTextContent(node, params);

  return node;
};

function appendClasses(node, _ref) {
  var classList = _ref.classList;

  if (classList && classList.forEach) {
    classList.forEach(function (className) {
      return node.classList.add(className);
    });
  }
}

function appendAttrs(node, _ref2) {
  var attrs = _ref2.attrs;

  if (attrs) {
    var attrNames = Object.keys(attrs);
    attrNames.forEach(function (attrName) {
      return node.setAttribute(attrName, attrs[attrName]);
    });
  }
}

function insertTextContent(node, _ref3) {
  var _ref3$textContent = _ref3.textContent,
      textContent = _ref3$textContent === undefined ? "" : _ref3$textContent;

  node.textContent = textContent;
}

exports.default = nodeFactory;

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var DEFAULT_STATE_NAME = exports.DEFAULT_STATE_NAME = 'Состояние';
var DEFAULT_TOOL_NAME = exports.DEFAULT_TOOL_NAME = 'Прибор';

var TOOL_TYPES = exports.TOOL_TYPES = ['switch', 'range'];
var DEFAULT_TOOL_TYPE = exports.DEFAULT_TOOL_TYPE = TOOL_TYPES[0];

var DEFAULT_IMAGE_ID = exports.DEFAULT_IMAGE_ID = '59a6bfd49bdf6c29d0ce82d0';

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.handleHeaderClick = handleHeaderClick;
exports.handleAddBtnClick = handleAddBtnClick;

var _v = __webpack_require__(5);

var _v2 = _interopRequireDefault(_v);

var _pubsub = __webpack_require__(1);

var _pubsub2 = _interopRequireDefault(_pubsub);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function handleHeaderClick($header, $list) {
  var closed = $list.classList.toggle('is-hidden');
  var $icon = $header.querySelector('.icon');
  $icon.style.transform = 'rotate(' + (closed ? 0 : 90) + 'deg)';
}

function handleAddBtnClick($header, $list, factory, eventName) {
  $list.classList.remove('is-hidden');
  $header.querySelector('.icon').style.transform = 'rotate(90deg)';
  var id = (0, _v2.default)();
  var $node = factory(id);
  $list.appendChild($node);
  _pubsub2.default.publish(eventName, id);
}

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

var rng = __webpack_require__(46);
var bytesToUuid = __webpack_require__(45);

function v4(options, buf, offset) {
  var i = buf && offset || 0;

  if (typeof(options) == 'string') {
    buf = options == 'binary' ? new Array(16) : null;
    options = null;
  }
  options = options || {};

  var rnds = options.random || (options.rng || rng)();

  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
  rnds[6] = (rnds[6] & 0x0f) | 0x40;
  rnds[8] = (rnds[8] & 0x3f) | 0x80;

  // Copy bytes to buffer, if provided
  if (buf) {
    for (var ii = 0; ii < 16; ++ii) {
      buf[i + ii] = rnds[ii];
    }
  }

  return buf || bytesToUuid(rnds);
}

module.exports = v4;


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * jsBezier
 *
 * Copyright (c) 2010 - 2017 jsPlumb (hello@jsplumbtoolkit.com)
 *
 * licensed under the MIT license.
 *
 * a set of Bezier curve functions that deal with Beziers, used by jsPlumb, and perhaps useful for other people.  These functions work with Bezier
 * curves of arbitrary degree.
 *
 * - functions are all in the 'jsBezier' namespace.
 *
 * - all input points should be in the format {x:.., y:..}. all output points are in this format too.
 *
 * - all input curves should be in the format [ {x:.., y:..}, {x:.., y:..}, {x:.., y:..}, {x:.., y:..} ]
 *
 * - 'location' as used as an input here refers to a decimal in the range 0-1 inclusive, which indicates a point some proportion along the length
 * of the curve.  location as output has the same format and meaning.
 *
 *
 * Function List:
 * --------------
 *
 * distanceFromCurve(point, curve)
 *
 * 	Calculates the distance that the given point lies from the given Bezier.  Note that it is computed relative to the center of the Bezier,
 * so if you have stroked the curve with a wide pen you may wish to take that into account!  The distance returned is relative to the values
 * of the curve and the point - it will most likely be pixels.
 *
 * gradientAtPoint(curve, location)
 *
 * 	Calculates the gradient to the curve at the given location, as a decimal between 0 and 1 inclusive.
 *
 * gradientAtPointAlongCurveFrom (curve, location)
 *
 *	Calculates the gradient at the point on the given curve that is 'distance' units from location.
 *
 * nearestPointOnCurve(point, curve)
 *
 *	Calculates the nearest point to the given point on the given curve.  The return value of this is a JS object literal, containing both the
 *point's coordinates and also the 'location' of the point (see above), for example:  { point:{x:551,y:150}, location:0.263365 }.
 *
 * pointOnCurve(curve, location)
 *
 * 	Calculates the coordinates of the point on the given Bezier curve at the given location.
 *
 * pointAlongCurveFrom(curve, location, distance)
 *
 * 	Calculates the coordinates of the point on the given curve that is 'distance' units from location.  'distance' should be in the same coordinate
 * space as that used to construct the Bezier curve.  For an HTML Canvas usage, for example, distance would be a measure of pixels.
 *
 * locationAlongCurveFrom(curve, location, distance)
 *
 * 	Calculates the location on the given curve that is 'distance' units from location.  'distance' should be in the same coordinate
 * space as that used to construct the Bezier curve.  For an HTML Canvas usage, for example, distance would be a measure of pixels.
 *
 * perpendicularToCurveAt(curve, location, length, distance)
 *
 * 	Calculates the perpendicular to the given curve at the given location.  length is the length of the line you wish for (it will be centered
 * on the point at 'location'). distance is optional, and allows you to specify a point along the path from the given location as the center of
 * the perpendicular returned.  The return value of this is an array of two points: [ {x:...,y:...}, {x:...,y:...} ].
 *
 *
 */

(function() {

    var root = this;

    if(typeof Math.sgn == "undefined") {
        Math.sgn = function(x) { return x == 0 ? 0 : x > 0 ? 1 :-1; };
    }

    var Vectors = {
            subtract 	: 	function(v1, v2) { return {x:v1.x - v2.x, y:v1.y - v2.y }; },
            dotProduct	: 	function(v1, v2) { return (v1.x * v2.x)  + (v1.y * v2.y); },
            square		:	function(v) { return Math.sqrt((v.x * v.x) + (v.y * v.y)); },
            scale		:	function(v, s) { return {x:v.x * s, y:v.y * s }; }
        },

        maxRecursion = 64,
        flatnessTolerance = Math.pow(2.0,-maxRecursion-1);

    /**
     * Calculates the distance that the point lies from the curve.
     *
     * @param point a point in the form {x:567, y:3342}
     * @param curve a Bezier curve in the form [{x:..., y:...}, {x:..., y:...}, {x:..., y:...}, {x:..., y:...}].  note that this is currently
     * hardcoded to assume cubiz beziers, but would be better off supporting any degree.
     * @return a JS object literal containing location and distance, for example: {location:0.35, distance:10}.  Location is analogous to the location
     * argument you pass to the pointOnPath function: it is a ratio of distance travelled along the curve.  Distance is the distance in pixels from
     * the point to the curve.
     */
    var _distanceFromCurve = function(point, curve) {
        var candidates = [],
            w = _convertToBezier(point, curve),
            degree = curve.length - 1, higherDegree = (2 * degree) - 1,
            numSolutions = _findRoots(w, higherDegree, candidates, 0),
            v = Vectors.subtract(point, curve[0]), dist = Vectors.square(v), t = 0.0;

        for (var i = 0; i < numSolutions; i++) {
            v = Vectors.subtract(point, _bezier(curve, degree, candidates[i], null, null));
            var newDist = Vectors.square(v);
            if (newDist < dist) {
                dist = newDist;
                t = candidates[i];
            }
        }
        v = Vectors.subtract(point, curve[degree]);
        newDist = Vectors.square(v);
        if (newDist < dist) {
            dist = newDist;
            t = 1.0;
        }
        return {location:t, distance:dist};
    };
    /**
     * finds the nearest point on the curve to the given point.
     */
    var _nearestPointOnCurve = function(point, curve) {
        var td = _distanceFromCurve(point, curve);
        return {point:_bezier(curve, curve.length - 1, td.location, null, null), location:td.location};
    };
    var _convertToBezier = function(point, curve) {
        var degree = curve.length - 1, higherDegree = (2 * degree) - 1,
            c = [], d = [], cdTable = [], w = [],
            z = [ [1.0, 0.6, 0.3, 0.1], [0.4, 0.6, 0.6, 0.4], [0.1, 0.3, 0.6, 1.0] ];

        for (var i = 0; i <= degree; i++) c[i] = Vectors.subtract(curve[i], point);
        for (var i = 0; i <= degree - 1; i++) {
            d[i] = Vectors.subtract(curve[i+1], curve[i]);
            d[i] = Vectors.scale(d[i], 3.0);
        }
        for (var row = 0; row <= degree - 1; row++) {
            for (var column = 0; column <= degree; column++) {
                if (!cdTable[row]) cdTable[row] = [];
                cdTable[row][column] = Vectors.dotProduct(d[row], c[column]);
            }
        }
        for (i = 0; i <= higherDegree; i++) {
            if (!w[i]) w[i] = [];
            w[i].y = 0.0;
            w[i].x = parseFloat(i) / higherDegree;
        }
        var n = degree, m = degree-1;
        for (var k = 0; k <= n + m; k++) {
            var lb = Math.max(0, k - m),
                ub = Math.min(k, n);
            for (i = lb; i <= ub; i++) {
                j = k - i;
                w[i+j].y += cdTable[j][i] * z[j][i];
            }
        }
        return w;
    };
    /**
     * counts how many roots there are.
     */
    var _findRoots = function(w, degree, t, depth) {
        var left = [], right = [],
            left_count, right_count,
            left_t = [], right_t = [];

        switch (_getCrossingCount(w, degree)) {
            case 0 : {
                return 0;
            }
            case 1 : {
                if (depth >= maxRecursion) {
                    t[0] = (w[0].x + w[degree].x) / 2.0;
                    return 1;
                }
                if (_isFlatEnough(w, degree)) {
                    t[0] = _computeXIntercept(w, degree);
                    return 1;
                }
                break;
            }
        }
        _bezier(w, degree, 0.5, left, right);
        left_count  = _findRoots(left,  degree, left_t, depth+1);
        right_count = _findRoots(right, degree, right_t, depth+1);
        for (var i = 0; i < left_count; i++) t[i] = left_t[i];
        for (var i = 0; i < right_count; i++) t[i+left_count] = right_t[i];
        return (left_count+right_count);
    };
    var _getCrossingCount = function(curve, degree) {
        var n_crossings = 0, sign, old_sign;
        sign = old_sign = Math.sgn(curve[0].y);
        for (var i = 1; i <= degree; i++) {
            sign = Math.sgn(curve[i].y);
            if (sign != old_sign) n_crossings++;
            old_sign = sign;
        }
        return n_crossings;
    };
    var _isFlatEnough = function(curve, degree) {
        var  error,
            intercept_1, intercept_2, left_intercept, right_intercept,
            a, b, c, det, dInv, a1, b1, c1, a2, b2, c2;
        a = curve[0].y - curve[degree].y;
        b = curve[degree].x - curve[0].x;
        c = curve[0].x * curve[degree].y - curve[degree].x * curve[0].y;

        var max_distance_above = max_distance_below = 0.0;

        for (var i = 1; i < degree; i++) {
            var value = a * curve[i].x + b * curve[i].y + c;
            if (value > max_distance_above)
                max_distance_above = value;
            else if (value < max_distance_below)
                max_distance_below = value;
        }

        a1 = 0.0; b1 = 1.0; c1 = 0.0; a2 = a; b2 = b;
        c2 = c - max_distance_above;
        det = a1 * b2 - a2 * b1;
        dInv = 1.0/det;
        intercept_1 = (b1 * c2 - b2 * c1) * dInv;
        a2 = a; b2 = b; c2 = c - max_distance_below;
        det = a1 * b2 - a2 * b1;
        dInv = 1.0/det;
        intercept_2 = (b1 * c2 - b2 * c1) * dInv;
        left_intercept = Math.min(intercept_1, intercept_2);
        right_intercept = Math.max(intercept_1, intercept_2);
        error = right_intercept - left_intercept;
        return (error < flatnessTolerance)? 1 : 0;
    };
    var _computeXIntercept = function(curve, degree) {
        var XLK = 1.0, YLK = 0.0,
            XNM = curve[degree].x - curve[0].x, YNM = curve[degree].y - curve[0].y,
            XMK = curve[0].x - 0.0, YMK = curve[0].y - 0.0,
            det = XNM*YLK - YNM*XLK, detInv = 1.0/det,
            S = (XNM*YMK - YNM*XMK) * detInv;
        return 0.0 + XLK * S;
    };
    var _bezier = function(curve, degree, t, left, right) {
        var temp = [[]];
        for (var j =0; j <= degree; j++) temp[0][j] = curve[j];
        for (var i = 1; i <= degree; i++) {
            for (var j =0 ; j <= degree - i; j++) {
                if (!temp[i]) temp[i] = [];
                if (!temp[i][j]) temp[i][j] = {};
                temp[i][j].x = (1.0 - t) * temp[i-1][j].x + t * temp[i-1][j+1].x;
                temp[i][j].y = (1.0 - t) * temp[i-1][j].y + t * temp[i-1][j+1].y;
            }
        }
        if (left != null)
            for (j = 0; j <= degree; j++) left[j]  = temp[j][0];
        if (right != null)
            for (j = 0; j <= degree; j++) right[j] = temp[degree-j][j];

        return (temp[degree][0]);
    };

    var _curveFunctionCache = {};
    var _getCurveFunctions = function(order) {
        var fns = _curveFunctionCache[order];
        if (!fns) {
            fns = [];
            var f_term = function() { return function(t) { return Math.pow(t, order); }; },
                l_term = function() { return function(t) { return Math.pow((1-t), order); }; },
                c_term = function(c) { return function(t) { return c; }; },
                t_term = function() { return function(t) { return t; }; },
                one_minus_t_term = function() { return function(t) { return 1-t; }; },
                _termFunc = function(terms) {
                    return function(t) {
                        var p = 1;
                        for (var i = 0; i < terms.length; i++) p = p * terms[i](t);
                        return p;
                    };
                };

            fns.push(new f_term());  // first is t to the power of the curve order
            for (var i = 1; i < order; i++) {
                var terms = [new c_term(order)];
                for (var j = 0 ; j < (order - i); j++) terms.push(new t_term());
                for (var j = 0 ; j < i; j++) terms.push(new one_minus_t_term());
                fns.push(new _termFunc(terms));
            }
            fns.push(new l_term());  // last is (1-t) to the power of the curve order

            _curveFunctionCache[order] = fns;
        }

        return fns;
    };


    /**
     * calculates a point on the curve, for a Bezier of arbitrary order.
     * @param curve an array of control points, eg [{x:10,y:20}, {x:50,y:50}, {x:100,y:100}, {x:120,y:100}].  For a cubic bezier this should have four points.
     * @param location a decimal indicating the distance along the curve the point should be located at.  this is the distance along the curve as it travels, taking the way it bends into account.  should be a number from 0 to 1, inclusive.
     */
    var _pointOnPath = function(curve, location) {
        var cc = _getCurveFunctions(curve.length - 1),
            _x = 0, _y = 0;
        for (var i = 0; i < curve.length ; i++) {
            _x = _x + (curve[i].x * cc[i](location));
            _y = _y + (curve[i].y * cc[i](location));
        }

        return {x:_x, y:_y};
    };

    var _dist = function(p1,p2) {
        return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
    };

    var _isPoint = function(curve) {
        return curve[0].x == curve[1].x && curve[0].y == curve[1].y;
    };

    /**
     * finds the point that is 'distance' along the path from 'location'.  this method returns both the x,y location of the point and also
     * its 'location' (proportion of travel along the path); the method below - _pointAlongPathFrom - calls this method and just returns the
     * point.
     */
    var _pointAlongPath = function(curve, location, distance) {

        if (_isPoint(curve)) {
            return {
                point:curve[0],
                location:location
            };
        }

        var prev = _pointOnPath(curve, location),
            tally = 0,
            curLoc = location,
            direction = distance > 0 ? 1 : -1,
            cur = null;

        while (tally < Math.abs(distance)) {
            curLoc += (0.005 * direction);
            cur = _pointOnPath(curve, curLoc);
            tally += _dist(cur, prev);
            prev = cur;
        }
        return {point:cur, location:curLoc};
    };

    var _length = function(curve) {
        if (_isPoint(curve)) return 0;

        var prev = _pointOnPath(curve, 0),
            tally = 0,
            curLoc = 0,
            direction = 1,
            cur = null;

        while (curLoc < 1) {
            curLoc += (0.005 * direction);
            cur = _pointOnPath(curve, curLoc);
            tally += _dist(cur, prev);
            prev = cur;
        }
        return tally;
    };

    /**
     * finds the point that is 'distance' along the path from 'location'.
     */
    var _pointAlongPathFrom = function(curve, location, distance) {
        return _pointAlongPath(curve, location, distance).point;
    };

    /**
     * finds the location that is 'distance' along the path from 'location'.
     */
    var _locationAlongPathFrom = function(curve, location, distance) {
        return _pointAlongPath(curve, location, distance).location;
    };

    /**
     * returns the gradient of the curve at the given location, which is a decimal between 0 and 1 inclusive.
     *
     * thanks // http://bimixual.org/AnimationLibrary/beziertangents.html
     */
    var _gradientAtPoint = function(curve, location) {
        var p1 = _pointOnPath(curve, location),
            p2 = _pointOnPath(curve.slice(0, curve.length - 1), location),
            dy = p2.y - p1.y, dx = p2.x - p1.x;
        return dy == 0 ? Infinity : Math.atan(dy / dx);
    };

    /**
     returns the gradient of the curve at the point which is 'distance' from the given location.
     if this point is greater than location 1, the gradient at location 1 is returned.
     if this point is less than location 0, the gradient at location 0 is returned.
     */
    var _gradientAtPointAlongPathFrom = function(curve, location, distance) {
        var p = _pointAlongPath(curve, location, distance);
        if (p.location > 1) p.location = 1;
        if (p.location < 0) p.location = 0;
        return _gradientAtPoint(curve, p.location);
    };

    /**
     * calculates a line that is 'length' pixels long, perpendicular to, and centered on, the path at 'distance' pixels from the given location.
     * if distance is not supplied, the perpendicular for the given location is computed (ie. we set distance to zero).
     */
    var _perpendicularToPathAt = function(curve, location, length, distance) {
        distance = distance == null ? 0 : distance;
        var p = _pointAlongPath(curve, location, distance),
            m = _gradientAtPoint(curve, p.location),
            _theta2 = Math.atan(-1 / m),
            y =  length / 2 * Math.sin(_theta2),
            x =  length / 2 * Math.cos(_theta2);
        return [{x:p.point.x + x, y:p.point.y + y}, {x:p.point.x - x, y:p.point.y - y}];
    };

    var jsBezier = this.jsBezier = {
        distanceFromCurve : _distanceFromCurve,
        gradientAtPoint : _gradientAtPoint,
        gradientAtPointAlongCurveFrom : _gradientAtPointAlongPathFrom,
        nearestPointOnCurve : _nearestPointOnCurve,
        pointOnCurve : _pointOnPath,
        pointAlongCurveFrom : _pointAlongPathFrom,
        perpendicularToCurveAt : _perpendicularToPathAt,
        locationAlongCurveFrom:_locationAlongPathFrom,
        getLength:_length,
        version:"0.9.0"
    };

    if (true) {
        exports.jsBezier = jsBezier;
    }

}).call(typeof window !== 'undefined' ? window : this);

/**
 * Biltong v0.4.0
 *
 * Various geometry functions written as part of jsPlumb and perhaps useful for others.
 *
 * Copyright (c) 2017 jsPlumb
 * https://jsplumbtoolkit.com
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following
 * conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */
;(function() {

    "use strict";
    var root = this;

    var Biltong = root.Biltong = {
        version:"0.4.0"
    };

    if (true) {
        exports.Biltong = Biltong;
    }

    var _isa = function(a) { return Object.prototype.toString.call(a) === "[object Array]"; },
        _pointHelper = function(p1, p2, fn) {
            p1 = _isa(p1) ? p1 : [p1.x, p1.y];
            p2 = _isa(p2) ? p2 : [p2.x, p2.y];
            return fn(p1, p2);
        },
        /**
         * @name Biltong.gradient
         * @function
         * @desc Calculates the gradient of a line between the two points.
         * @param {Point} p1 First point, either as a 2 entry array or object with `left` and `top` properties.
         * @param {Point} p2 Second point, either as a 2 entry array or object with `left` and `top` properties.
         * @return {Float} The gradient of a line between the two points.
         */
        _gradient = Biltong.gradient = function(p1, p2) {
            return _pointHelper(p1, p2, function(_p1, _p2) {
                if (_p2[0] == _p1[0])
                    return _p2[1] > _p1[1] ? Infinity : -Infinity;
                else if (_p2[1] == _p1[1])
                    return _p2[0] > _p1[0] ? 0 : -0;
                else
                    return (_p2[1] - _p1[1]) / (_p2[0] - _p1[0]);
            });
        },
        /**
         * @name Biltong.normal
         * @function
         * @desc Calculates the gradient of a normal to a line between the two points.
         * @param {Point} p1 First point, either as a 2 entry array or object with `left` and `top` properties.
         * @param {Point} p2 Second point, either as a 2 entry array or object with `left` and `top` properties.
         * @return {Float} The gradient of a normal to a line between the two points.
         */
        _normal = Biltong.normal = function(p1, p2) {
            return -1 / _gradient(p1, p2);
        },
        /**
         * @name Biltong.lineLength
         * @function
         * @desc Calculates the length of a line between the two points.
         * @param {Point} p1 First point, either as a 2 entry array or object with `left` and `top` properties.
         * @param {Point} p2 Second point, either as a 2 entry array or object with `left` and `top` properties.
         * @return {Float} The length of a line between the two points.
         */
        _lineLength = Biltong.lineLength = function(p1, p2) {
            return _pointHelper(p1, p2, function(_p1, _p2) {
                return Math.sqrt(Math.pow(_p2[1] - _p1[1], 2) + Math.pow(_p2[0] - _p1[0], 2));
            });
        },
        /**
         * @name Biltong.quadrant
         * @function
         * @desc Calculates the quadrant in which the angle between the two points lies.
         * @param {Point} p1 First point, either as a 2 entry array or object with `left` and `top` properties.
         * @param {Point} p2 Second point, either as a 2 entry array or object with `left` and `top` properties.
         * @return {Integer} The quadrant - 1 for upper right, 2 for lower right, 3 for lower left, 4 for upper left.
         */
        _quadrant = Biltong.quadrant = function(p1, p2) {
            return _pointHelper(p1, p2, function(_p1, _p2) {
                if (_p2[0] > _p1[0]) {
                    return (_p2[1] > _p1[1]) ? 2 : 1;
                }
                else if (_p2[0] == _p1[0]) {
                    return _p2[1] > _p1[1] ? 2 : 1;
                }
                else {
                    return (_p2[1] > _p1[1]) ? 3 : 4;
                }
            });
        },
        /**
         * @name Biltong.theta
         * @function
         * @desc Calculates the angle between the two points.
         * @param {Point} p1 First point, either as a 2 entry array or object with `left` and `top` properties.
         * @param {Point} p2 Second point, either as a 2 entry array or object with `left` and `top` properties.
         * @return {Float} The angle between the two points.
         */
        _theta = Biltong.theta = function(p1, p2) {
            return _pointHelper(p1, p2, function(_p1, _p2) {
                var m = _gradient(_p1, _p2),
                    t = Math.atan(m),
                    s = _quadrant(_p1, _p2);
                if ((s == 4 || s== 3)) t += Math.PI;
                if (t < 0) t += (2 * Math.PI);

                return t;
            });
        },
        /**
         * @name Biltong.intersects
         * @function
         * @desc Calculates whether or not the two rectangles intersect.
         * @param {Rectangle} r1 First rectangle, as a js object in the form `{x:.., y:.., w:.., h:..}`
         * @param {Rectangle} r2 Second rectangle, as a js object in the form `{x:.., y:.., w:.., h:..}`
         * @return {Boolean} True if the rectangles intersect, false otherwise.
         */
        _intersects = Biltong.intersects = function(r1, r2) {
            var x1 = r1.x, x2 = r1.x + r1.w, y1 = r1.y, y2 = r1.y + r1.h,
                a1 = r2.x, a2 = r2.x + r2.w, b1 = r2.y, b2 = r2.y + r2.h;

            return  ( (x1 <= a1 && a1 <= x2) && (y1 <= b1 && b1 <= y2) ) ||
                ( (x1 <= a2 && a2 <= x2) && (y1 <= b1 && b1 <= y2) ) ||
                ( (x1 <= a1 && a1 <= x2) && (y1 <= b2 && b2 <= y2) ) ||
                ( (x1 <= a2 && a1 <= x2) && (y1 <= b2 && b2 <= y2) ) ||
                ( (a1 <= x1 && x1 <= a2) && (b1 <= y1 && y1 <= b2) ) ||
                ( (a1 <= x2 && x2 <= a2) && (b1 <= y1 && y1 <= b2) ) ||
                ( (a1 <= x1 && x1 <= a2) && (b1 <= y2 && y2 <= b2) ) ||
                ( (a1 <= x2 && x1 <= a2) && (b1 <= y2 && y2 <= b2) );
        },
        /**
         * @name Biltong.encloses
         * @function
         * @desc Calculates whether or not r2 is completely enclosed by r1.
         * @param {Rectangle} r1 First rectangle, as a js object in the form `{x:.., y:.., w:.., h:..}`
         * @param {Rectangle} r2 Second rectangle, as a js object in the form `{x:.., y:.., w:.., h:..}`
         * @param {Boolean} [allowSharedEdges=false] If true, the concept of enclosure allows for one or more edges to be shared by the two rectangles.
         * @return {Boolean} True if r1 encloses r2, false otherwise.
         */
        _encloses = Biltong.encloses = function(r1, r2, allowSharedEdges) {
            var x1 = r1.x, x2 = r1.x + r1.w, y1 = r1.y, y2 = r1.y + r1.h,
                a1 = r2.x, a2 = r2.x + r2.w, b1 = r2.y, b2 = r2.y + r2.h,
                c = function(v1, v2, v3, v4) { return allowSharedEdges ? v1 <= v2 && v3>= v4 : v1 < v2 && v3 > v4; };

            return c(x1,a1,x2,a2) && c(y1,b1,y2,b2);
        },
        _segmentMultipliers = [null, [1, -1], [1, 1], [-1, 1], [-1, -1] ],
        _inverseSegmentMultipliers = [null, [-1, -1], [-1, 1], [1, 1], [1, -1] ],
        /**
         * @name Biltong.pointOnLine
         * @function
         * @desc Calculates a point on the line from `fromPoint` to `toPoint` that is `distance` units along the length of the line.
         * @param {Point} p1 First point, either as a 2 entry array or object with `left` and `top` properties.
         * @param {Point} p2 Second point, either as a 2 entry array or object with `left` and `top` properties.
         * @return {Point} Point on the line, in the form `{ x:..., y:... }`.
         */
        _pointOnLine = Biltong.pointOnLine = function(fromPoint, toPoint, distance) {
            var m = _gradient(fromPoint, toPoint),
                s = _quadrant(fromPoint, toPoint),
                segmentMultiplier = distance > 0 ? _segmentMultipliers[s] : _inverseSegmentMultipliers[s],
                theta = Math.atan(m),
                y = Math.abs(distance * Math.sin(theta)) * segmentMultiplier[1],
                x =  Math.abs(distance * Math.cos(theta)) * segmentMultiplier[0];
            return { x:fromPoint.x + x, y:fromPoint.y + y };
        },
        /**
         * @name Biltong.perpendicularLineTo
         * @function
         * @desc Calculates a line of length `length` that is perpendicular to the line from `fromPoint` to `toPoint` and passes through `toPoint`.
         * @param {Point} p1 First point, either as a 2 entry array or object with `left` and `top` properties.
         * @param {Point} p2 Second point, either as a 2 entry array or object with `left` and `top` properties.
         * @return {Line} Perpendicular line, in the form `[ { x:..., y:... }, { x:..., y:... } ]`.
         */
        _perpendicularLineTo = Biltong.perpendicularLineTo = function(fromPoint, toPoint, length) {
            var m = _gradient(fromPoint, toPoint),
                theta2 = Math.atan(-1 / m),
                y =  length / 2 * Math.sin(theta2),
                x =  length / 2 * Math.cos(theta2);
            return [{x:toPoint.x + x, y:toPoint.y + y}, {x:toPoint.x - x, y:toPoint.y - y}];
        };
}).call(typeof window !== 'undefined' ? window : this);
;
(function () {

    "use strict";

    var root = this,
        Sniff = {
            android: navigator.userAgent.toLowerCase().indexOf("android") > -1
        },
        matchesSelector = function (el, selector, ctx) {
            ctx = ctx || el.parentNode;
            var possibles = ctx.querySelectorAll(selector);
            for (var i = 0; i < possibles.length; i++) {
                if (possibles[i] === el) {
                    return true;
                }
            }
            return false;
        },
        _gel = function (el) {
            return (typeof el == "string" || el.constructor === String) ? document.getElementById(el) : el;
        },
        _t = function (e) {
            return e.srcElement || e.target;
        },
    //
    // gets path info for the given event - the path from target to obj, in the event's bubble chain. if doCompute
    // is false we just return target for the path.
    //
        _pi = function(e, target, obj, doCompute) {
            if (!doCompute) return { path:[target], end:1 };
            else if (typeof e.path !== "undefined" && e.path.indexOf) {
                return { path: e.path, end: e.path.indexOf(obj) };
            } else {
                var out = { path:[], end:-1 }, _one = function(el) {
                    out.path.push(el);
                    if (el === obj) {
                        out.end = out.path.length - 1;
                    }
                    else if (el.parentNode != null) {
                        _one(el.parentNode)
                    }
                };
                _one(target);
                return out;
            }
        },
        _d = function (l, fn) {
            for (var i = 0, j = l.length; i < j; i++) {
                if (l[i] == fn) break;
            }
            if (i < l.length) l.splice(i, 1);
        },
        guid = 1,
    //
    // this function generates a guid for every handler, sets it on the handler, then adds
    // it to the associated object's map of handlers for the given event. this is what enables us
    // to unbind all events of some type, or all events (the second of which can be requested by the user,
    // but it also used by Mottle when an element is removed.)
        _store = function (obj, event, fn) {
            var g = guid++;
            obj.__ta = obj.__ta || {};
            obj.__ta[event] = obj.__ta[event] || {};
            // store each handler with a unique guid.
            obj.__ta[event][g] = fn;
            // set the guid on the handler.
            fn.__tauid = g;
            return g;
        },
        _unstore = function (obj, event, fn) {
            obj.__ta && obj.__ta[event] && delete obj.__ta[event][fn.__tauid];
            // a handler might have attached extra functions, so we unbind those too.
            if (fn.__taExtra) {
                for (var i = 0; i < fn.__taExtra.length; i++) {
                    _unbind(obj, fn.__taExtra[i][0], fn.__taExtra[i][1]);
                }
                fn.__taExtra.length = 0;
            }
            // a handler might have attached an unstore callback
            fn.__taUnstore && fn.__taUnstore();
        },
        _curryChildFilter = function (children, obj, fn, evt) {
            if (children == null) return fn;
            else {
                var c = children.split(","),
                    _fn = function (e) {
                        _fn.__tauid = fn.__tauid;
                        var t = _t(e), target = t;  // t is the target element on which the event occurred. it is the
                        // element we will wish to pass to any callbacks.
                        var pathInfo = _pi(e, t, obj, children != null)
                        if (pathInfo.end != -1) {
                            for (var p = 0; p < pathInfo.end; p++) {
                                target = pathInfo.path[p];
                                for (var i = 0; i < c.length; i++) {
                                    if (matchesSelector(target, c[i], obj)) {
                                        fn.apply(target, arguments);
                                    }
                                }
                            }
                        }
                    };
                registerExtraFunction(fn, evt, _fn);
                return _fn;
            }
        },
    //
    // registers an 'extra' function on some event listener function we were given - a function that we
    // created and bound to the element as part of our housekeeping, and which we want to unbind and remove
    // whenever the given function is unbound.
        registerExtraFunction = function (fn, evt, newFn) {
            fn.__taExtra = fn.__taExtra || [];
            fn.__taExtra.push([evt, newFn]);
        },
        DefaultHandler = function (obj, evt, fn, children) {
            if (isTouchDevice && touchMap[evt]) {
                var tfn = _curryChildFilter(children, obj, fn, touchMap[evt]);
                _bind(obj, touchMap[evt], tfn , fn);
            }
            if (evt === "focus" && obj.getAttribute("tabindex") == null) {
                obj.setAttribute("tabindex", "1");
            }
            _bind(obj, evt, _curryChildFilter(children, obj, fn, evt), fn);
        },
        SmartClickHandler = function (obj, evt, fn, children) {
            if (obj.__taSmartClicks == null) {
                var down = function (e) {
                        obj.__tad = _pageLocation(e);
                    },
                    up = function (e) {
                        obj.__tau = _pageLocation(e);
                    },
                    click = function (e) {
                        if (obj.__tad && obj.__tau && obj.__tad[0] === obj.__tau[0] && obj.__tad[1] === obj.__tau[1]) {
                            for (var i = 0; i < obj.__taSmartClicks.length; i++)
                                obj.__taSmartClicks[i].apply(_t(e), [ e ]);
                        }
                    };
                DefaultHandler(obj, "mousedown", down, children);
                DefaultHandler(obj, "mouseup", up, children);
                DefaultHandler(obj, "click", click, children);
                obj.__taSmartClicks = [];
            }

            // store in the list of callbacks
            obj.__taSmartClicks.push(fn);
            // the unstore function removes this function from the object's listener list for this type.
            fn.__taUnstore = function () {
                _d(obj.__taSmartClicks, fn);
            };
        },
        _tapProfiles = {
            "tap": {touches: 1, taps: 1},
            "dbltap": {touches: 1, taps: 2},
            "contextmenu": {touches: 2, taps: 1}
        },
        TapHandler = function (clickThreshold, dblClickThreshold) {
            return function (obj, evt, fn, children) {
                // if event is contextmenu, for devices which are mouse only, we want to
                // use the default bind.
                if (evt == "contextmenu" && isMouseDevice)
                    DefaultHandler(obj, evt, fn, children);
                else {
                    // the issue here is that this down handler gets registered only for the
                    // child nodes in the first registration. in fact it should be registered with
                    // no child selector and then on down we should cycle through the registered
                    // functions to see if one of them matches. on mouseup we should execute ALL of
                    // the functions whose children are either null or match the element.
                    if (obj.__taTapHandler == null) {
                        var tt = obj.__taTapHandler = {
                            tap: [],
                            dbltap: [],
                            contextmenu: [],
                            down: false,
                            taps: 0,
                            downSelectors: []
                        };
                        var down = function (e) {
                                var target = _t(e), pathInfo = _pi(e, target, obj, children != null), finished = false;
                                for (var p = 0; p < pathInfo.end; p++) {
                                    if (finished) return;
                                    target = pathInfo.path[p];
                                    for (var i = 0; i < tt.downSelectors.length; i++) {
                                        if (tt.downSelectors[i] == null || matchesSelector(target, tt.downSelectors[i], obj)) {
                                            tt.down = true;
                                            setTimeout(clearSingle, clickThreshold);
                                            setTimeout(clearDouble, dblClickThreshold);
                                            finished = true;
                                            break; // we only need one match on mousedown
                                        }
                                    }
                                }
                            },
                            up = function (e) {
                                if (tt.down) {
                                    var target = _t(e), currentTarget, pathInfo;
                                    tt.taps++;
                                    var tc = _touchCount(e);
                                    for (var eventId in _tapProfiles) {
                                        if (_tapProfiles.hasOwnProperty(eventId)) {
                                            var p = _tapProfiles[eventId];
                                            if (p.touches === tc && (p.taps === 1 || p.taps === tt.taps)) {
                                                for (var i = 0; i < tt[eventId].length; i++) {
                                                    pathInfo = _pi(e, target, obj, tt[eventId][i][1] != null);
                                                    for (var pLoop = 0; pLoop < pathInfo.end; pLoop++) {
                                                        currentTarget = pathInfo.path[pLoop];
                                                        // this is a single event registration handler.
                                                        if (tt[eventId][i][1] == null || matchesSelector(currentTarget, tt[eventId][i][1], obj)) {
                                                            tt[eventId][i][0].apply(currentTarget, [ e ]);
                                                            break;
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            },
                            clearSingle = function () {
                                tt.down = false;
                            },
                            clearDouble = function () {
                                tt.taps = 0;
                            };

                        DefaultHandler(obj, "mousedown", down);
                        DefaultHandler(obj, "mouseup", up);
                    }
                    // add this child selector (it can be null, that's fine).
                    obj.__taTapHandler.downSelectors.push(children);

                    obj.__taTapHandler[evt].push([fn, children]);
                    // the unstore function removes this function from the object's listener list for this type.
                    fn.__taUnstore = function () {
                        _d(obj.__taTapHandler[evt], fn);
                    };
                }
            };
        },
        meeHelper = function (type, evt, obj, target) {
            for (var i in obj.__tamee[type]) {
                if (obj.__tamee[type].hasOwnProperty(i)) {
                    obj.__tamee[type][i].apply(target, [ evt ]);
                }
            }
        },
        MouseEnterExitHandler = function () {
            var activeElements = [];
            return function (obj, evt, fn, children) {
                if (!obj.__tamee) {
                    // __tamee holds a flag saying whether the mouse is currently "in" the element, and a list of
                    // both mouseenter and mouseexit functions.
                    obj.__tamee = { over: false, mouseenter: [], mouseexit: [] };
                    // register over and out functions
                    var over = function (e) {
                            var t = _t(e);
                            if ((children == null && (t == obj && !obj.__tamee.over)) || (matchesSelector(t, children, obj) && (t.__tamee == null || !t.__tamee.over))) {
                                meeHelper("mouseenter", e, obj, t);
                                t.__tamee = t.__tamee || {};
                                t.__tamee.over = true;
                                activeElements.push(t);
                            }
                        },
                        out = function (e) {
                            var t = _t(e);
                            // is the current target one of the activeElements? and is the
                            // related target NOT a descendant of it?
                            for (var i = 0; i < activeElements.length; i++) {
                                if (t == activeElements[i] && !matchesSelector((e.relatedTarget || e.toElement), "*", t)) {
                                    t.__tamee.over = false;
                                    activeElements.splice(i, 1);
                                    meeHelper("mouseexit", e, obj, t);
                                }
                            }
                        };

                    _bind(obj, "mouseover", _curryChildFilter(children, obj, over, "mouseover"), over);
                    _bind(obj, "mouseout", _curryChildFilter(children, obj, out, "mouseout"), out);
                }

                fn.__taUnstore = function () {
                    delete obj.__tamee[evt][fn.__tauid];
                };

                _store(obj, evt, fn);
                obj.__tamee[evt][fn.__tauid] = fn;
            };
        },
        isTouchDevice = "ontouchstart" in document.documentElement,
        isMouseDevice = "onmousedown" in document.documentElement,
        touchMap = { "mousedown": "touchstart", "mouseup": "touchend", "mousemove": "touchmove" },
        touchstart = "touchstart", touchend = "touchend", touchmove = "touchmove",
        iev = (function () {
            var rv = -1;
            if (navigator.appName == 'Microsoft Internet Explorer') {
                var ua = navigator.userAgent,
                    re = new RegExp("MSIE ([0-9]{1,}[\.0-9]{0,})");
                if (re.exec(ua) != null)
                    rv = parseFloat(RegExp.$1);
            }
            return rv;
        })(),
        isIELT9 = iev > -1 && iev < 9,
        _genLoc = function (e, prefix) {
            if (e == null) return [ 0, 0 ];
            var ts = _touches(e), t = _getTouch(ts, 0);
            return [t[prefix + "X"], t[prefix + "Y"]];
        },
        _pageLocation = function (e) {
            if (e == null) return [ 0, 0 ];
            if (isIELT9) {
                return [ e.clientX + document.documentElement.scrollLeft, e.clientY + document.documentElement.scrollTop ];
            }
            else {
                return _genLoc(e, "page");
            }
        },
        _screenLocation = function (e) {
            return _genLoc(e, "screen");
        },
        _clientLocation = function (e) {
            return _genLoc(e, "client");
        },
        _getTouch = function (touches, idx) {
            return touches.item ? touches.item(idx) : touches[idx];
        },
        _touches = function (e) {
            return e.touches && e.touches.length > 0 ? e.touches :
                    e.changedTouches && e.changedTouches.length > 0 ? e.changedTouches :
                    e.targetTouches && e.targetTouches.length > 0 ? e.targetTouches :
                [ e ];
        },
        _touchCount = function (e) {
            return _touches(e).length;
        },
    //http://www.quirksmode.org/blog/archives/2005/10/_and_the_winner_1.html
        _bind = function (obj, type, fn, originalFn) {
            _store(obj, type, fn);
            originalFn.__tauid = fn.__tauid;
            if (obj.addEventListener)
                obj.addEventListener(type, fn, false);
            else if (obj.attachEvent) {
                var key = type + fn.__tauid;
                obj["e" + key] = fn;
                // TODO look at replacing with .call(..)
                obj[key] = function () {
                    obj["e" + key] && obj["e" + key](window.event);
                };
                obj.attachEvent("on" + type, obj[key]);
            }
        },
        _unbind = function (obj, type, fn) {
            if (fn == null) return;
            _each(obj, function () {
                var _el = _gel(this);
                _unstore(_el, type, fn);
                // it has been bound if there is a tauid. otherwise it was not bound and we can ignore it.
                if (fn.__tauid != null) {
                    if (_el.removeEventListener) {
                        _el.removeEventListener(type, fn, false);
                        if (isTouchDevice && touchMap[type]) _el.removeEventListener(touchMap[type], fn, false);
                    }
                    else if (this.detachEvent) {
                        var key = type + fn.__tauid;
                        _el[key] && _el.detachEvent("on" + type, _el[key]);
                        _el[key] = null;
                        _el["e" + key] = null;
                    }
                }

                // if a touch event was also registered, deregister now.
                if (fn.__taTouchProxy) {
                    _unbind(obj, fn.__taTouchProxy[1], fn.__taTouchProxy[0]);
                }
            });
        },
        _each = function (obj, fn) {
            if (obj == null) return;
            // if a list (or list-like), use it. if a string, get a list
            // by running the string through querySelectorAll. else, assume
            // it's an Element.
            // obj.top is "unknown" in IE8.
            obj = (typeof Window !== "undefined" && (typeof obj.top !== "unknown" && obj == obj.top)) ? [ obj ] :
                    (typeof obj !== "string") && (obj.tagName == null && obj.length != null) ? obj :
                    typeof obj === "string" ? document.querySelectorAll(obj)
                : [ obj ];

            for (var i = 0; i < obj.length; i++)
                fn.apply(obj[i]);
        };

    /**
     * Mottle offers support for abstracting out the differences
     * between touch and mouse devices, plus "smart click" functionality
     * (don't fire click if the mouse has moved between mousedown and mouseup),
     * and synthesized click/tap events.
     * @class Mottle
     * @constructor
     * @param {Object} params Constructor params
     * @param {Number} [params.clickThreshold=250] Threshold, in milliseconds beyond which a touchstart followed by a touchend is not considered to be a click.
     * @param {Number} [params.dblClickThreshold=450] Threshold, in milliseconds beyond which two successive tap events are not considered to be a click.
     * @param {Boolean} [params.smartClicks=false] If true, won't fire click events if the mouse has moved between mousedown and mouseup. Note that this functionality
     * requires that Mottle consume the mousedown event, and so may not be viable in all use cases.
     */
    root.Mottle = function (params) {
        params = params || {};
        var clickThreshold = params.clickThreshold || 250,
            dblClickThreshold = params.dblClickThreshold || 450,
            mouseEnterExitHandler = new MouseEnterExitHandler(),
            tapHandler = new TapHandler(clickThreshold, dblClickThreshold),
            _smartClicks = params.smartClicks,
            _doBind = function (obj, evt, fn, children) {
                if (fn == null) return;
                _each(obj, function () {
                    var _el = _gel(this);
                    if (_smartClicks && evt === "click")
                        SmartClickHandler(_el, evt, fn, children);
                    else if (evt === "tap" || evt === "dbltap" || evt === "contextmenu") {
                        tapHandler(_el, evt, fn, children);
                    }
                    else if (evt === "mouseenter" || evt == "mouseexit")
                        mouseEnterExitHandler(_el, evt, fn, children);
                    else
                        DefaultHandler(_el, evt, fn, children);
                });
            };

        /**
         * Removes an element from the DOM, and deregisters all event handlers for it. You should use this
         * to ensure you don't leak memory.
         * @method remove
         * @param {String|Element} el Element, or id of the element, to remove.
         * @return {Mottle} The current Mottle instance; you can chain this method.
         */
        this.remove = function (el) {
            _each(el, function () {
                var _el = _gel(this);
                if (_el.__ta) {
                    for (var evt in _el.__ta) {
                        if (_el.__ta.hasOwnProperty(evt)) {
                            for (var h in _el.__ta[evt]) {
                                if (_el.__ta[evt].hasOwnProperty(h))
                                    _unbind(_el, evt, _el.__ta[evt][h]);
                            }
                        }
                    }
                }
                _el.parentNode && _el.parentNode.removeChild(_el);
            });
            return this;
        };

        /**
         * Register an event handler, optionally as a delegate for some set of descendant elements. Note
         * that this method takes either 3 or 4 arguments - if you supply 3 arguments it is assumed you have
         * omitted the `children` parameter, and that the event handler should be bound directly to the given element.
         * @method on
         * @param {Element[]|Element|String} el Either an Element, or a CSS spec for a list of elements, or an array of Elements.
         * @param {String} [children] Comma-delimited list of selectors identifying allowed children.
         * @param {String} event Event ID.
         * @param {Function} fn Event handler function.
         * @return {Mottle} The current Mottle instance; you can chain this method.
         */
        this.on = function (el, event, children, fn) {
            var _el = arguments[0],
                _c = arguments.length == 4 ? arguments[2] : null,
                _e = arguments[1],
                _f = arguments[arguments.length - 1];

            _doBind(_el, _e, _f, _c);
            return this;
        };

        /**
         * Cancel delegate event handling for the given function. Note that unlike with 'on' you do not supply
         * a list of child selectors here: it removes event delegation from all of the child selectors for which the
         * given function was registered (if any).
         * @method off
         * @param {Element[]|Element|String} el Element - or ID of element - from which to remove event listener.
         * @param {String} event Event ID.
         * @param {Function} fn Event handler function.
         * @return {Mottle} The current Mottle instance; you can chain this method.
         */
        this.off = function (el, event, fn) {
            _unbind(el, event, fn);
            return this;
        };

        /**
         * Triggers some event for a given element.
         * @method trigger
         * @param {Element} el Element for which to trigger the event.
         * @param {String} event Event ID.
         * @param {Event} originalEvent The original event. Should be optional of course, but currently is not, due
         * to the jsPlumb use case that caused this method to be added.
         * @param {Object} [payload] Optional object to set as `payload` on the generated event; useful for message passing.
         * @return {Mottle} The current Mottle instance; you can chain this method.
         */
        this.trigger = function (el, event, originalEvent, payload) {
            // MouseEvent undefined in old IE; that's how we know it's a mouse event.  A fine Microsoft paradox.
            var originalIsMouse = isMouseDevice && (typeof MouseEvent === "undefined" || originalEvent == null || originalEvent.constructor === MouseEvent);

            var eventToBind = (isTouchDevice && !isMouseDevice && touchMap[event]) ? touchMap[event] : event,
                bindingAMouseEvent = !(isTouchDevice && !isMouseDevice && touchMap[event]);

            var pl = _pageLocation(originalEvent), sl = _screenLocation(originalEvent), cl = _clientLocation(originalEvent);
            _each(el, function () {
                var _el = _gel(this), evt;
                originalEvent = originalEvent || {
                    screenX: sl[0],
                    screenY: sl[1],
                    clientX: cl[0],
                    clientY: cl[1]
                };

                var _decorate = function (_evt) {
                    if (payload) _evt.payload = payload;
                };

                var eventGenerators = {
                    "TouchEvent": function (evt) {
                        var touch = document.createTouch(window, _el, 0, pl[0], pl[1],
                            sl[0], sl[1],
                            cl[0], cl[1],
                            0, 0, 0, 0);

                        // https://gist.github.com/sstephenson/448808
                        var touches = document.createTouchList(touch);
                        var targetTouches = document.createTouchList(touch);
                        var changedTouches = document.createTouchList(touch);
                        evt.initTouchEvent(eventToBind, true, true, window, null, sl[0], sl[1],
                            cl[0], cl[1], false, false, false, false,
                            touches, targetTouches, changedTouches, 1, 0);
                    },
                    "MouseEvents": function (evt) {
                        evt.initMouseEvent(eventToBind, true, true, window, 0,
                            sl[0], sl[1],
                            cl[0], cl[1],
                            false, false, false, false, 1, _el);

                        if (Sniff.android) {
                            // Android's touch events are not standard.
                            var t = document.createTouch(window, _el, 0, pl[0], pl[1],
                                sl[0], sl[1],
                                cl[0], cl[1],
                                0, 0, 0, 0);

                            evt.touches = evt.targetTouches = evt.changedTouches = document.createTouchList(t);
                        }
                    }
                };

                if (document.createEvent) {

                    var ite = !bindingAMouseEvent && !originalIsMouse && (isTouchDevice && touchMap[event] && !Sniff.android),
                        evtName = ite ? "TouchEvent" : "MouseEvents";

                    evt = document.createEvent(evtName);
                    eventGenerators[evtName](evt);
                    _decorate(evt);
                    _el.dispatchEvent(evt);
                }
                else if (document.createEventObject) {
                    evt = document.createEventObject();
                    evt.eventType = evt.eventName = eventToBind;
                    evt.screenX = sl[0];
                    evt.screenY = sl[1];
                    evt.clientX = cl[0];
                    evt.clientY = cl[1];
                    _decorate(evt);
                    _el.fireEvent('on' + eventToBind, evt);
                }
            });
            return this;
        }
    };

    /**
     * Static method to assist in 'consuming' an element: uses `stopPropagation` where available, or sets
     * `e.returnValue=false` where it is not.
     * @method Mottle.consume
     * @param {Event} e Event to consume
     * @param {Boolean} [doNotPreventDefault=false] If true, does not call `preventDefault()` on the event.
     */
    root.Mottle.consume = function (e, doNotPreventDefault) {
        if (e.stopPropagation)
            e.stopPropagation();
        else
            e.returnValue = false;

        if (!doNotPreventDefault && e.preventDefault)
            e.preventDefault();
    };

    /**
     * Gets the page location corresponding to the given event. For touch events this means get the page location of the first touch.
     * @method Mottle.pageLocation
     * @param {Event} e Event to get page location for.
     * @return {Number[]} [left, top] for the given event.
     */
    root.Mottle.pageLocation = _pageLocation;

    /**
     * Forces touch events to be turned "on". Useful for testing: even if you don't have a touch device, you can still
     * trigger a touch event when this is switched on and it will be captured and acted on.
     * @method setForceTouchEvents
     * @param {Boolean} value If true, force touch events to be on.
     */
    root.Mottle.setForceTouchEvents = function (value) {
        isTouchDevice = value;
    };

    /**
     * Forces mouse events to be turned "on". Useful for testing: even if you don't have a mouse, you can still
     * trigger a mouse event when this is switched on and it will be captured and acted on.
     * @method setForceMouseEvents
     * @param {Boolean} value If true, force mouse events to be on.
     */
    root.Mottle.setForceMouseEvents = function (value) {
        isMouseDevice = value;
    };

    root.Mottle.version = "0.8.0";

    if (true) {
        exports.Mottle = root.Mottle;
    }

}).call(typeof window === "undefined" ? this : window);

/**
 drag/drop functionality for use with jsPlumb but with
 no knowledge of jsPlumb. supports multiple scopes (separated by whitespace), dragging
 multiple elements, constrain to parent, drop filters, drag start filters, custom
 css classes.

 a lot of the functionality of this script is expected to be plugged in:

 addClass
 removeClass

 addEvent
 removeEvent

 getPosition
 setPosition
 getSize

 indexOf
 intersects

 the name came from here:

 http://mrsharpoblunto.github.io/foswig.js/

 copyright 2016 jsPlumb
 */

;(function() {

    "use strict";
    var root = this;

    var _suggest = function(list, item, head) {
        if (list.indexOf(item) === -1) {
            head ? list.unshift(item) : list.push(item);
            return true;
        }
        return false;
    };

    var _vanquish = function(list, item) {
        var idx = list.indexOf(item);
        if (idx != -1) list.splice(idx, 1);
    };

    var _difference = function(l1, l2) {
        var d = [];
        for (var i = 0; i < l1.length; i++) {
            if (l2.indexOf(l1[i]) == -1)
                d.push(l1[i]);
        }
        return d;
    };

    var _isString = function(f) {
        return f == null ? false : (typeof f === "string" || f.constructor == String);
    };

    var getOffsetRect = function (elem) {
        // (1)
        var box = elem.getBoundingClientRect(),
            body = document.body,
            docElem = document.documentElement,
        // (2)
            scrollTop = window.pageYOffset || docElem.scrollTop || body.scrollTop,
            scrollLeft = window.pageXOffset || docElem.scrollLeft || body.scrollLeft,
        // (3)
            clientTop = docElem.clientTop || body.clientTop || 0,
            clientLeft = docElem.clientLeft || body.clientLeft || 0,
        // (4)
            top  = box.top +  scrollTop - clientTop,
            left = box.left + scrollLeft - clientLeft;

        return { top: Math.round(top), left: Math.round(left) };
    };

    var matchesSelector = function(el, selector, ctx) {
        ctx = ctx || el.parentNode;
        var possibles = ctx.querySelectorAll(selector);
        for (var i = 0; i < possibles.length; i++) {
            if (possibles[i] === el)
                return true;
        }
        return false;
    };

    var iev = (function() {
            var rv = -1;
            if (navigator.appName == 'Microsoft Internet Explorer') {
                var ua = navigator.userAgent,
                    re = new RegExp("MSIE ([0-9]{1,}[\.0-9]{0,})");
                if (re.exec(ua) != null)
                    rv = parseFloat(RegExp.$1);
            }
            return rv;
        })(),
        DEFAULT_GRID_X = 50,
        DEFAULT_GRID_Y = 50,
        isIELT9 = iev > -1 && iev < 9,
        isIE9 = iev == 9,
        _pl = function(e) {
            if (isIELT9) {
                return [ e.clientX + document.documentElement.scrollLeft, e.clientY + document.documentElement.scrollTop ];
            }
            else {
                var ts = _touches(e), t = _getTouch(ts, 0);
                // for IE9 pageX might be null if the event was synthesized. We try for pageX/pageY first,
                // falling back to clientX/clientY if necessary. In every other browser we want to use pageX/pageY.
                return isIE9 ? [t.pageX || t.clientX, t.pageY || t.clientY] : [t.pageX, t.pageY];
            }
        },
        _getTouch = function(touches, idx) { return touches.item ? touches.item(idx) : touches[idx]; },
        _touches = function(e) {
            return e.touches && e.touches.length > 0 ? e.touches :
                    e.changedTouches && e.changedTouches.length > 0 ? e.changedTouches :
                    e.targetTouches && e.targetTouches.length > 0 ? e.targetTouches :
                [ e ];
        },
        _classes = {
            draggable:"katavorio-draggable",    // draggable elements
            droppable:"katavorio-droppable",    // droppable elements
            drag : "katavorio-drag",            // elements currently being dragged
            selected:"katavorio-drag-selected", // elements in current drag selection
            active : "katavorio-drag-active",   // droppables that are targets of a currently dragged element
            hover : "katavorio-drag-hover",     // droppables over which a matching drag element is hovering
            noSelect : "katavorio-drag-no-select", // added to the body to provide a hook to suppress text selection
            ghostProxy:"katavorio-ghost-proxy"  // added to a ghost proxy element in use when a drag has exited the bounds of its parent.
        },
        _defaultScope = "katavorio-drag-scope",
        _events = [ "stop", "start", "drag", "drop", "over", "out", "beforeStart" ],
        _devNull = function() {},
        _true = function() { return true; },
        _foreach = function(l, fn, from) {
            for (var i = 0; i < l.length; i++) {
                if (l[i] != from)
                    fn(l[i]);
            }
        },
        _setDroppablesActive = function(dd, val, andHover, drag) {
            _foreach(dd, function(e) {
                e.setActive(val);
                if (val) e.updatePosition();
                if (andHover) e.setHover(drag, val);
            });
        },
        _each = function(obj, fn) {
            if (obj == null) return;
            obj = !_isString(obj) && (obj.tagName == null && obj.length != null) ? obj : [ obj ];
            for (var i = 0; i < obj.length; i++)
                fn.apply(obj[i], [ obj[i] ]);
        },
        _consume = function(e) {
            if (e.stopPropagation) {
                e.stopPropagation();
                e.preventDefault();
            }
            else {
                e.returnValue = false;
            }
        },
        _defaultInputFilterSelector = "input,textarea,select,button,option",
    //
    // filters out events on all input elements, like textarea, checkbox, input, select.
        _inputFilter = function(e, el, _katavorio) {
            var t = e.srcElement || e.target;
            return !matchesSelector(t, _katavorio.getInputFilterSelector(), el);
        };

    var Super = function(el, params, css, scope) {
        this.params = params || {};
        this.el = el;
        this.params.addClass(this.el, this._class);
        this.uuid = _uuid();
        var enabled = true;
        this.setEnabled = function(e) { enabled = e; };
        this.isEnabled = function() { return enabled; };
        this.toggleEnabled = function() { enabled = !enabled; };
        this.setScope = function(scopes) {
            this.scopes = scopes ? scopes.split(/\s+/) : [ scope ];
        };
        this.addScope = function(scopes) {
            var m = {};
            _each(this.scopes, function(s) { m[s] = true;});
            _each(scopes ? scopes.split(/\s+/) : [], function(s) { m[s] = true;});
            this.scopes = [];
            for (var i in m) this.scopes.push(i);
        };
        this.removeScope = function(scopes) {
            var m = {};
            _each(this.scopes, function(s) { m[s] = true;});
            _each(scopes ? scopes.split(/\s+/) : [], function(s) { delete m[s];});
            this.scopes = [];
            for (var i in m) this.scopes.push(i);
        };
        this.toggleScope = function(scopes) {
            var m = {};
            _each(this.scopes, function(s) { m[s] = true;});
            _each(scopes ? scopes.split(/\s+/) : [], function(s) {
                if (m[s]) delete m[s];
                else m[s] = true;
            });
            this.scopes = [];
            for (var i in m) this.scopes.push(i);
        };
        this.setScope(params.scope);
        this.k = params.katavorio;
        return params.katavorio;
    };

    var TRUE = function() { return true; };
    var FALSE = function() { return false; };

    var Drag = function(el, params, css, scope) {
        this._class = css.draggable;
        var k = Super.apply(this, arguments);
        this.rightButtonCanDrag = this.params.rightButtonCanDrag;
        var downAt = [0,0], posAtDown = null, pagePosAtDown = null, pageDelta = [0,0], moving = false,
            consumeStartEvent = this.params.consumeStartEvent !== false,
            dragEl = this.el,
            clone = this.params.clone,
            scroll = this.params.scroll,
            _multipleDrop = params.multipleDrop !== false,
            isConstrained = false,
            useGhostProxy = params.ghostProxy === true ? TRUE : params.ghostProxy && typeof params.ghostProxy === "function" ? params.ghostProxy : FALSE,
            ghostProxy = function(el) { return el.cloneNode(true); };

        var snapThreshold = params.snapThreshold || 5,
            _snap = function(pos, x, y, thresholdX, thresholdY) {
                thresholdX = thresholdX || snapThreshold;
                thresholdY = thresholdY || snapThreshold;
                var _dx = Math.floor(pos[0] / x),
                    _dxl = x * _dx,
                    _dxt = _dxl + x,
                    _x = Math.abs(pos[0] - _dxl) <= thresholdX ? _dxl : Math.abs(_dxt - pos[0]) <= thresholdX ? _dxt : pos[0];

                var _dy = Math.floor(pos[1] / y),
                    _dyl = y * _dy,
                    _dyt = _dyl + y,
                    _y = Math.abs(pos[1] - _dyl) <= thresholdY ? _dyl : Math.abs(_dyt - pos[1]) <= thresholdY ? _dyt : pos[1];

                return [ _x, _y];
            };

        this.posses = [];
        this.posseRoles = {};

        this.toGrid = function(pos) {
            if (this.params.grid == null) {
                return pos;
            }
            else {
                return _snap(pos, this.params.grid[0], this.params.grid[1]);
            }
        };

        this.snap = function(x, y) {
            if (dragEl == null) return;
            x = x || (this.params.grid ? this.params.grid[0] : DEFAULT_GRID_X);
            y = y || (this.params.grid ? this.params.grid[1] : DEFAULT_GRID_Y);
            var p = this.params.getPosition(dragEl);
            this.params.setPosition(dragEl, _snap(p, x, y, x, y));
        };

        this.setUseGhostProxy = function(val) {
            useGhostProxy = val ? TRUE : FALSE;
        };

        var constrain;
        var negativeFilter = function(pos) {
            return (params.allowNegative === false) ? [ Math.max (0, pos[0]), Math.max(0, pos[1]) ] : pos;
        };

        var _setConstrain = function(value) {
            constrain = typeof value === "function" ? value : value ? function(pos) {
                return negativeFilter([
                    Math.max(0, Math.min(constrainRect.w - this.size[0], pos[0])),
                    Math.max(0, Math.min(constrainRect.h - this.size[1], pos[1]))
                ]);
            }.bind(this) : function(pos) { return negativeFilter(pos); };
        }.bind(this);

        _setConstrain(typeof this.params.constrain === "function" ? this.params.constrain  : (this.params.constrain || this.params.containment));


        /**
         * Sets whether or not the Drag is constrained. A value of 'true' means constrain to parent bounds; a function
         * will be executed and returns true if the position is allowed.
         * @param value
         */
        this.setConstrain = function(value) {
            _setConstrain(value);
        };

        var revertFunction;
        /**
         * Sets a function to call on drag stop, which, if it returns true, indicates that the given element should
         * revert to its position before the previous drag.
         * @param fn
         */
        this.setRevert = function(fn) {
            revertFunction = fn;
        };

        var _assignId = function(obj) {
                if (typeof obj == "function") {
                    obj._katavorioId = _uuid();
                    return obj._katavorioId;
                } else {
                    return obj;
                }
            },
        // a map of { spec -> [ fn, exclusion ] } entries.
            _filters = {},
            _testFilter = function(e) {
                for (var key in _filters) {
                    var f = _filters[key];
                    var rv = f[0](e);
                    if (f[1]) rv = !rv;
                    if (!rv) return false;
                }
                return true;
            },
            _setFilter = this.setFilter = function(f, _exclude) {
                if (f) {
                    var key = _assignId(f);
                    _filters[key] = [
                        function(e) {
                            var t = e.srcElement || e.target, m;
                            if (_isString(f)) {
                                m = matchesSelector(t, f, el);
                            }
                            else if (typeof f === "function") {
                                m = f(e, el);
                            }
                            return m;
                        },
                            _exclude !== false
                    ];

                }
            },
            _addFilter = this.addFilter = _setFilter,
            _removeFilter = this.removeFilter = function(f) {
                var key = typeof f == "function" ? f._katavorioId : f;
                delete _filters[key];
            };

        this.clearAllFilters = function() {
            _filters = {};
        };

        this.canDrag = this.params.canDrag || _true;

        var constrainRect,
            matchingDroppables = [], intersectingDroppables = [];

        this.downListener = function(e) {
            var isNotRightClick = this.rightButtonCanDrag || (e.which !== 3 && e.button !== 2);
            if (isNotRightClick && this.isEnabled() && this.canDrag()) {
                var _f =  _testFilter(e) && _inputFilter(e, this.el, this.k);
                if (_f) {
                    if (!clone)
                        dragEl = this.el;
                    else {
                        dragEl = this.el.cloneNode(true);
                        dragEl.setAttribute("id", null);
                        dragEl.style.position = "absolute";
                        // the clone node is added to the body; getOffsetRect gives us a value
                        // relative to the body.
                        var b = getOffsetRect(this.el);
                        dragEl.style.left = b.left + "px";
                        dragEl.style.top = b.top + "px";
                        document.body.appendChild(dragEl);
                    }
                    consumeStartEvent && _consume(e);
                    downAt = _pl(e);
                    //
                    this.params.bind(document, "mousemove", this.moveListener);
                    this.params.bind(document, "mouseup", this.upListener);
                    k.markSelection(this);
                    k.markPosses(this);
                    this.params.addClass(document.body, css.noSelect);
                    _dispatch("beforeStart", {el:this.el, pos:posAtDown, e:e, drag:this});
                }
                else if (this.params.consumeFilteredEvents) {
                    _consume(e);
                }
            }
        }.bind(this);

        this.moveListener = function(e) {
            if (downAt) {
                if (!moving) {
                    var _continue = _dispatch("start", {el:this.el, pos:posAtDown, e:e, drag:this});
                    if (_continue !== false) {
                        if (!downAt) return;
                        this.mark(true);
                        moving = true;
                    }
                }

                // it is possible that the start event caused the drag to be aborted. So we check
                // again that we are currently dragging.
                if (downAt) {
                    intersectingDroppables.length = 0;
                    var pos = _pl(e), dx = pos[0] - downAt[0], dy = pos[1] - downAt[1],
                        z = this.params.ignoreZoom ? 1 : k.getZoom();
                    dx /= z;
                    dy /= z;
                    this.moveBy(dx, dy, e);
                    k.updateSelection(dx, dy, this);
                    k.updatePosses(dx, dy, this);
                }
            }
        }.bind(this);

        this.upListener = function(e) {
            if (downAt) {
                downAt = null;
                this.params.unbind(document, "mousemove", this.moveListener);
                this.params.unbind(document, "mouseup", this.upListener);
                this.params.removeClass(document.body, css.noSelect);
                this.unmark(e);
                k.unmarkSelection(this, e);
                k.unmarkPosses(this, e);
                this.stop(e);
                k.notifySelectionDragStop(this, e);
                k.notifyPosseDragStop(this, e);
                moving = false;
                if (clone) {
                    dragEl && dragEl.parentNode && dragEl.parentNode.removeChild(dragEl);
                    dragEl = null;
                }

                intersectingDroppables.length = 0;

                if (revertFunction && revertFunction(this.el, this.params.getPosition(this.el)) === true) {
                    this.params.setPosition(this.el, posAtDown);
                    _dispatch("revert", this.el);
                }
            }
        }.bind(this);

        this.getFilters = function() { return _filters; };

        this.abort = function() {
            if (downAt != null)
                this.upListener();
        };

        this.getDragElement = function() {
            return dragEl || this.el;
        };

        var listeners = {"start":[], "drag":[], "stop":[], "over":[], "out":[], "beforeStart":[], "revert":[] };
        if (params.events.start) listeners.start.push(params.events.start);
        if (params.events.beforeStart) listeners.beforeStart.push(params.events.beforeStart);
        if (params.events.stop) listeners.stop.push(params.events.stop);
        if (params.events.drag) listeners.drag.push(params.events.drag);
        if (params.events.revert) listeners.revert.push(params.events.revert);

        this.on = function(evt, fn) {
            if (listeners[evt]) listeners[evt].push(fn);
        };

        this.off = function(evt, fn) {
            if (listeners[evt]) {
                var l = [];
                for (var i = 0; i < listeners[evt].length; i++) {
                    if (listeners[evt][i] !== fn) l.push(listeners[evt][i]);
                }
                listeners[evt] = l;
            }
        };

        var _dispatch = function(evt, value) {
            if (listeners[evt]) {
                for (var i = 0; i < listeners[evt].length; i++) {
                    try {
                        listeners[evt][i](value);
                    }
                    catch (e) { }
                }
            }
        };

        this.notifyStart = function(e) {
            _dispatch("start", {el:this.el, pos:this.params.getPosition(dragEl), e:e, drag:this});
        };

        this.stop = function(e, force) {
            if (force || moving) {
                var positions = [],
                    sel = k.getSelection(),
                    dPos = this.params.getPosition(dragEl);

                if (sel.length > 1) {
                    for (var i = 0; i < sel.length; i++) {
                        var p = this.params.getPosition(sel[i].el);
                        positions.push([ sel[i].el, { left: p[0], top: p[1] }, sel[i] ]);
                    }
                }
                else {
                    positions.push([ dragEl, {left:dPos[0], top:dPos[1]}, this ]);
                }

                _dispatch("stop", {
                    el: dragEl,
                    pos: ghostProxyOffsets || dPos,
                    finalPos:dPos,
                    e: e,
                    drag: this,
                    selection:positions
                });
            }
        };

        this.mark = function(andNotify) {
            posAtDown = this.params.getPosition(dragEl);
            pagePosAtDown = this.params.getPosition(dragEl, true);
            pageDelta = [pagePosAtDown[0] - posAtDown[0], pagePosAtDown[1] - posAtDown[1]];
            this.size = this.params.getSize(dragEl);
            matchingDroppables = k.getMatchingDroppables(this);
            _setDroppablesActive(matchingDroppables, true, false, this);
            this.params.addClass(dragEl, this.params.dragClass || css.drag);
            //if (this.params.constrain || this.params.containment) {
            var cs = this.params.getSize(dragEl.parentNode);
            constrainRect = { w:cs[0], h:cs[1] };
            //}
            if (andNotify) {
                k.notifySelectionDragStart(this);
            }
        };
        var ghostProxyOffsets;
        this.unmark = function(e, doNotCheckDroppables) {
            _setDroppablesActive(matchingDroppables, false, true, this);


            if (isConstrained && useGhostProxy(this.el)) {
                ghostProxyOffsets = [dragEl.offsetLeft, dragEl.offsetTop];
                this.el.parentNode.removeChild(dragEl);
                dragEl = this.el;
            }
            else {
                ghostProxyOffsets = null;
            }

            this.params.removeClass(dragEl, this.params.dragClass || css.drag);
            matchingDroppables.length = 0;
            isConstrained = false;
            if (!doNotCheckDroppables) {
                if (intersectingDroppables.length > 0 && ghostProxyOffsets) {
                    params.setPosition(this.el, ghostProxyOffsets);
                }
                intersectingDroppables.sort(_rankSort);
                for (var i = 0; i < intersectingDroppables.length; i++) {
                    var retVal = intersectingDroppables[i].drop(this, e);
                    if (retVal === true) break;
                }
            }
        };
        this.moveBy = function(dx, dy, e) {
            intersectingDroppables.length = 0;
            var desiredLoc = this.toGrid([posAtDown[0] + dx, posAtDown[1] + dy]),
                cPos = constrain(desiredLoc, dragEl);

            if (useGhostProxy(this.el)) {
                if (desiredLoc[0] != cPos[0] || desiredLoc[1] != cPos[1]) {
                    if (!isConstrained) {
                        var gp = ghostProxy(this.el);
                        params.addClass(gp, _classes.ghostProxy);
                        this.el.parentNode.appendChild(gp);
                        dragEl = gp;
                        isConstrained = true;
                    }
                    cPos = desiredLoc;
                }
                else {
                    if (isConstrained) {
                        this.el.parentNode.removeChild(dragEl);
                        dragEl = this.el;
                        isConstrained = false;
                    }
                }
            }

            var rect = { x:cPos[0], y:cPos[1], w:this.size[0], h:this.size[1]},
                pageRect = { x:rect.x + pageDelta[0], y:rect.y + pageDelta[1], w:rect.w, h:rect.h},
                focusDropElement = null;



            this.params.setPosition(dragEl, cPos);
            for (var i = 0; i < matchingDroppables.length; i++) {
                var r2 = { x:matchingDroppables[i].pagePosition[0], y:matchingDroppables[i].pagePosition[1], w:matchingDroppables[i].size[0], h:matchingDroppables[i].size[1]};
                if (this.params.intersects(pageRect, r2) && (_multipleDrop || focusDropElement == null || focusDropElement == matchingDroppables[i].el) && matchingDroppables[i].canDrop(this)) {
                    if (!focusDropElement) focusDropElement = matchingDroppables[i].el;
                    intersectingDroppables.push(matchingDroppables[i]);
                    matchingDroppables[i].setHover(this, true, e);
                }
                else if (matchingDroppables[i].isHover()) {
                    matchingDroppables[i].setHover(this, false, e);
                }
            }

            _dispatch("drag", {el:this.el, pos:cPos, e:e, drag:this});

            /* test to see if the parent needs to be scrolled (future)
             if (scroll) {
             var pnsl = dragEl.parentNode.scrollLeft, pnst = dragEl.parentNode.scrollTop;
             console.log("scroll!", pnsl, pnst);
             }*/
        };
        this.destroy = function() {
            this.params.unbind(this.el, "mousedown", this.downListener);
            this.params.unbind(document, "mousemove", this.moveListener);
            this.params.unbind(document, "mouseup", this.upListener);
            this.downListener = null;
            this.upListener = null;
            this.moveListener = null;
        };

        // init:register mousedown, and perhaps set a filter
        this.params.bind(this.el, "mousedown", this.downListener);

        // if handle provded, use that.  otherwise, try to set a filter.
        // note that a `handle` selector always results in filterExclude being set to false, ie.
        // the selector defines the handle element(s).
        if (this.params.handle)
            _setFilter(this.params.handle, false);
        else
            _setFilter(this.params.filter, this.params.filterExclude);
    };

    var Drop = function(el, params, css, scope) {
        this._class = css.droppable;
        this.params = params || {};
        this.rank = params.rank || 0;
        this._activeClass = this.params.activeClass || css.active;
        this._hoverClass = this.params.hoverClass || css.hover;
        Super.apply(this, arguments);
        var hover = false;
        this.allowLoopback = this.params.allowLoopback !== false;

        this.setActive = function(val) {
            this.params[val ? "addClass" : "removeClass"](this.el, this._activeClass);
        };

        this.updatePosition = function() {
            this.position = this.params.getPosition(this.el);
            this.pagePosition = this.params.getPosition(this.el, true);
            this.size = this.params.getSize(this.el);
        };

        this.canDrop = this.params.canDrop || function(drag) {
            return true;
        };

        this.isHover = function() { return hover; };

        this.setHover = function(drag, val, e) {
            // if turning off hover but this was not the drag that caused the hover, ignore.
            if (val || this.el._katavorioDragHover == null || this.el._katavorioDragHover == drag.el._katavorio) {
                this.params[val ? "addClass" : "removeClass"](this.el, this._hoverClass);
                //this.el._katavorioDragHover = val ? drag.el._katavorio : null;
                this.el._katavorioDragHover = val ? drag.el._katavorio : null;
                if (hover !== val)
                    this.params.events[val ? "over" : "out"]({el:this.el, e:e, drag:drag, drop:this});
                hover = val;
            }
        };

        this.drop = function(drag, event) {
            return this.params.events["drop"]({ drag:drag, e:event, drop:this });
        };

        this.destroy = function() {
            this._class = null;
            this._activeClass = null;
            this._hoverClass = null;
            //this.params = null;
            hover = null;
            //this.el = null;
        };
    };

    var _uuid = function() {
        return ('xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
            var r = Math.random()*16|0, v = c == 'x' ? r : (r&0x3|0x8);
            return v.toString(16);
        }));
    };

    var _rankSort = function(a,b) {
        return a.rank < b.rank ? 1 : a.rank > b.rank ? -1 : 0;
    };

    var _gel = function(el) {
        if (el == null) return null;
        el = (typeof el === "string" || el.constructor == String)  ? document.getElementById(el) : el;
        if (el == null) return null;
        el._katavorio = el._katavorio || _uuid();
        return el;
    };

    root.Katavorio = function(katavorioParams) {

        var _selection = [],
            _selectionMap = {};

        this._dragsByScope = {};
        this._dropsByScope = {};
        var _zoom = 1,
            _reg = function(obj, map) {
                _each(obj, function(_obj) {
                    for(var i = 0; i < _obj.scopes.length; i++) {
                        map[_obj.scopes[i]] = map[_obj.scopes[i]] || [];
                        map[_obj.scopes[i]].push(_obj);
                    }
                });
            },
            _unreg = function(obj, map) {
                var c = 0;
                _each(obj, function(_obj) {
                    for(var i = 0; i < _obj.scopes.length; i++) {
                        if (map[_obj.scopes[i]]) {
                            var idx = katavorioParams.indexOf(map[_obj.scopes[i]], _obj);
                            if (idx != -1) {
                                map[_obj.scopes[i]].splice(idx, 1);
                                c++;
                            }
                        }
                    }
                });

                return c > 0 ;
            },
            _getMatchingDroppables = this.getMatchingDroppables = function(drag) {
                var dd = [], _m = {};
                for (var i = 0; i < drag.scopes.length; i++) {
                    var _dd = this._dropsByScope[drag.scopes[i]];
                    if (_dd) {
                        for (var j = 0; j < _dd.length; j++) {
                            if (_dd[j].canDrop(drag) &&  !_m[_dd[j].uuid] && (_dd[j].allowLoopback || _dd[j].el !== drag.el)) {
                                _m[_dd[j].uuid] = true;
                                dd.push(_dd[j]);
                            }
                        }
                    }
                }
                dd.sort(_rankSort);
                return dd;
            },
            _prepareParams = function(p) {
                p = p || {};
                var _p = {
                    events:{}
                }, i;
                for (i in katavorioParams) _p[i] = katavorioParams[i];
                for (i in p) _p[i] = p[i];
                // events

                for (i = 0; i < _events.length; i++) {
                    _p.events[_events[i]] = p[_events[i]] || _devNull;
                }
                _p.katavorio = this;
                return _p;
            }.bind(this),
            _mistletoe = function(existingDrag, params) {
                for (var i = 0; i < _events.length; i++) {
                    if (params[_events[i]]) {
                        existingDrag.on(_events[i], params[_events[i]]);
                    }
                }
            }.bind(this),
            _css = {},
            overrideCss = katavorioParams.css || {},
            _scope = katavorioParams.scope || _defaultScope;

        // prepare map of css classes based on defaults frst, then optional overrides
        for (var i in _classes) _css[i] = _classes[i];
        for (var i in overrideCss) _css[i] = overrideCss[i];

        var inputFilterSelector = katavorioParams.inputFilterSelector || _defaultInputFilterSelector;
        /**
         * Gets the selector identifying which input elements to filter from drag events.
         * @method getInputFilterSelector
         * @return {String} Current input filter selector.
         */
        this.getInputFilterSelector = function() { return inputFilterSelector; };

        /**
         * Sets the selector identifying which input elements to filter from drag events.
         * @method setInputFilterSelector
         * @param {String} selector Input filter selector to set.
         * @return {Katavorio} Current instance; method may be chained.
         */
        this.setInputFilterSelector = function(selector) {
            inputFilterSelector = selector;
            return this;
        };

        this.draggable = function(el, params) {
            var o = [];
            _each(el, function(_el) {
                _el = _gel(_el);
                if (_el != null) {
                    if (_el._katavorioDrag == null) {
                        var p = _prepareParams(params);
                        _el._katavorioDrag = new Drag(_el, p, _css, _scope);
                        _reg(_el._katavorioDrag, this._dragsByScope);
                        o.push(_el._katavorioDrag);
                        katavorioParams.addClass(_el, _css.draggable);
                    }
                    else {
                        _mistletoe(_el._katavorioDrag, params);
                    }
                }
            }.bind(this));
            return o;

        };

        this.droppable = function(el, params) {
            var o = [];
            _each(el, function(_el) {
                _el = _gel(_el);
                if (_el != null) {
                    var drop = new Drop(_el, _prepareParams(params), _css, _scope);
                    _el._katavorioDrop = _el._katavorioDrop || [];
                    _el._katavorioDrop.push(drop);
                    _reg(drop, this._dropsByScope);
                    o.push(drop);
                    katavorioParams.addClass(_el, _css.droppable);
                }
            }.bind(this));
            return o;
        };

        /**
         * @name Katavorio#select
         * @function
         * @desc Adds an element to the current selection (for multiple node drag)
         * @param {Element|String} DOM element - or id of the element - to add.
         */
        this.select = function(el) {
            _each(el, function() {
                var _el = _gel(this);
                if (_el && _el._katavorioDrag) {
                    if (!_selectionMap[_el._katavorio]) {
                        _selection.push(_el._katavorioDrag);
                        _selectionMap[_el._katavorio] = [ _el, _selection.length - 1 ];
                        katavorioParams.addClass(_el, _css.selected);
                    }
                }
            });
            return this;
        };

        /**
         * @name Katavorio#deselect
         * @function
         * @desc Removes an element from the current selection (for multiple node drag)
         * @param {Element|String} DOM element - or id of the element - to remove.
         */
        this.deselect = function(el) {
            _each(el, function() {
                var _el = _gel(this);
                if (_el && _el._katavorio) {
                    var e = _selectionMap[_el._katavorio];
                    if (e) {
                        var _s = [];
                        for (var i = 0; i < _selection.length; i++)
                            if (_selection[i].el !== _el) _s.push(_selection[i]);
                        _selection = _s;
                        delete _selectionMap[_el._katavorio];
                        katavorioParams.removeClass(_el, _css.selected);
                    }
                }
            });
            return this;
        };

        this.deselectAll = function() {
            for (var i in _selectionMap) {
                var d = _selectionMap[i];
                katavorioParams.removeClass(d[0], _css.selected);
            }

            _selection.length = 0;
            _selectionMap = {};
        };

        this.markSelection = function(drag) {
            _foreach(_selection, function(e) { e.mark(); }, drag);
        };

        this.markPosses = function(drag) {
            if (drag.posses) {
                _each(drag.posses, function(p) {
                    if (drag.posseRoles[p] && _posses[p]) {
                        _foreach(_posses[p].members, function (d) {
                            d.mark();
                        }, drag);
                    }
                })
            }
        };

        this.unmarkSelection = function(drag, event) {
            _foreach(_selection, function(e) { e.unmark(event); }, drag);
        };

        this.unmarkPosses = function(drag, event) {
            if (drag.posses) {
                _each(drag.posses, function(p) {
                    if (drag.posseRoles[p] && _posses[p]) {
                        _foreach(_posses[p].members, function (d) {
                            d.unmark(event, true);
                        }, drag);
                    }
                });
            }
        };

        this.getSelection = function() { return _selection.slice(0); };

        this.updateSelection = function(dx, dy, drag) {
            _foreach(_selection, function(e) { e.moveBy(dx, dy); }, drag);
        };

        var _posseAction = function(fn, drag) {
            if (drag.posses) {
                _each(drag.posses, function(p) {
                    if (drag.posseRoles[p] && _posses[p]) {
                        _foreach(_posses[p].members, function (e) {
                            fn(e);
                        }, drag);
                    }
                });
            }
        };

        this.updatePosses = function(dx, dy, drag) {
            _posseAction(function(e) { e.moveBy(dx, dy); }, drag);
        };

        this.notifyPosseDragStop = function(drag, evt) {
            _posseAction(function(e) { e.stop(evt, true); }, drag);
        };

        this.notifySelectionDragStop = function(drag, evt) {
            _foreach(_selection, function(e) { e.stop(evt, true); }, drag);
        };

        this.notifySelectionDragStart = function(drag, evt) {
            _foreach(_selection, function(e) { e.notifyStart(evt);}, drag);
        };

        this.setZoom = function(z) { _zoom = z; };
        this.getZoom = function() { return _zoom; };

        // does the work of changing scopes
        var _scopeManip = function(kObj, scopes, map, fn) {
            _each(kObj, function(_kObj) {
                _unreg(_kObj, map);  // deregister existing scopes
                _kObj[fn](scopes); // set scopes
                _reg(_kObj, map); // register new ones
            });
        };

        _each([ "set", "add", "remove", "toggle"], function(v) {
            this[v + "Scope"] = function(el, scopes) {
                _scopeManip(el._katavorioDrag, scopes, this._dragsByScope, v + "Scope");
                _scopeManip(el._katavorioDrop, scopes, this._dropsByScope, v + "Scope");
            }.bind(this);
            this[v + "DragScope"] = function(el, scopes) {
                _scopeManip(el.constructor === Drag ? el : el._katavorioDrag, scopes, this._dragsByScope, v + "Scope");
            }.bind(this);
            this[v + "DropScope"] = function(el, scopes) {
                _scopeManip(el.constructor === Drop ? el : el._katavorioDrop, scopes, this._dropsByScope, v + "Scope");
            }.bind(this);
        }.bind(this));

        this.snapToGrid = function(x, y) {
            for (var s in this._dragsByScope) {
                _foreach(this._dragsByScope[s], function(d) { d.snap(x, y); });
            }
        };

        this.getDragsForScope = function(s) { return this._dragsByScope[s]; };
        this.getDropsForScope = function(s) { return this._dropsByScope[s]; };

        var _destroy = function(el, type, map) {
            el = _gel(el);
            if (el[type]) {

                // remove from selection, if present.
                var selIdx = _selection.indexOf(el[type]);
                if (selIdx >= 0) {
                    _selection.splice(selIdx, 1);
                }

                if (_unreg(el[type], map)) {
                    _each(el[type], function(kObj) { kObj.destroy() });
                }

                delete el[type];
            }
        };

        this.elementRemoved = function(el) {
            this.destroyDraggable(el);
            this.destroyDroppable(el);
        };

        this.destroyDraggable = function(el) {
            _destroy(el, "_katavorioDrag", this._dragsByScope);
        };

        this.destroyDroppable = function(el) {
            _destroy(el, "_katavorioDrop", this._dropsByScope);
        };

        this.reset = function() {
            this._dragsByScope = {};
            this._dropsByScope = {};
            _selection = [];
            _selectionMap = {};
            _posses = {};
        };

        // ----- groups
        var _posses = {};

        var _processOneSpec = function(el, _spec, dontAddExisting) {
            var posseId = _isString(_spec) ? _spec : _spec.id;
            var active = _isString(_spec) ? true : _spec.active !== false;
            var posse = _posses[posseId] || (function() {
                var g = {name:posseId, members:[]};
                _posses[posseId] = g;
                return g;
            })();
            _each(el, function(_el) {
                if (_el._katavorioDrag) {

                    if (dontAddExisting && _el._katavorioDrag.posseRoles[posse.name] != null) return;

                    _suggest(posse.members, _el._katavorioDrag);
                    _suggest(_el._katavorioDrag.posses, posse.name);
                    _el._katavorioDrag.posseRoles[posse.name] = active;
                }
            });
            return posse;
        };

        /**
         * Add the given element to the posse with the given id, creating the group if it at first does not exist.
         * @method addToPosse
         * @param {Element} el Element to add.
         * @param {String...|Object...} spec Variable args parameters. Each argument can be a either a String, indicating
         * the ID of a Posse to which the element should be added as an active participant, or an Object containing
         * `{ id:"posseId", active:false/true}`. In the latter case, if `active` is not provided it is assumed to be
         * true.
         * @returns {Posse|Posse[]} The Posse(s) to which the element(s) was/were added.
         */
        this.addToPosse = function(el, spec) {

            var posses = [];

            for (var i = 1; i < arguments.length; i++) {
                posses.push(_processOneSpec(el, arguments[i]));
            }

            return posses.length == 1 ? posses[0] : posses;
        };

        /**
         * Sets the posse(s) for the element with the given id, creating those that do not yet exist, and removing from
         * the element any current Posses that are not specified by this method call. This method will not change the
         * active/passive state if it is given a posse in which the element is already a member.
         * @method setPosse
         * @param {Element} el Element to set posse(s) on.
         * @param {String...|Object...} spec Variable args parameters. Each argument can be a either a String, indicating
         * the ID of a Posse to which the element should be added as an active participant, or an Object containing
         * `{ id:"posseId", active:false/true}`. In the latter case, if `active` is not provided it is assumed to be
         * true.
         * @returns {Posse|Posse[]} The Posse(s) to which the element(s) now belongs.
         */
        this.setPosse = function(el, spec) {

            var posses = [];

            for (var i = 1; i < arguments.length; i++) {
                posses.push(_processOneSpec(el, arguments[i], true).name);
            }

            _each(el, function(_el) {
                if (_el._katavorioDrag) {
                    var diff = _difference(_el._katavorioDrag.posses, posses);
                    var p = [];
                    Array.prototype.push.apply(p, _el._katavorioDrag.posses);
                    for (var i = 0; i < diff.length; i++) {
                        this.removeFromPosse(_el, diff[i]);
                    }
                }
            }.bind(this));

            return posses.length == 1 ? posses[0] : posses;
        };

        /**
         * Remove the given element from the given posse(s).
         * @method removeFromPosse
         * @param {Element} el Element to remove.
         * @param {String...} posseId Varargs parameter: one value for each posse to remove the element from.
         */
        this.removeFromPosse = function(el, posseId) {
            if (arguments.length < 2) throw new TypeError("No posse id provided for remove operation");
            for(var i = 1; i < arguments.length; i++) {
                posseId = arguments[i];
                _each(el, function (_el) {
                    if (_el._katavorioDrag && _el._katavorioDrag.posses) {
                        var d = _el._katavorioDrag;
                        _each(posseId, function (p) {
                            _vanquish(_posses[p].members, d);
                            _vanquish(d.posses, p);
                            delete d.posseRoles[p];
                        });
                    }
                });
            }
        };

        /**
         * Remove the given element from all Posses to which it belongs.
         * @method removeFromAllPosses
         * @param {Element|Element[]} el Element to remove from Posses.
         */
        this.removeFromAllPosses = function(el) {
            _each(el, function(_el) {
                if (_el._katavorioDrag && _el._katavorioDrag.posses) {
                    var d = _el._katavorioDrag;
                    _each(d.posses, function(p) {
                        _vanquish(_posses[p].members, d);
                    });
                    d.posses.length = 0;
                    d.posseRoles = {};
                }
            });
        };

        /**
         * Changes the participation state for the element in the Posse with the given ID.
         * @param {Element|Element[]} el Element(s) to change state for.
         * @param {String} posseId ID of the Posse to change element state for.
         * @param {Boolean} state True to make active, false to make passive.
         */
        this.setPosseState = function(el, posseId, state) {
            var posse = _posses[posseId];
            if (posse) {
                _each(el, function(_el) {
                    if (_el._katavorioDrag && _el._katavorioDrag.posses) {
                        _el._katavorioDrag.posseRoles[posse.name] = state;
                    }
                });
            }
        };

    };

    root.Katavorio.version = "0.19.2";

    if (true) {
        exports.Katavorio = root.Katavorio;
    }

}).call(typeof window !== 'undefined' ? window : this);

/*
 * jsPlumb
 *
 * Title:jsPlumb 2.3.0
 *
 * Provides a way to visually connect elements on an HTML page, using SVG.
 *
 * This file contains utility functions that run in both browsers and headless.
 *
 * Copyright (c) 2010 - 2017 jsPlumb (hello@jsplumbtoolkit.com)
 *
 * http://jsplumbtoolkit.com
 * http://github.com/sporritt/jsplumb
 *
 * Dual licensed under the MIT and GPL2 licenses.
 */

;
(function () {

    var _isa = function (a) {
            return Object.prototype.toString.call(a) === "[object Array]";
        },
        _isnum = function (n) {
            return Object.prototype.toString.call(n) === "[object Number]";
        },
        _iss = function (s) {
            return typeof s === "string";
        },
        _isb = function (s) {
            return typeof s === "boolean";
        },
        _isnull = function (s) {
            return s == null;
        },
        _iso = function (o) {
            return o == null ? false : Object.prototype.toString.call(o) === "[object Object]";
        },
        _isd = function (o) {
            return Object.prototype.toString.call(o) === "[object Date]";
        },
        _isf = function (o) {
            return Object.prototype.toString.call(o) === "[object Function]";
        },
        _isNamedFunction = function(o) {
            return _isf(o) && o.name != null && o.name.length > 0;
        },
        _ise = function (o) {
            for (var i in o) {
                if (o.hasOwnProperty(i)) {
                    return false;
                }
            }
            return true;
        };

    var root = this;
    root.jsPlumbUtil = {
        isArray: _isa,
        isString: _iss,
        isBoolean: _isb,
        isNull: _isnull,
        isObject: _iso,
        isDate: _isd,
        isFunction: _isf,
        isEmpty: _ise,
        isNumber: _isnum,
        clone: function (a) {
            if (_iss(a)) {
                return "" + a;
            }
            else if (_isb(a)) {
                return !!a;
            }
            else if (_isd(a)) {
                return new Date(a.getTime());
            }
            else if (_isf(a)) {
                return a;
            }
            else if (_isa(a)) {
                var b = [];
                for (var i = 0; i < a.length; i++) {
                    b.push(this.clone(a[i]));
                }
                return b;
            }
            else if (_iso(a)) {
                var c = {};
                for (var j in a) {
                    c[j] = this.clone(a[j]);
                }
                return c;
            }
            else {
                return a;
            }
        },
        merge: function (a, b, collations) {
            // first change the collations array - if present - into a lookup table, because its faster.
            var cMap = {}, ar, i;
            collations = collations || [];
            for (i = 0; i < collations.length; i++) {
                cMap[collations[i]] = true;
            }

            var c = this.clone(a);
            for (i in b) {
                if (c[i] == null) {
                    c[i] = b[i];
                }
                else if (_iss(b[i]) || _isb(b[i])) {
                    if (!cMap[i]) {
                        c[i] = b[i]; // if we dont want to collate, just copy it in.
                    }
                    else {
                        ar = [];
                        // if c's object is also an array we can keep its values.
                        ar.push.apply(ar, _isa(c[i]) ? c[i] : [ c[i] ]);
                        ar.push.apply(ar, _isa(b[i]) ? b[i] : [ b[i] ]);
                        c[i] = ar;
                    }
                }
                else {
                    if (_isa(b[i])) {
                        ar = [];
                        // if c's object is also an array we can keep its values.
                        if (_isa(c[i])) {
                            ar.push.apply(ar, c[i]);
                        }
                        ar.push.apply(ar, b[i]);
                        c[i] = ar;
                    }
                    else if (_iso(b[i])) {
                        // overwite c's value with an object if it is not already one.
                        if (!_iso(c[i])) {
                            c[i] = {};
                        }
                        for (var j in b[i]) {
                            c[i][j] = b[i][j];
                        }
                    }
                }

            }
            return c;
        },
        replace: function (inObj, path, value) {
            if (inObj == null) {
                return;
            }
            var q = inObj, t = q;
            path.replace(/([^\.])+/g, function (term, lc, pos, str) {
                var array = term.match(/([^\[0-9]+){1}(\[)([0-9+])/),
                    last = pos + term.length >= str.length,
                    _getArray = function () {
                        return t[array[1]] || (function () {
                            t[array[1]] = [];
                            return t[array[1]];
                        })();
                    };

                if (last) {
                    // set term = value on current t, creating term as array if necessary.
                    if (array) {
                        _getArray()[array[3]] = value;
                    }
                    else {
                        t[term] = value;
                    }
                }
                else {
                    // set to current t[term], creating t[term] if necessary.
                    if (array) {
                        var a = _getArray();
                        t = a[array[3]] || (function () {
                            a[array[3]] = {};
                            return a[array[3]];
                        })();
                    }
                    else {
                        t = t[term] || (function () {
                            t[term] = {};
                            return t[term];
                        })();
                    }
                }
            });

            return inObj;
        },
        //
        // chain a list of functions, supplied by [ object, method name, args ], and return on the first
        // one that returns the failValue. if none return the failValue, return the successValue.
        //
        functionChain: function (successValue, failValue, fns) {
            for (var i = 0; i < fns.length; i++) {
                var o = fns[i][0][fns[i][1]].apply(fns[i][0], fns[i][2]);
                if (o === failValue) {
                    return o;
                }
            }
            return successValue;
        },
        // take the given model and expand out any parameters.
        // 'functionPrefix' is optional, and if present, helps jsplumb figure out what to do if a value is a Function.
        // if you do not provide it, jsplumb will run the given values through any functions it finds, and use the function's
        // output as the value in the result. if you do provide the prefix, only functions that are named and have this prefix
        // will be executed; other functions will be passed as values to the output.
        populate: function (model, values, functionPrefix) {
            // for a string, see if it has parameter matches, and if so, try to make the substitutions.
            var getValue = function (fromString) {
                    var matches = fromString.match(/(\${.*?})/g);
                    if (matches != null) {
                        for (var i = 0; i < matches.length; i++) {
                            var val = values[matches[i].substring(2, matches[i].length - 1)] || "";
                            if (val != null) {
                                fromString = fromString.replace(matches[i], val);
                            }
                        }
                    }
                    return fromString;
                },
            // process one entry.
                _one = function (d) {
                    if (d != null) {
                        if (_iss(d)) {
                            return getValue(d);
                        }
                        else if (_isf(d) && (functionPrefix == null || (d.name || "").indexOf(functionPrefix) === 0)) {
                            return d(values);
                        }
                        else if (_isa(d)) {
                            var r = [];
                            for (var i = 0; i < d.length; i++) {
                                r.push(_one(d[i]));
                            }
                            return r;
                        }
                        else if (_iso(d)) {
                            var s = {};
                            for (var j in d) {
                                s[j] = _one(d[j]);
                            }
                            return s;
                        }
                        else {
                            return d;
                        }
                    }
                };

            return _one(model);
        },
        findWithFunction: function (a, f) {
            if (a) {
                for (var i = 0; i < a.length; i++) {
                    if (f(a[i])) {
                        return i;
                    }
                }
            }
            return -1;
        },
        removeWithFunction: function (a, f) {
            var idx = root.jsPlumbUtil.findWithFunction(a, f);
            if (idx > -1) {
                a.splice(idx, 1);
            }
            return idx !== -1;
        },
        remove: function (l, v) {
            var idx = l.indexOf(v);
            if (idx > -1) {
                l.splice(idx, 1);
            }
            return idx !== -1;
        },
        // TODO support insert index
        addWithFunction: function (list, item, hashFunction) {
            if (root.jsPlumbUtil.findWithFunction(list, hashFunction) === -1) {
                list.push(item);
            }
        },
        addToList: function (map, key, value, insertAtStart) {
            var l = map[key];
            if (l == null) {
                l = [];
                map[key] = l;
            }
            l[insertAtStart ? "unshift" : "push"](value);
            return l;
        },
        suggest : function(list, item, insertAtHead) {
            if (list.indexOf(item) === -1) {
                if (insertAtHead) {
                    list.unshift(item);
                } else {
                    list.push(item);
                }
                return true;
            }
            return false;
        },
        //
        // extends the given obj (which can be an array) with the given constructor function, prototype functions, and
        // class members, any of which may be null.
        //
        extend: function (child, parent, _protoFn) {
            var i;
            parent = _isa(parent) ? parent : [ parent ];

            for (i = 0; i < parent.length; i++) {
                for (var j in parent[i].prototype) {
                    if (parent[i].prototype.hasOwnProperty(j)) {
                        child.prototype[j] = parent[i].prototype[j];
                    }
                }
            }

            var _makeFn = function (name, protoFn) {
                return function () {
                    for (i = 0; i < parent.length; i++) {
                        if (parent[i].prototype[name]) {
                            parent[i].prototype[name].apply(this, arguments);
                        }
                    }
                    return protoFn.apply(this, arguments);
                };
            };

            var _oneSet = function (fns) {
                for (var k in fns) {
                    child.prototype[k] = _makeFn(k, fns[k]);
                }
            };

            if (arguments.length > 2) {
                for (i = 2; i < arguments.length; i++) {
                    _oneSet(arguments[i]);
                }
            }

            return child;
        },
        uuid: function () {
            return ('xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
                var r = Math.random() * 16 | 0, v = c === 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            }));
        },
        logEnabled: true,
        log: function () {
            if (root.jsPlumbUtil.logEnabled && typeof console !== "undefined") {
                try {
                    var msg = arguments[arguments.length - 1];
                    console.log(msg);
                }
                catch (e) {
                }
            }
        },

        /**
         * Wraps one function with another, creating a placeholder for the
         * wrapped function if it was null. this is used to wrap the various
         * drag/drop event functions - to allow jsPlumb to be notified of
         * important lifecycle events without imposing itself on the user's
         * drag/drop functionality.
         * @method jsPlumbUtil.wrap
         * @param {Function} wrappedFunction original function to wrap; may be null.
         * @param {Function} newFunction function to wrap the original with.
         * @param {Object} [returnOnThisValue] Optional. Indicates that the wrappedFunction should
         * not be executed if the newFunction returns a value matching 'returnOnThisValue'.
         * note that this is a simple comparison and only works for primitives right now.
         */
        wrap: function (wrappedFunction, newFunction, returnOnThisValue) {
            wrappedFunction = wrappedFunction || function () {
            };
            newFunction = newFunction || function () {
            };
            return function () {
                var r = null;
                try {
                    r = newFunction.apply(this, arguments);
                } catch (e) {
                    root.jsPlumbUtil.log("jsPlumb function failed : " + e);
                }
                if (returnOnThisValue == null || (r !== returnOnThisValue)) {
                    try {
                        r = wrappedFunction.apply(this, arguments);
                    } catch (e) {
                        root.jsPlumbUtil.log("wrapped function failed : " + e);
                    }
                }
                return r;
            };
        }
    };

    root.jsPlumbUtil.EventGenerator = function () {
        var _listeners = {},
            eventsSuspended = false,
            tick = false,
        // this is a list of events that should re-throw any errors that occur during their dispatch. it is current private.
            eventsToDieOn = { "ready": true },
            queue = [];

        this.bind = function (event, listener, insertAtStart) {
            var _one = function(evt) {
                root.jsPlumbUtil.addToList(_listeners, evt, listener, insertAtStart);
                listener.__jsPlumb = listener.__jsPlumb || {};
                listener.__jsPlumb[root.jsPlumbUtil.uuid()] = evt;
            };

            if (typeof event === "string") {
                _one(event);
            }
            else if (event.length != null) {
                for (var i = 0; i < event.length; i++) {
                    _one(event[i]);
                }
            }

            return this;
        };

        this.fire = function (event, value, originalEvent) {
            if (!tick) {
                tick = true;
                if (!eventsSuspended && _listeners[event]) {
                    var l = _listeners[event].length, i = 0, _gone = false, ret = null;
                    if (!this.shouldFireEvent || this.shouldFireEvent(event, value, originalEvent)) {
                        while (!_gone && i < l && ret !== false) {
                            // doing it this way rather than catching and then possibly re-throwing means that an error propagated by this
                            // method will have the whole call stack available in the debugger.
                            if (eventsToDieOn[event]) {
                                _listeners[event][i].apply(this, [value, originalEvent]);
                            }
                            else {
                                try {
                                    ret = _listeners[event][i].apply(this, [value, originalEvent]);
                                } catch (e) {
                                    root.jsPlumbUtil.log("jsPlumb: fire failed for event " + event + " : " + e);
                                }
                            }
                            i++;
                            if (_listeners == null || _listeners[event] == null) {
                                _gone = true;
                            }
                        }
                    }
                }
                tick = false;
                _drain();
            } else {
                queue.unshift(arguments);
            }
            return this;
        };

        var _drain = function() {
            var n = queue.pop();
            if (n) {
                this.fire.apply(this, n);
            }
        }.bind(this);

        this.unbind = function (eventOrListener, listener) {

            if (arguments.length === 0) {
                _listeners = {};
            }
            else if (arguments.length === 1) {
                if (typeof eventOrListener === "string") {
                    delete _listeners[eventOrListener];
                }
                else if (eventOrListener.__jsPlumb) {
                    var evt;
                    for (var i in eventOrListener.__jsPlumb) {
                        evt = eventOrListener.__jsPlumb[i];
                        root.jsPlumbUtil.remove(_listeners[evt] || [], eventOrListener);
                    }
                }
            }
            else if (arguments.length === 2) {
                root.jsPlumbUtil.remove(_listeners[eventOrListener] || [], listener);
            }

            return this;
        };

        this.getListener = function (forEvent) {
            return _listeners[forEvent];
        };
        this.setSuspendEvents = function (val) {
            eventsSuspended = val;
        };
        this.isSuspendEvents = function () {
            return eventsSuspended;
        };
        this.silently = function(fn) {
            this.setSuspendEvents(true);
            try {
                fn();
            }
            catch (e) {
                root.jsPlumbUtil.log("Cannot execute silent function " + e);
            }
            this.setSuspendEvents(false);
        };
        this.cleanupListeners = function () {
            for (var i in _listeners) {
                _listeners[i] = null;
            }
        };
    };

    root.jsPlumbUtil.EventGenerator.prototype = {
        cleanup: function () {
            this.cleanupListeners();
        }
    };

    if (true) {
        exports.jsPlumbUtil = root.jsPlumbUtil;
    }

}).call(typeof window !== 'undefined' ? window : this);

/*
 * jsPlumb Community Edition
 *
 * Provides a way to visually connect elements on an HTML page, using SVG.
 *
 * This file contains utility functions that run in browsers only.
 *
 * Copyright (c) 2010 - 2017 jsPlumb (hello@jsplumbtoolkit.com)
 *
 * https://jsplumbtoolkit.com
 * https://github.com/jsplumb/jsplumb
 *
 * Dual licensed under the MIT and GPL2 licenses.
 */
 ;(function() {

  "use strict";

   var root = this;

    root.jsPlumbUtil.matchesSelector = function(el, selector, ctx) {
       ctx = ctx || el.parentNode;
       var possibles = ctx.querySelectorAll(selector);
       for (var i = 0; i < possibles.length; i++) {
           if (possibles[i] === el) {
               return true;
           }
       }
       return false;
   };

    root.jsPlumbUtil.consume = function(e, doNotPreventDefault) {
       if (e.stopPropagation) {
           e.stopPropagation();
       }
       else {
           e.returnValue = false;
       }

       if (!doNotPreventDefault && e.preventDefault){
           e.preventDefault();
       }
   };

   /*
    * Function: sizeElement
    * Helper to size and position an element. You would typically use
    * this when writing your own Connector or Endpoint implementation.
    *
    * Parameters:
    *  x - [int] x position for the element origin
    *  y - [int] y position for the element origin
    *  w - [int] width of the element
    *  h - [int] height of the element
    *
    */
    root.jsPlumbUtil.sizeElement = function(el, x, y, w, h) {
       if (el) {
           el.style.height = h + "px";
           el.height = h;
           el.style.width = w + "px";
           el.width = w;
           el.style.left = x + "px";
           el.style.top = y + "px";
       }
   };

 }).call(typeof window !== 'undefined' ? window : this);

/*
 * jsPlumb
 * 
 * Title:jsPlumb 2.3.0
 * 
 * Provides a way to visually connect elements on an HTML page, using SVG.
 * 
 * This file contains the core code.
 *
 * Copyright (c) 2010 - 2017 jsPlumb (hello@jsplumbtoolkit.com)
 * 
 * http://jsplumbtoolkit.com
 * http://github.com/sporritt/jsplumb
 * 
 * Dual licensed under the MIT and GPL2 licenses.
 */
(function () {

    "use strict";

    var root = this;
    var connectorTypes = [], rendererTypes;

    var _ju = root.jsPlumbUtil,

        /**
         * creates a timestamp, using milliseconds since 1970, but as a string.
         */
        _timestamp = function () {
            return "" + (new Date()).getTime();
        },

    // helper method to update the hover style whenever it, or paintStyle, changes.
    // we use paintStyle as the foundation and merge hoverPaintStyle over the
    // top.
        _updateHoverStyle = function (component) {
            if (component._jsPlumb.paintStyle && component._jsPlumb.hoverPaintStyle) {
                var mergedHoverStyle = {};
                jsPlumb.extend(mergedHoverStyle, component._jsPlumb.paintStyle);
                jsPlumb.extend(mergedHoverStyle, component._jsPlumb.hoverPaintStyle);
                delete component._jsPlumb.hoverPaintStyle;
                // we want the fill of paintStyle to override a gradient, if possible.
                if (mergedHoverStyle.gradient && component._jsPlumb.paintStyle.fill) {
                    delete mergedHoverStyle.gradient;
                }
                component._jsPlumb.hoverPaintStyle = mergedHoverStyle;
            }
        },
        events = ["tap", "dbltap", "click", "dblclick", "mouseover", "mouseout", "mousemove", "mousedown", "mouseup", "contextmenu" ],
        eventFilters = { "mouseout": "mouseleave", "mouseexit": "mouseleave" },
        _updateAttachedElements = function (component, state, timestamp, sourceElement) {
            var affectedElements = component.getAttachedElements();
            if (affectedElements) {
                for (var i = 0, j = affectedElements.length; i < j; i++) {
                    if (!sourceElement || sourceElement !== affectedElements[i]) {
                        affectedElements[i].setHover(state, true, timestamp);			// tell the attached elements not to inform their own attached elements.
                    }
                }
            }
        },
        _splitType = function (t) {
            return t == null ? null : t.split(" ");
        },
        _mapType = function(map, obj, typeId) {
            for (var i in obj) {
                map[i] = typeId;
            }
        },
        _each = function(fn, obj) {
            obj = _ju.isArray(obj) || (obj.length != null && !_ju.isString(obj)) ? obj : [ obj ];
            for (var i = 0; i < obj.length; i++) {
                try {
                    fn.apply(obj[i], [ obj[i] ]);
                }
                catch (e) {
                    _ju.log(".each iteration failed : " + e);
                }
            }
        },
        _applyTypes = function (component, params, doNotRepaint) {
            if (component.getDefaultType) {
                var td = component.getTypeDescriptor(), map = {};
                var defType = component.getDefaultType();
                var o = _ju.merge({}, defType);
                _mapType(map, defType, "__default");
                for (var i = 0, j = component._jsPlumb.types.length; i < j; i++) {
                    var tid = component._jsPlumb.types[i];
                    if (tid !== "__default") {
                        var _t = component._jsPlumb.instance.getType(tid, td);
                        if (_t != null) {
                            o = _ju.merge(o, _t, [ "cssClass" ]);
                            _mapType(map, _t, tid);
                        }
                    }
                }

                if (params) {
                    o = _ju.populate(o, params, "_");
                }

                component.applyType(o, doNotRepaint, map);
                if (!doNotRepaint) {
                    component.repaint();
                }
            }
        },

// ------------------------------ BEGIN jsPlumbUIComponent --------------------------------------------

        jsPlumbUIComponent = root.jsPlumbUIComponent = function (params) {

            _ju.EventGenerator.apply(this, arguments);

            var self = this,
                a = arguments,
                idPrefix = self.idPrefix,
                id = idPrefix + (new Date()).getTime();

            this._jsPlumb = {
                instance: params._jsPlumb,
                parameters: params.parameters || {},
                paintStyle: null,
                hoverPaintStyle: null,
                paintStyleInUse: null,
                hover: false,
                beforeDetach: params.beforeDetach,
                beforeDrop: params.beforeDrop,
                overlayPlacements: [],
                hoverClass: params.hoverClass || params._jsPlumb.Defaults.HoverClass,
                types: [],
                typeCache:{}
            };

            this.cacheTypeItem = function(key, item, typeId) {
                this._jsPlumb.typeCache[typeId] = this._jsPlumb.typeCache[typeId] || {};
                this._jsPlumb.typeCache[typeId][key] = item;
            };
            this.getCachedTypeItem = function(key, typeId) {
                return this._jsPlumb.typeCache[typeId] ? this._jsPlumb.typeCache[typeId][key] : null;
            };

            this.getId = function () {
                return id;
            };

// ----------------------------- default type --------------------------------------------


            var o = params.overlays || [], oo = {};
            if (this.defaultOverlayKeys) {
                for (var i = 0; i < this.defaultOverlayKeys.length; i++) {
                    Array.prototype.push.apply(o, this._jsPlumb.instance.Defaults[this.defaultOverlayKeys[i]] || []);
                }

                for (i = 0; i < o.length; i++) {
                    // if a string, convert to object representation so that we can store the typeid on it.
                    // also assign an id.
                    var fo = jsPlumb.convertToFullOverlaySpec(o[i]);
                    oo[fo[1].id] = fo;
                }
            }

            var _defaultType = {
                overlays:oo,
                parameters: params.parameters || {},
                scope: params.scope || this._jsPlumb.instance.getDefaultScope()
            };
            this.getDefaultType = function() {
                return _defaultType;
            };
            this.appendToDefaultType = function(obj) {
                for (var i in obj) {
                    _defaultType[i] = obj[i];
                }
            };

// ----------------------------- end default type --------------------------------------------

            // all components can generate events

            if (params.events) {
                for (var evtName in params.events) {
                    self.bind(evtName, params.events[evtName]);
                }
            }

            // all components get this clone function.
            // TODO issue 116 showed a problem with this - it seems 'a' that is in
            // the clone function's scope is shared by all invocations of it, the classic
            // JS closure problem.  for now, jsPlumb does a version of this inline where
            // it used to call clone.  but it would be nice to find some time to look
            // further at this.
            this.clone = function () {
                var o = Object.create(this.constructor.prototype);
                this.constructor.apply(o, a);
                return o;
            }.bind(this);

            // user can supply a beforeDetach callback, which will be executed before a detach
            // is performed; returning false prevents the detach.
            this.isDetachAllowed = function (connection) {
                var r = true;
                if (this._jsPlumb.beforeDetach) {
                    try {
                        r = this._jsPlumb.beforeDetach(connection);
                    }
                    catch (e) {
                        _ju.log("jsPlumb: beforeDetach callback failed", e);
                    }
                }
                return r;
            };

            // user can supply a beforeDrop callback, which will be executed before a dropped
            // connection is confirmed. user can return false to reject connection.
            this.isDropAllowed = function (sourceId, targetId, scope, connection, dropEndpoint, source, target) {
                var r = this._jsPlumb.instance.checkCondition("beforeDrop", {
                    sourceId: sourceId,
                    targetId: targetId,
                    scope: scope,
                    connection: connection,
                    dropEndpoint: dropEndpoint,
                    source: source, target: target
                });
                if (this._jsPlumb.beforeDrop) {
                    try {
                        r = this._jsPlumb.beforeDrop({
                            sourceId: sourceId,
                            targetId: targetId,
                            scope: scope,
                            connection: connection,
                            dropEndpoint: dropEndpoint,
                            source: source, target: target
                        });
                    }
                    catch (e) {
                        _ju.log("jsPlumb: beforeDrop callback failed", e);
                    }
                }
                return r;
            };

            var domListeners = [];

            // sets the component associated with listener events. for instance, an overlay delegates
            // its events back to a connector. but if the connector is swapped on the underlying connection,
            // then this component must be changed. This is called by setConnector in the Connection class.
            this.setListenerComponent = function (c) {
                for (var i = 0; i < domListeners.length; i++) {
                    domListeners[i][3] = c;
                }
            };


        };

    var _removeTypeCssHelper = function (component, typeIndex) {
        var typeId = component._jsPlumb.types[typeIndex],
            type = component._jsPlumb.instance.getType(typeId, component.getTypeDescriptor());

        if (type != null && type.cssClass && component.canvas) {
            component._jsPlumb.instance.removeClass(component.canvas, type.cssClass);
        }
    };

    _ju.extend(root.jsPlumbUIComponent, _ju.EventGenerator, {

        getParameter: function (name) {
            return this._jsPlumb.parameters[name];
        },

        setParameter: function (name, value) {
            this._jsPlumb.parameters[name] = value;
        },

        getParameters: function () {
            return this._jsPlumb.parameters;
        },

        setParameters: function (p) {
            this._jsPlumb.parameters = p;
        },

        getClass:function() {
            return jsPlumb.getClass(this.canvas);
        },

        hasClass:function(clazz) {
            return jsPlumb.hasClass(this.canvas, clazz);
        },

        addClass: function (clazz) {
            jsPlumb.addClass(this.canvas, clazz);
        },

        removeClass: function (clazz) {
            jsPlumb.removeClass(this.canvas, clazz);
        },

        updateClasses: function (classesToAdd, classesToRemove) {
            jsPlumb.updateClasses(this.canvas, classesToAdd, classesToRemove);
        },

        setType: function (typeId, params, doNotRepaint) {
            this.clearTypes();
            this._jsPlumb.types = _splitType(typeId) || [];
            _applyTypes(this, params, doNotRepaint);
        },

        getType: function () {
            return this._jsPlumb.types;
        },

        reapplyTypes: function (params, doNotRepaint) {
            _applyTypes(this, params, doNotRepaint);
        },

        hasType: function (typeId) {
            return this._jsPlumb.types.indexOf(typeId) !== -1;
        },

        addType: function (typeId, params, doNotRepaint) {
            var t = _splitType(typeId), _cont = false;
            if (t != null) {
                for (var i = 0, j = t.length; i < j; i++) {
                    if (!this.hasType(t[i])) {
                        this._jsPlumb.types.push(t[i]);
                        _cont = true;
                    }
                }
                if (_cont) {
                    _applyTypes(this, params, doNotRepaint);
                }
            }
        },

        removeType: function (typeId, params, doNotRepaint) {
            var t = _splitType(typeId), _cont = false, _one = function (tt) {
                var idx = this._jsPlumb.types.indexOf(tt);
                if (idx !== -1) {
                    // remove css class if necessary
                    _removeTypeCssHelper(this, idx);
                    this._jsPlumb.types.splice(idx, 1);
                    return true;
                }
                return false;
            }.bind(this);

            if (t != null) {
                for (var i = 0, j = t.length; i < j; i++) {
                    _cont = _one(t[i]) || _cont;
                }
                if (_cont) {
                    _applyTypes(this, params, doNotRepaint);
                }
            }
        },
        clearTypes: function (params, doNotRepaint) {
            var i = this._jsPlumb.types.length;
            for (var j = 0; j < i; j++) {
                _removeTypeCssHelper(this, 0);
                this._jsPlumb.types.splice(0, 1);
            }
            _applyTypes(this, params, doNotRepaint);
        },

        toggleType: function (typeId, params, doNotRepaint) {
            var t = _splitType(typeId);
            if (t != null) {
                for (var i = 0, j = t.length; i < j; i++) {
                    var idx = this._jsPlumb.types.indexOf(t[i]);
                    if (idx !== -1) {
                        _removeTypeCssHelper(this, idx);
                        this._jsPlumb.types.splice(idx, 1);
                    }
                    else {
                        this._jsPlumb.types.push(t[i]);
                    }
                }

                _applyTypes(this, params, doNotRepaint);
            }
        },
        applyType: function (t, doNotRepaint) {
            this.setPaintStyle(t.paintStyle, doNotRepaint);
            this.setHoverPaintStyle(t.hoverPaintStyle, doNotRepaint);
            if (t.parameters) {
                for (var i in t.parameters) {
                    this.setParameter(i, t.parameters[i]);
                }
            }
            this._jsPlumb.paintStyleInUse = this.getPaintStyle();
        },
        setPaintStyle: function (style, doNotRepaint) {
            // this._jsPlumb.paintStyle = jsPlumb.extend({}, style);
            // TODO figure out if we want components to clone paintStyle so as not to share it.
            this._jsPlumb.paintStyle = style;
            this._jsPlumb.paintStyleInUse = this._jsPlumb.paintStyle;
            _updateHoverStyle(this);
            if (!doNotRepaint) {
                this.repaint();
            }
        },
        getPaintStyle: function () {
            return this._jsPlumb.paintStyle;
        },
        setHoverPaintStyle: function (style, doNotRepaint) {
            //this._jsPlumb.hoverPaintStyle = jsPlumb.extend({}, style);
            // TODO figure out if we want components to clone paintStyle so as not to share it.
            this._jsPlumb.hoverPaintStyle = style;
            _updateHoverStyle(this);
            if (!doNotRepaint) {
                this.repaint();
            }
        },
        getHoverPaintStyle: function () {
            return this._jsPlumb.hoverPaintStyle;
        },
        destroy: function (force) {
            if (force || this.typeId == null) {
                this.cleanupListeners(); // this is on EventGenerator
                this.clone = null;
                this._jsPlumb = null;
            }
        },

        isHover: function () {
            return this._jsPlumb.hover;
        },

        setHover: function (hover, ignoreAttachedElements, timestamp) {
            // while dragging, we ignore these events.  this keeps the UI from flashing and
            // swishing and whatevering.
            if (this._jsPlumb && !this._jsPlumb.instance.currentlyDragging && !this._jsPlumb.instance.isHoverSuspended()) {

                this._jsPlumb.hover = hover;
                var method = hover ? "addClass" : "removeClass";

                if (this.canvas != null) {
                    if (this._jsPlumb.instance.hoverClass != null) {
                        this._jsPlumb.instance[method](this.canvas, this._jsPlumb.instance.hoverClass);
                    }
                    if (this._jsPlumb.hoverClass != null) {
                        this._jsPlumb.instance[method](this.canvas, this._jsPlumb.hoverClass);
                    }
                }
                if (this._jsPlumb.hoverPaintStyle != null) {
                    this._jsPlumb.paintStyleInUse = hover ? this._jsPlumb.hoverPaintStyle : this._jsPlumb.paintStyle;
                    if (!this._jsPlumb.instance.isSuspendDrawing()) {
                        timestamp = timestamp || _timestamp();
                        this.repaint({timestamp: timestamp, recalc: false});
                    }
                }
                // get the list of other affected elements, if supported by this component.
                // for a connection, its the endpoints.  for an endpoint, its the connections! surprise.
                if (this.getAttachedElements && !ignoreAttachedElements) {
                    _updateAttachedElements(this, hover, _timestamp(), this);
                }
            }
        }
    });

// ------------------------------ END jsPlumbUIComponent --------------------------------------------

    var _jsPlumbInstanceIndex = 0,
        getInstanceIndex = function () {
            var i = _jsPlumbInstanceIndex + 1;
            _jsPlumbInstanceIndex++;
            return i;
        };

    var jsPlumbInstance = root.jsPlumbInstance = function (_defaults) {

        this.version = "2.5.1";

        if (_defaults) {
            jsPlumb.extend(this.Defaults, _defaults);
        }

        this.logEnabled = this.Defaults.LogEnabled;
        this._connectionTypes = {};
        this._endpointTypes = {};

        _ju.EventGenerator.apply(this);

        var _currentInstance = this,
            _instanceIndex = getInstanceIndex(),
            _bb = _currentInstance.bind,
            _initialDefaults = {},
            _zoom = 1,
            _info = function (el) {
                if (el == null) {
                    return null;
                }
                else if (el.nodeType === 3 || el.nodeType === 8) {
                    return { el:el, text:true };
                }
                else {
                    var _el = _currentInstance.getElement(el);
                    return { el: _el, id: (_ju.isString(el) && _el == null) ? el : _getId(_el) };
                }
            };

        this.getInstanceIndex = function () {
            return _instanceIndex;
        };

        this.setZoom = function (z, repaintEverything) {
            _zoom = z;
            _currentInstance.fire("zoom", _zoom);
            if (repaintEverything) {
                _currentInstance.repaintEverything();
            }
            return true;
        };
        this.getZoom = function () {
            return _zoom;
        };

        for (var i in this.Defaults) {
            _initialDefaults[i] = this.Defaults[i];
        }

        var _container, _containerDelegations = [];
        this.unbindContainer = function() {
            if (_container != null && _containerDelegations.length > 0) {
                for (var i = 0; i < _containerDelegations.length; i++) {
                    _currentInstance.off(_container, _containerDelegations[i][0], _containerDelegations[i][1]);
                }
            }
        };
        this.setContainer = function (c) {

            this.unbindContainer();

            // get container as dom element.
            c = this.getElement(c);
            // move existing connections and endpoints, if any.
            this.select().each(function (conn) {
                conn.moveParent(c);
            });
            this.selectEndpoints().each(function (ep) {
                ep.moveParent(c);
            });

            // set container.
            var previousContainer = _container;
            _container = c;
            _containerDelegations.length = 0;
            var eventAliases = {
                "endpointclick":"endpointClick",
                "endpointdblclick":"endpointDblClick"
            };

            var _oneDelegateHandler = function (id, e, componentType) {
                var t = e.srcElement || e.target,
                    jp = (t && t.parentNode ? t.parentNode._jsPlumb : null) || (t ? t._jsPlumb : null) || (t && t.parentNode && t.parentNode.parentNode ? t.parentNode.parentNode._jsPlumb : null);
                if (jp) {
                    jp.fire(id, jp, e);
                    var alias = componentType ? eventAliases[componentType + id] || id : id;
                    // jsplumb also fires every event coming from components/overlays. That's what the test for `jp.component` is for.
                    _currentInstance.fire(alias, jp.component || jp, e);
                }
            };

            var _addOneDelegate = function(eventId, selector, fn) {
                _containerDelegations.push([eventId, fn]);
                _currentInstance.on(_container, eventId, selector, fn);
            };

            // delegate one event on the container to jsplumb elements. it might be possible to
            // abstract this out: each of endpoint, connection and overlay could register themselves with
            // jsplumb as "component types" or whatever, and provide a suitable selector. this would be
            // done by the renderer (although admittedly from 2.0 onwards we're not supporting vml anymore)
            var _oneDelegate = function (id) {
                // connections.
                _addOneDelegate(id, ".jtk-connector", function (e) {
                    _oneDelegateHandler(id, e);
                });
                // endpoints. note they can have an enclosing div, or not.
                _addOneDelegate(id, ".jtk-endpoint", function (e) {
                    _oneDelegateHandler(id, e, "endpoint");
                });
                // overlays
                _addOneDelegate(id, ".jtk-overlay", function (e) {
                    _oneDelegateHandler(id, e);
                });
            };

            for (var i = 0; i < events.length; i++) {
                _oneDelegate(events[i]);
            }

            // managed elements
            for (var elId in managedElements) {
                var el = managedElements[elId].el;
                if (el.parentNode === previousContainer) {
                    previousContainer.removeChild(el);
                    _container.appendChild(el);
                }
            }

        };
        this.getContainer = function () {
            return _container;
        };

        this.bind = function (event, fn) {
            if ("ready" === event && initialized) {
                fn();
            }
            else {
                _bb.apply(_currentInstance, [event, fn]);
            }
        };

        _currentInstance.importDefaults = function (d) {
            for (var i in d) {
                _currentInstance.Defaults[i] = d[i];
            }
            if (d.Container) {
                _currentInstance.setContainer(d.Container);
            }

            return _currentInstance;
        };

        _currentInstance.restoreDefaults = function () {
            _currentInstance.Defaults = jsPlumb.extend({}, _initialDefaults);
            return _currentInstance;
        };

        var log = null,
            initialized = false,
        // TODO remove from window scope
            connections = [],
        // map of element id -> endpoint lists. an element can have an arbitrary
        // number of endpoints on it, and not all of them have to be connected
        // to anything.
            endpointsByElement = {},
            endpointsByUUID = {},
            managedElements = {},
            offsets = {},
            offsetTimestamps = {},
            draggableStates = {},
            connectionBeingDragged = false,
            sizes = [],
            _suspendDrawing = false,
            _suspendedAt = null,
            DEFAULT_SCOPE = this.Defaults.Scope,
            _curIdStamp = 1,
            _idstamp = function () {
                return "" + _curIdStamp++;
            },

        //
        // appends an element to some other element, which is calculated as follows:
        //
        // 1. if Container exists, use that element.
        // 2. if the 'parent' parameter exists, use that.
        // 3. otherwise just use the root element.
        //
        //
            _appendElement = function (el, parent) {
                if (_container) {
                    _container.appendChild(el);
                }
                else if (!parent) {
                    this.appendToRoot(el);
                }
                else {
                    this.getElement(parent).appendChild(el);
                }
            }.bind(this),

        //
        // Draws an endpoint and its connections. this is the main entry point into drawing connections as well
        // as endpoints, since jsPlumb is endpoint-centric under the hood.
        //
        // @param element element to draw (of type library specific element object)
        // @param ui UI object from current library's event system. optional.
        // @param timestamp timestamp for this paint cycle. used to speed things up a little by cutting down the amount of offset calculations we do.
        // @param clearEdits defaults to false; indicates that mouse edits for connectors should be cleared
        ///
            _draw = function (element, ui, timestamp, clearEdits) {

                if (!_suspendDrawing) {
                    var id = _getId(element),
                        repaintEls,
                        dm = _currentInstance.getDragManager();

                    if (dm) {
                        repaintEls = dm.getElementsForDraggable(id);
                    }

                    if (timestamp == null) {
                        timestamp = _timestamp();
                    }

                    // update the offset of everything _before_ we try to draw anything.
                    var o = _updateOffset({ elId: id, offset: ui, recalc: false, timestamp: timestamp });

                    if (repaintEls && o && o.o) {
                        for (var i in repaintEls) {
                            _updateOffset({
                                elId: repaintEls[i].id,
                                offset: {
                                    left: o.o.left + repaintEls[i].offset.left,
                                    top: o.o.top + repaintEls[i].offset.top
                                },
                                recalc: false,
                                timestamp: timestamp
                            });
                        }
                    }

                    _currentInstance.anchorManager.redraw(id, ui, timestamp, null, clearEdits);

                    if (repaintEls) {
                        for (var j in repaintEls) {
                            _currentInstance.anchorManager.redraw(repaintEls[j].id, ui, timestamp, repaintEls[j].offset, clearEdits, true);
                        }
                    }
                }
            },

        //
        // gets an Endpoint by uuid.
        //
            _getEndpoint = function (uuid) {
                return endpointsByUUID[uuid];
            },

            /**
             * inits a draggable if it's not already initialised.
             * TODO: somehow abstract this to the adapter, because the concept of "draggable" has no
             * place on the server.
             */
            _initDraggableIfNecessary = function (element, isDraggable, dragOptions, id, fireEvent) {
                // move to DragManager?
                if (!jsPlumb.headless) {
                    var _draggable = isDraggable == null ? false : isDraggable;
                    if (_draggable) {
                        if (jsPlumb.isDragSupported(element, _currentInstance)) {
                            var options = dragOptions || _currentInstance.Defaults.DragOptions;
                            options = jsPlumb.extend({}, options); // make a copy.
                            if (!jsPlumb.isAlreadyDraggable(element, _currentInstance)) {
                                var dragEvent = jsPlumb.dragEvents.drag,
                                    stopEvent = jsPlumb.dragEvents.stop,
                                    startEvent = jsPlumb.dragEvents.start,
                                    _started = false;

                                _manage(id, element);

                                options[startEvent] = _ju.wrap(options[startEvent], function () {
                                    _currentInstance.setHoverSuspended(true);
                                    _currentInstance.select({source: element}).addClass(_currentInstance.elementDraggingClass + " " + _currentInstance.sourceElementDraggingClass, true);
                                    _currentInstance.select({target: element}).addClass(_currentInstance.elementDraggingClass + " " + _currentInstance.targetElementDraggingClass, true);
                                    _currentInstance.setConnectionBeingDragged(true);
                                    if (options.canDrag) {
                                        return dragOptions.canDrag();
                                    }
                                }, false);

                                options[dragEvent] = _ju.wrap(options[dragEvent], function () {
                                    // TODO: here we could actually use getDragObject, and then compute it ourselves,
                                    // since every adapter does the same thing. but i'm not sure why YUI's getDragObject
                                    // differs from getUIPosition so much
                                    var ui = _currentInstance.getUIPosition(arguments, _currentInstance.getZoom());
                                    if (ui != null) {
                                        _draw(element, ui, null, true);
                                        if (_started) {
                                            _currentInstance.addClass(element, "jtk-dragged");
                                        }
                                        _started = true;
                                    }
                                });
                                options[stopEvent] = _ju.wrap(options[stopEvent], function () {
                                    var elements = arguments[0].selection, uip;

                                    var _one = function (_e) {
                                        if (_e[1] != null) {
                                            // run the reported offset through the code that takes parent containers
                                            // into account, to adjust if necessary (issue 554)
                                            uip = _currentInstance.getUIPosition([{
                                                el:_e[2].el,
                                                pos:[_e[1].left, _e[1].top]
                                            }]);
                                            _draw(_e[2].el, uip);
                                        }
                                        _currentInstance.removeClass(_e[0], "jtk-dragged");
                                        _currentInstance.select({source: _e[2].el}).removeClass(_currentInstance.elementDraggingClass + " " + _currentInstance.sourceElementDraggingClass, true);
                                        _currentInstance.select({target: _e[2].el}).removeClass(_currentInstance.elementDraggingClass + " " + _currentInstance.targetElementDraggingClass, true);
                                        _currentInstance.getDragManager().dragEnded(_e[2].el);
                                    };

                                    for (var i = 0; i < elements.length; i++) {
                                        _one(elements[i]);
                                    }

                                    _started = false;
                                    _currentInstance.setHoverSuspended(false);
                                    _currentInstance.setConnectionBeingDragged(false);
                                });
                                var elId = _getId(element); // need ID
                                draggableStates[elId] = true;
                                var draggable = draggableStates[elId];
                                options.disabled = draggable == null ? false : !draggable;
                                _currentInstance.initDraggable(element, options);
                                _currentInstance.getDragManager().register(element);
                                if (fireEvent) {
                                    _currentInstance.fire("elementDraggable", {el:element, options:options});
                                }
                            }
                            else {
                                // already draggable. attach any start, drag or stop listeners to the current Drag.
                                if (dragOptions.force) {
                                    _currentInstance.initDraggable(element, options);
                                }
                            }
                        }
                    }
                }
            },

            _scopeMatch = function (e1, e2) {
                var s1 = e1.scope.split(/\s/), s2 = e2.scope.split(/\s/);
                for (var i = 0; i < s1.length; i++) {
                    for (var j = 0; j < s2.length; j++) {
                        if (s2[j] === s1[i]) {
                            return true;
                        }
                    }
                }

                return false;
            },

            _mergeOverrides = function (def, values) {
                var m = jsPlumb.extend({}, def);
                for (var i in values) {
                    if (values[i]) {
                        m[i] = values[i];
                    }
                }
                return m;
            },

        /*
         * prepares a final params object that can be passed to _newConnection, taking into account defaults, events, etc.
         */
            _prepareConnectionParams = function (params, referenceParams) {
                var _p = jsPlumb.extend({ }, params);
                if (referenceParams) {
                    jsPlumb.extend(_p, referenceParams);
                }

                // hotwire endpoints passed as source or target to sourceEndpoint/targetEndpoint, respectively.
                if (_p.source) {
                    if (_p.source.endpoint) {
                        _p.sourceEndpoint = _p.source;
                    }
                    else {
                        _p.source = _currentInstance.getElement(_p.source);
                    }
                }
                if (_p.target) {
                    if (_p.target.endpoint) {
                        _p.targetEndpoint = _p.target;
                    }
                    else {
                        _p.target = _currentInstance.getElement(_p.target);
                    }
                }

                // test for endpoint uuids to connect
                if (params.uuids) {
                    _p.sourceEndpoint = _getEndpoint(params.uuids[0]);
                    _p.targetEndpoint = _getEndpoint(params.uuids[1]);
                }

                // now ensure that if we do have Endpoints already, they're not full.
                // source:
                if (_p.sourceEndpoint && _p.sourceEndpoint.isFull()) {
                    _ju.log(_currentInstance, "could not add connection; source endpoint is full");
                    return;
                }

                // target:
                if (_p.targetEndpoint && _p.targetEndpoint.isFull()) {
                    _ju.log(_currentInstance, "could not add connection; target endpoint is full");
                    return;
                }

                // if source endpoint mandates connection type and nothing specified in our params, use it.
                if (!_p.type && _p.sourceEndpoint) {
                    _p.type = _p.sourceEndpoint.connectionType;
                }

                // copy in any connectorOverlays that were specified on the source endpoint.
                // it doesnt copy target endpoint overlays.  i'm not sure if we want it to or not.
                if (_p.sourceEndpoint && _p.sourceEndpoint.connectorOverlays) {
                    _p.overlays = _p.overlays || [];
                    for (var i = 0, j = _p.sourceEndpoint.connectorOverlays.length; i < j; i++) {
                        _p.overlays.push(_p.sourceEndpoint.connectorOverlays[i]);
                    }
                }

                // scope
                if (_p.sourceEndpoint && _p.sourceEndpoint.scope) {
                    _p.scope = _p.sourceEndpoint.scope;
                }

                // pointer events
                if (!_p["pointer-events"] && _p.sourceEndpoint && _p.sourceEndpoint.connectorPointerEvents) {
                    _p["pointer-events"] = _p.sourceEndpoint.connectorPointerEvents;
                }


                var _addEndpoint = function (el, def, idx) {
                    return _currentInstance.addEndpoint(el, _mergeOverrides(def, {
                        anchor: _p.anchors ? _p.anchors[idx] : _p.anchor,
                        endpoint: _p.endpoints ? _p.endpoints[idx] : _p.endpoint,
                        paintStyle: _p.endpointStyles ? _p.endpointStyles[idx] : _p.endpointStyle,
                        hoverPaintStyle: _p.endpointHoverStyles ? _p.endpointHoverStyles[idx] : _p.endpointHoverStyle
                    }));
                };

                // check for makeSource/makeTarget specs.

                var _oneElementDef = function (type, idx, defs, matchType) {
                    if (_p[type] && !_p[type].endpoint && !_p[type + "Endpoint"] && !_p.newConnection) {
                        var tid = _getId(_p[type]), tep = defs[tid];

                        tep = tep ? tep[matchType] : null;

                        if (tep) {
                            // if not enabled, return.
                            if (!tep.enabled) {
                                return false;
                            }
                            var newEndpoint = tep.endpoint != null && tep.endpoint._jsPlumb ? tep.endpoint : _addEndpoint(_p[type], tep.def, idx);
                            if (newEndpoint.isFull()) {
                                return false;
                            }
                            _p[type + "Endpoint"] = newEndpoint;
                            if (!_p.scope && tep.def.scope) {
                                _p.scope = tep.def.scope;
                            } // provide scope if not already provided and endpoint def has one.
                            if (tep.uniqueEndpoint) {
                                if (!tep.endpoint) {
                                    tep.endpoint = newEndpoint;
                                    newEndpoint.setDeleteOnEmpty(false);
                                }
                                else {
                                    newEndpoint.finalEndpoint = tep.endpoint;
                                }
                            } else {
                                newEndpoint.setDeleteOnEmpty(true);
                            }
                        }
                    }
                };

                if (_oneElementDef("source", 0, this.sourceEndpointDefinitions, _p.type || "default") === false) {
                    return;
                }
                if (_oneElementDef("target", 1, this.targetEndpointDefinitions, _p.type || "default") === false) {
                    return;
                }

                // last, ensure scopes match
                if (_p.sourceEndpoint && _p.targetEndpoint) {
                    if (!_scopeMatch(_p.sourceEndpoint, _p.targetEndpoint)) {
                        _p = null;
                    }
                }

                return _p;
            }.bind(_currentInstance),

            _newConnection = function (params) {
                var connectionFunc = _currentInstance.Defaults.ConnectionType || _currentInstance.getDefaultConnectionType();

                params._jsPlumb = _currentInstance;
                params.newConnection = _newConnection;
                params.newEndpoint = _newEndpoint;
                params.endpointsByUUID = endpointsByUUID;
                params.endpointsByElement = endpointsByElement;
                params.finaliseConnection = _finaliseConnection;
                params.id = "con_" + _idstamp();
                var con = new connectionFunc(params);

                // if the connection is draggable, then maybe we need to tell the target endpoint to init the
                // dragging code. it won't run again if it already configured to be draggable.
                if (con.isDetachable()) {
                    con.endpoints[0].initDraggable("_jsPlumbSource");
                    con.endpoints[1].initDraggable("_jsPlumbTarget");
                }

                return con;
            },

        //
        // adds the connection to the backing model, fires an event if necessary and then redraws
        //
            _finaliseConnection = _currentInstance.finaliseConnection = function (jpc, params, originalEvent, doInformAnchorManager) {
                params = params || {};
                // add to list of connections (by scope).
                if (!jpc.suspendedEndpoint) {
                    connections.push(jpc);
                }

                jpc.pending = null;

                // turn off isTemporarySource on the source endpoint (only viable on first draw)
                jpc.endpoints[0].isTemporarySource = false;

                // always inform the anchor manager
                // except that if jpc has a suspended endpoint it's not true to say the
                // connection is new; it has just (possibly) moved. the question is whether
                // to make that call here or in the anchor manager.  i think perhaps here.
                if (doInformAnchorManager !== false) {
                    _currentInstance.anchorManager.newConnection(jpc);
                }

                // force a paint
                _draw(jpc.source);

                // fire an event
                if (!params.doNotFireConnectionEvent && params.fireEvent !== false) {

                    var eventArgs = {
                        connection: jpc,
                        source: jpc.source, target: jpc.target,
                        sourceId: jpc.sourceId, targetId: jpc.targetId,
                        sourceEndpoint: jpc.endpoints[0], targetEndpoint: jpc.endpoints[1]
                    };

                    _currentInstance.fire("connection", eventArgs, originalEvent);
                }
            },

        /*
         factory method to prepare a new endpoint.  this should always be used instead of creating Endpoints
         manually, since this method attaches event listeners and an id.
         */
            _newEndpoint = function (params, id) {
                var endpointFunc = _currentInstance.Defaults.EndpointType || jsPlumb.Endpoint;
                var _p = jsPlumb.extend({}, params);
                _p._jsPlumb = _currentInstance;
                _p.newConnection = _newConnection;
                _p.newEndpoint = _newEndpoint;
                _p.endpointsByUUID = endpointsByUUID;
                _p.endpointsByElement = endpointsByElement;
                _p.fireDetachEvent = fireDetachEvent;
                _p.elementId = id || _getId(_p.source);
                var ep = new endpointFunc(_p);
                ep.id = "ep_" + _idstamp();
                _manage(_p.elementId, _p.source);

                if (!jsPlumb.headless) {
                    _currentInstance.getDragManager().endpointAdded(_p.source, id);
                }

                return ep;
            },

        /*
         * performs the given function operation on all the connections found
         * for the given element id; this means we find all the endpoints for
         * the given element, and then for each endpoint find the connectors
         * connected to it. then we pass each connection in to the given
         * function.
         */
            _operation = function (elId, func, endpointFunc) {
                var endpoints = endpointsByElement[elId];
                if (endpoints && endpoints.length) {
                    for (var i = 0, ii = endpoints.length; i < ii; i++) {
                        for (var j = 0, jj = endpoints[i].connections.length; j < jj; j++) {
                            var retVal = func(endpoints[i].connections[j]);
                            // if the function passed in returns true, we exit.
                            // most functions return false.
                            if (retVal) {
                                return;
                            }
                        }
                        if (endpointFunc) {
                            endpointFunc(endpoints[i]);
                        }
                    }
                }
            },

            _setDraggable = function (element, draggable) {
                return jsPlumb.each(element, function (el) {
                    if (_currentInstance.isDragSupported(el)) {
                        draggableStates[_currentInstance.getAttribute(el, "id")] = draggable;
                        _currentInstance.setElementDraggable(el, draggable);
                    }
                });
            },
        /*
         * private method to do the business of hiding/showing.
         *
         * @param el
         *            either Id of the element in question or a library specific
         *            object for the element.
         * @param state
         *            String specifying a value for the css 'display' property
         *            ('block' or 'none').
         */
            _setVisible = function (el, state, alsoChangeEndpoints) {
                state = state === "block";
                var endpointFunc = null;
                if (alsoChangeEndpoints) {
                    endpointFunc = function (ep) {
                        ep.setVisible(state, true, true);
                    };
                }
                var info = _info(el);
                _operation(info.id, function (jpc) {
                    if (state && alsoChangeEndpoints) {
                        // this test is necessary because this functionality is new, and i wanted to maintain backwards compatibility.
                        // this block will only set a connection to be visible if the other endpoint in the connection is also visible.
                        var oidx = jpc.sourceId === info.id ? 1 : 0;
                        if (jpc.endpoints[oidx].isVisible()) {
                            jpc.setVisible(true);
                        }
                    }
                    else { // the default behaviour for show, and what always happens for hide, is to just set the visibility without getting clever.
                        jpc.setVisible(state);
                    }
                }, endpointFunc);
            },
        /*
         * toggles the draggable state of the given element(s).
         * el is either an id, or an element object, or a list of ids/element objects.
         */
            _toggleDraggable = function (el) {
                var state;
                jsPlumb.each(el, function (el) {
                    var elId = _currentInstance.getAttribute(el, "id");
                    state = draggableStates[elId] == null ? false : draggableStates[elId];
                    state = !state;
                    draggableStates[elId] = state;
                    _currentInstance.setDraggable(el, state);
                    return state;
                }.bind(this));
                return state;
            },
            /**
             * private method to do the business of toggling hiding/showing.
             */
            _toggleVisible = function (elId, changeEndpoints) {
                var endpointFunc = null;
                if (changeEndpoints) {
                    endpointFunc = function (ep) {
                        var state = ep.isVisible();
                        ep.setVisible(!state);
                    };
                }
                _operation(elId, function (jpc) {
                    var state = jpc.isVisible();
                    jpc.setVisible(!state);
                }, endpointFunc);
            },

        // TODO comparison performance
            _getCachedData = function (elId) {
                var o = offsets[elId];
                if (!o) {
                    return _updateOffset({elId: elId});
                }
                else {
                    return {o: o, s: sizes[elId]};
                }
            },

            /**
             * gets an id for the given element, creating and setting one if
             * necessary.  the id is of the form
             *
             *    jsPlumb_<instance index>_<index in instance>
             *
             * where "index in instance" is a monotonically increasing integer that starts at 0,
             * for each instance.  this method is used not only to assign ids to elements that do not
             * have them but also to connections and endpoints.
             */
            _getId = function (element, uuid, doNotCreateIfNotFound) {
                if (_ju.isString(element)) {
                    return element;
                }
                if (element == null) {
                    return null;
                }
                var id = _currentInstance.getAttribute(element, "id");
                if (!id || id === "undefined") {
                    // check if fixed uuid parameter is given
                    if (arguments.length === 2 && arguments[1] !== undefined) {
                        id = uuid;
                    }
                    else if (arguments.length === 1 || (arguments.length === 3 && !arguments[2])) {
                        id = "jsPlumb_" + _instanceIndex + "_" + _idstamp();
                    }

                    if (!doNotCreateIfNotFound) {
                        _currentInstance.setAttribute(element, "id", id);
                    }
                }
                return id;
            };

        this.setConnectionBeingDragged = function (v) {
            connectionBeingDragged = v;
        };
        this.isConnectionBeingDragged = function () {
            return connectionBeingDragged;
        };

        /**
         * Returns a map of all the elements this jsPlumbInstance is currently managing.
         * @returns {Object} Map of [id-> {el, endpoint[], connection, position}] information.
         */
        this.getManagedElements = function() {
            return managedElements;
        };

        this.connectorClass = "jtk-connector";
        this.connectorOutlineClass = "jtk-connector-outline";
        this.editableConnectorClass = "jtk-connector-editable";
        this.connectedClass = "jtk-connected";
        this.hoverClass = "jtk-hover";
        this.endpointClass = "jtk-endpoint";
        this.endpointConnectedClass = "jtk-endpoint-connected";
        this.endpointFullClass = "jtk-endpoint-full";
        this.endpointDropAllowedClass = "jtk-endpoint-drop-allowed";
        this.endpointDropForbiddenClass = "jtk-endpoint-drop-forbidden";
        this.overlayClass = "jtk-overlay";
        this.draggingClass = "jtk-dragging";
        this.elementDraggingClass = "jtk-element-dragging";
        this.sourceElementDraggingClass = "jtk-source-element-dragging";
        this.targetElementDraggingClass = "jtk-target-element-dragging";
        this.endpointAnchorClassPrefix = "jtk-endpoint-anchor";
        this.hoverSourceClass = "jtk-source-hover";
        this.hoverTargetClass = "jtk-target-hover";
        this.dragSelectClass = "jtk-drag-select";

        this.Anchors = {};
        this.Connectors = {  "svg": {} };
        this.Endpoints = { "svg": {} };
        this.Overlays = { "svg": {} } ;
        this.ConnectorRenderers = {};
        this.SVG = "svg";

// --------------------------- jsPlumbInstance public API ---------------------------------------------------------


        this.addEndpoint = function (el, params, referenceParams) {
            referenceParams = referenceParams || {};
            var p = jsPlumb.extend({}, referenceParams);
            jsPlumb.extend(p, params);
            p.endpoint = p.endpoint || _currentInstance.Defaults.Endpoint;
            p.paintStyle = p.paintStyle || _currentInstance.Defaults.EndpointStyle;

            var results = [],
                inputs = (_ju.isArray(el) || (el.length != null && !_ju.isString(el))) ? el : [ el ];

            for (var i = 0, j = inputs.length; i < j; i++) {
                p.source = _currentInstance.getElement(inputs[i]);
                _ensureContainer(p.source);

                var id = _getId(p.source), e = _newEndpoint(p, id);

                // ensure element is managed.
                var myOffset = _manage(id, p.source).info.o;
                _ju.addToList(endpointsByElement, id, e);

                if (!_suspendDrawing) {
                    e.paint({
                        anchorLoc: e.anchor.compute({ xy: [ myOffset.left, myOffset.top ], wh: sizes[id], element: e, timestamp: _suspendedAt }),
                        timestamp: _suspendedAt
                    });
                }

                results.push(e);
            }

            return results.length === 1 ? results[0] : results;
        };

        this.addEndpoints = function (el, endpoints, referenceParams) {
            var results = [];
            for (var i = 0, j = endpoints.length; i < j; i++) {
                var e = _currentInstance.addEndpoint(el, endpoints[i], referenceParams);
                if (_ju.isArray(e)) {
                    Array.prototype.push.apply(results, e);
                }
                else {
                    results.push(e);
                }
            }
            return results;
        };

        this.animate = function (el, properties, options) {
            if (!this.animationSupported) {
                return false;
            }

            options = options || {};
            var del = _currentInstance.getElement(el),
                id = _getId(del),
                stepFunction = jsPlumb.animEvents.step,
                completeFunction = jsPlumb.animEvents.complete;

            options[stepFunction] = _ju.wrap(options[stepFunction], function () {
                _currentInstance.revalidate(id);
            });

            // onComplete repaints, just to make sure everything looks good at the end of the animation.
            options[completeFunction] = _ju.wrap(options[completeFunction], function () {
                _currentInstance.revalidate(id);
            });

            _currentInstance.doAnimate(del, properties, options);
        };

        /**
         * checks for a listener for the given condition, executing it if found, passing in the given value.
         * condition listeners would have been attached using "bind" (which is, you could argue, now overloaded, since
         * firing click events etc is a bit different to what this does).  i thought about adding a "bindCondition"
         * or something, but decided against it, for the sake of simplicity. jsPlumb will never fire one of these
         * condition events anyway.
         */
        this.checkCondition = function (conditionName, args) {
            var l = _currentInstance.getListener(conditionName),
                r = true;

            if (l && l.length > 0) {
                var values = Array.prototype.slice.call(arguments, 1);
                try {
                    for (var i = 0, j = l.length; i < j; i++) {
                        r = r && l[i].apply(l[i], values);
                    }
                }
                catch (e) {
                    _ju.log(_currentInstance, "cannot check condition [" + conditionName + "]" + e);
                }
            }
            return r;
        };

        this.connect = function (params, referenceParams) {
            // prepare a final set of parameters to create connection with
            var _p = _prepareConnectionParams(params, referenceParams), jpc;
            // TODO probably a nicer return value if the connection was not made.  _prepareConnectionParams
            // will return null (and log something) if either endpoint was full.  what would be nicer is to
            // create a dedicated 'error' object.
            if (_p) {
                if (_p.source == null && _p.sourceEndpoint == null) {
                    _ju.log("Cannot establish connection - source does not exist");
                    return;
                }
                if (_p.target == null && _p.targetEndpoint == null) {
                    _ju.log("Cannot establish connection - target does not exist");
                    return;
                }
                _ensureContainer(_p.source);
                // create the connection.  it is not yet registered
                jpc = _newConnection(_p);
                // now add it the model, fire an event, and redraw
                _finaliseConnection(jpc, _p);
            }
            return jpc;
        };

        var stTypes = [
            { el: "source", elId: "sourceId", epDefs: "sourceEndpointDefinitions" },
            { el: "target", elId: "targetId", epDefs: "targetEndpointDefinitions" }
        ];

        var _set = function (c, el, idx, doNotRepaint) {
            var ep, _st = stTypes[idx], cId = c[_st.elId], cEl = c[_st.el], sid, sep,
                oldEndpoint = c.endpoints[idx];

            var evtParams = {
                index: idx,
                originalSourceId: idx === 0 ? cId : c.sourceId,
                newSourceId: c.sourceId,
                originalTargetId: idx === 1 ? cId : c.targetId,
                newTargetId: c.targetId,
                connection: c
            };

            if (el.constructor === jsPlumb.Endpoint) {
                ep = el;
                ep.addConnection(c);
                el = ep.element;
            }
            else {
                sid = _getId(el);
                sep = this[_st.epDefs][sid];

                if (sid === c[_st.elId]) {
                    ep = null; // dont change source/target if the element is already the one given.
                }
                else if (sep) {
                    for (var t in sep) {
                        if (!sep[t].enabled) {
                            return;
                        }
                        ep = sep[t].endpoint != null && sep[t].endpoint._jsPlumb ? sep[t].endpoint : this.addEndpoint(el, sep[t].def);
                        if (sep[t].uniqueEndpoint) {
                            sep[t].endpoint = ep;
                        }
                        ep.addConnection(c);
                    }
                }
                else {
                    ep = c.makeEndpoint(idx === 0, el, sid);
                }
            }

            if (ep != null) {
                oldEndpoint.detachFromConnection(c);
                c.endpoints[idx] = ep;
                c[_st.el] = ep.element;
                c[_st.elId] = ep.elementId;
                evtParams[idx === 0 ? "newSourceId" : "newTargetId"] = ep.elementId;

                fireMoveEvent(evtParams);

                if (!doNotRepaint) {
                    c.repaint();
                }
            }

            evtParams.element = el;
            return evtParams;

        }.bind(this);

        this.setSource = function (connection, el, doNotRepaint) {
            var p = _set(connection, el, 0, doNotRepaint);
            this.anchorManager.sourceChanged(p.originalSourceId, p.newSourceId, connection, p.el);
        };
        this.setTarget = function (connection, el, doNotRepaint) {
            var p = _set(connection, el, 1, doNotRepaint);
            this.anchorManager.updateOtherEndpoint(p.originalSourceId, p.originalTargetId, p.newTargetId, connection);
        };

        this.deleteEndpoint = function (object, dontUpdateHover, deleteAttachedObjects) {
            var endpoint = (typeof object === "string") ? endpointsByUUID[object] : object;
            if (endpoint) {
                _currentInstance.deleteObject({ endpoint: endpoint, dontUpdateHover: dontUpdateHover, deleteAttachedObjects:deleteAttachedObjects });
            }
            return _currentInstance;
        };

        this.deleteEveryEndpoint = function () {
            var _is = _currentInstance.setSuspendDrawing(true);
            for (var id in endpointsByElement) {
                var endpoints = endpointsByElement[id];
                if (endpoints && endpoints.length) {
                    for (var i = 0, j = endpoints.length; i < j; i++) {
                        _currentInstance.deleteEndpoint(endpoints[i], true);
                    }
                }
            }
            endpointsByElement = {};
            managedElements = {};
            endpointsByUUID = {};
            offsets = {};
            offsetTimestamps = {};
            _currentInstance.anchorManager.reset();
            var dm = _currentInstance.getDragManager();
            if (dm) {
                dm.reset();
            }
            if (!_is) {
                _currentInstance.setSuspendDrawing(false);
            }
            return _currentInstance;
        };

        var fireDetachEvent = function (jpc, doFireEvent, originalEvent) {
            // may have been given a connection, or in special cases, an object
            var connType = _currentInstance.Defaults.ConnectionType || _currentInstance.getDefaultConnectionType(),
                argIsConnection = jpc.constructor === connType,
                params = argIsConnection ? {
                    connection: jpc,
                    source: jpc.source, target: jpc.target,
                    sourceId: jpc.sourceId, targetId: jpc.targetId,
                    sourceEndpoint: jpc.endpoints[0], targetEndpoint: jpc.endpoints[1]
                } : jpc;

            if (doFireEvent) {
                _currentInstance.fire("connectionDetached", params, originalEvent);
            }

            // always fire this. used by internal jsplumb stuff.
            _currentInstance.fire("internal.connectionDetached", params, originalEvent);

            _currentInstance.anchorManager.connectionDetached(params);
        };

        var fireMoveEvent = _currentInstance.fireMoveEvent = function (params, evt) {
            _currentInstance.fire("connectionMoved", params, evt);
        };

        this.unregisterEndpoint = function (endpoint) {
            if (endpoint._jsPlumb.uuid) {
                endpointsByUUID[endpoint._jsPlumb.uuid] = null;
            }
            _currentInstance.anchorManager.deleteEndpoint(endpoint);
            // TODO at least replace this with a removeWithFunction call.
            for (var e in endpointsByElement) {
                var endpoints = endpointsByElement[e];
                if (endpoints) {
                    var newEndpoints = [];
                    for (var i = 0, j = endpoints.length; i < j; i++) {
                        if (endpoints[i] !== endpoint) {
                            newEndpoints.push(endpoints[i]);
                        }
                    }

                    endpointsByElement[e] = newEndpoints;
                }
                if (endpointsByElement[e].length < 1) {
                    delete endpointsByElement[e];
                }
            }
        };

        var IS_DETACH_ALLOWED = "isDetachAllowed";
        var BEFORE_DETACH = "beforeDetach";
        var CHECK_CONDITION = "checkCondition";

        /**
         * Deletes a Connection.
         * @method deleteConnection
         * @param connection Connection to delete
         * @param {Object} [params] Optional delete parameters
         * @param {Boolean} [params.doNotFireEvent=false] If true, a connection detached event will not be fired. Otherwise one will.
         * @param {Boolean} [params.force=false] If true, the connection will be deleted even if a beforeDetach interceptor tries to stop the deletion.
         * @returns {Boolean} True if the connection was deleted, false otherwise.
         */
        this.deleteConnection = function(connection, params) {

            if (connection != null) {
                params = params || {};

                if (params.force || _ju.functionChain(true, false, [
                    [ connection.endpoints[0], IS_DETACH_ALLOWED, [ connection ] ],
                    [ connection.endpoints[1], IS_DETACH_ALLOWED, [ connection ] ],
                    [ connection, IS_DETACH_ALLOWED, [ connection ] ],
                    [ _currentInstance, CHECK_CONDITION, [ BEFORE_DETACH, connection ] ]
                ])) {

                    connection.setHover(false);
                    fireDetachEvent(connection, !connection.pending && params.fireEvent !== false, params.originalEvent);

                    connection.endpoints[0].detachFromConnection(connection);
                    connection.endpoints[1].detachFromConnection(connection);
                    _ju.removeWithFunction(connections, function (_c) {
                        return connection.id === _c.id;
                    });

                    connection.cleanup();
                    connection.destroy();
                    return true;
                }
            }
            return false;
        };

        /**
         * Remove all Connections from all elements, but leaves Endpoints in place ((unless a connection is set to auto delete its Endpoints).
         * @method deleteEveryConnection
         * @param {Object} [params] optional params object for the call
         * @param {Boolean} [params.fireEvent=true] Whether or not to fire detach events
         * @param {Boolean} [params.forceDetach=false] If true, this call will ignore any `beforeDetach` interceptors.
         * @returns {Number} The number of connections that were deleted.
         */
        this.deleteEveryConnection = function (params) {
            params = params || {};
            var count = connections.length, deletedCount = 0;
            _currentInstance.batch(function () {
                for (var i = 0; i < count; i++) {
                    deletedCount += _currentInstance.deleteConnection(connections[0], params) ? 1 : 0;
                }
            });
            return deletedCount;
        };

        /**
         * Removes all an element's Connections.
         * @method deleteConnectionsForElement
         * @param {Object} el Either the id of the element, or a selector for the element.
         * @param {Object} [params] Optional parameters.
         * @param {Boolean} [params.fireEvent=true] Whether or not to fire the detach event.
         * @param {Boolean} [params.forceDetach=false] If true, this call will ignore any `beforeDetach` interceptors.
         * @return {jsPlumbInstance} The current jsPlumb instance.
         */
        this.deleteConnectionsForElement = function (el, params) {
            params = params || {};
            el = _currentInstance.getElement(el);
            var id = _getId(el), endpoints = endpointsByElement[id];
            if (endpoints && endpoints.length) {
                for (var i = 0, j = endpoints.length; i < j; i++) {
                    endpoints[i].deleteEveryConnection(params);
                }
            }
            return _currentInstance;
        };

        /// not public.  but of course its exposed. how to change this.
        this.deleteObject = function (params) {
            var result = {
                    endpoints: {},
                    connections: {},
                    endpointCount: 0,
                    connectionCount: 0
                },
                deleteAttachedObjects = params.deleteAttachedObjects !== false;

            var unravelConnection = function (connection) {
                if (connection != null && result.connections[connection.id] == null) {
                    if (!params.dontUpdateHover && connection._jsPlumb != null) {
                        connection.setHover(false);
                    }
                    result.connections[connection.id] = connection;
                    result.connectionCount++;
                }
            };
            var unravelEndpoint = function (endpoint) {
                if (endpoint != null && result.endpoints[endpoint.id] == null) {
                    if (!params.dontUpdateHover && endpoint._jsPlumb != null) {
                        endpoint.setHover(false);
                    }
                    result.endpoints[endpoint.id] = endpoint;
                    result.endpointCount++;

                    if (deleteAttachedObjects) {
                        for (var i = 0; i < endpoint.connections.length; i++) {
                            var c = endpoint.connections[i];
                            unravelConnection(c);
                        }
                    }
                }
            };

            if (params.connection) {
                unravelConnection(params.connection);
            }
            else {
                unravelEndpoint(params.endpoint);
            }

            // loop through connections
            for (var i in result.connections) {
                var c = result.connections[i];
                if (c._jsPlumb) {
                    _ju.removeWithFunction(connections, function (_c) {
                        return c.id === _c.id;
                    });

                    fireDetachEvent(c, params.fireEvent === false ? false : !c.pending, params.originalEvent);
                    var doNotCleanup = params.deleteAttachedObjects == null ? null : !params.deleteAttachedObjects;

                    c.endpoints[0].detachFromConnection(c, null, doNotCleanup);
                    c.endpoints[1].detachFromConnection(c, null, doNotCleanup);

                    c.cleanup(true);
                    c.destroy(true);
                }
            }

            // loop through endpoints
            for (var j in result.endpoints) {
                var e = result.endpoints[j];
                if (e._jsPlumb) {
                    _currentInstance.unregisterEndpoint(e);
                    // FIRE some endpoint deleted event?
                    e.cleanup(true);
                    e.destroy(true);
                }
            }

            return result;
        };

        this.draggable = function (el, options) {
            var info;
            _each(function(_el) {
                 info = _info(_el);
                if (info.el) {
                    _initDraggableIfNecessary(info.el, true, options, info.id, true);
                }
            }, el);
            return _currentInstance;
        };

        this.droppable = function(el, options) {
            var info;
            options = options || {};
            options.allowLoopback = false;
            _each(function(_el) {
                info = _info(_el);
                if (info.el) {
                    _currentInstance.initDroppable(info.el, options);
                }
            }, el);
            return _currentInstance;
        };

        // helpers for select/selectEndpoints
        var _setOperation = function (list, func, args, selector) {
                for (var i = 0, j = list.length; i < j; i++) {
                    list[i][func].apply(list[i], args);
                }
                return selector(list);
            },
            _getOperation = function (list, func, args) {
                var out = [];
                for (var i = 0, j = list.length; i < j; i++) {
                    out.push([ list[i][func].apply(list[i], args), list[i] ]);
                }
                return out;
            },
            setter = function (list, func, selector) {
                return function () {
                    return _setOperation(list, func, arguments, selector);
                };
            },
            getter = function (list, func) {
                return function () {
                    return _getOperation(list, func, arguments);
                };
            },
            prepareList = function (input, doNotGetIds) {
                var r = [];
                if (input) {
                    if (typeof input === 'string') {
                        if (input === "*") {
                            return input;
                        }
                        r.push(input);
                    }
                    else {
                        if (doNotGetIds) {
                            r = input;
                        }
                        else {
                            if (input.length) {
                                for (var i = 0, j = input.length; i < j; i++) {
                                    r.push(_info(input[i]).id);
                                }
                            }
                            else {
                                r.push(_info(input).id);
                            }
                        }
                    }
                }
                return r;
            },
            filterList = function (list, value, missingIsFalse) {
                if (list === "*") {
                    return true;
                }
                return list.length > 0 ? list.indexOf(value) !== -1 : !missingIsFalse;
            };

        // get some connections, specifying source/target/scope
        this.getConnections = function (options, flat) {
            if (!options) {
                options = {};
            } else if (options.constructor === String) {
                options = { "scope": options };
            }
            var scope = options.scope || _currentInstance.getDefaultScope(),
                scopes = prepareList(scope, true),
                sources = prepareList(options.source),
                targets = prepareList(options.target),
                results = (!flat && scopes.length > 1) ? {} : [],
                _addOne = function (scope, obj) {
                    if (!flat && scopes.length > 1) {
                        var ss = results[scope];
                        if (ss == null) {
                            ss = results[scope] = [];
                        }
                        ss.push(obj);
                    } else {
                        results.push(obj);
                    }
                };

            for (var j = 0, jj = connections.length; j < jj; j++) {
                var c = connections[j],
                    sourceId = c.proxies && c.proxies[0] ? c.proxies[0].originalEp.elementId : c.sourceId,
                    targetId = c.proxies && c.proxies[1] ? c.proxies[1].originalEp.elementId : c.targetId;

                if (filterList(scopes, c.scope) && filterList(sources, sourceId) && filterList(targets, targetId)) {
                    _addOne(c.scope, c);
                }
            }

            return results;
        };

        var _curryEach = function (list, executor) {
                return function (f) {
                    for (var i = 0, ii = list.length; i < ii; i++) {
                        f(list[i]);
                    }
                    return executor(list);
                };
            },
            _curryGet = function (list) {
                return function (idx) {
                    return list[idx];
                };
            };

        var _makeCommonSelectHandler = function (list, executor) {
            var out = {
                    length: list.length,
                    each: _curryEach(list, executor),
                    get: _curryGet(list)
                },
                setters = ["setHover", "removeAllOverlays", "setLabel", "addClass", "addOverlay", "removeOverlay",
                    "removeOverlays", "showOverlay", "hideOverlay", "showOverlays", "hideOverlays", "setPaintStyle",
                    "setHoverPaintStyle", "setSuspendEvents", "setParameter", "setParameters", "setVisible",
                    "repaint", "addType", "toggleType", "removeType", "removeClass", "setType", "bind", "unbind" ],

                getters = ["getLabel", "getOverlay", "isHover", "getParameter", "getParameters", "getPaintStyle",
                    "getHoverPaintStyle", "isVisible", "hasType", "getType", "isSuspendEvents" ],
                i, ii;

            for (i = 0, ii = setters.length; i < ii; i++) {
                out[setters[i]] = setter(list, setters[i], executor);
            }

            for (i = 0, ii = getters.length; i < ii; i++) {
                out[getters[i]] = getter(list, getters[i]);
            }

            return out;
        };

        var _makeConnectionSelectHandler = function (list) {
            var common = _makeCommonSelectHandler(list, _makeConnectionSelectHandler);
            return jsPlumb.extend(common, {
                // setters
                setDetachable: setter(list, "setDetachable", _makeConnectionSelectHandler),
                setReattach: setter(list, "setReattach", _makeConnectionSelectHandler),
                setConnector: setter(list, "setConnector", _makeConnectionSelectHandler),
                delete: function () {
                    for (var i = 0, ii = list.length; i < ii; i++) {
                        _currentInstance.deleteConnection(list[i]);
                    }
                },
                // getters
                isDetachable: getter(list, "isDetachable"),
                isReattach: getter(list, "isReattach")
            });
        };

        var _makeEndpointSelectHandler = function (list) {
            var common = _makeCommonSelectHandler(list, _makeEndpointSelectHandler);
            return jsPlumb.extend(common, {
                setEnabled: setter(list, "setEnabled", _makeEndpointSelectHandler),
                setAnchor: setter(list, "setAnchor", _makeEndpointSelectHandler),
                isEnabled: getter(list, "isEnabled"),
                deleteEveryConnection: function () {
                    for (var i = 0, ii = list.length; i < ii; i++) {
                        list[i].deleteEveryConnection();
                    }
                },
                "delete": function () {
                    for (var i = 0, ii = list.length; i < ii; i++) {
                        _currentInstance.deleteEndpoint(list[i]);
                    }
                }
            });
        };

        this.select = function (params) {
            params = params || {};
            params.scope = params.scope || "*";
            return _makeConnectionSelectHandler(params.connections || _currentInstance.getConnections(params, true));
        };

        this.selectEndpoints = function (params) {
            params = params || {};
            params.scope = params.scope || "*";
            var noElementFilters = !params.element && !params.source && !params.target,
                elements = noElementFilters ? "*" : prepareList(params.element),
                sources = noElementFilters ? "*" : prepareList(params.source),
                targets = noElementFilters ? "*" : prepareList(params.target),
                scopes = prepareList(params.scope, true);

            var ep = [];

            for (var el in endpointsByElement) {
                var either = filterList(elements, el, true),
                    source = filterList(sources, el, true),
                    sourceMatchExact = sources !== "*",
                    target = filterList(targets, el, true),
                    targetMatchExact = targets !== "*";

                // if they requested 'either' then just match scope. otherwise if they requested 'source' (not as a wildcard) then we have to match only endpoints that have isSource set to to true, and the same thing with isTarget.
                if (either || source || target) {
                    inner:
                        for (var i = 0, ii = endpointsByElement[el].length; i < ii; i++) {
                            var _ep = endpointsByElement[el][i];
                            if (filterList(scopes, _ep.scope, true)) {

                                var noMatchSource = (sourceMatchExact && sources.length > 0 && !_ep.isSource),
                                    noMatchTarget = (targetMatchExact && targets.length > 0 && !_ep.isTarget);

                                if (noMatchSource || noMatchTarget) {
                                    continue inner;
                                }

                                ep.push(_ep);
                            }
                        }
                }
            }

            return _makeEndpointSelectHandler(ep);
        };

        // get all connections managed by the instance of jsplumb.
        this.getAllConnections = function () {
            return connections;
        };
        this.getDefaultScope = function () {
            return DEFAULT_SCOPE;
        };
        // get an endpoint by uuid.
        this.getEndpoint = _getEndpoint;
        /**
         * Gets the list of Endpoints for a given element.
         * @method getEndpoints
         * @param {String|Element|Selector} el The element to get endpoints for.
         * @return {Endpoint[]} An array of Endpoints for the specified element.
         */
        this.getEndpoints = function (el) {
            return endpointsByElement[_info(el).id] || [];
        };
        // gets the default endpoint type. used when subclassing. see wiki.
        this.getDefaultEndpointType = function () {
            return jsPlumb.Endpoint;
        };
        // gets the default connection type. used when subclassing.  see wiki.
        this.getDefaultConnectionType = function () {
            return jsPlumb.Connection;
        };
        /*
         * Gets an element's id, creating one if necessary. really only exposed
         * for the lib-specific functionality to access; would be better to pass
         * the current instance into the lib-specific code (even though this is
         * a static call. i just don't want to expose it to the public API).
         */
        this.getId = _getId;

        this.appendElement = _appendElement;

        var _hoverSuspended = false;
        this.isHoverSuspended = function () {
            return _hoverSuspended;
        };
        this.setHoverSuspended = function (s) {
            _hoverSuspended = s;
        };

        // set an element's connections to be hidden
        this.hide = function (el, changeEndpoints) {
            _setVisible(el, "none", changeEndpoints);
            return _currentInstance;
        };

        // exposed for other objects to use to get a unique id.
        this.idstamp = _idstamp;

        this.connectorsInitialized = false;
        this.registerConnectorType = function (connector, name) {
            connectorTypes.push([connector, name]);
        };

        // ensure that, if the current container exists, it is a DOM element and not a selector.
        // if it does not exist and `candidate` is supplied, the offset parent of that element will be set as the Container.
        // this is used to do a better default behaviour for the case that the user has not set a container:
        // addEndpoint, makeSource, makeTarget and connect all call this method with the offsetParent of the
        // element in question (for connect it is the source element). So if no container is set, it is inferred
        // to be the offsetParent of the first element the user tries to connect.
        var _ensureContainer = function (candidate) {
            if (!_container && candidate) {
                var can = _currentInstance.getElement(candidate);
                if (can.offsetParent) {
                    _currentInstance.setContainer(can.offsetParent);
                }
            }
        };

        var _getContainerFromDefaults = function () {
            if (_currentInstance.Defaults.Container) {
                _currentInstance.setContainer(_currentInstance.Defaults.Container);
            }
        };

        // check if a given element is managed or not. if not, add to our map. if drawing is not suspended then
        // we'll also stash its dimensions; otherwise we'll do this in a lazy way through updateOffset.
        var _manage = _currentInstance.manage = function (id, element, _transient) {
            if (!managedElements[id]) {
                managedElements[id] = {
                    el: element,
                    endpoints: [],
                    connections: []
                };

                managedElements[id].info = _updateOffset({ elId: id, timestamp: _suspendedAt });
                if (!_transient) {
                    _currentInstance.fire("manageElement", { id:id, info:managedElements[id].info, el:element });
                }
            }

            return managedElements[id];
        };

        var _unmanage = function(id) {
            if (managedElements[id]) {
                delete managedElements[id];
                _currentInstance.fire("unmanageElement", id);
            }
        };

        /**
         * updates the offset and size for a given element, and stores the
         * values. if 'offset' is not null we use that (it would have been
         * passed in from a drag call) because it's faster; but if it is null,
         * or if 'recalc' is true in order to force a recalculation, we get the current values.
         */
        var _updateOffset = this.updateOffset = function (params) {

            var timestamp = params.timestamp, recalc = params.recalc, offset = params.offset, elId = params.elId, s;
            if (_suspendDrawing && !timestamp) {
                timestamp = _suspendedAt;
            }
            if (!recalc) {
                if (timestamp && timestamp === offsetTimestamps[elId]) {
                    return {o: params.offset || offsets[elId], s: sizes[elId]};
                }
            }
            if (recalc || (!offset && offsets[elId] == null)) { // if forced repaint or no offset available, we recalculate.

                // get the current size and offset, and store them
                s = managedElements[elId] ? managedElements[elId].el : null;
                if (s != null) {
                    sizes[elId] = _currentInstance.getSize(s);
                    offsets[elId] = _currentInstance.getOffset(s);
                    offsetTimestamps[elId] = timestamp;
                }
            } else {
                offsets[elId] = offset || offsets[elId];
                if (sizes[elId] == null) {
                    s = managedElements[elId].el;
                    if (s != null) {
                        sizes[elId] = _currentInstance.getSize(s);
                    }
                }
                offsetTimestamps[elId] = timestamp;
            }

            if (offsets[elId] && !offsets[elId].right) {
                offsets[elId].right = offsets[elId].left + sizes[elId][0];
                offsets[elId].bottom = offsets[elId].top + sizes[elId][1];
                offsets[elId].width = sizes[elId][0];
                offsets[elId].height = sizes[elId][1];
                offsets[elId].centerx = offsets[elId].left + (offsets[elId].width / 2);
                offsets[elId].centery = offsets[elId].top + (offsets[elId].height / 2);
            }

            return {o: offsets[elId], s: sizes[elId]};
        };

        /**
         * callback from the current library to tell us to prepare ourselves (attach
         * mouse listeners etc; can't do that until the library has provided a bind method)
         */
        this.init = function () {
            rendererTypes = root.jsPlumb.getRenderModes();

            var _oneType = function (renderer, name, fn) {
                root.jsPlumb.Connectors[renderer][name] = function () {
                    fn.apply(this, arguments);
                    root.jsPlumb.ConnectorRenderers[renderer].apply(this, arguments);
                };
                _ju.extend(root.jsPlumb.Connectors[renderer][name], [ fn, root.jsPlumb.ConnectorRenderers[renderer]]);
            };

            if (!root.jsPlumb.connectorsInitialized) {
                for (var i = 0; i < connectorTypes.length; i++) {
                    for (var j = 0; j < rendererTypes.length; j++) {
                        _oneType(rendererTypes[j], connectorTypes[i][1], connectorTypes[i][0]);
                    }

                }
                root.jsPlumb.connectorsInitialized = true;
            }

            if (!initialized) {
                _getContainerFromDefaults();
                _currentInstance.anchorManager = new root.jsPlumb.AnchorManager({jsPlumbInstance: _currentInstance});
                initialized = true;
                _currentInstance.fire("ready", _currentInstance);
            }
        }.bind(this);

        this.log = log;
        this.jsPlumbUIComponent = jsPlumbUIComponent;

        /*
         * Creates an anchor with the given params.
         *
         *
         * Returns: The newly created Anchor.
         * Throws: an error if a named anchor was not found.
         */
        this.makeAnchor = function () {
            var pp, _a = function (t, p) {
                if (root.jsPlumb.Anchors[t]) {
                    return new root.jsPlumb.Anchors[t](p);
                }
                if (!_currentInstance.Defaults.DoNotThrowErrors) {
                    throw { msg: "jsPlumb: unknown anchor type '" + t + "'" };
                }
            };
            if (arguments.length === 0) {
                return null;
            }
            var specimen = arguments[0], elementId = arguments[1], jsPlumbInstance = arguments[2], newAnchor = null;
            // if it appears to be an anchor already...
            if (specimen.compute && specimen.getOrientation) {
                return specimen;
            }  //TODO hazy here about whether it should be added or is already added somehow.
            // is it the name of an anchor type?
            else if (typeof specimen === "string") {
                newAnchor = _a(arguments[0], {elementId: elementId, jsPlumbInstance: _currentInstance});
            }
            // is it an array? it will be one of:
            // an array of [spec, params] - this defines a single anchor, which may be dynamic, but has parameters.
            // an array of arrays - this defines some dynamic anchors
            // an array of numbers - this defines a single anchor.
            else if (_ju.isArray(specimen)) {
                if (_ju.isArray(specimen[0]) || _ju.isString(specimen[0])) {
                    // if [spec, params] format
                    if (specimen.length === 2 && _ju.isObject(specimen[1])) {
                        // if first arg is a string, its a named anchor with params
                        if (_ju.isString(specimen[0])) {
                            pp = root.jsPlumb.extend({elementId: elementId, jsPlumbInstance: _currentInstance}, specimen[1]);
                            newAnchor = _a(specimen[0], pp);
                        }
                        // otherwise first arg is array, second is params. we treat as a dynamic anchor, which is fine
                        // even if the first arg has only one entry. you could argue all anchors should be implicitly dynamic in fact.
                        else {
                            pp = root.jsPlumb.extend({elementId: elementId, jsPlumbInstance: _currentInstance, anchors: specimen[0]}, specimen[1]);
                            newAnchor = new root.jsPlumb.DynamicAnchor(pp);
                        }
                    }
                    else {
                        newAnchor = new jsPlumb.DynamicAnchor({anchors: specimen, selector: null, elementId: elementId, jsPlumbInstance: _currentInstance});
                    }

                }
                else {
                    var anchorParams = {
                        x: specimen[0], y: specimen[1],
                        orientation: (specimen.length >= 4) ? [ specimen[2], specimen[3] ] : [0, 0],
                        offsets: (specimen.length >= 6) ? [ specimen[4], specimen[5] ] : [ 0, 0 ],
                        elementId: elementId,
                        jsPlumbInstance: _currentInstance,
                        cssClass: specimen.length === 7 ? specimen[6] : null
                    };
                    newAnchor = new root.jsPlumb.Anchor(anchorParams);
                    newAnchor.clone = function () {
                        return new root.jsPlumb.Anchor(anchorParams);
                    };
                }
            }

            if (!newAnchor.id) {
                newAnchor.id = "anchor_" + _idstamp();
            }
            return newAnchor;
        };

        /**
         * makes a list of anchors from the given list of types or coords, eg
         * ["TopCenter", "RightMiddle", "BottomCenter", [0, 1, -1, -1] ]
         */
        this.makeAnchors = function (types, elementId, jsPlumbInstance) {
            var r = [];
            for (var i = 0, ii = types.length; i < ii; i++) {
                if (typeof types[i] === "string") {
                    r.push(root.jsPlumb.Anchors[types[i]]({elementId: elementId, jsPlumbInstance: jsPlumbInstance}));
                }
                else if (_ju.isArray(types[i])) {
                    r.push(_currentInstance.makeAnchor(types[i], elementId, jsPlumbInstance));
                }
            }
            return r;
        };

        /**
         * Makes a dynamic anchor from the given list of anchors (which may be in shorthand notation as strings or dimension arrays, or Anchor
         * objects themselves) and the given, optional, anchorSelector function (jsPlumb uses a default if this is not provided; most people will
         * not need to provide this - i think).
         */
        this.makeDynamicAnchor = function (anchors, anchorSelector) {
            return new root.jsPlumb.DynamicAnchor({anchors: anchors, selector: anchorSelector, elementId: null, jsPlumbInstance: _currentInstance});
        };

// --------------------- makeSource/makeTarget ---------------------------------------------- 

        this.targetEndpointDefinitions = {};
        this.sourceEndpointDefinitions = {};

        var selectorFilter = function (evt, _el, selector, _instance, negate) {
            var t = evt.target || evt.srcElement, ok = false,
                sel = _instance.getSelector(_el, selector);
            for (var j = 0; j < sel.length; j++) {
                if (sel[j] === t) {
                    ok = true;
                    break;
                }
            }
            return negate ? !ok : ok;
        };

        var _makeElementDropHandler = function (elInfo, p, dropOptions, isSource, isTarget) {
            var proxyComponent = new jsPlumbUIComponent(p);
            var _drop = p._jsPlumb.EndpointDropHandler({
                jsPlumb: _currentInstance,
                enabled: function () {
                    return elInfo.def.enabled;
                },
                isFull: function () {
                    var targetCount = _currentInstance.select({target: elInfo.id}).length;
                    return elInfo.def.maxConnections > 0 && targetCount >= elInfo.def.maxConnections;
                },
                element: elInfo.el,
                elementId: elInfo.id,
                isSource: isSource,
                isTarget: isTarget,
                addClass: function (clazz) {
                    _currentInstance.addClass(elInfo.el, clazz);
                },
                removeClass: function (clazz) {
                    _currentInstance.removeClass(elInfo.el, clazz);
                },
                onDrop: function (jpc) {
                    var source = jpc.endpoints[0];
                    source.anchor.locked = false;
                },
                isDropAllowed: function () {
                    return proxyComponent.isDropAllowed.apply(proxyComponent, arguments);
                },
                isRedrop:function(jpc) {
                    return (jpc.suspendedElement != null && jpc.suspendedEndpoint != null && jpc.suspendedEndpoint.element === elInfo.el);
                },
                getEndpoint: function (jpc) {

                    // make a new Endpoint for the target, or get it from the cache if uniqueEndpoint
                    // is set. if its a redrop the new endpoint will be immediately cleaned up.

                    var newEndpoint = elInfo.def.endpoint;

                    // if no cached endpoint, or there was one but it has been cleaned up
                    // (ie. detached), create a new one
                    if (newEndpoint == null || newEndpoint._jsPlumb == null) {
                        var eps = _currentInstance.deriveEndpointAndAnchorSpec(jpc.getType().join(" "), true);
                        var pp = eps.endpoints ? root.jsPlumb.extend(p, {
                            endpoint:elInfo.def.def.endpoint || eps.endpoints[1]
                        }) :p;
                        if (eps.anchors) {
                            pp = root.jsPlumb.extend(pp, {
                                anchor:elInfo.def.def.anchor || eps.anchors[1]
                            });
                        }
                        newEndpoint = _currentInstance.addEndpoint(elInfo.el, pp);
                        newEndpoint._mtNew = true;
                    }

                    if (p.uniqueEndpoint) {
                        elInfo.def.endpoint = newEndpoint;
                    }

                    newEndpoint.setDeleteOnEmpty(true);

                    // if connection is detachable, init the new endpoint to be draggable, to support that happening.
                    if (jpc.isDetachable()) {
                        newEndpoint.initDraggable();
                    }

                    // if the anchor has a 'positionFinder' set, then delegate to that function to find
                    // out where to locate the anchor.
                    if (newEndpoint.anchor.positionFinder != null) {
                        var dropPosition = _currentInstance.getUIPosition(arguments, _currentInstance.getZoom()),
                            elPosition = _currentInstance.getOffset(elInfo.el),
                            elSize = _currentInstance.getSize(elInfo.el),
                            ap = dropPosition == null ? [0,0] : newEndpoint.anchor.positionFinder(dropPosition, elPosition, elSize, newEndpoint.anchor.constructorParams);

                        newEndpoint.anchor.x = ap[0];
                        newEndpoint.anchor.y = ap[1];
                        // now figure an orientation for it..kind of hard to know what to do actually. probably the best thing i can do is to
                        // support specifying an orientation in the anchor's spec. if one is not supplied then i will make the orientation
                        // be what will cause the most natural link to the source: it will be pointing at the source, but it needs to be
                        // specified in one axis only, and so how to make that choice? i think i will use whichever axis is the one in which
                        // the target is furthest away from the source.
                    }

                    return newEndpoint;
                },
                maybeCleanup: function (ep) {
                    if (ep._mtNew && ep.connections.length === 0) {
                        _currentInstance.deleteObject({endpoint: ep});
                    }
                    else {
                        delete ep._mtNew;
                    }
                }
            });

            // wrap drop events as needed and initialise droppable
            var dropEvent = root.jsPlumb.dragEvents.drop;
            dropOptions.scope = dropOptions.scope || (p.scope || _currentInstance.Defaults.Scope);
            dropOptions[dropEvent] = _ju.wrap(dropOptions[dropEvent], _drop, true);

            // if target, return true from the over event. this will cause katavorio to stop setting drops to hover
            // if multipleDrop is set to false.
            if (isTarget) {
                dropOptions[root.jsPlumb.dragEvents.over] = function () { return true; };
            }

            // vanilla jsplumb only
            if (p.allowLoopback === false) {
                dropOptions.canDrop = function (_drag) {
                    var de = _drag.getDragElement()._jsPlumbRelatedElement;
                    return de !== elInfo.el;
                };
            }
            _currentInstance.initDroppable(elInfo.el, dropOptions, "internal");

            return _drop;

        };

        // see API docs
        this.makeTarget = function (el, params, referenceParams) {

            // put jsplumb ref into params without altering the params passed in
            var p = root.jsPlumb.extend({_jsPlumb: this}, referenceParams);
            root.jsPlumb.extend(p, params);

            var maxConnections = p.maxConnections || -1,

                _doOne = function (el) {

                    // get the element's id and store the endpoint definition for it.  jsPlumb.connect calls will look for one of these,
                    // and use the endpoint definition if found.
                    // decode the info for this element (id and element)
                    var elInfo = _info(el),
                        elid = elInfo.id,
                        dropOptions = root.jsPlumb.extend({}, p.dropOptions || {}),
                        type = p.connectionType || "default";

                    this.targetEndpointDefinitions[elid] = this.targetEndpointDefinitions[elid] || {};

                    _ensureContainer(elid);

                    // if this is a group and the user has not mandated a rank, set to -1 so that Nodes takes
                    // precedence.
                    if (elInfo.el._isJsPlumbGroup && dropOptions.rank == null) {
                        dropOptions.rank = -1;
                    }

                    // store the definition
                    var _def = {
                        def: root.jsPlumb.extend({}, p),
                        uniqueEndpoint: p.uniqueEndpoint,
                        maxConnections: maxConnections,
                        enabled: true
                    };

                    if (p.createEndpoint) {
                        _def.uniqueEndpoint = true;
                        _def.endpoint = _currentInstance.addEndpoint(el, _def.def);
                        _def.endpoint.setDeleteOnEmpty(false);
                    }

                    elInfo.def = _def;
                    this.targetEndpointDefinitions[elid][type] = _def;
                    _makeElementDropHandler(elInfo, p, dropOptions, p.isSource === true, true);
                    // stash the definition on the drop
                    elInfo.el._katavorioDrop[elInfo.el._katavorioDrop.length - 1].targetDef = _def;

                }.bind(this);

            // make an array if only given one element
            var inputs = el.length && el.constructor !== String ? el : [ el ];

            // register each one in the list.
            for (var i = 0, ii = inputs.length; i < ii; i++) {
                _doOne(inputs[i]);
            }

            return this;
        };

        // see api docs
        this.unmakeTarget = function (el, doNotClearArrays) {
            var info = _info(el);
            _currentInstance.destroyDroppable(info.el, "internal");
            if (!doNotClearArrays) {
                delete this.targetEndpointDefinitions[info.id];
            }

            return this;
        };

        // see api docs
        this.makeSource = function (el, params, referenceParams) {
            var p = root.jsPlumb.extend({_jsPlumb: this}, referenceParams);
            root.jsPlumb.extend(p, params);
            var type = p.connectionType || "default";
            var aae = _currentInstance.deriveEndpointAndAnchorSpec(type);
            p.endpoint = p.endpoint || aae.endpoints[0];
            p.anchor = p.anchor || aae.anchors[0];
            var maxConnections = p.maxConnections || -1,
                onMaxConnections = p.onMaxConnections,
                _doOne = function (elInfo) {
                    // get the element's id and store the endpoint definition for it.  jsPlumb.connect calls will look for one of these,
                    // and use the endpoint definition if found.
                    var elid = elInfo.id,
                        _del = this.getElement(elInfo.el);

                    this.sourceEndpointDefinitions[elid] = this.sourceEndpointDefinitions[elid] || {};
                    _ensureContainer(elid);

                    var _def = {
                        def:root.jsPlumb.extend({}, p),
                        uniqueEndpoint: p.uniqueEndpoint,
                        maxConnections: maxConnections,
                        enabled: true
                    };

                    if (p.createEndpoint) {
                        _def.uniqueEndpoint = true;
                        _def.endpoint = _currentInstance.addEndpoint(el, _def.def);
                        _def.endpoint.setDeleteOnEmpty(false);
                    }

                    this.sourceEndpointDefinitions[elid][type] = _def;
                    elInfo.def = _def;

                    var stopEvent = root.jsPlumb.dragEvents.stop,
                        dragEvent = root.jsPlumb.dragEvents.drag,
                        dragOptions = root.jsPlumb.extend({ }, p.dragOptions || {}),
                        existingDrag = dragOptions.drag,
                        existingStop = dragOptions.stop,
                        ep = null,
                        endpointAddedButNoDragYet = false;

                    // set scope if its not set in dragOptions but was passed in in params
                    dragOptions.scope = dragOptions.scope || p.scope;

                    dragOptions[dragEvent] = _ju.wrap(dragOptions[dragEvent], function () {
                        if (existingDrag) {
                            existingDrag.apply(this, arguments);
                        }
                        endpointAddedButNoDragYet = false;
                    });

                    dragOptions[stopEvent] = _ju.wrap(dragOptions[stopEvent], function () {

                        if (existingStop) {
                            existingStop.apply(this, arguments);
                        }
                        this.currentlyDragging = false;
                        if (ep._jsPlumb != null) { // if not cleaned up...

                            // reset the anchor to the anchor that was initially provided. the one we were using to drag
                            // the connection was just a placeholder that was located at the place the user pressed the
                            // mouse button to initiate the drag.
                            var anchorDef = p.anchor || this.Defaults.Anchor,
                                oldAnchor = ep.anchor,
                                oldConnection = ep.connections[0];

                            var    newAnchor = this.makeAnchor(anchorDef, elid, this),
                                _el = ep.element;

                            // if the anchor has a 'positionFinder' set, then delegate to that function to find
                            // out where to locate the anchor. issue 117.
                            if (newAnchor.positionFinder != null) {
                                var elPosition = _currentInstance.getOffset(_el),
                                    elSize = this.getSize(_el),
                                    dropPosition = { left: elPosition.left + (oldAnchor.x * elSize[0]), top: elPosition.top + (oldAnchor.y * elSize[1]) },
                                    ap = newAnchor.positionFinder(dropPosition, elPosition, elSize, newAnchor.constructorParams);

                                newAnchor.x = ap[0];
                                newAnchor.y = ap[1];
                            }

                            ep.setAnchor(newAnchor, true);
                            ep.repaint();
                            this.repaint(ep.elementId);
                            if (oldConnection != null) {
                                this.repaint(oldConnection.targetId);
                            }
                        }
                    }.bind(this));

                    // when the user presses the mouse, add an Endpoint, if we are enabled.
                    var mouseDownListener = function (e) {
                        // on right mouse button, abort.
                        if (e.which === 3 || e.button === 2) {
                            return;
                        }

                        // TODO store def on element.
                        var def = this.sourceEndpointDefinitions[elid][type];

                        // if disabled, return.
                        if (!def.enabled) {
                            return;
                        }

                        elid = this.getId(this.getElement(elInfo.el)); // elid might have changed since this method was called to configure the element.

                        // if a filter was given, run it, and return if it says no.
                        if (p.filter) {
                            var r = _ju.isString(p.filter) ? selectorFilter(e, elInfo.el, p.filter, this, p.filterExclude) : p.filter(e, elInfo.el);
                            if (r === false) {
                                return;
                            }
                        }

                        // if maxConnections reached
                        var sourceCount = this.select({source: elid}).length;
                        if (def.maxConnections >= 0 && (sourceCount >= def.maxConnections)) {
                            if (onMaxConnections) {
                                onMaxConnections({
                                    element: elInfo.el,
                                    maxConnections: maxConnections
                                }, e);
                            }
                            return false;
                        }

                        // find the position on the element at which the mouse was pressed; this is where the endpoint
                        // will be located.
                        var elxy = root.jsPlumb.getPositionOnElement(e, _del, _zoom);

                        // we need to override the anchor in here, and force 'isSource', but we don't want to mess with
                        // the params passed in, because after a connection is established we're going to reset the endpoint
                        // to have the anchor we were given.
                        var tempEndpointParams = {};
                        root.jsPlumb.extend(tempEndpointParams, p);
                        tempEndpointParams.isTemporarySource = true;
                        tempEndpointParams.anchor = [ elxy[0], elxy[1] , 0, 0];
                        tempEndpointParams.dragOptions = dragOptions;

                        if (def.def.scope) {
                            tempEndpointParams.scope = def.def.scope;
                        }

                        ep = this.addEndpoint(elid, tempEndpointParams);
                        endpointAddedButNoDragYet = true;
                        ep.setDeleteOnEmpty(true);

                        // if unique endpoint and it's already been created, push it onto the endpoint we create. at the end
                        // of a successful connection we'll switch to that endpoint.
                        // TODO this is the same code as the programmatic endpoints create on line 1050 ish
                        if (def.uniqueEndpoint) {
                            if (!def.endpoint) {
                                def.endpoint = ep;
                                ep.setDeleteOnEmpty(false);
                            }
                            else {
                                ep.finalEndpoint = def.endpoint;
                            }
                        }

                        var _delTempEndpoint = function () {
                            // this mouseup event is fired only if no dragging occurred, by jquery and yui, but for mootools
                            // it is fired even if dragging has occurred, in which case we would blow away a perfectly
                            // legitimate endpoint, were it not for this check.  the flag is set after adding an
                            // endpoint and cleared in a drag listener we set in the dragOptions above.
                            _currentInstance.off(ep.canvas, "mouseup", _delTempEndpoint);
                            _currentInstance.off(elInfo.el, "mouseup", _delTempEndpoint);
                            if (endpointAddedButNoDragYet) {
                                endpointAddedButNoDragYet = false;
                                _currentInstance.deleteEndpoint(ep);
                            }
                        };

                        _currentInstance.on(ep.canvas, "mouseup", _delTempEndpoint);
                        _currentInstance.on(elInfo.el, "mouseup", _delTempEndpoint);

                        // optionally check for attributes to extract from the source element
                        var payload = {};
                        if (def.def.extract) {
                            for (var att in def.def.extract) {
                                var v = (e.srcElement || e.target).getAttribute(att);
                                if (v) {
                                    payload[def.def.extract[att]] = v;
                                }
                            }
                        }

                        // and then trigger its mousedown event, which will kick off a drag, which will start dragging
                        // a new connection from this endpoint.
                        _currentInstance.trigger(ep.canvas, "mousedown", e, payload);

                        _ju.consume(e);

                    }.bind(this);

                    this.on(elInfo.el, "mousedown", mouseDownListener);
                    _def.trigger = mouseDownListener;

                    // if a filter was provided, set it as a dragFilter on the element,
                    // to prevent the element drag function from kicking in when we want to
                    // drag a new connection
                    if (p.filter && (_ju.isString(p.filter) || _ju.isFunction(p.filter))) {
                        _currentInstance.setDragFilter(elInfo.el, p.filter);
                    }

                    var dropOptions = root.jsPlumb.extend({}, p.dropOptions || {});

                    _makeElementDropHandler(elInfo, p, dropOptions, true, p.isTarget === true);

                }.bind(this);

            var inputs = el.length && el.constructor !== String ? el : [ el ];
            for (var i = 0, ii = inputs.length; i < ii; i++) {
                _doOne(_info(inputs[i]));
            }

            return this;
        };

        // see api docs
        this.unmakeSource = function (el, connectionType, doNotClearArrays) {
            var info = _info(el);
            _currentInstance.destroyDroppable(info.el, "internal");
            var eldefs = this.sourceEndpointDefinitions[info.id];
            if (eldefs) {
                for (var def in eldefs) {
                    if (connectionType == null || connectionType === def) {
                        var mouseDownListener = eldefs[def].trigger;
                        if (mouseDownListener) {
                            _currentInstance.off(info.el, "mousedown", mouseDownListener);
                        }
                        if (!doNotClearArrays) {
                            delete this.sourceEndpointDefinitions[info.id][def];
                        }
                    }
                }
            }

            return this;
        };

        // see api docs
        this.unmakeEverySource = function () {
            for (var i in this.sourceEndpointDefinitions) {
                _currentInstance.unmakeSource(i, null, true);
            }

            this.sourceEndpointDefinitions = {};
            return this;
        };

        var _getScope = function (el, types, connectionType) {
            types = _ju.isArray(types) ? types : [ types ];
            var id = _getId(el);
            connectionType = connectionType || "default";
            for (var i = 0; i < types.length; i++) {
                var eldefs = this[types[i]][id];
                if (eldefs && eldefs[connectionType]) {
                    return eldefs[connectionType].def.scope || this.Defaults.Scope;
                }
            }
        }.bind(this);

        var _setScope = function (el, scope, types, connectionType) {
            types = _ju.isArray(types) ? types : [ types ];
            var id = _getId(el);
            connectionType = connectionType || "default";
            for (var i = 0; i < types.length; i++) {
                var eldefs = this[types[i]][id];
                if (eldefs && eldefs[connectionType]) {
                    eldefs[connectionType].def.scope = scope;
                }
            }

        }.bind(this);

        this.getScope = function (el, scope) {
            return _getScope(el, [ "sourceEndpointDefinitions", "targetEndpointDefinitions" ]);
        };
        this.getSourceScope = function (el) {
            return _getScope(el, "sourceEndpointDefinitions");
        };
        this.getTargetScope = function (el) {
            return _getScope(el, "targetEndpointDefinitions");
        };
        this.setScope = function (el, scope, connectionType) {
            this.setSourceScope(el, scope, connectionType);
            this.setTargetScope(el, scope, connectionType);
        };
        this.setSourceScope = function (el, scope, connectionType) {
            _setScope(el, scope, "sourceEndpointDefinitions", connectionType);
            // we get the source scope during the mousedown event, but we also want to set this.
            this.setDragScope(el, scope);
        };
        this.setTargetScope = function (el, scope, connectionType) {
            _setScope(el, scope, "targetEndpointDefinitions", connectionType);
            this.setDropScope(el, scope);
        };

        // see api docs
        this.unmakeEveryTarget = function () {
            for (var i in this.targetEndpointDefinitions) {
                _currentInstance.unmakeTarget(i, true);
            }

            this.targetEndpointDefinitions = {};
            return this;
        };

        // does the work of setting a source enabled or disabled.
        var _setEnabled = function (type, el, state, toggle, connectionType) {
            var a = type === "source" ? this.sourceEndpointDefinitions : this.targetEndpointDefinitions,
                originalState, info, newState;

            connectionType = connectionType || "default";

            // a selector or an array
            if (el.length && !_ju.isString(el)) {
                originalState = [];
                for (var i = 0, ii = el.length; i < ii; i++) {
                    info = _info(el[i]);
                    if (a[info.id] && a[info.id][connectionType]) {
                        originalState[i] = a[info.id][connectionType].enabled;
                        newState = toggle ? !originalState[i] : state;
                        a[info.id][connectionType].enabled = newState;
                        _currentInstance[newState ? "removeClass" : "addClass"](info.el, "jtk-" + type + "-disabled");
                    }
                }
            }
            // otherwise a DOM element or a String ID.
            else {
                info = _info(el);
                var id = info.id;
                if (a[id] && a[id][connectionType]) {
                    originalState = a[id][connectionType].enabled;
                    newState = toggle ? !originalState : state;
                    a[id][connectionType].enabled = newState;
                    _currentInstance[newState ? "removeClass" : "addClass"](info.el, "jtk-" + type + "-disabled");
                }
            }
            return originalState;
        }.bind(this);

        var _first = function (el, fn) {
            if (_ju.isString(el) || !el.length) {
                return fn.apply(this, [ el ]);
            }
            else if (el.length) {
                return fn.apply(this, [ el[0] ]);
            }

        }.bind(this);

        this.toggleSourceEnabled = function (el, connectionType) {
            _setEnabled("source", el, null, true, connectionType);
            return this.isSourceEnabled(el, connectionType);
        };

        this.setSourceEnabled = function (el, state, connectionType) {
            return _setEnabled("source", el, state, null, connectionType);
        };
        this.isSource = function (el, connectionType) {
            connectionType = connectionType || "default";
            return _first(el, function (_el) {
                var eldefs = this.sourceEndpointDefinitions[_info(_el).id];
                return eldefs != null && eldefs[connectionType] != null;
            }.bind(this));
        };
        this.isSourceEnabled = function (el, connectionType) {
            connectionType = connectionType || "default";
            return _first(el, function (_el) {
                var sep = this.sourceEndpointDefinitions[_info(_el).id];
                return sep && sep[connectionType] && sep[connectionType].enabled === true;
            }.bind(this));
        };

        this.toggleTargetEnabled = function (el, connectionType) {
            _setEnabled("target", el, null, true, connectionType);
            return this.isTargetEnabled(el, connectionType);
        };

        this.isTarget = function (el, connectionType) {
            connectionType = connectionType || "default";
            return _first(el, function (_el) {
                var eldefs = this.targetEndpointDefinitions[_info(_el).id];
                return eldefs != null && eldefs[connectionType] != null;
            }.bind(this));
        };
        this.isTargetEnabled = function (el, connectionType) {
            connectionType = connectionType || "default";
            return _first(el, function (_el) {
                var tep = this.targetEndpointDefinitions[_info(_el).id];
                return tep && tep[connectionType] && tep[connectionType].enabled === true;
            }.bind(this));
        };
        this.setTargetEnabled = function (el, state, connectionType) {
            return _setEnabled("target", el, state, null, connectionType);
        };

// --------------------- end makeSource/makeTarget ----------------------------------------------

        this.ready = function (fn) {
            _currentInstance.bind("ready", fn);
        };

        var _elEach = function(el, fn) {
            // support both lists...
            if (typeof el === 'object' && el.length) {
                for (var i = 0, ii = el.length; i < ii; i++) {
                    fn(el[i]);
                }
            }
            else {// ...and single strings or elements.
                fn(el);
            }

            return _currentInstance;
        };

        // repaint some element's endpoints and connections
        this.repaint = function (el, ui, timestamp) {
            return _elEach(el, function(_el) {
                _draw(_el, ui, timestamp);
            });
        };

        this.revalidate = function (el, timestamp, isIdAlready) {
            return _elEach(el, function(_el) {
                var elId = isIdAlready ? _el : _currentInstance.getId(_el);
                _currentInstance.updateOffset({ elId: elId, recalc: true, timestamp:timestamp });
                var dm = _currentInstance.getDragManager();
                if (dm) {
                    dm.updateOffsets(elId);
                }
                _currentInstance.repaint(_el);
            });
        };

        // repaint every endpoint and connection.
        this.repaintEverything = function () {
            // TODO this timestamp causes continuous anchors to not repaint properly.
            // fix this. do not just take out the timestamp. it runs a lot faster with
            // the timestamp included.
            var timestamp = _timestamp(), elId;

            for (elId in endpointsByElement) {
                _currentInstance.updateOffset({ elId: elId, recalc: true, timestamp: timestamp });
            }

            for (elId in endpointsByElement) {
                _draw(elId, null, timestamp);
            }

            return this;
        };

        this.removeAllEndpoints = function (el, recurse, affectedElements) {
            affectedElements = affectedElements || [];
            var _one = function (_el) {
                var info = _info(_el),
                    ebe = endpointsByElement[info.id],
                    i, ii;

                if (ebe) {
                    affectedElements.push(info);
                    for (i = 0, ii = ebe.length; i < ii; i++) {
                        _currentInstance.deleteEndpoint(ebe[i], false);
                    }
                }
                delete endpointsByElement[info.id];

                if (recurse) {
                    if (info.el && info.el.nodeType !== 3 && info.el.nodeType !== 8) {
                        for (i = 0, ii = info.el.childNodes.length; i < ii; i++) {
                            _one(info.el.childNodes[i]);
                        }
                    }
                }

            };
            _one(el);
            return this;
        };

        var _doRemove = function(info, affectedElements) {
            _currentInstance.removeAllEndpoints(info.id, true, affectedElements);
            var dm = _currentInstance.getDragManager();
            var _one = function(_info) {

                if (dm) {
                    dm.elementRemoved(_info.id);
                }
                _currentInstance.anchorManager.clearFor(_info.id);
                _currentInstance.anchorManager.removeFloatingConnection(_info.id);

                if (_currentInstance.isSource(_info.el)) {
                    _currentInstance.unmakeSource(_info.el);
                }
                if (_currentInstance.isTarget(_info.el)) {
                    _currentInstance.unmakeTarget(_info.el);
                }
                _currentInstance.destroyDraggable(_info.el);
                _currentInstance.destroyDroppable(_info.el);


                delete _currentInstance.floatingConnections[_info.id];
                delete managedElements[_info.id];
                delete offsets[_info.id];
                if (_info.el) {
                    _currentInstance.removeElement(_info.el);
                    _info.el._jsPlumb = null;
                }
            };

            // remove all affected child elements
            for (var ae = 1; ae < affectedElements.length; ae++) {
                _one(affectedElements[ae]);
            }
            // and always remove the requested one from the dom.
            _one(info);
        };

        /**
         * Remove the given element, including cleaning up all endpoints registered for it.
         * This is exposed in the public API but also used internally by jsPlumb when removing the
         * element associated with a connection drag.
         */
        this.remove = function (el, doNotRepaint) {
            var info = _info(el), affectedElements = [];
            if (info.text) {
                info.el.parentNode.removeChild(info.el);
            }
            else if (info.id) {
                _currentInstance.batch(function () {
                    _doRemove(info, affectedElements);
                }, doNotRepaint === false);
            }
            return _currentInstance;
        };

        this.empty = function (el, doNotRepaint) {
            var affectedElements = [];
            var _one = function(el, dontRemoveFocus) {
                var info = _info(el);
                if (info.text) {
                    info.el.parentNode.removeChild(info.el);
                }
                else if (info.el) {
                    while(info.el.childNodes.length > 0) {
                        _one(info.el.childNodes[0]);
                    }
                    if (!dontRemoveFocus) {
                        _doRemove(info, affectedElements);
                    }
                }
            };

            _currentInstance.batch(function() {
                _one(el, true);
            }, doNotRepaint === false);

            return _currentInstance;
        };

        this.reset = function () {
            _currentInstance.silently(function() {
                _hoverSuspended = false;
                _currentInstance.removeAllGroups();
                _currentInstance.removeGroupManager();
                _currentInstance.deleteEveryEndpoint();
                _currentInstance.unbind();
                this.targetEndpointDefinitions = {};
                this.sourceEndpointDefinitions = {};
                connections.length = 0;
                if (this.doReset) {
                    this.doReset();
                }
            }.bind(this));
        };

        var _clearObject = function (obj) {
            if (obj.canvas && obj.canvas.parentNode) {
                obj.canvas.parentNode.removeChild(obj.canvas);
            }
            obj.cleanup();
            obj.destroy();
        };

        this.clear = function () {
            _currentInstance.select().each(_clearObject);
            _currentInstance.selectEndpoints().each(_clearObject);

            endpointsByElement = {};
            endpointsByUUID = {};
        };

        this.setDefaultScope = function (scope) {
            DEFAULT_SCOPE = scope;
            return _currentInstance;
        };

        // sets whether or not some element should be currently draggable.
        this.setDraggable = _setDraggable;

        this.deriveEndpointAndAnchorSpec = function(type, dontPrependDefault) {
            var bits = ((dontPrependDefault ? "" : "default ") + type).split(/[\s]/), eps = null, ep = null, a = null, as = null;
            for (var i = 0; i < bits.length; i++) {
                var _t = _currentInstance.getType(bits[i], "connection");
                if (_t) {
                    if (_t.endpoints) {
                        eps = _t.endpoints;
                    }
                    if (_t.endpoint) {
                        ep = _t.endpoint;
                    }
                    if (_t.anchors) {
                        as = _t.anchors;
                    }
                    if (_t.anchor) {
                        a = _t.anchor;
                    }
                }
            }
            return { endpoints: eps ? eps : [ ep, ep ], anchors: as ? as : [a, a ]};
        };

        // sets the id of some element, changing whatever we need to to keep track.
        this.setId = function (el, newId, doNotSetAttribute) {
            //
            var id;

            if (_ju.isString(el)) {
                id = el;
            }
            else {
                el = this.getElement(el);
                id = this.getId(el);
            }

            var sConns = this.getConnections({source: id, scope: '*'}, true),
                tConns = this.getConnections({target: id, scope: '*'}, true);

            newId = "" + newId;

            if (!doNotSetAttribute) {
                el = this.getElement(id);
                this.setAttribute(el, "id", newId);
            }
            else {
                el = this.getElement(newId);
            }

            endpointsByElement[newId] = endpointsByElement[id] || [];
            for (var i = 0, ii = endpointsByElement[newId].length; i < ii; i++) {
                endpointsByElement[newId][i].setElementId(newId);
                endpointsByElement[newId][i].setReferenceElement(el);
            }
            delete endpointsByElement[id];

            this.sourceEndpointDefinitions[newId] = this.sourceEndpointDefinitions[id];
            delete this.sourceEndpointDefinitions[id];
            this.targetEndpointDefinitions[newId] = this.targetEndpointDefinitions[id];
            delete this.targetEndpointDefinitions[id];

            this.anchorManager.changeId(id, newId);
            var dm = this.getDragManager();
            if (dm) {
                dm.changeId(id, newId);
            }
            managedElements[newId] = managedElements[id];
            delete managedElements[id];

            var _conns = function (list, epIdx, type) {
                for (var i = 0, ii = list.length; i < ii; i++) {
                    list[i].endpoints[epIdx].setElementId(newId);
                    list[i].endpoints[epIdx].setReferenceElement(el);
                    list[i][type + "Id"] = newId;
                    list[i][type] = el;
                }
            };
            _conns(sConns, 0, "source");
            _conns(tConns, 1, "target");

            this.repaint(newId);
        };

        this.setDebugLog = function (debugLog) {
            log = debugLog;
        };

        this.setSuspendDrawing = function (val, repaintAfterwards) {
            var curVal = _suspendDrawing;
            _suspendDrawing = val;
            if (val) {
                _suspendedAt = new Date().getTime();
            } else {
                _suspendedAt = null;
            }
            if (repaintAfterwards) {
                this.repaintEverything();
            }
            return curVal;
        };

        // returns whether or not drawing is currently suspended.
        this.isSuspendDrawing = function () {
            return _suspendDrawing;
        };

        // return timestamp for when drawing was suspended.
        this.getSuspendedAt = function () {
            return _suspendedAt;
        };

        this.batch = function (fn, doNotRepaintAfterwards) {
            var _wasSuspended = this.isSuspendDrawing();
            if (!_wasSuspended) {
                this.setSuspendDrawing(true);
            }
            try {
                fn();
            }
            catch (e) {
                _ju.log("Function run while suspended failed", e);
            }
            if (!_wasSuspended) {
                this.setSuspendDrawing(false, !doNotRepaintAfterwards);
            }
        };

        this.doWhileSuspended = this.batch;

        this.getCachedData = _getCachedData;
        this.timestamp = _timestamp;
        this.show = function (el, changeEndpoints) {
            _setVisible(el, "block", changeEndpoints);
            return _currentInstance;
        };

        // TODO: update this method to return the current state.
        this.toggleVisible = _toggleVisible;
        this.toggleDraggable = _toggleDraggable;
        this.addListener = this.bind;
    };

    _ju.extend(root.jsPlumbInstance, _ju.EventGenerator, {
        setAttribute: function (el, a, v) {
            this.setAttribute(el, a, v);
        },
        getAttribute: function (el, a) {
            return this.getAttribute(root.jsPlumb.getElement(el), a);
        },
        convertToFullOverlaySpec: function(spec) {
            if (_ju.isString(spec)) {
                spec = [ spec, { } ];
            }
            spec[1].id = spec[1].id || _ju.uuid();
            return spec;
        },
        registerConnectionType: function (id, type) {
            this._connectionTypes[id] = root.jsPlumb.extend({}, type);
            if (type.overlays) {
                var to = {};
                for (var i = 0; i < type.overlays.length; i++) {
                    // if a string, convert to object representation so that we can store the typeid on it.
                    // also assign an id.
                    var fo = this.convertToFullOverlaySpec(type.overlays[i]);
                    to[fo[1].id] = fo;
                }
                this._connectionTypes[id].overlays = to;
            }
        },
        registerConnectionTypes: function (types) {
            for (var i in types) {
                this.registerConnectionType(i, types[i]);
            }
        },
        registerEndpointType: function (id, type) {
            this._endpointTypes[id] = root.jsPlumb.extend({}, type);
            if (type.overlays) {
                var to = {};
                for (var i = 0; i < type.overlays.length; i++) {
                    // if a string, convert to object representation so that we can store the typeid on it.
                    // also assign an id.
                    var fo = this.convertToFullOverlaySpec(type.overlays[i]);
                    to[fo[1].id] = fo;
                }
                this._endpointTypes[id].overlays = to;
            }
        },
        registerEndpointTypes: function (types) {
            for (var i in types) {
                this.registerEndpointType(i, types[i]);
            }
        },
        getType: function (id, typeDescriptor) {
            return typeDescriptor === "connection" ? this._connectionTypes[id] : this._endpointTypes[id];
        },
        setIdChanged: function (oldId, newId) {
            this.setId(oldId, newId, true);
        },
        // set parent: change the parent for some node and update all the registrations we need to.
        setParent: function (el, newParent) {
            var _dom = this.getElement(el),
                _id = this.getId(_dom),
                _pdom = this.getElement(newParent),
                _pid = this.getId(_pdom),
                dm = this.getDragManager();

            _dom.parentNode.removeChild(_dom);
            _pdom.appendChild(_dom);
            if (dm) {
                dm.setParent(_dom, _id, _pdom, _pid);
            }
        },
        extend: function (o1, o2, names) {
            var i;
            if (names) {
                for (i = 0; i < names.length; i++) {
                    o1[names[i]] = o2[names[i]];
                }
            }
            else {
                for (i in o2) {
                    o1[i] = o2[i];
                }
            }

            return o1;
        },
        floatingConnections: {},
        getFloatingAnchorIndex: function (jpc) {
            return jpc.endpoints[0].isFloating() ? 0 : jpc.endpoints[1].isFloating() ? 1 : -1;
        }
    });

    jsPlumbInstance.prototype.Defaults = {
        Anchor: "Bottom",
        Anchors: [ null, null ],
        ConnectionsDetachable: true,
        ConnectionOverlays: [ ],
        Connector: "Bezier",
        Container: null,
        DoNotThrowErrors: false,
        DragOptions: { },
        DropOptions: { },
        Endpoint: "Dot",
        EndpointOverlays: [ ],
        Endpoints: [ null, null ],
        EndpointStyle: { fill: "#456" },
        EndpointStyles: [ null, null ],
        EndpointHoverStyle: null,
        EndpointHoverStyles: [ null, null ],
        HoverPaintStyle: null,
        LabelStyle: { color: "black" },
        LogEnabled: false,
        Overlays: [ ],
        MaxConnections: 1,
        PaintStyle: { "stroke-width": 4, stroke: "#456" },
        ReattachConnections: false,
        RenderMode: "svg",
        Scope: "jsPlumb_DefaultScope"
    };

// --------------------- static instance + module registration -------------------------------------------

// create static instance and assign to window if window exists.	
    var jsPlumb = new jsPlumbInstance();
    // register on 'root' (lets us run on server or browser)
    root.jsPlumb = jsPlumb;
    // add 'getInstance' method to static instance
    jsPlumb.getInstance = function (_defaults, overrideFns) {
        var j = new jsPlumbInstance(_defaults);
        if (overrideFns) {
            for (var ovf in overrideFns) {
                j[ovf] = overrideFns[ovf];
            }
        }
        j.init();
        return j;
    };
    jsPlumb.each = function (spec, fn) {
        if (spec == null) {
            return;
        }
        if (typeof spec === "string") {
            fn(jsPlumb.getElement(spec));
        }
        else if (spec.length != null) {
            for (var i = 0; i < spec.length; i++) {
                fn(jsPlumb.getElement(spec[i]));
            }
        }
        else {
            fn(spec);
        } // assume it's an element.
    };

    // CommonJS
    if (true) {
        exports.jsPlumb = jsPlumb;
    }

// --------------------- end static instance + AMD registration -------------------------------------------		

}).call(typeof window !== 'undefined' ? window : this);

/*
 * jsPlumb Community Edition
 *
 * Provides a way to visually connect elements on an HTML page, using SVG.
 *
 * This file contains the base functionality for DOM type adapters.
 *
 * Copyright (c) 2010 - 2017 jsPlumb (hello@jsplumbtoolkit.com)
 *
 * https://jsplumbtoolkit.com
 * https://github.com/jsplumb/jsplumb
 *
 * Dual licensed under the MIT and GPL2 licenses.
 */
;
(function () {

    var root = this, _ju = root.jsPlumbUtil;

    var _genLoc = function (prefix, e) {
            if (e == null) {
                return [ 0, 0 ];
            }
            var ts = _touches(e), t = _getTouch(ts, 0);
            return [t[prefix + "X"], t[prefix + "Y"]];
        },
        _pageLocation = _genLoc.bind(this, "page"),
        _screenLocation = _genLoc.bind(this, "screen"),
        _clientLocation = _genLoc.bind(this, "client"),
        _getTouch = function (touches, idx) {
            return touches.item ? touches.item(idx) : touches[idx];
        },
        _touches = function (e) {
            return e.touches && e.touches.length > 0 ? e.touches :
                    e.changedTouches && e.changedTouches.length > 0 ? e.changedTouches :
                    e.targetTouches && e.targetTouches.length > 0 ? e.targetTouches :
                [ e ];
        };

    /**
     Manages dragging for some instance of jsPlumb.

     TODO instead of this being accessed directly, it should subscribe to events on the jsPlumb instance: every method
     in here is called directly by jsPlumb. But what should happen is that we have unpublished events that this listens
     to.  The only trick is getting one of these instantiated with every jsPlumb instance: it needs to have a hook somehow.
     Basically the general idea is to pull ALL the drag code out (prototype method registrations plus this) into a
     dedicated drag script), that does not necessarily need to be included.


     */
    var DragManager = function (_currentInstance) {
        var _draggables = {}, _dlist = [], _delements = {}, _elementsWithEndpoints = {},
        // elementids mapped to the draggable to which they belong.
            _draggablesForElements = {};

        /**
         register some element as draggable.  right now the drag init stuff is done elsewhere, and it is
         possible that will continue to be the case.
         */
        this.register = function (el) {
            var id = _currentInstance.getId(el),
                parentOffset = _currentInstance.getOffset(el);

            if (!_draggables[id]) {
                _draggables[id] = el;
                _dlist.push(el);
                _delements[id] = {};
            }

            // look for child elements that have endpoints and register them against this draggable.
            var _oneLevel = function (p) {
                if (p) {
                    for (var i = 0; i < p.childNodes.length; i++) {
                        if (p.childNodes[i].nodeType !== 3 && p.childNodes[i].nodeType !== 8) {
                            var cEl = jsPlumb.getElement(p.childNodes[i]),
                                cid = _currentInstance.getId(p.childNodes[i], null, true);
                            if (cid && _elementsWithEndpoints[cid] && _elementsWithEndpoints[cid] > 0) {
                                var cOff = _currentInstance.getOffset(cEl);
                                _delements[id][cid] = {
                                    id: cid,
                                    offset: {
                                        left: cOff.left - parentOffset.left,
                                        top: cOff.top - parentOffset.top
                                    }
                                };
                                _draggablesForElements[cid] = id;
                            }
                            _oneLevel(p.childNodes[i]);
                        }
                    }
                }
            };

            _oneLevel(el);
        };

        // refresh the offsets for child elements of this element.
        this.updateOffsets = function (elId, childOffsetOverrides) {
            if (elId != null) {
                childOffsetOverrides = childOffsetOverrides || {};
                var domEl = jsPlumb.getElement(elId),
                    id = _currentInstance.getId(domEl),
                    children = _delements[id],
                    parentOffset = _currentInstance.getOffset(domEl);

                if (children) {
                    for (var i in children) {
                        if (children.hasOwnProperty(i)) {
                            var cel = jsPlumb.getElement(i),
                                cOff = childOffsetOverrides[i] || _currentInstance.getOffset(cel);

                            // do not update if we have a value already and we'd just be writing 0,0
                            if (cel.offsetParent == null && _delements[id][i] != null) {
                                continue;
                            }

                            _delements[id][i] = {
                                id: i,
                                offset: {
                                    left: cOff.left - parentOffset.left,
                                    top: cOff.top - parentOffset.top
                                }
                            };
                            _draggablesForElements[i] = id;
                        }
                    }
                }
            }
        };

        /**
         notification that an endpoint was added to the given el.  we go up from that el's parent
         node, looking for a parent that has been registered as a draggable. if we find one, we add this
         el to that parent's list of elements to update on drag (if it is not there already)
         */
        this.endpointAdded = function (el, id) {

            id = id || _currentInstance.getId(el);

            var b = document.body,
                p = el.parentNode;

            _elementsWithEndpoints[id] = _elementsWithEndpoints[id] ? _elementsWithEndpoints[id] + 1 : 1;

            while (p != null && p !== b) {
                var pid = _currentInstance.getId(p, null, true);
                if (pid && _draggables[pid]) {
                    var pLoc = _currentInstance.getOffset(p);

                    if (_delements[pid][id] == null) {
                        var cLoc = _currentInstance.getOffset(el);
                        _delements[pid][id] = {
                            id: id,
                            offset: {
                                left: cLoc.left - pLoc.left,
                                top: cLoc.top - pLoc.top
                            }
                        };
                        _draggablesForElements[id] = pid;
                    }
                    break;
                }
                p = p.parentNode;
            }
        };

        this.endpointDeleted = function (endpoint) {
            if (_elementsWithEndpoints[endpoint.elementId]) {
                _elementsWithEndpoints[endpoint.elementId]--;
                if (_elementsWithEndpoints[endpoint.elementId] <= 0) {
                    for (var i in _delements) {
                        if (_delements.hasOwnProperty(i) && _delements[i]) {
                            delete _delements[i][endpoint.elementId];
                            delete _draggablesForElements[endpoint.elementId];
                        }
                    }
                }
            }
        };

        this.changeId = function (oldId, newId) {
            _delements[newId] = _delements[oldId];
            _delements[oldId] = {};
            _draggablesForElements[newId] = _draggablesForElements[oldId];
            _draggablesForElements[oldId] = null;
        };

        this.getElementsForDraggable = function (id) {
            return _delements[id];
        };

        this.elementRemoved = function (elementId) {
            var elId = _draggablesForElements[elementId];
            if (elId) {
                delete _delements[elId][elementId];
                delete _draggablesForElements[elementId];
            }
        };

        this.reset = function () {
            _draggables = {};
            _dlist = [];
            _delements = {};
            _elementsWithEndpoints = {};
        };

        //
        // notification drag ended. We check automatically if need to update some
        // ancestor's offsets.
        //
        this.dragEnded = function (el) {
            if (el.offsetParent != null) {
                var id = _currentInstance.getId(el),
                    ancestor = _draggablesForElements[id];

                if (ancestor) {
                    this.updateOffsets(ancestor);
                }
            }
        };

        this.setParent = function (el, elId, p, pId, currentChildLocation) {
            var current = _draggablesForElements[elId];
            if (!_delements[pId]) {
                _delements[pId] = {};
            }
            var pLoc = _currentInstance.getOffset(p),
                cLoc = currentChildLocation || _currentInstance.getOffset(el);

            if (current && _delements[current]) {
                delete _delements[current][elId];
            }

            _delements[pId][elId] = {
                id:elId,
                offset : {
                    left: cLoc.left - pLoc.left,
                    top: cLoc.top - pLoc.top
                }
            };
            _draggablesForElements[elId] = pId;
        };

        this.clearParent = function(el, elId) {
            var current = _draggablesForElements[elId];
            if (current) {
                delete _delements[current][elId];
                delete _draggablesForElements[elId];
            }
        };

        this.revalidateParent = function(el, elId, childOffset) {
            var current = _draggablesForElements[elId];
            if (current) {
                var co = {};
                co[elId] = childOffset;
                this.updateOffsets(current, co);
                _currentInstance.revalidate(current);
            }
        };

        this.getDragAncestor = function (el) {
            var de = jsPlumb.getElement(el),
                id = _currentInstance.getId(de),
                aid = _draggablesForElements[id];

            if (aid) {
                return jsPlumb.getElement(aid);
            }
            else {
                return null;
            }
        };

    };

    var trim = function (str) {
            return str == null ? null : (str.replace(/^\s\s*/, '').replace(/\s\s*$/, ''));
        },
        _setClassName = function (el, cn) {
            cn = trim(cn);
            if (typeof el.className.baseVal !== "undefined") {
                el.className.baseVal = cn;
            }
            else {
                el.className = cn;
            }
        },
        _getClassName = function (el) {
            return (typeof el.className.baseVal === "undefined") ? el.className : el.className.baseVal;
        },
        _classManip = function (el, classesToAdd, classesToRemove) {
            classesToAdd = classesToAdd == null ? [] : _ju.isArray(classesToAdd) ? classesToAdd : classesToAdd.split(/\s+/);
            classesToRemove = classesToRemove == null ? [] : _ju.isArray(classesToRemove) ? classesToRemove : classesToRemove.split(/\s+/);

            var className = _getClassName(el),
                curClasses = className.split(/\s+/);

            var _oneSet = function (add, classes) {
                for (var i = 0; i < classes.length; i++) {
                    if (add) {
                        if (curClasses.indexOf(classes[i]) === -1) {
                            curClasses.push(classes[i]);
                        }
                    }
                    else {
                        var idx = curClasses.indexOf(classes[i]);
                        if (idx !== -1) {
                            curClasses.splice(idx, 1);
                        }
                    }
                }
            };

            _oneSet(true, classesToAdd);
            _oneSet(false, classesToRemove);

            _setClassName(el, curClasses.join(" "));
        };

    root.jsPlumb.extend(root.jsPlumbInstance.prototype, {

        headless: false,

        pageLocation: _pageLocation,
        screenLocation: _screenLocation,
        clientLocation: _clientLocation,

        getDragManager:function() {
            if (this.dragManager == null) {
                this.dragManager = new DragManager(this);
            }

            return this.dragManager;
        },

        recalculateOffsets:function(elId) {
            this.getDragManager().updateOffsets(elId);
        },

        createElement:function(tag, style, clazz, atts) {
            return this.createElementNS(null, tag, style, clazz, atts);
        },

        createElementNS:function(ns, tag, style, clazz, atts) {
            var e = ns == null ? document.createElement(tag) : document.createElementNS(ns, tag);
            var i;
            style = style || {};
            for (i in style) {
                e.style[i] = style[i];
            }

            if (clazz) {
                e.className = clazz;
            }

            atts = atts || {};
            for (i in atts) {
                e.setAttribute(i, "" + atts[i]);
            }

            return e;
        },

        getAttribute: function (el, attName) {
            return el.getAttribute != null ? el.getAttribute(attName) : null;
        },

        setAttribute: function (el, a, v) {
            if (el.setAttribute != null) {
                el.setAttribute(a, v);
            }
        },

        setAttributes: function (el, atts) {
            for (var i in atts) {
                if (atts.hasOwnProperty(i)) {
                    el.setAttribute(i, atts[i]);
                }
            }
        },
        appendToRoot: function (node) {
            document.body.appendChild(node);
        },
        getRenderModes: function () {
            return [ "svg"  ];
        },
        getClass:_getClassName,
        addClass: function (el, clazz) {
            jsPlumb.each(el, function (e) {
                _classManip(e, clazz);
            });
        },
        hasClass: function (el, clazz) {
            el = jsPlumb.getElement(el);
            if (el.classList) {
                return el.classList.contains(clazz);
            }
            else {
                return _getClassName(el).indexOf(clazz) !== -1;
            }
        },
        removeClass: function (el, clazz) {
            jsPlumb.each(el, function (e) {
                _classManip(e, null, clazz);
            });
        },
        updateClasses: function (el, toAdd, toRemove) {
            jsPlumb.each(el, function (e) {
                _classManip(e, toAdd, toRemove);
            });
        },
        setClass: function (el, clazz) {
            jsPlumb.each(el, function (e) {
                _setClassName(e, clazz);
            });
        },
        setPosition: function (el, p) {
            el.style.left = p.left + "px";
            el.style.top = p.top + "px";
        },
        getPosition: function (el) {
            var _one = function (prop) {
                var v = el.style[prop];
                return v ? v.substring(0, v.length - 2) : 0;
            };
            return {
                left: _one("left"),
                top: _one("top")
            };
        },
        getStyle:function(el, prop) {
            if (typeof window.getComputedStyle !== 'undefined') {
                return getComputedStyle(el, null).getPropertyValue(prop);
            } else {
                return el.currentStyle[prop];
            }
        },
        getSelector: function (ctx, spec) {
            var sel = null;
            if (arguments.length === 1) {
                sel = ctx.nodeType != null ? ctx : document.querySelectorAll(ctx);
            }
            else {
                sel = ctx.querySelectorAll(spec);
            }

            return sel;
        },
        getOffset:function(el, relativeToRoot, container) {
            el = jsPlumb.getElement(el);
            container = container || this.getContainer();
            var out = {
                    left: el.offsetLeft,
                    top: el.offsetTop
                },
                op = (relativeToRoot  || (container != null && (el !== container && el.offsetParent !== container))) ?  el.offsetParent : null,
                _maybeAdjustScroll = function(offsetParent) {
                    if (offsetParent != null && offsetParent !== document.body && (offsetParent.scrollTop > 0 || offsetParent.scrollLeft > 0)) {
                        out.left -= offsetParent.scrollLeft;
                        out.top -= offsetParent.scrollTop;
                    }
                }.bind(this);

            while (op != null) {
                out.left += op.offsetLeft;
                out.top += op.offsetTop;
                _maybeAdjustScroll(op);
                op = relativeToRoot ? op.offsetParent :
                        op.offsetParent === container ? null : op.offsetParent;
            }

            // if container is scrolled and the element (or its offset parent) is not absolute or fixed, adjust accordingly.
            if (container != null && !relativeToRoot && (container.scrollTop > 0 || container.scrollLeft > 0)) {
                var pp = el.offsetParent != null ? this.getStyle(el.offsetParent, "position") : "static",
                    p = this.getStyle(el, "position");
                if (p !== "absolute" && p !== "fixed" && pp !== "absolute" && pp !== "fixed") {
                    out.left -= container.scrollLeft;
                    out.top -= container.scrollTop;
                }
            }
            return out;
        },
        //
        // return x+y proportion of the given element's size corresponding to the location of the given event.
        //
        getPositionOnElement: function (evt, el, zoom) {
            var box = typeof el.getBoundingClientRect !== "undefined" ? el.getBoundingClientRect() : { left: 0, top: 0, width: 0, height: 0 },
                body = document.body,
                docElem = document.documentElement,
                scrollTop = window.pageYOffset || docElem.scrollTop || body.scrollTop,
                scrollLeft = window.pageXOffset || docElem.scrollLeft || body.scrollLeft,
                clientTop = docElem.clientTop || body.clientTop || 0,
                clientLeft = docElem.clientLeft || body.clientLeft || 0,
                pst = 0,
                psl = 0,
                top = box.top + scrollTop - clientTop + (pst * zoom),
                left = box.left + scrollLeft - clientLeft + (psl * zoom),
                cl = jsPlumb.pageLocation(evt),
                w = box.width || (el.offsetWidth * zoom),
                h = box.height || (el.offsetHeight * zoom),
                x = (cl[0] - left) / w,
                y = (cl[1] - top) / h;

            return [ x, y ];
        },

        /**
         * Gets the absolute position of some element as read from the left/top properties in its style.
         * @method getAbsolutePosition
         * @param {Element} el The element to retrieve the absolute coordinates from. **Note** this is a DOM element, not a selector from the underlying library.
         * @return {Number[]} [left, top] pixel values.
         */
        getAbsolutePosition: function (el) {
            var _one = function (s) {
                var ss = el.style[s];
                if (ss) {
                    return parseFloat(ss.substring(0, ss.length - 2));
                }
            };
            return [ _one("left"), _one("top") ];
        },

        /**
         * Sets the absolute position of some element by setting the left/top properties in its style.
         * @method setAbsolutePosition
         * @param {Element} el The element to set the absolute coordinates on. **Note** this is a DOM element, not a selector from the underlying library.
         * @param {Number[]} xy x and y coordinates
         * @param {Number[]} [animateFrom] Optional previous xy to animate from.
         * @param {Object} [animateOptions] Options for the animation.
         */
        setAbsolutePosition: function (el, xy, animateFrom, animateOptions) {
            if (animateFrom) {
                this.animate(el, {
                    left: "+=" + (xy[0] - animateFrom[0]),
                    top: "+=" + (xy[1] - animateFrom[1])
                }, animateOptions);
            }
            else {
                el.style.left = xy[0] + "px";
                el.style.top = xy[1] + "px";
            }
        },
        /**
         * gets the size for the element, in an array : [ width, height ].
         */
        getSize: function (el) {
            return [ el.offsetWidth, el.offsetHeight ];
        },
        getWidth: function (el) {
            return el.offsetWidth;
        },
        getHeight: function (el) {
            return el.offsetHeight;
        },
        getRenderMode : function() { return "svg"; }

    });
}).call(typeof window !== 'undefined' ? window : this);

/*
 * jsPlumb Community Edition
 *
 * Provides a way to visually connect elements on an HTML page, using SVG.
 *
 * This file contains code for components that support overlays.
 *
 * Copyright (c) 2010 - 2017 jsPlumb (hello@jsplumbtoolkit.com)
 *
 * https://jsplumbtoolkit.com
 * https://github.com/jsplumb/jsplumb
 *
 * Dual licensed under the MIT and GPL2 licenses.
 */
;(function() {

    "use strict";
    var root = this, _jp = root.jsPlumb, _ju = root.jsPlumbUtil;

    // ------------------------------ BEGIN OverlayCapablejsPlumbUIComponent --------------------------------------------

    var _internalLabelOverlayId = "__label",
    // this is a shortcut helper method to let people add a label as
    // overlay.
        _makeLabelOverlay = function (component, params) {

            var _params = {
                    cssClass: params.cssClass,
                    labelStyle: component.labelStyle,
                    id: _internalLabelOverlayId,
                    component: component,
                    _jsPlumb: component._jsPlumb.instance  // TODO not necessary, since the instance can be accessed through the component.
                },
                mergedParams = _jp.extend(_params, params);

            return new _jp.Overlays[component._jsPlumb.instance.getRenderMode()].Label(mergedParams);
        },
        _processOverlay = function (component, o) {
            var _newOverlay = null;
            if (_ju.isArray(o)) {	// this is for the shorthand ["Arrow", { width:50 }] syntax
                // there's also a three arg version:
                // ["Arrow", { width:50 }, {location:0.7}]
                // which merges the 3rd arg into the 2nd.
                var type = o[0],
                // make a copy of the object so as not to mess up anyone else's reference...
                    p = _jp.extend({component: component, _jsPlumb: component._jsPlumb.instance}, o[1]);
                if (o.length === 3) {
                    _jp.extend(p, o[2]);
                }
                _newOverlay = new _jp.Overlays[component._jsPlumb.instance.getRenderMode()][type](p);
            } else if (o.constructor === String) {
                _newOverlay = new _jp.Overlays[component._jsPlumb.instance.getRenderMode()][o]({component: component, _jsPlumb: component._jsPlumb.instance});
            } else {
                _newOverlay = o;
            }

            _newOverlay.id = _newOverlay.id || _ju.uuid();
            component.cacheTypeItem("overlay", _newOverlay, _newOverlay.id);
            component._jsPlumb.overlays[_newOverlay.id] = _newOverlay;

            return _newOverlay;
        };

    _jp.OverlayCapableJsPlumbUIComponent = function (params) {

        root.jsPlumbUIComponent.apply(this, arguments);
        this._jsPlumb.overlays = {};
        this._jsPlumb.overlayPositions = {};

        if (params.label) {
            this.getDefaultType().overlays[_internalLabelOverlayId] = ["Label", {
                label: params.label,
                location: params.labelLocation || this.defaultLabelLocation || 0.5,
                labelStyle: params.labelStyle || this._jsPlumb.instance.Defaults.LabelStyle,
                id:_internalLabelOverlayId
            }];
        }

        this.setListenerComponent = function (c) {
            if (this._jsPlumb) {
                for (var i in this._jsPlumb.overlays) {
                    this._jsPlumb.overlays[i].setListenerComponent(c);
                }
            }
        };
    };

    _jp.OverlayCapableJsPlumbUIComponent.applyType = function (component, t) {
        if (t.overlays) {
            // loop through the ones in the type. if already present on the component,
            // dont remove or re-add.
            var keep = {}, i;

            for (i in t.overlays) {

                var existing = component._jsPlumb.overlays[t.overlays[i][1].id];
                if (existing) {
                    // maybe update from data, if there were parameterised values for instance.
                    existing.updateFrom(t.overlays[i][1]);
                    keep[t.overlays[i][1].id] = true;
                }
                else {
                    var c = component.getCachedTypeItem("overlay", t.overlays[i][1].id);
                    if (c != null) {
                        c.reattach(component._jsPlumb.instance, component);
                        c.setVisible(true);
                        // maybe update from data, if there were parameterised values for instance.
                        c.updateFrom(t.overlays[i][1]);
                        component._jsPlumb.overlays[c.id] = c;
                    }
                    else {
                        c = component.addOverlay(t.overlays[i], true);
                    }
                    keep[c.id] = true;
                }
            }

            // now loop through the full overlays and remove those that we dont want to keep
            for (i in component._jsPlumb.overlays) {
                if (keep[component._jsPlumb.overlays[i].id] == null) {
                    component.removeOverlay(component._jsPlumb.overlays[i].id, true); // remove overlay but dont clean it up.
                    // that would remove event listeners etc; overlays are never discarded by the types stuff, they are
                    // just detached/reattached.
                }
            }
        }
    };

    _ju.extend(_jp.OverlayCapableJsPlumbUIComponent, root.jsPlumbUIComponent, {

        setHover: function (hover, ignoreAttachedElements) {
            if (this._jsPlumb && !this._jsPlumb.instance.isConnectionBeingDragged()) {
                for (var i in this._jsPlumb.overlays) {
                    this._jsPlumb.overlays[i][hover ? "addClass" : "removeClass"](this._jsPlumb.instance.hoverClass);
                }
            }
        },
        addOverlay: function (overlay, doNotRepaint) {
            var o = _processOverlay(this, overlay);
            if (!doNotRepaint) {
                this.repaint();
            }
            return o;
        },
        getOverlay: function (id) {
            return this._jsPlumb.overlays[id];
        },
        getOverlays: function () {
            return this._jsPlumb.overlays;
        },
        hideOverlay: function (id) {
            var o = this.getOverlay(id);
            if (o) {
                o.hide();
            }
        },
        hideOverlays: function () {
            for (var i in this._jsPlumb.overlays) {
                this._jsPlumb.overlays[i].hide();
            }
        },
        showOverlay: function (id) {
            var o = this.getOverlay(id);
            if (o) {
                o.show();
            }
        },
        showOverlays: function () {
            for (var i in this._jsPlumb.overlays) {
                this._jsPlumb.overlays[i].show();
            }
        },
        removeAllOverlays: function (doNotRepaint) {
            for (var i in this._jsPlumb.overlays) {
                if (this._jsPlumb.overlays[i].cleanup) {
                    this._jsPlumb.overlays[i].cleanup();
                }
            }

            this._jsPlumb.overlays = {};
            this._jsPlumb.overlayPositions = null;
            if (!doNotRepaint) {
                this.repaint();
            }
        },
        removeOverlay: function (overlayId, dontCleanup) {
            var o = this._jsPlumb.overlays[overlayId];
            if (o) {
                o.setVisible(false);
                if (!dontCleanup && o.cleanup) {
                    o.cleanup();
                }
                delete this._jsPlumb.overlays[overlayId];
                if (this._jsPlumb.overlayPositions) {
                    delete this._jsPlumb.overlayPositions[overlayId];
                }
            }
        },
        removeOverlays: function () {
            for (var i = 0, j = arguments.length; i < j; i++) {
                this.removeOverlay(arguments[i]);
            }
        },
        moveParent: function (newParent) {
            if (this.bgCanvas) {
                this.bgCanvas.parentNode.removeChild(this.bgCanvas);
                newParent.appendChild(this.bgCanvas);
            }

            if (this.canvas && this.canvas.parentNode) {
                this.canvas.parentNode.removeChild(this.canvas);
                newParent.appendChild(this.canvas);

                for (var i in this._jsPlumb.overlays) {
                    if (this._jsPlumb.overlays[i].isAppendedAtTopLevel) {
                        var el = this._jsPlumb.overlays[i].getElement();
                        el.parentNode.removeChild(el);
                        newParent.appendChild(el);
                    }
                }
            }
        },
        getLabel: function () {
            var lo = this.getOverlay(_internalLabelOverlayId);
            return lo != null ? lo.getLabel() : null;
        },
        getLabelOverlay: function () {
            return this.getOverlay(_internalLabelOverlayId);
        },
        setLabel: function (l) {
            var lo = this.getOverlay(_internalLabelOverlayId);
            if (!lo) {
                var params = l.constructor === String || l.constructor === Function ? { label: l } : l;
                lo = _makeLabelOverlay(this, params);
                this._jsPlumb.overlays[_internalLabelOverlayId] = lo;
            }
            else {
                if (l.constructor === String || l.constructor === Function) {
                    lo.setLabel(l);
                }
                else {
                    if (l.label) {
                        lo.setLabel(l.label);
                    }
                    if (l.location) {
                        lo.setLocation(l.location);
                    }
                }
            }

            if (!this._jsPlumb.instance.isSuspendDrawing()) {
                this.repaint();
            }
        },
        cleanup: function (force) {
            for (var i in this._jsPlumb.overlays) {
                this._jsPlumb.overlays[i].cleanup(force);
                this._jsPlumb.overlays[i].destroy(force);
            }
            if (force) {
                this._jsPlumb.overlays = {};
                this._jsPlumb.overlayPositions = null;
            }
        },
        setVisible: function (v) {
            this[v ? "showOverlays" : "hideOverlays"]();
        },
        setAbsoluteOverlayPosition: function (overlay, xy) {
            this._jsPlumb.overlayPositions[overlay.id] = xy;
        },
        getAbsoluteOverlayPosition: function (overlay) {
            return this._jsPlumb.overlayPositions ? this._jsPlumb.overlayPositions[overlay.id] : null;
        },
        _clazzManip:function(action, clazz, dontUpdateOverlays) {
            if (!dontUpdateOverlays) {
                for (var i in this._jsPlumb.overlays) {
                    this._jsPlumb.overlays[i][action + "Class"](clazz);
                }
            }
        },
        addClass:function(clazz, dontUpdateOverlays) {
            this._clazzManip("add", clazz, dontUpdateOverlays);
        },
        removeClass:function(clazz, dontUpdateOverlays) {
            this._clazzManip("remove", clazz, dontUpdateOverlays);
        }
    });

// ------------------------------ END OverlayCapablejsPlumbUIComponent --------------------------------------------

}).call(typeof window !== 'undefined' ? window : this);

/*
 * jsPlumb Community Edition
 * 
 * Provides a way to visually connect elements on an HTML page, using SVG.
 * 
 * This file contains the code for Endpoints.
 *
 * Copyright (c) 2010 - 2017 jsPlumb (hello@jsplumbtoolkit.com)
 * 
 * https://jsplumbtoolkit.com
 * https://github.com/jsplumb/jsplumb
 * 
 * Dual licensed under the MIT and GPL2 licenses.
 */
(function () {

    "use strict";
    var root = this, _jp = root.jsPlumb, _ju = root.jsPlumbUtil;

    // create the drag handler for a connection
    var _makeConnectionDragHandler = function (endpoint, placeholder, _jsPlumb) {
        var stopped = false;
        return {
            drag: function () {
                if (stopped) {
                    stopped = false;
                    return true;
                }

                if (placeholder.element) {
                    var _ui = _jsPlumb.getUIPosition(arguments, _jsPlumb.getZoom());
                    if (_ui != null) {
                        _jsPlumb.setPosition(placeholder.element, _ui);
                    }
                    _jsPlumb.repaint(placeholder.element, _ui);
                    // always repaint the source endpoint, because only continuous/dynamic anchors cause the endpoint
                    // to be repainted, so static anchors need to be told (or the endpoint gets dragged around)
                    endpoint.paint({anchorPoint:endpoint.anchor.getCurrentLocation({element:endpoint})});
                }
            },
            stopDrag: function () {
                stopped = true;
            }
        };
    };

    // creates a placeholder div for dragging purposes, adds it, and pre-computes its offset.
    var _makeDraggablePlaceholder = function (placeholder, _jsPlumb, ipco, ips) {
        var n = _jsPlumb.createElement("div", { position : "absolute" });
        _jsPlumb.appendElement(n);
        var id = _jsPlumb.getId(n);
        _jsPlumb.setPosition(n, ipco);
        n.style.width = ips[0] + "px";
        n.style.height = ips[1] + "px";
        _jsPlumb.manage(id, n, true); // TRANSIENT MANAGE
        // create and assign an id, and initialize the offset.
        placeholder.id = id;
        placeholder.element = n;
    };

    // create a floating endpoint (for drag connections)
    var _makeFloatingEndpoint = function (paintStyle, referenceAnchor, endpoint, referenceCanvas, sourceElement, _jsPlumb, _newEndpoint, scope) {
        var floatingAnchor = new _jp.FloatingAnchor({ reference: referenceAnchor, referenceCanvas: referenceCanvas, jsPlumbInstance: _jsPlumb });
        //setting the scope here should not be the way to fix that mootools issue.  it should be fixed by not
        // adding the floating endpoint as a droppable.  that makes more sense anyway!
        // TRANSIENT MANAGE
        return _newEndpoint({
            paintStyle: paintStyle,
            endpoint: endpoint,
            anchor: floatingAnchor,
            source: sourceElement,
            scope: scope
        });
    };

    var typeParameters = [ "connectorStyle", "connectorHoverStyle", "connectorOverlays",
        "connector", "connectionType", "connectorClass", "connectorHoverClass" ];

    // a helper function that tries to find a connection to the given element, and returns it if so. if elementWithPrecedence is null,
    // or no connection to it is found, we return the first connection in our list.
    var findConnectionToUseForDynamicAnchor = function (ep, elementWithPrecedence) {
        var idx = 0;
        if (elementWithPrecedence != null) {
            for (var i = 0; i < ep.connections.length; i++) {
                if (ep.connections[i].sourceId === elementWithPrecedence || ep.connections[i].targetId === elementWithPrecedence) {
                    idx = i;
                    break;
                }
            }
        }

        return ep.connections[idx];
    };

    _jp.Endpoint = function (params) {
        var _jsPlumb = params._jsPlumb,
            _newConnection = params.newConnection,
            _newEndpoint = params.newEndpoint;

        this.idPrefix = "_jsplumb_e_";
        this.defaultLabelLocation = [ 0.5, 0.5 ];
        this.defaultOverlayKeys = ["Overlays", "EndpointOverlays"];
        _jp.OverlayCapableJsPlumbUIComponent.apply(this, arguments);

// TYPE

        this.appendToDefaultType({
            connectionType:params.connectionType,
            maxConnections: params.maxConnections == null ? this._jsPlumb.instance.Defaults.MaxConnections : params.maxConnections, // maximum number of connections this endpoint can be the source of.,
            paintStyle: params.endpointStyle || params.paintStyle || params.style || this._jsPlumb.instance.Defaults.EndpointStyle || _jp.Defaults.EndpointStyle,
            hoverPaintStyle: params.endpointHoverStyle || params.hoverPaintStyle || this._jsPlumb.instance.Defaults.EndpointHoverStyle || _jp.Defaults.EndpointHoverStyle,
            connectorStyle: params.connectorStyle,
            connectorHoverStyle: params.connectorHoverStyle,
            connectorClass: params.connectorClass,
            connectorHoverClass: params.connectorHoverClass,
            connectorOverlays: params.connectorOverlays,
            connector: params.connector,
            connectorTooltip: params.connectorTooltip
        });

// END TYPE

        this._jsPlumb.enabled = !(params.enabled === false);
        this._jsPlumb.visible = true;
        this.element = _jp.getElement(params.source);
        this._jsPlumb.uuid = params.uuid;
        this._jsPlumb.floatingEndpoint = null;
        var inPlaceCopy = null;
        if (this._jsPlumb.uuid) {
            params.endpointsByUUID[this._jsPlumb.uuid] = this;
        }
        this.elementId = params.elementId;
        this.dragProxy = params.dragProxy;

        this._jsPlumb.connectionCost = params.connectionCost;
        this._jsPlumb.connectionsDirected = params.connectionsDirected;
        this._jsPlumb.currentAnchorClass = "";
        this._jsPlumb.events = {};

        var deleteOnEmpty = params.deleteOnEmpty === true;
        this.setDeleteOnEmpty = function(d) {
            deleteOnEmpty = d;
        };

        var _updateAnchorClass = function () {
            // stash old, get new
            var oldAnchorClass = _jsPlumb.endpointAnchorClassPrefix + "-" + this._jsPlumb.currentAnchorClass;
            this._jsPlumb.currentAnchorClass = this.anchor.getCssClass();
            var anchorClass = _jsPlumb.endpointAnchorClassPrefix + (this._jsPlumb.currentAnchorClass ? "-" + this._jsPlumb.currentAnchorClass : "");

            this.removeClass(oldAnchorClass);
            this.addClass(anchorClass);
            // add and remove at the same time to reduce the number of reflows.
            _jp.updateClasses(this.element, anchorClass, oldAnchorClass);
        }.bind(this);

        this.prepareAnchor = function(anchorParams) {
            var a = this._jsPlumb.instance.makeAnchor(anchorParams, this.elementId, _jsPlumb);
            a.bind("anchorChanged", function (currentAnchor) {
                this.fire("anchorChanged", {endpoint: this, anchor: currentAnchor});
                _updateAnchorClass();
            }.bind(this));
            return a;
        };

        this.setPreparedAnchor = function(anchor, doNotRepaint) {
            this._jsPlumb.instance.continuousAnchorFactory.clear(this.elementId);
            this.anchor = anchor;
            _updateAnchorClass();

            if (!doNotRepaint) {
                this._jsPlumb.instance.repaint(this.elementId);
            }

            return this;
        };

        this.setAnchor = function (anchorParams, doNotRepaint) {
            var a = this.prepareAnchor(anchorParams);
            this.setPreparedAnchor(a, doNotRepaint);
            return this;
        };

        var internalHover = function (state) {
            if (this.connections.length > 0) {
                for (var i = 0; i < this.connections.length; i++) {
                    this.connections[i].setHover(state, false);
                }
            }
            else {
                this.setHover(state);
            }
        }.bind(this);

        this.bind("mouseover", function () {
            internalHover(true);
        });
        this.bind("mouseout", function () {
            internalHover(false);
        });

        // ANCHOR MANAGER
        if (!params._transient) { // in place copies, for example, are transient.  they will never need to be retrieved during a paint cycle, because they dont move, and then they are deleted.
            this._jsPlumb.instance.anchorManager.add(this, this.elementId);
        }

        this.prepareEndpoint = function(ep, typeId) {
            var _e = function (t, p) {
                var rm = _jsPlumb.getRenderMode();
                if (_jp.Endpoints[rm][t]) {
                    return new _jp.Endpoints[rm][t](p);
                }
                if (!_jsPlumb.Defaults.DoNotThrowErrors) {
                    throw { msg: "jsPlumb: unknown endpoint type '" + t + "'" };
                }
            };

            var endpointArgs = {
                _jsPlumb: this._jsPlumb.instance,
                cssClass: params.cssClass,
                container: params.container,
                tooltip: params.tooltip,
                connectorTooltip: params.connectorTooltip,
                endpoint: this
            };

            var endpoint;

            if (_ju.isString(ep)) {
                endpoint = _e(ep, endpointArgs);
            }
            else if (_ju.isArray(ep)) {
                endpointArgs = _ju.merge(ep[1], endpointArgs);
                endpoint = _e(ep[0], endpointArgs);
            }
            else {
                endpoint = ep.clone();
            }

            // assign a clone function using a copy of endpointArgs. this is used when a drag starts: the endpoint that was dragged is cloned,
            // and the clone is left in its place while the original one goes off on a magical journey.
            // the copy is to get around a closure problem, in which endpointArgs ends up getting shared by
            // the whole world.
            //var argsForClone = jsPlumb.extend({}, endpointArgs);
            endpoint.clone = function () {
                // TODO this, and the code above, can be refactored to be more dry.
                if (_ju.isString(ep)) {
                    return _e(ep, endpointArgs);
                }
                else if (_ju.isArray(ep)) {
                    endpointArgs = _ju.merge(ep[1], endpointArgs);
                    return _e(ep[0], endpointArgs);
                }
            }.bind(this);

            endpoint.typeId = typeId;
            return endpoint;
        };

        this.setEndpoint = function(ep, doNotRepaint) {
            var _ep = this.prepareEndpoint(ep);
            this.setPreparedEndpoint(_ep, true);
        };

        this.setPreparedEndpoint = function (ep, doNotRepaint) {
            if (this.endpoint != null) {
                this.endpoint.cleanup();
                this.endpoint.destroy();
            }
            this.endpoint = ep;
            this.type = this.endpoint.type;
            this.canvas = this.endpoint.canvas;
        };

        _jp.extend(this, params, typeParameters);

        this.isSource = params.isSource || false;
        this.isTemporarySource = params.isTemporarySource || false;
        this.isTarget = params.isTarget || false;

        this.connections = params.connections || [];
        this.connectorPointerEvents = params["connector-pointer-events"];

        this.scope = params.scope || _jsPlumb.getDefaultScope();
        this.timestamp = null;
        this.reattachConnections = params.reattach || _jsPlumb.Defaults.ReattachConnections;
        this.connectionsDetachable = _jsPlumb.Defaults.ConnectionsDetachable;
        if (params.connectionsDetachable === false || params.detachable === false) {
            this.connectionsDetachable = false;
        }
        this.dragAllowedWhenFull = params.dragAllowedWhenFull !== false;

        if (params.onMaxConnections) {
            this.bind("maxConnections", params.onMaxConnections);
        }

        //
        // add a connection. not part of public API.
        //
        this.addConnection = function (connection) {
            this.connections.push(connection);
            this[(this.connections.length > 0 ? "add" : "remove") + "Class"](_jsPlumb.endpointConnectedClass);
            this[(this.isFull() ? "add" : "remove") + "Class"](_jsPlumb.endpointFullClass);
        };

        this.detachFromConnection = function (connection, idx, doNotCleanup) {
            idx = idx == null ? this.connections.indexOf(connection) : idx;
            if (idx >= 0) {
                this.connections.splice(idx, 1);
                this[(this.connections.length > 0 ? "add" : "remove") + "Class"](_jsPlumb.endpointConnectedClass);
                this[(this.isFull() ? "add" : "remove") + "Class"](_jsPlumb.endpointFullClass);
            }

            if (!doNotCleanup && deleteOnEmpty && this.connections.length === 0) {
                _jsPlumb.deleteObject({
                    endpoint: this,
                    fireEvent: false,
                    deleteAttachedObjects: doNotCleanup !== true
                });
            }
        };

        this.deleteEveryConnection = function(params) {
            var c = this.connections.length;
            for (var i = 0; i < c; i++) {
                _jsPlumb.deleteConnection(this.connections[0], params);
            }
        };

        this.detachFrom = function (targetEndpoint, fireEvent, originalEvent) {
            var c = [];
            for (var i = 0; i < this.connections.length; i++) {
                if (this.connections[i].endpoints[1] === targetEndpoint || this.connections[i].endpoints[0] === targetEndpoint) {
                    c.push(this.connections[i]);
                }
            }
            for (var j = 0, count = c.length; j < count; j++) {
                _jsPlumb.deleteConnection(c[0]);
            }
            return this;
        };

        this.getElement = function () {
            return this.element;
        };

        this.setElement = function (el) {
            var parentId = this._jsPlumb.instance.getId(el),
                curId = this.elementId;
            // remove the endpoint from the list for the current endpoint's element
            _ju.removeWithFunction(params.endpointsByElement[this.elementId], function (e) {
                return e.id === this.id;
            }.bind(this));
            this.element = _jp.getElement(el);
            this.elementId = _jsPlumb.getId(this.element);
            _jsPlumb.anchorManager.rehomeEndpoint(this, curId, this.element);
            _jsPlumb.dragManager.endpointAdded(this.element);
            _ju.addToList(params.endpointsByElement, parentId, this);
            return this;
        };

        /**
         * private but must be exposed.
         */
        this.makeInPlaceCopy = function () {
            var loc = this.anchor.getCurrentLocation({element: this}),
                o = this.anchor.getOrientation(this),
                acc = this.anchor.getCssClass(),
                inPlaceAnchor = {
                    bind: function () {
                    },
                    compute: function () {
                        return [ loc[0], loc[1] ];
                    },
                    getCurrentLocation: function () {
                        return [ loc[0], loc[1] ];
                    },
                    getOrientation: function () {
                        return o;
                    },
                    getCssClass: function () {
                        return acc;
                    }
                };

            return _newEndpoint({
                dropOptions: params.dropOptions,
                anchor: inPlaceAnchor,
                source: this.element,
                paintStyle: this.getPaintStyle(),
                endpoint: params.hideOnDrag ? "Blank" : this.endpoint,
                _transient: true,
                scope: this.scope,
                reference:this
            });
        };

        /**
         * returns a connection from the pool; used when dragging starts.  just gets the head of the array if it can.
         */
        this.connectorSelector = function () {
            var candidate = this.connections[0];
            if (candidate) {
                return candidate;
            }
            else {
                return (this.connections.length < this._jsPlumb.maxConnections) || this._jsPlumb.maxConnections === -1 ? null : candidate;
            }
        };

        this.setStyle = this.setPaintStyle;

        this.paint = function (params) {
            params = params || {};
            var timestamp = params.timestamp, recalc = !(params.recalc === false);
            if (!timestamp || this.timestamp !== timestamp) {

                var info = _jsPlumb.updateOffset({ elId: this.elementId, timestamp: timestamp });

                var xy = params.offset ? params.offset.o : info.o;
                if (xy != null) {
                    var ap = params.anchorPoint, connectorPaintStyle = params.connectorPaintStyle;
                    if (ap == null) {
                        var wh = params.dimensions || info.s,
                            anchorParams = { xy: [ xy.left, xy.top ], wh: wh, element: this, timestamp: timestamp };
                        if (recalc && this.anchor.isDynamic && this.connections.length > 0) {
                            var c = findConnectionToUseForDynamicAnchor(this, params.elementWithPrecedence),
                                oIdx = c.endpoints[0] === this ? 1 : 0,
                                oId = oIdx === 0 ? c.sourceId : c.targetId,
                                oInfo = _jsPlumb.getCachedData(oId),
                                oOffset = oInfo.o, oWH = oInfo.s;
                            anchorParams.txy = [ oOffset.left, oOffset.top ];
                            anchorParams.twh = oWH;
                            anchorParams.tElement = c.endpoints[oIdx];
                        }
                        ap = this.anchor.compute(anchorParams);
                    }

                    this.endpoint.compute(ap, this.anchor.getOrientation(this), this._jsPlumb.paintStyleInUse, connectorPaintStyle || this.paintStyleInUse);
                    this.endpoint.paint(this._jsPlumb.paintStyleInUse, this.anchor);
                    this.timestamp = timestamp;

                    // paint overlays
                    for (var i in this._jsPlumb.overlays) {
                        if (this._jsPlumb.overlays.hasOwnProperty(i)) {
                            var o = this._jsPlumb.overlays[i];
                            if (o.isVisible()) {
                                this._jsPlumb.overlayPlacements[i] = o.draw(this.endpoint, this._jsPlumb.paintStyleInUse);
                                o.paint(this._jsPlumb.overlayPlacements[i]);
                            }
                        }
                    }
                }
            }
        };

        this.getTypeDescriptor = function () {
            return "endpoint";
        };
        this.isVisible = function () {
            return this._jsPlumb.visible;
        };

        this.repaint = this.paint;

        var draggingInitialised = false;
        this.initDraggable = function () {

            // is this a connection source? we make it draggable and have the
            // drag listener maintain a connection with a floating endpoint.
            if (!draggingInitialised && _jp.isDragSupported(this.element)) {
                var placeholderInfo = { id: null, element: null },
                    jpc = null,
                    existingJpc = false,
                    existingJpcParams = null,
                    _dragHandler = _makeConnectionDragHandler(this, placeholderInfo, _jsPlumb),
                    dragOptions = params.dragOptions || {},
                    defaultOpts = {},
                    startEvent = _jp.dragEvents.start,
                    stopEvent = _jp.dragEvents.stop,
                    dragEvent = _jp.dragEvents.drag,
                    beforeStartEvent = _jp.dragEvents.beforeStart,
                    payload;

                // respond to beforeStart from katavorio; this will have, optionally, a payload of attribute values
                // that were placed there by the makeSource mousedown listener.
                var beforeStart = function(beforeStartParams) {
                    payload = beforeStartParams.e.payload || {};
                };

                var start = function (startParams) {

// -------------   first, get a connection to drag. this may be null, in which case we are dragging a new one.

                    jpc = this.connectorSelector();

// -------------------------------- now a bunch of tests about whether or not to proceed -------------------------

                    var _continue = true;
                    // if not enabled, return
                    if (!this.isEnabled()) {
                        _continue = false;
                    }
                    // if no connection and we're not a source - or temporarily a source, as is the case with makeSource - return.
                    if (jpc == null && !this.isSource && !this.isTemporarySource) {
                        _continue = false;
                    }
                    // otherwise if we're full and not allowed to drag, also return false.
                    if (this.isSource && this.isFull() && !(jpc != null && this.dragAllowedWhenFull)) {
                        _continue = false;
                    }
                    // if the connection was setup as not detachable or one of its endpoints
                    // was setup as connectionsDetachable = false, or Defaults.ConnectionsDetachable
                    // is set to false...
                    if (jpc != null && !jpc.isDetachable(this)) {
                        _continue = false;
                    }

                    var beforeDrag = _jsPlumb.checkCondition(jpc == null ? "beforeDrag" : "beforeStartDetach", {
                        endpoint:this,
                        source:this.element,
                        sourceId:this.elementId,
                        connection:jpc
                    });
                    if (beforeDrag === false) {
                        _continue = false;
                    }
                    // else we might have been given some data. we'll pass it in to a new connection as 'data'.
                    // here we also merge in the optional payload we were given on mousedown.
                    else if (typeof beforeDrag === "object") {
                        _jp.extend(beforeDrag, payload || {});
                    }
                    else {
                        // or if no beforeDrag data, maybe use the payload on its own.
                        beforeDrag = payload || {};
                    }

                    if (_continue === false) {
                        // this is for mootools and yui. returning false from this causes jquery to stop drag.
                        // the events are wrapped in both mootools and yui anyway, but i don't think returning
                        // false from the start callback would stop a drag.
                        if (_jsPlumb.stopDrag) {
                            _jsPlumb.stopDrag(this.canvas);
                        }
                        _dragHandler.stopDrag();
                        return false;
                    }

// ---------------------------------------------------------------------------------------------------------------------

                    // ok to proceed.

                    // clear hover for all connections for this endpoint before continuing.
                    for (var i = 0; i < this.connections.length; i++) {
                        this.connections[i].setHover(false);
                    }

                    this.addClass("endpointDrag");
                    _jsPlumb.setConnectionBeingDragged(true);

                    // if we're not full but there was a connection, make it null. we'll create a new one.
                    if (jpc && !this.isFull() && this.isSource) {
                        jpc = null;
                    }

                    _jsPlumb.updateOffset({ elId: this.elementId });

// ----------------    make the element we will drag around, and position it -----------------------------

                    var ipco = this._jsPlumb.instance.getOffset(this.canvas),
                        canvasElement = this.canvas,
                        ips = this._jsPlumb.instance.getSize(this.canvas);

                    _makeDraggablePlaceholder(placeholderInfo, _jsPlumb, ipco, ips);

                    // store the id of the dragging div and the source element. the drop function will pick these up.                   
                    _jsPlumb.setAttributes(this.canvas, {
                        "dragId": placeholderInfo.id,
                        "elId": this.elementId
                    });

// ------------------- create an endpoint that will be our floating endpoint ------------------------------------

                    var endpointToFloat = this.dragProxy || this.endpoint;
                    if (this.dragProxy == null && this.connectionType != null) {
                        var aae = this._jsPlumb.instance.deriveEndpointAndAnchorSpec(this.connectionType);
                        if (aae.endpoints[1]) {
                            endpointToFloat = aae.endpoints[1];
                        }
                    }
                    var centerAnchor = this._jsPlumb.instance.makeAnchor("Center");
                    centerAnchor.isFloating = true;
                    this._jsPlumb.floatingEndpoint = _makeFloatingEndpoint(this.getPaintStyle(), centerAnchor, endpointToFloat, this.canvas, placeholderInfo.element, _jsPlumb, _newEndpoint, this.scope);
                    var _savedAnchor = this._jsPlumb.floatingEndpoint.anchor;


                    if (jpc == null) {

                        this.setHover(false, false);
                        // create a connection. one end is this endpoint, the other is a floating endpoint.                    
                        jpc = _newConnection({
                            sourceEndpoint: this,
                            targetEndpoint: this._jsPlumb.floatingEndpoint,
                            source: this.element,  // for makeSource with parent option.  ensure source element is represented correctly.
                            target: placeholderInfo.element,
                            anchors: [ this.anchor, this._jsPlumb.floatingEndpoint.anchor ],
                            paintStyle: params.connectorStyle, // this can be null. Connection will use the default.
                            hoverPaintStyle: params.connectorHoverStyle,
                            connector: params.connector, // this can also be null. Connection will use the default.
                            overlays: params.connectorOverlays,
                            type: this.connectionType,
                            cssClass: this.connectorClass,
                            hoverClass: this.connectorHoverClass,
                            scope:params.scope,
                            data:beforeDrag
                        });
                        jpc.pending = true;
                        jpc.addClass(_jsPlumb.draggingClass);
                        this._jsPlumb.floatingEndpoint.addClass(_jsPlumb.draggingClass);
                        this._jsPlumb.floatingEndpoint.anchor = _savedAnchor;
                        // fire an event that informs that a connection is being dragged
                        _jsPlumb.fire("connectionDrag", jpc);

                        // register the new connection on the drag manager. This connection, at this point, is 'pending',
                        // and has as its target a temporary element (the 'placeholder'). If the connection subsequently
                        // becomes established, the anchor manager is informed that the target of the connection has
                        // changed.

                        _jsPlumb.anchorManager.newConnection(jpc);

                    } else {
                        existingJpc = true;
                        jpc.setHover(false);
                        // new anchor idx
                        var anchorIdx = jpc.endpoints[0].id === this.id ? 0 : 1;
                        this.detachFromConnection(jpc, null, true);                         // detach from the connection while dragging is occurring. but dont cleanup automatically.

                        // store the original scope (issue 57)
                        var dragScope = _jsPlumb.getDragScope(canvasElement);
                        _jsPlumb.setAttribute(this.canvas, "originalScope", dragScope);

                        // fire an event that informs that a connection is being dragged. we do this before
                        // replacing the original target with the floating element info.
                        _jsPlumb.fire("connectionDrag", jpc);

                        // now we replace ourselves with the temporary div we created above:
                        if (anchorIdx === 0) {
                            existingJpcParams = [ jpc.source, jpc.sourceId, canvasElement, dragScope ];
                            _jsPlumb.anchorManager.sourceChanged(jpc.endpoints[anchorIdx].elementId, placeholderInfo.id, jpc, placeholderInfo.element);

                        } else {
                            existingJpcParams = [ jpc.target, jpc.targetId, canvasElement, dragScope ];
                            jpc.target = placeholderInfo.element;
                            jpc.targetId = placeholderInfo.id;

                            _jsPlumb.anchorManager.updateOtherEndpoint(jpc.sourceId, jpc.endpoints[anchorIdx].elementId, jpc.targetId, jpc);
                        }

                        // store the original endpoint and assign the new floating endpoint for the drag.
                        jpc.suspendedEndpoint = jpc.endpoints[anchorIdx];

                        // PROVIDE THE SUSPENDED ELEMENT, BE IT A SOURCE OR TARGET (ISSUE 39)
                        jpc.suspendedElement = jpc.endpoints[anchorIdx].getElement();
                        jpc.suspendedElementId = jpc.endpoints[anchorIdx].elementId;
                        jpc.suspendedElementType = anchorIdx === 0 ? "source" : "target";

                        jpc.suspendedEndpoint.setHover(false);
                        this._jsPlumb.floatingEndpoint.referenceEndpoint = jpc.suspendedEndpoint;
                        jpc.endpoints[anchorIdx] = this._jsPlumb.floatingEndpoint;

                        jpc.addClass(_jsPlumb.draggingClass);
                        this._jsPlumb.floatingEndpoint.addClass(_jsPlumb.draggingClass);
                    }

                    // register it and register connection on it.
                    _jsPlumb.floatingConnections[placeholderInfo.id] = jpc;
                    // only register for the target endpoint; we will not be dragging the source at any time
                    // before this connection is either discarded or made into a permanent connection.
                    _ju.addToList(params.endpointsByElement, placeholderInfo.id, this._jsPlumb.floatingEndpoint);
                    // tell jsplumb about it
                    _jsPlumb.currentlyDragging = true;
                }.bind(this);

                var stop = function () {
                    _jsPlumb.setConnectionBeingDragged(false);

                    if (jpc && jpc.endpoints != null) {
                        // get the actual drop event (decode from library args to stop function)
                        var originalEvent = _jsPlumb.getDropEvent(arguments);
                        // unlock the other endpoint (if it is dynamic, it would have been locked at drag start)
                        var idx = _jsPlumb.getFloatingAnchorIndex(jpc);
                        jpc.endpoints[idx === 0 ? 1 : 0].anchor.locked = false;
                        // TODO: Dont want to know about css classes inside jsplumb, ideally.
                        jpc.removeClass(_jsPlumb.draggingClass);

                        // if we have the floating endpoint then the connection has not been dropped
                        // on another endpoint.  If it is a new connection we throw it away. If it is an
                        // existing connection we check to see if we should reattach it, throwing it away
                        // if not.
                        if (this._jsPlumb && (jpc.deleteConnectionNow || jpc.endpoints[idx] === this._jsPlumb.floatingEndpoint)) {
                            // 6a. if the connection was an existing one...
                            if (existingJpc && jpc.suspendedEndpoint) {
                                // fix for issue35, thanks Sylvain Gizard: when firing the detach event make sure the
                                // floating endpoint has been replaced.
                                if (idx === 0) {
                                    jpc.floatingElement = jpc.source;
                                    jpc.floatingId = jpc.sourceId;
                                    jpc.floatingEndpoint = jpc.endpoints[0];
                                    jpc.floatingIndex = 0;
                                    jpc.source = existingJpcParams[0];
                                    jpc.sourceId = existingJpcParams[1];
                                } else {
                                    // keep a copy of the floating element; the anchor manager will want to clean up.
                                    jpc.floatingElement = jpc.target;
                                    jpc.floatingId = jpc.targetId;
                                    jpc.floatingEndpoint = jpc.endpoints[1];
                                    jpc.floatingIndex = 1;
                                    jpc.target = existingJpcParams[0];
                                    jpc.targetId = existingJpcParams[1];
                                }

                                var fe = this._jsPlumb.floatingEndpoint; // store for later removal.
                                // restore the original scope (issue 57)
                                _jsPlumb.setDragScope(existingJpcParams[2], existingJpcParams[3]);
                                jpc.endpoints[idx] = jpc.suspendedEndpoint;
                                // IF the connection should be reattached, or the other endpoint refuses detach, then
                                // reset the connection to its original state
                                //if (jpc.isReattach() || jpc._forceReattach || jpc._forceDetach || !jpc.endpoints[idx === 0 ? 1 : 0].detach({connection:jpc, ignoreTarget:false, forceDetach:false, fireEvent:true, originalEvent:originalEvent, endpointBeingDeleted:true})) {
                                if (jpc.isReattach() || jpc._forceReattach || jpc._forceDetach || !_jsPlumb.deleteConnection(jpc)) {

                                    jpc.setHover(false);
                                    jpc._forceDetach = null;
                                    jpc._forceReattach = null;
                                    this._jsPlumb.floatingEndpoint.detachFromConnection(jpc);
                                    jpc.suspendedEndpoint.addConnection(jpc);

                                    // TODO this code is duplicated in lots of places...and there is nothing external
                                    // in the code; it all refers to the connection itself. we could add a
                                    // `checkSanity(connection)` method to anchorManager that did this.
                                    if (idx === 1) {
                                        _jsPlumb.anchorManager.updateOtherEndpoint(jpc.sourceId, jpc.floatingId, jpc.targetId, jpc);
                                    }
                                    else {
                                        _jsPlumb.anchorManager.sourceChanged(jpc.floatingId, jpc.sourceId, jpc, jpc.source);
                                    }

                                    _jsPlumb.repaint(existingJpcParams[1]);
                                }
                                else {
                                    _jsPlumb.deleteObject({endpoint: fe});
                                }
                            }
                        }

                        // makeTargets sets this flag, to tell us we have been replaced and should delete this object.
                        if (this.deleteAfterDragStop) {
                            _jsPlumb.deleteObject({endpoint: this});
                        }
                        else {
                            if (this._jsPlumb) {
                                 this.paint({recalc: false});
                            }
                        }

                        // although the connection is no longer valid, there are use cases where this is useful.
                        _jsPlumb.fire("connectionDragStop", jpc, originalEvent);
                        // fire this event to give people more fine-grained control (connectionDragStop fires a lot)
                        if (jpc.pending) {
                            _jsPlumb.fire("connectionAborted", jpc, originalEvent);
                        }
                        // tell jsplumb that dragging is finished.
                        _jsPlumb.currentlyDragging = false;
                        jpc.suspendedElement = null;
                        jpc.suspendedEndpoint = null;
                        jpc = null;
                    }

                    // if no endpoints, jpc already cleaned up. but still we want to ensure we're reset properly.
                    // remove the element associated with the floating endpoint
                    // (and its associated floating endpoint and visual artefacts)
                    if (placeholderInfo && placeholderInfo.element) {
                        _jsPlumb.remove(placeholderInfo.element, false, false);
                    }
                    // remove the inplace copy
                    if (inPlaceCopy) {
                        _jsPlumb.deleteObject({endpoint: inPlaceCopy});
                    }

                    if (this._jsPlumb) {
                        // make our canvas visible (TODO: hand off to library; we should not know about DOM)
                        this.canvas.style.visibility = "visible";
                        // unlock our anchor
                        this.anchor.locked = false;
                        // clear floating anchor.
                        this._jsPlumb.floatingEndpoint = null;
                    }

                }.bind(this);

                dragOptions = _jp.extend(defaultOpts, dragOptions);
                dragOptions.scope = this.scope || dragOptions.scope;
                dragOptions[beforeStartEvent] = _ju.wrap(dragOptions[beforeStartEvent], beforeStart, false);
                dragOptions[startEvent] = _ju.wrap(dragOptions[startEvent], start, false);
                // extracted drag handler function so can be used by makeSource
                dragOptions[dragEvent] = _ju.wrap(dragOptions[dragEvent], _dragHandler.drag);
                dragOptions[stopEvent] = _ju.wrap(dragOptions[stopEvent], stop);
                dragOptions.multipleDrop = false;

                dragOptions.canDrag = function () {
                    return this.isSource || this.isTemporarySource || /*(this.isTarget && */this.connections.length > 0/*)*/;
                }.bind(this);

                _jsPlumb.initDraggable(this.canvas, dragOptions, "internal");

                this.canvas._jsPlumbRelatedElement = this.element;

                draggingInitialised = true;
            }
        };

        var ep = params.endpoint || this._jsPlumb.instance.Defaults.Endpoint || _jp.Defaults.Endpoint;
        this.setEndpoint(ep, true);
        var anchorParamsToUse = params.anchor ? params.anchor : params.anchors ? params.anchors : (_jsPlumb.Defaults.Anchor || "Top");
        this.setAnchor(anchorParamsToUse, true);

        // finally, set type if it was provided
        var type = [ "default", (params.type || "")].join(" ");
        this.addType(type, params.data, true);
        this.canvas = this.endpoint.canvas;
        this.canvas._jsPlumb = this;

        this.initDraggable();

        // pulled this out into a function so we can reuse it for the inPlaceCopy canvas; you can now drop detached connections
        // back onto the endpoint you detached it from.
        var _initDropTarget = function (canvas, isTransient, endpoint, referenceEndpoint) {

            if (_jp.isDropSupported(this.element)) {
                var dropOptions = params.dropOptions || _jsPlumb.Defaults.DropOptions || _jp.Defaults.DropOptions;
                dropOptions = _jp.extend({}, dropOptions);
                dropOptions.scope = dropOptions.scope || this.scope;
                var dropEvent = _jp.dragEvents.drop,
                    overEvent = _jp.dragEvents.over,
                    outEvent = _jp.dragEvents.out,
                    _ep = this,
                    drop = _jsPlumb.EndpointDropHandler({
                        getEndpoint: function () {
                            return _ep;
                        },
                        jsPlumb: _jsPlumb,
                        enabled: function () {
                            return endpoint != null ? endpoint.isEnabled() : true;
                        },
                        isFull: function () {
                            return endpoint.isFull();
                        },
                        element: this.element,
                        elementId: this.elementId,
                        isSource: this.isSource,
                        isTarget: this.isTarget,
                        addClass: function (clazz) {
                            _ep.addClass(clazz);
                        },
                        removeClass: function (clazz) {
                            _ep.removeClass(clazz);
                        },
                        isDropAllowed: function () {
                            return _ep.isDropAllowed.apply(_ep, arguments);
                        },
                        reference:referenceEndpoint,
                        isRedrop:function(jpc, dhParams) {
                            return jpc.suspendedEndpoint && dhParams.reference && (jpc.suspendedEndpoint.id === dhParams.reference.id);
                        }
                    });

                dropOptions[dropEvent] = _ju.wrap(dropOptions[dropEvent], drop, true);
                dropOptions[overEvent] = _ju.wrap(dropOptions[overEvent], function () {
                    var draggable = _jp.getDragObject(arguments),
                        id = _jsPlumb.getAttribute(_jp.getElement(draggable), "dragId"),
                        _jpc = _jsPlumb.floatingConnections[id];

                    if (_jpc != null) {
                        var idx = _jsPlumb.getFloatingAnchorIndex(_jpc);
                        // here we should fire the 'over' event if we are a target and this is a new connection,
                        // or we are the same as the floating endpoint.
                        var _cont = (this.isTarget && idx !== 0) || (_jpc.suspendedEndpoint && this.referenceEndpoint && this.referenceEndpoint.id === _jpc.suspendedEndpoint.id);
                        if (_cont) {
                            var bb = _jsPlumb.checkCondition("checkDropAllowed", {
                                sourceEndpoint: _jpc.endpoints[idx],
                                targetEndpoint: this,
                                connection: _jpc
                            });
                            this[(bb ? "add" : "remove") + "Class"](_jsPlumb.endpointDropAllowedClass);
                            this[(bb ? "remove" : "add") + "Class"](_jsPlumb.endpointDropForbiddenClass);
                            _jpc.endpoints[idx].anchor.over(this.anchor, this);
                        }
                    }
                }.bind(this));

                dropOptions[outEvent] = _ju.wrap(dropOptions[outEvent], function () {
                    var draggable = _jp.getDragObject(arguments),
                        id = draggable == null ? null : _jsPlumb.getAttribute(_jp.getElement(draggable), "dragId"),
                        _jpc = id ? _jsPlumb.floatingConnections[id] : null;

                    if (_jpc != null) {
                        var idx = _jsPlumb.getFloatingAnchorIndex(_jpc);
                        var _cont = (this.isTarget && idx !== 0) || (_jpc.suspendedEndpoint && this.referenceEndpoint && this.referenceEndpoint.id === _jpc.suspendedEndpoint.id);
                        if (_cont) {
                            this.removeClass(_jsPlumb.endpointDropAllowedClass);
                            this.removeClass(_jsPlumb.endpointDropForbiddenClass);
                            _jpc.endpoints[idx].anchor.out();
                        }
                    }
                }.bind(this));

                _jsPlumb.initDroppable(canvas, dropOptions, "internal", isTransient);
            }
        }.bind(this);

        // Initialise the endpoint's canvas as a drop target. The drop handler will take care of the logic of whether
        // something can actually be dropped.
        if (!this.anchor.isFloating) {
            _initDropTarget(this.canvas, !(params._transient || this.anchor.isFloating), this, params.reference);
        }

        return this;
    };

    _ju.extend(_jp.Endpoint, _jp.OverlayCapableJsPlumbUIComponent, {

        setVisible: function (v, doNotChangeConnections, doNotNotifyOtherEndpoint) {
            this._jsPlumb.visible = v;
            if (this.canvas) {
                this.canvas.style.display = v ? "block" : "none";
            }
            this[v ? "showOverlays" : "hideOverlays"]();
            if (!doNotChangeConnections) {
                for (var i = 0; i < this.connections.length; i++) {
                    this.connections[i].setVisible(v);
                    if (!doNotNotifyOtherEndpoint) {
                        var oIdx = this === this.connections[i].endpoints[0] ? 1 : 0;
                        // only change the other endpoint if this is its only connection.
                        if (this.connections[i].endpoints[oIdx].connections.length === 1) {
                            this.connections[i].endpoints[oIdx].setVisible(v, true, true);
                        }
                    }
                }
            }
        },
        getAttachedElements: function () {
            return this.connections;
        },
        applyType: function (t, doNotRepaint) {
            this.setPaintStyle(t.endpointStyle || t.paintStyle, doNotRepaint);
            this.setHoverPaintStyle(t.endpointHoverStyle || t.hoverPaintStyle, doNotRepaint);
            if (t.maxConnections != null) {
                this._jsPlumb.maxConnections = t.maxConnections;
            }
            if (t.scope) {
                this.scope = t.scope;
            }
            _jp.extend(this, t, typeParameters);
            if (t.cssClass != null && this.canvas) {
                this._jsPlumb.instance.addClass(this.canvas, t.cssClass);
            }
            _jp.OverlayCapableJsPlumbUIComponent.applyType(this, t);
        },
        isEnabled: function () {
            return this._jsPlumb.enabled;
        },
        setEnabled: function (e) {
            this._jsPlumb.enabled = e;
        },
        cleanup: function () {
            var anchorClass = this._jsPlumb.instance.endpointAnchorClassPrefix + (this._jsPlumb.currentAnchorClass ? "-" + this._jsPlumb.currentAnchorClass : "");
            _jp.removeClass(this.element, anchorClass);
            this.anchor = null;
            this.endpoint.cleanup(true);
            this.endpoint.destroy();
            this.endpoint = null;
            // drag/drop
            this._jsPlumb.instance.destroyDraggable(this.canvas, "internal");
            this._jsPlumb.instance.destroyDroppable(this.canvas, "internal");
        },
        setHover: function (h) {
            if (this.endpoint && this._jsPlumb && !this._jsPlumb.instance.isConnectionBeingDragged()) {
                this.endpoint.setHover(h);
            }
        },
        isFull: function () {
            return this._jsPlumb.maxConnections === 0 ? true : !(this.isFloating() || this._jsPlumb.maxConnections < 0 || this.connections.length < this._jsPlumb.maxConnections);
        },
        /**
         * private but needs to be exposed.
         */
        isFloating: function () {
            return this.anchor != null && this.anchor.isFloating;
        },
        isConnectedTo: function (endpoint) {
            var found = false;
            if (endpoint) {
                for (var i = 0; i < this.connections.length; i++) {
                    if (this.connections[i].endpoints[1] === endpoint || this.connections[i].endpoints[0] === endpoint) {
                        found = true;
                        break;
                    }
                }
            }
            return found;
        },
        getConnectionCost: function () {
            return this._jsPlumb.connectionCost;
        },
        setConnectionCost: function (c) {
            this._jsPlumb.connectionCost = c;
        },
        areConnectionsDirected: function () {
            return this._jsPlumb.connectionsDirected;
        },
        setConnectionsDirected: function (b) {
            this._jsPlumb.connectionsDirected = b;
        },
        setElementId: function (_elId) {
            this.elementId = _elId;
            this.anchor.elementId = _elId;
        },
        setReferenceElement: function (_el) {
            this.element = _jp.getElement(_el);
        },
        setDragAllowedWhenFull: function (allowed) {
            this.dragAllowedWhenFull = allowed;
        },
        equals: function (endpoint) {
            return this.anchor.equals(endpoint.anchor);
        },
        getUuid: function () {
            return this._jsPlumb.uuid;
        },
        computeAnchor: function (params) {
            return this.anchor.compute(params);
        }
    });

    root.jsPlumbInstance.prototype.EndpointDropHandler = function (dhParams) {
        return function (e) {

            var _jsPlumb = dhParams.jsPlumb;

            // remove the classes that are added dynamically. drop is neither forbidden nor allowed now that
            // the drop is finishing.
            dhParams.removeClass(_jsPlumb.endpointDropAllowedClass);
            dhParams.removeClass(_jsPlumb.endpointDropForbiddenClass);

            var originalEvent = _jsPlumb.getDropEvent(arguments),
                draggable = _jsPlumb.getDragObject(arguments),
                id = _jsPlumb.getAttribute(draggable, "dragId"),
                elId = _jsPlumb.getAttribute(draggable, "elId"),
                scope = _jsPlumb.getAttribute(draggable, "originalScope"),
                jpc = _jsPlumb.floatingConnections[id];

            // if no active connection, bail.
            if (jpc == null) {
                return;
            }

            // calculate if this is an existing connection.
            var existingConnection = jpc.suspendedEndpoint != null;

            // if suspended endpoint exists but has been cleaned up, bail. This means it's an existing connection
            // that has been detached and will shortly be discarded.
            if (existingConnection && jpc.suspendedEndpoint._jsPlumb == null) {
                return;
            }

            // get the drop endpoint. for a normal connection this is just the one that would replace the currently
            // floating endpoint. for a makeTarget this is a new endpoint that is created on drop. But we leave that to
            // the handler to figure out.
            var _ep = dhParams.getEndpoint(jpc);

            // If we're not given an endpoint to use, bail.
            if (_ep == null) {
                return;
            }

            // if this is a drop back where the connection came from, mark it force reattach and
            // return; the stop handler will reattach. without firing an event.
            if (dhParams.isRedrop(jpc, dhParams)) {
                jpc._forceReattach = true;
                jpc.setHover(false);
                if (dhParams.maybeCleanup) {
                    dhParams.maybeCleanup(_ep);
                }
                return;
            }

            // ensure we dont bother trying to drop sources on non-source eps, and same for target.
            var idx = _jsPlumb.getFloatingAnchorIndex(jpc);
            if ((idx === 0 && !dhParams.isSource)|| (idx === 1 && !dhParams.isTarget)){
                if (dhParams.maybeCleanup) {
                    dhParams.maybeCleanup(_ep);
                }
                return;
            }

            if (dhParams.onDrop) {
                dhParams.onDrop(jpc);
            }

            // restore the original scope if necessary (issue 57)
            if (scope) {
                _jsPlumb.setDragScope(draggable, scope);
            }

            // if the target of the drop is full, fire an event (we abort below)
            // makeTarget: keep.
            var isFull = dhParams.isFull(e);
            if (isFull) {
                _ep.fire("maxConnections", {
                    endpoint: this,
                    connection: jpc,
                    maxConnections: _ep._jsPlumb.maxConnections
                }, originalEvent);
            }
            //
            // if endpoint enabled, not full, and matches the index of the floating endpoint...
            if (!isFull &&  dhParams.enabled()) {
                var _doContinue = true;

                // before testing for beforeDrop, reset the connection's source/target to be the actual DOM elements
                // involved (that is, stash any temporary stuff used for dragging. but we need to keep it around in
                // order that the anchor manager can clean things up properly).
                if (idx === 0) {
                    jpc.floatingElement = jpc.source;
                    jpc.floatingId = jpc.sourceId;
                    jpc.floatingEndpoint = jpc.endpoints[0];
                    jpc.floatingIndex = 0;
                    jpc.source = dhParams.element;
                    jpc.sourceId = dhParams.elementId;
                } else {
                    jpc.floatingElement = jpc.target;
                    jpc.floatingId = jpc.targetId;
                    jpc.floatingEndpoint = jpc.endpoints[1];
                    jpc.floatingIndex = 1;
                    jpc.target = dhParams.element;
                    jpc.targetId = dhParams.elementId;
                }

                // if this is an existing connection and detach is not allowed we won't continue. The connection's
                // endpoints have been reinstated; everything is back to how it was.
                if (existingConnection && jpc.suspendedEndpoint.id !== _ep.id) {
                    if (!jpc.isDetachAllowed(jpc) || !jpc.endpoints[idx].isDetachAllowed(jpc) || !jpc.suspendedEndpoint.isDetachAllowed(jpc) || !_jsPlumb.checkCondition("beforeDetach", jpc)) {
                        _doContinue = false;
                    }
                }

// ------------ wrap the execution path in a function so we can support asynchronous beforeDrop

                var continueFunction = function (optionalData) {
                    // remove this jpc from the current endpoint, which is a floating endpoint that we will
                    // subsequently discard.
                    jpc.endpoints[idx].detachFromConnection(jpc);

                    // if there's a suspended endpoint, detach it from the connection.
                    if (jpc.suspendedEndpoint) {
                        jpc.suspendedEndpoint.detachFromConnection(jpc);
                    }

                    jpc.endpoints[idx] = _ep;
                    _ep.addConnection(jpc);

                    // copy our parameters in to the connection:
                    var params = _ep.getParameters();
                    for (var aParam in params) {
                        jpc.setParameter(aParam, params[aParam]);
                    }

                    if (!existingConnection) {
                        // if not an existing connection and
                        if (params.draggable) {
                            _jsPlumb.initDraggable(this.element, dhParams.dragOptions, "internal", _jsPlumb);
                        }
                    }
                    else {
                        var suspendedElementId = jpc.suspendedEndpoint.elementId;
                        _jsPlumb.fireMoveEvent({
                            index: idx,
                            originalSourceId: idx === 0 ? suspendedElementId : jpc.sourceId,
                            newSourceId: idx === 0 ? _ep.elementId : jpc.sourceId,
                            originalTargetId: idx === 1 ? suspendedElementId : jpc.targetId,
                            newTargetId: idx === 1 ? _ep.elementId : jpc.targetId,
                            originalSourceEndpoint: idx === 0 ? jpc.suspendedEndpoint : jpc.endpoints[0],
                            newSourceEndpoint: idx === 0 ? _ep : jpc.endpoints[0],
                            originalTargetEndpoint: idx === 1 ? jpc.suspendedEndpoint : jpc.endpoints[1],
                            newTargetEndpoint: idx === 1 ? _ep : jpc.endpoints[1],
                            connection: jpc
                        }, originalEvent);
                    }

                    if (idx === 1) {
                        _jsPlumb.anchorManager.updateOtherEndpoint(jpc.sourceId, jpc.floatingId, jpc.targetId, jpc);
                    }
                    else {
                        _jsPlumb.anchorManager.sourceChanged(jpc.floatingId, jpc.sourceId, jpc, jpc.source);
                    }

                    // when makeSource has uniqueEndpoint:true, we want to create connections with new endpoints
                    // that are subsequently deleted. So makeSource sets `finalEndpoint`, which is the Endpoint to
                    // which the connection should be attached. The `detachFromConnection` call below results in the
                    // temporary endpoint being cleaned up.
                    if (jpc.endpoints[0].finalEndpoint) {
                        var _toDelete = jpc.endpoints[0];
                        _toDelete.detachFromConnection(jpc);
                        jpc.endpoints[0] = jpc.endpoints[0].finalEndpoint;
                        jpc.endpoints[0].addConnection(jpc);
                    }

                    // if optionalData was given, merge it onto the connection's data.
                    if (_ju.isObject(optionalData)) {
                        jpc.mergeData(optionalData);
                    }
                    // finalise will inform the anchor manager and also add to
                    // connectionsByScope if necessary.
                    _jsPlumb.finaliseConnection(jpc, null, originalEvent, false);
                    jpc.setHover(false);

                }.bind(this);

                var dontContinueFunction = function () {
                    // otherwise just put it back on the endpoint it was on before the drag.
                    if (jpc.suspendedEndpoint) {
                        jpc.endpoints[idx] = jpc.suspendedEndpoint;
                        jpc.setHover(false);
                        jpc._forceDetach = true;
                        if (idx === 0) {
                            jpc.source = jpc.suspendedEndpoint.element;
                            jpc.sourceId = jpc.suspendedEndpoint.elementId;
                        } else {
                            jpc.target = jpc.suspendedEndpoint.element;
                            jpc.targetId = jpc.suspendedEndpoint.elementId;
                        }
                        jpc.suspendedEndpoint.addConnection(jpc);

                        // TODO checkSanity
                        if (idx === 1) {
                            _jsPlumb.anchorManager.updateOtherEndpoint(jpc.sourceId, jpc.floatingId, jpc.targetId, jpc);
                        }
                        else {
                            _jsPlumb.anchorManager.sourceChanged(jpc.floatingId, jpc.sourceId, jpc, jpc.source);
                        }

                        _jsPlumb.repaint(jpc.sourceId);
                        jpc._forceDetach = false;
                    }
                };

// --------------------------------------
                // now check beforeDrop.  this will be available only on Endpoints that are setup to
                // have a beforeDrop condition (although, secretly, under the hood all Endpoints and
                // the Connection have them, because they are on jsPlumbUIComponent.  shhh!), because
                // it only makes sense to have it on a target endpoint.
                _doContinue = _doContinue && dhParams.isDropAllowed(jpc.sourceId, jpc.targetId, jpc.scope, jpc, _ep);// && jpc.pending;

                if (_doContinue) {
                    continueFunction(_doContinue);
                    return true;
                }
                else {
                    dontContinueFunction();
                }
            }

            if (dhParams.maybeCleanup) {
                dhParams.maybeCleanup(_ep);
            }

            _jsPlumb.currentlyDragging = false;
        };
    };
}).call(typeof window !== 'undefined' ? window : this);

/*
 * jsPlumb Community Edition
 * 
 * Provides a way to visually connect elements on an HTML page, using SVG.
 * 
 * This file contains the code for Connections.
 *
 * Copyright (c) 2010 - 2017 jsPlumb (hello@jsplumbtoolkit.com)
 * 
 * https://jsplumbtoolkit.com
 * https://github.com/jsplumb/jsplumb
 * 
 * Dual licensed under the MIT and GPL2 licenses.
 */
;
(function () {

    "use strict";
    var root = this,
        _jp = root.jsPlumb,
        _ju = root.jsPlumbUtil;

    var makeConnector = function (_jsPlumb, renderMode, connectorName, connectorArgs, forComponent) {
            if (!_jsPlumb.Defaults.DoNotThrowErrors && _jp.Connectors[renderMode][connectorName] == null) {
                throw { msg: "jsPlumb: unknown connector type '" + connectorName + "'" };
            }

            return new _jp.Connectors[renderMode][connectorName](connectorArgs, forComponent);
        },
        _makeAnchor = function (anchorParams, elementId, _jsPlumb) {
            return (anchorParams) ? _jsPlumb.makeAnchor(anchorParams, elementId, _jsPlumb) : null;
        },
        _updateConnectedClass = function (conn, element, _jsPlumb, remove) {
            if (element != null) {
                element._jsPlumbConnections = element._jsPlumbConnections || {};
                if (remove) {
                    delete element._jsPlumbConnections[conn.id];
                }
                else {
                    element._jsPlumbConnections[conn.id] = true;
                }

                if (_ju.isEmpty(element._jsPlumbConnections)) {
                    _jsPlumb.removeClass(element, _jsPlumb.connectedClass);
                }
                else {
                    _jsPlumb.addClass(element, _jsPlumb.connectedClass);
                }
            }
        };

    _jp.Connection = function (params) {
        var _newEndpoint = params.newEndpoint;

        this.id = params.id;
        this.connector = null;
        this.idPrefix = "_jsplumb_c_";
        this.defaultLabelLocation = 0.5;
        this.defaultOverlayKeys = ["Overlays", "ConnectionOverlays"];
        // if a new connection is the result of moving some existing connection, params.previousConnection
        // will have that Connection in it. listeners for the jsPlumbConnection event can look for that
        // member and take action if they need to.
        this.previousConnection = params.previousConnection;
        this.source = _jp.getElement(params.source);
        this.target = _jp.getElement(params.target);
        // sourceEndpoint and targetEndpoint override source/target, if they are present. but 
        // source is not overridden if the Endpoint has declared it is not the final target of a connection;
        // instead we use the source that the Endpoint declares will be the final source element.
        if (params.sourceEndpoint) {
            this.source = params.sourceEndpoint.getElement();
        }
        if (params.targetEndpoint) {
            this.target = params.targetEndpoint.getElement();
        }

        _jp.OverlayCapableJsPlumbUIComponent.apply(this, arguments);

        this.sourceId = this._jsPlumb.instance.getId(this.source);
        this.targetId = this._jsPlumb.instance.getId(this.target);
        this.scope = params.scope; // scope may have been passed in to the connect call. if it wasn't, we will pull it from the source endpoint, after having initialised the endpoints.            
        this.endpoints = [];
        this.endpointStyles = [];

        var _jsPlumb = this._jsPlumb.instance;

        _jsPlumb.manage(this.sourceId, this.source);
        _jsPlumb.manage(this.targetId, this.target);

        this._jsPlumb.visible = true;
        this._jsPlumb.editable = params.editable === true;
        this._jsPlumb.params = {
            cssClass: params.cssClass,
            container: params.container,
            "pointer-events": params["pointer-events"],
            editorParams: params.editorParams,
            overlays: params.overlays
        };
        this._jsPlumb.lastPaintedAt = null;

        // listen to mouseover and mouseout events passed from the container delegate.
        this.bind("mouseover", function () {
            this.setHover(true);
        }.bind(this));
        this.bind("mouseout", function () {
            this.setHover(false);
        }.bind(this));

        this.editableRequested = params.editable !== false;
        this.setEditable = function(e) {
            return this.connector ? this.connector.setEditable(e) : false;
        };
        this.isEditable = function() { return this.connector ? this.connector.isEditable() : false; };
        this.isEditing = function() { return this.connector ? this.connector.isEditing() : false; };

// INITIALISATION CODE

        this.makeEndpoint = function (isSource, el, elId, ep) {
            elId = elId || this._jsPlumb.instance.getId(el);
            return this.prepareEndpoint(_jsPlumb, _newEndpoint, this, ep, isSource ? 0 : 1, params, el, elId);
        };

        // if type given, get the endpoint definitions mapping to that type from the jsplumb instance, and use those.
        // we apply types at the end of this constructor but endpoints are only honoured in a type definition at
        // create time.
        if (params.type) {
            params.endpoints = params.endpoints || this._jsPlumb.instance.deriveEndpointAndAnchorSpec(params.type).endpoints;
        }

        var eS = this.makeEndpoint(true, this.source, this.sourceId, params.sourceEndpoint),
            eT = this.makeEndpoint(false, this.target, this.targetId, params.targetEndpoint);

        if (eS) {
            _ju.addToList(params.endpointsByElement, this.sourceId, eS);
        }
        if (eT) {
            _ju.addToList(params.endpointsByElement, this.targetId, eT);
        }
        // if scope not set, set it to be the scope for the source endpoint.
        if (!this.scope) {
            this.scope = this.endpoints[0].scope;
        }

        // if explicitly told to (or not to) delete endpoints when empty, override endpoint's preferences
        if (params.deleteEndpointsOnEmpty != null) {
            this.endpoints[0].setDeleteOnEmpty(params.deleteEndpointsOnEmpty);
            this.endpoints[1].setDeleteOnEmpty(params.deleteEndpointsOnEmpty);
        }
//        else {
//            // otherwise, unless the endpoints say otherwise, mark them for deletion.
//            if (!this.endpoints[0]._doNotDeleteOnDetach) this.endpoints[0]._deleteOnDetach = true;
//            if (!this.endpoints[1]._doNotDeleteOnDetach) this.endpoints[1]._deleteOnDetach = true;
//        }

// -------------------------- DEFAULT TYPE ---------------------------------------------

        // DETACHABLE
        var _detachable = _jsPlumb.Defaults.ConnectionsDetachable;
        if (params.detachable === false) {
            _detachable = false;
        }
        if (this.endpoints[0].connectionsDetachable === false) {
            _detachable = false;
        }
        if (this.endpoints[1].connectionsDetachable === false) {
            _detachable = false;
        }
        // REATTACH
        var _reattach = params.reattach || this.endpoints[0].reattachConnections || this.endpoints[1].reattachConnections || _jsPlumb.Defaults.ReattachConnections;

        this.appendToDefaultType({
            detachable: _detachable,
            reattach: _reattach,
            paintStyle:this.endpoints[0].connectorStyle || this.endpoints[1].connectorStyle || params.paintStyle || _jsPlumb.Defaults.PaintStyle || _jp.Defaults.PaintStyle,
            hoverPaintStyle:this.endpoints[0].connectorHoverStyle || this.endpoints[1].connectorHoverStyle || params.hoverPaintStyle || _jsPlumb.Defaults.HoverPaintStyle || _jp.Defaults.HoverPaintStyle
        });

        var _suspendedAt = _jsPlumb.getSuspendedAt();
        if (!_jsPlumb.isSuspendDrawing()) {
            // paint the endpoints
            var myInfo = _jsPlumb.getCachedData(this.sourceId),
                myOffset = myInfo.o, myWH = myInfo.s,
                otherInfo = _jsPlumb.getCachedData(this.targetId),
                otherOffset = otherInfo.o,
                otherWH = otherInfo.s,
                initialTimestamp = _suspendedAt || _jsPlumb.timestamp(),
                anchorLoc = this.endpoints[0].anchor.compute({
                    xy: [ myOffset.left, myOffset.top ], wh: myWH, element: this.endpoints[0],
                    elementId: this.endpoints[0].elementId,
                    txy: [ otherOffset.left, otherOffset.top ], twh: otherWH, tElement: this.endpoints[1],
                    timestamp: initialTimestamp
                });

            this.endpoints[0].paint({ anchorLoc: anchorLoc, timestamp: initialTimestamp });

            anchorLoc = this.endpoints[1].anchor.compute({
                xy: [ otherOffset.left, otherOffset.top ], wh: otherWH, element: this.endpoints[1],
                elementId: this.endpoints[1].elementId,
                txy: [ myOffset.left, myOffset.top ], twh: myWH, tElement: this.endpoints[0],
                timestamp: initialTimestamp
            });
            this.endpoints[1].paint({ anchorLoc: anchorLoc, timestamp: initialTimestamp });
        }

        this.getTypeDescriptor = function () {
            return "connection";
        };
        this.getAttachedElements = function () {
            return this.endpoints;
        };

        this.isDetachable = function () {
            return this._jsPlumb.detachable === true;
        };
        this.setDetachable = function (detachable) {
            this._jsPlumb.detachable = detachable === true;
        };
        this.isReattach = function () {
            return this._jsPlumb.reattach === true || this.endpoints[0].reattachConnections === true || this.endpoints[1].reattachConnections === true;
        };
        this.setReattach = function (reattach) {
            this._jsPlumb.reattach = reattach === true;
        };

//        this["delete"] = function() {
//            this.endpoints[0].detachFromConnection(this);
//            this.endpoints[1].detachFromConnection(this);
//            params.deleteConnection(this);
//        };

// END INITIALISATION CODE


// COST + DIRECTIONALITY
        // if cost not supplied, try to inherit from source endpoint
        this._jsPlumb.cost = params.cost || this.endpoints[0].getConnectionCost();
        this._jsPlumb.directed = params.directed;
        // inherit directed flag if set no source endpoint
        if (params.directed == null) {
            this._jsPlumb.directed = this.endpoints[0].areConnectionsDirected();
        }
// END COST + DIRECTIONALITY

// PARAMETERS
        // merge all the parameters objects into the connection.  parameters set
        // on the connection take precedence; then source endpoint params, then
        // finally target endpoint params.
        var _p = _jp.extend({}, this.endpoints[1].getParameters());
        _jp.extend(_p, this.endpoints[0].getParameters());
        _jp.extend(_p, this.getParameters());
        this.setParameters(_p);
// END PARAMETERS

// PAINTING

        this.setConnector(this.endpoints[0].connector || this.endpoints[1].connector || params.connector || _jsPlumb.Defaults.Connector || _jp.Defaults.Connector, true);
        if (params.geometry) {
            this.connector.setGeometry(params.geometry);
        }
        var data = params.data == null || !_ju.isObject(params.data) ? {} : params.data;
        this.getData = function() { return data; };
        this.setData = function(d) { data = d || {}; };
        this.mergeData = function(d) { data = _jp.extend(data, d); };

        // the very last thing we do is apply types, if there are any.
        var _types = [ "default", this.endpoints[0].connectionType, this.endpoints[1].connectionType,  params.type ].join(" ");
        if (/[^\s]/.test(_types)) {
            this.addType(_types, params.data, true);
        }

        this.updateConnectedClass();

// END PAINTING    
    };

    _ju.extend(_jp.Connection, _jp.OverlayCapableJsPlumbUIComponent, {
        applyType: function (t, doNotRepaint, typeMap) {

            // none of these things result in the creation of objects so can be ignored.
            if (t.detachable != null) {
                this.setDetachable(t.detachable);
            }
            if (t.reattach != null) {
                this.setReattach(t.reattach);
            }
            if (t.scope) {
                this.scope = t.scope;
            }

            if (t.cssClass != null && this.canvas) {
                this._jsPlumb.instance.addClass(this.canvas, t.cssClass);
            }

            var _anchors = null;
            // this also results in the creation of objects.
            if (t.anchor) {
                // note that even if the param was anchor, we store `anchors`.
                _anchors = this.getCachedTypeItem("anchors", typeMap.anchor);
                if (_anchors == null) {
                    _anchors = [ this._jsPlumb.instance.makeAnchor(t.anchor), this._jsPlumb.instance.makeAnchor(t.anchor) ];
                    this.cacheTypeItem("anchors", _anchors, typeMap.anchor);
                }
            }
            else if (t.anchors) {
                _anchors = this.getCachedTypeItem("anchors", typeMap.anchors);
                if (_anchors == null) {
                    _anchors = [
                        this._jsPlumb.instance.makeAnchor(t.anchors[0]),
                        this._jsPlumb.instance.makeAnchor(t.anchors[1])
                    ];
                    this.cacheTypeItem("anchors", _anchors, typeMap.anchors);
                }
            }
            if (_anchors != null) {
                this.endpoints[0].anchor = _anchors[0];
                this.endpoints[1].anchor = _anchors[1];
                if (this.endpoints[1].anchor.isDynamic) {
                    this._jsPlumb.instance.repaint(this.endpoints[1].elementId);
                }
            }

            _jp.OverlayCapableJsPlumbUIComponent.applyType(this, t);
        },
        addClass: function (c, informEndpoints) {
            if (informEndpoints) {
                this.endpoints[0].addClass(c);
                this.endpoints[1].addClass(c);
                if (this.suspendedEndpoint) {
                    this.suspendedEndpoint.addClass(c);
                }
            }
            if (this.connector) {
                this.connector.addClass(c);
            }
        },
        removeClass: function (c, informEndpoints) {
            if (informEndpoints) {
                this.endpoints[0].removeClass(c);
                this.endpoints[1].removeClass(c);
                if (this.suspendedEndpoint) {
                    this.suspendedEndpoint.removeClass(c);
                }
            }
            if (this.connector) {
                this.connector.removeClass(c);
            }
        },
        isVisible: function () {
            return this._jsPlumb.visible;
        },
        setVisible: function (v) {
            this._jsPlumb.visible = v;
            if (this.connector) {
                this.connector.setVisible(v);
            }
            this.repaint();
        },
        cleanup: function () {
            this.updateConnectedClass(true);
            this.endpoints = null;
            this.source = null;
            this.target = null;
            if (this.connector != null) {
                this.connector.cleanup(true);
                this.connector.destroy(true);
            }
            this.connector = null;
        },
        updateConnectedClass:function(remove) {
            if (this._jsPlumb) {
                _updateConnectedClass(this, this.source, this._jsPlumb.instance, remove);
                _updateConnectedClass(this, this.target, this._jsPlumb.instance, remove);
            }
        },
        setHover: function (state) {
            if (this.connector && this._jsPlumb && !this._jsPlumb.instance.isConnectionBeingDragged()) {
                this.connector.setHover(state);
                root.jsPlumb[state ? "addClass" : "removeClass"](this.source, this._jsPlumb.instance.hoverSourceClass);
                root.jsPlumb[state ? "addClass" : "removeClass"](this.target, this._jsPlumb.instance.hoverTargetClass);
            }
        },
        getUuids:function() {
            return [ this.endpoints[0].getUuid(), this.endpoints[1].getUuid() ];
        },
        getCost: function () {
            return this._jsPlumb ? this._jsPlumb.cost : -Infinity;
        },
        setCost: function (c) {
            this._jsPlumb.cost = c;
        },
        isDirected: function () {
            return this._jsPlumb.directed === true;
        },
        getConnector: function () {
            return this.connector;
        },
        getGeometry : function() {
            return this.connector ? this.connector.getGeometry() : null;
        },
        setGeometry : function(g) {
            if (this.connector) {
                this.connector.setGeometry(g);
            }
        },
        prepareConnector:function(connectorSpec, typeId) {
            var connectorArgs = {
                    _jsPlumb: this._jsPlumb.instance,
                    cssClass: (this._jsPlumb.params.cssClass || "") + (this.isEditable() ? this._jsPlumb.instance.editableConnectorClass : ""),
                    container: this._jsPlumb.params.container,
                    "pointer-events": this._jsPlumb.params["pointer-events"],
                    editable:this.editableRequested
                },
                renderMode = this._jsPlumb.instance.getRenderMode(),
                connector;

            if (_ju.isString(connectorSpec)) {
                connector = makeConnector(this._jsPlumb.instance, renderMode, connectorSpec, connectorArgs, this);
            } // lets you use a string as shorthand.
            else if (_ju.isArray(connectorSpec)) {
                if (connectorSpec.length === 1) {
                    connector = makeConnector(this._jsPlumb.instance, renderMode, connectorSpec[0], connectorArgs, this);
                }
                else {
                    connector = makeConnector(this._jsPlumb.instance, renderMode, connectorSpec[0], _ju.merge(connectorSpec[1], connectorArgs), this);
                }
            }
            if (typeId != null) {
                connector.typeId = typeId;
            }
            return connector;
        },
        setPreparedConnector: function(connector, doNotRepaint, doNotChangeListenerComponent, typeId) {

            var previous, previousClasses = "";
            // the connector will not be cleaned up if it was set as part of a type, because `typeId` will be set on it
            // and we havent passed in `true` for "force" here.
            if (this.connector != null) {
                previous = this.connector;
                previousClasses = previous.getClass();
                this.connector.cleanup();
                this.connector.destroy();
            }

            this.connector = connector;
            if (typeId) {
                this.cacheTypeItem("connector", connector, typeId);
            }

            this.canvas = this.connector.canvas;
            this.bgCanvas = this.connector.bgCanvas;

            // put classes from prior connector onto the canvas
            this.addClass(previousClasses);

            // new: instead of binding listeners per connector, we now just have one delegate on the container.
            // so for that handler we set the connection as the '_jsPlumb' member of the canvas element, and
            // bgCanvas, if it exists, which it does right now in the VML renderer, so it won't from v 2.0.0 onwards.
            if (this.canvas) {
                this.canvas._jsPlumb = this;
            }
            if (this.bgCanvas) {
                this.bgCanvas._jsPlumb = this;
            }

            if (previous != null) {
                var o = this.getOverlays();
                for (var i = 0; i < o.length; i++) {
                    if (o[i].transfer) {
                        o[i].transfer(this.connector);
                    }
                }
            }

            if (!doNotChangeListenerComponent) {
                this.setListenerComponent(this.connector);
            }
            if (!doNotRepaint) {
                this.repaint();
            }
        },
        setConnector: function (connectorSpec, doNotRepaint, doNotChangeListenerComponent, typeId) {
            var connector = this.prepareConnector(connectorSpec, typeId);
            this.setPreparedConnector(connector, doNotRepaint, doNotChangeListenerComponent, typeId);
        },
        paint: function (params) {

            if (!this._jsPlumb.instance.isSuspendDrawing() && this._jsPlumb.visible) {
                params = params || {};
                var timestamp = params.timestamp,
                // if the moving object is not the source we must transpose the two references.
                    swap = false,
                    tId = swap ? this.sourceId : this.targetId, sId = swap ? this.targetId : this.sourceId,
                    tIdx = swap ? 0 : 1, sIdx = swap ? 1 : 0;

                if (timestamp == null || timestamp !== this._jsPlumb.lastPaintedAt) {
                    var sourceInfo = this._jsPlumb.instance.updateOffset({elId:sId}).o,
                        targetInfo = this._jsPlumb.instance.updateOffset({elId:tId}).o,
                        sE = this.endpoints[sIdx], tE = this.endpoints[tIdx];

                    var sAnchorP = sE.anchor.getCurrentLocation({xy: [sourceInfo.left, sourceInfo.top], wh: [sourceInfo.width, sourceInfo.height], element: sE, timestamp: timestamp}),
                        tAnchorP = tE.anchor.getCurrentLocation({xy: [targetInfo.left, targetInfo.top], wh: [targetInfo.width, targetInfo.height], element: tE, timestamp: timestamp});

                    this.connector.resetBounds();

                    this.connector.compute({
                        sourcePos: sAnchorP,
                        targetPos: tAnchorP,
                        sourceEndpoint: this.endpoints[sIdx],
                        targetEndpoint: this.endpoints[tIdx],
                        "stroke-width": this._jsPlumb.paintStyleInUse.strokeWidth,
                        sourceInfo: sourceInfo,
                        targetInfo: targetInfo
                    });

                    var overlayExtents = { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity };

                    // compute overlays. we do this first so we can get their placements, and adjust the
                    // container if needs be (if an overlay would be clipped)
                    for (var i in this._jsPlumb.overlays) {
                        if (this._jsPlumb.overlays.hasOwnProperty(i)) {
                            var o = this._jsPlumb.overlays[i];
                            if (o.isVisible()) {
                                this._jsPlumb.overlayPlacements[i] = o.draw(this.connector, this._jsPlumb.paintStyleInUse, this.getAbsoluteOverlayPosition(o));
                                overlayExtents.minX = Math.min(overlayExtents.minX, this._jsPlumb.overlayPlacements[i].minX);
                                overlayExtents.maxX = Math.max(overlayExtents.maxX, this._jsPlumb.overlayPlacements[i].maxX);
                                overlayExtents.minY = Math.min(overlayExtents.minY, this._jsPlumb.overlayPlacements[i].minY);
                                overlayExtents.maxY = Math.max(overlayExtents.maxY, this._jsPlumb.overlayPlacements[i].maxY);
                            }
                        }
                    }

                    var lineWidth = parseFloat(this._jsPlumb.paintStyleInUse.strokeWidth || 1) / 2,
                        outlineWidth = parseFloat(this._jsPlumb.paintStyleInUse.strokeWidth || 0),
                        extents = {
                            xmin: Math.min(this.connector.bounds.minX - (lineWidth + outlineWidth), overlayExtents.minX),
                            ymin: Math.min(this.connector.bounds.minY - (lineWidth + outlineWidth), overlayExtents.minY),
                            xmax: Math.max(this.connector.bounds.maxX + (lineWidth + outlineWidth), overlayExtents.maxX),
                            ymax: Math.max(this.connector.bounds.maxY + (lineWidth + outlineWidth), overlayExtents.maxY)
                        };
                    // paint the connector.
                    this.connector.paint(this._jsPlumb.paintStyleInUse, null, extents);
                    // and then the overlays
                    for (var j in this._jsPlumb.overlays) {
                        if (this._jsPlumb.overlays.hasOwnProperty(j)) {
                            var p = this._jsPlumb.overlays[j];
                            if (p.isVisible()) {
                                p.paint(this._jsPlumb.overlayPlacements[j], extents);
                            }
                        }
                    }
                }
                this._jsPlumb.lastPaintedAt = timestamp;
            }
        },
        repaint: function (params) {
            params = params || {};
            this.paint({ elId: this.sourceId, recalc: !(params.recalc === false), timestamp: params.timestamp});
        },
        prepareEndpoint: function (_jsPlumb, _newEndpoint, conn, existing, index, params, element, elementId) {
            var e;
            if (existing) {
                conn.endpoints[index] = existing;
                existing.addConnection(conn);
            } else {
                if (!params.endpoints) {
                    params.endpoints = [ null, null ];
                }
                var ep = params.endpoints[index] || params.endpoint || _jsPlumb.Defaults.Endpoints[index] || _jp.Defaults.Endpoints[index] || _jsPlumb.Defaults.Endpoint || _jp.Defaults.Endpoint;
                if (!params.endpointStyles) {
                    params.endpointStyles = [ null, null ];
                }
                if (!params.endpointHoverStyles) {
                    params.endpointHoverStyles = [ null, null ];
                }
                var es = params.endpointStyles[index] || params.endpointStyle || _jsPlumb.Defaults.EndpointStyles[index] || _jp.Defaults.EndpointStyles[index] || _jsPlumb.Defaults.EndpointStyle || _jp.Defaults.EndpointStyle;
                // Endpoints derive their fill from the connector's stroke, if no fill was specified.
                if (es.fill == null && params.paintStyle != null) {
                    es.fill = params.paintStyle.stroke;
                }

                if (es.outlineStroke == null && params.paintStyle != null) {
                    es.outlineStroke = params.paintStyle.outlineStroke;
                }
                if (es.outlineWidth == null && params.paintStyle != null) {
                    es.outlineWidth = params.paintStyle.outlineWidth;
                }

                var ehs = params.endpointHoverStyles[index] || params.endpointHoverStyle || _jsPlumb.Defaults.EndpointHoverStyles[index] || _jp.Defaults.EndpointHoverStyles[index] || _jsPlumb.Defaults.EndpointHoverStyle || _jp.Defaults.EndpointHoverStyle;
                // endpoint hover fill style is derived from connector's hover stroke style
                if (params.hoverPaintStyle != null) {
                    if (ehs == null) {
                        ehs = {};
                    }
                    if (ehs.fill == null) {
                        ehs.fill = params.hoverPaintStyle.stroke;
                    }
                }
                var a = params.anchors ? params.anchors[index] :
                        params.anchor ? params.anchor :
                            _makeAnchor(_jsPlumb.Defaults.Anchors[index], elementId, _jsPlumb) ||
                            _makeAnchor(_jp.Defaults.Anchors[index], elementId, _jsPlumb) ||
                            _makeAnchor(_jsPlumb.Defaults.Anchor, elementId, _jsPlumb) ||
                            _makeAnchor(_jp.Defaults.Anchor, elementId, _jsPlumb),
                    u = params.uuids ? params.uuids[index] : null;

                e = _newEndpoint({
                    paintStyle: es, hoverPaintStyle: ehs, endpoint: ep, connections: [ conn ],
                    uuid: u, anchor: a, source: element, scope: params.scope,
                    reattach: params.reattach || _jsPlumb.Defaults.ReattachConnections,
                    detachable: params.detachable || _jsPlumb.Defaults.ConnectionsDetachable
                });
                if (existing == null) {
                    e.setDeleteOnEmpty(true);
                }
                conn.endpoints[index] = e;

                if (params.drawEndpoints === false) {
                    e.setVisible(false, true, true);
                }

            }
            return e;
        }

    }); // END Connection class            
}).call(typeof window !== 'undefined' ? window : this);

/*
 * jsPlumb Community Edition
 * 
 * Provides a way to visually connect elements on an HTML page, using SVG.
 * 
 * This file contains the code for creating and manipulating anchors.
 *
 * Copyright (c) 2010 - 2017 jsPlumb (hello@jsplumbtoolkit.com)
 * 
 * https://jsplumbtoolkit.com
 * https://github.com/jsplumb/jsplumb
 * 
 * Dual licensed under the MIT and GPL2 licenses.
 */
;
(function () {

    "use strict";

    var root = this,
        _ju = root.jsPlumbUtil,
        _jp = root.jsPlumb;

    //
    // manages anchors for all elements.
    //
    _jp.AnchorManager = function (params) {
        var _amEndpoints = {},
            continuousAnchorLocations = {},
            userDefinedContinuousAnchorLocations = {},
            continuousAnchorOrientations = {},
            Orientation = { HORIZONTAL: "horizontal", VERTICAL: "vertical", DIAGONAL: "diagonal", IDENTITY: "identity" },
            axes = ["left", "top", "right", "bottom"],
            connectionsByElementId = {},
            self = this,
            anchorLists = {},
            jsPlumbInstance = params.jsPlumbInstance,
            floatingConnections = {},
            calculateOrientation = function (sourceId, targetId, sd, td, sourceAnchor, targetAnchor) {

                if (sourceId === targetId) {
                    return {
                        orientation: Orientation.IDENTITY,
                        a: ["top", "top"]
                    };
                }

                var theta = Math.atan2((td.centery - sd.centery), (td.centerx - sd.centerx)),
                    theta2 = Math.atan2((sd.centery - td.centery), (sd.centerx - td.centerx));

// --------------------------------------------------------------------------------------

                // improved face calculation. get midpoints of each face for source and target, then put in an array with all combinations of
                // source/target faces. sort this array by distance between midpoints. the entry at index 0 is our preferred option. we can
                // go through the array one by one until we find an entry in which each requested face is supported.
                var candidates = [], midpoints = { };
                (function (types, dim) {
                    for (var i = 0; i < types.length; i++) {
                        midpoints[types[i]] = {
                            "left": [ dim[i].left, dim[i].centery ],
                            "right": [ dim[i].right, dim[i].centery ],
                            "top": [ dim[i].centerx, dim[i].top ],
                            "bottom": [ dim[i].centerx , dim[i].bottom]
                        };
                    }
                })([ "source", "target" ], [ sd, td ]);

                for (var sf = 0; sf < axes.length; sf++) {
                    for (var tf = 0; tf < axes.length; tf++) {
                        candidates.push({
                            source: axes[sf],
                            target: axes[tf],
                            dist: Biltong.lineLength(midpoints.source[axes[sf]], midpoints.target[axes[tf]])
                        });
                    }
                }

                candidates.sort(function (a, b) {
                    return a.dist < b.dist ? -1 : a.dist > b.dist ? 1 : 0;
                });

                // now go through this list and try to get an entry that satisfies both (there will be one, unless one of the anchors
                // declares no available faces)
                var sourceEdge = candidates[0].source, targetEdge = candidates[0].target;
                for (var i = 0; i < candidates.length; i++) {

                    if (!sourceAnchor.isContinuous || sourceAnchor.isEdgeSupported(candidates[i].source)) {
                        sourceEdge = candidates[i].source;
                    }
                    else {
                        sourceEdge = null;
                    }

                    if (!targetAnchor.isContinuous || targetAnchor.isEdgeSupported(candidates[i].target)) {
                        targetEdge = candidates[i].target;
                    }
                    else {
                        targetEdge = null;
                    }

                    if (sourceEdge != null && targetEdge != null) {
                        break;
                    }
                }

// --------------------------------------------------------------------------------------

                return {
                    a: [ sourceEdge, targetEdge ],
                    theta: theta,
                    theta2: theta2
                };
            },
        // used by placeAnchors function
            placeAnchorsOnLine = function (desc, elementDimensions, elementPosition, connections, horizontal, otherMultiplier, reverse) {
                var a = [], step = elementDimensions[horizontal ? 0 : 1] / (connections.length + 1);

                for (var i = 0; i < connections.length; i++) {
                    var val = (i + 1) * step, other = otherMultiplier * elementDimensions[horizontal ? 1 : 0];
                    if (reverse) {
                        val = elementDimensions[horizontal ? 0 : 1] - val;
                    }

                    var dx = (horizontal ? val : other), x = elementPosition[0] + dx, xp = dx / elementDimensions[0],
                        dy = (horizontal ? other : val), y = elementPosition[1] + dy, yp = dy / elementDimensions[1];

                    a.push([ x, y, xp, yp, connections[i][1], connections[i][2] ]);
                }

                return a;
            },
        // used by edgeSortFunctions
            currySort = function (reverseAngles) {
                return function (a, b) {
                    var r = true;
                    if (reverseAngles) {
                        r = a[0][0] < b[0][0];
                    }
                    else {
                        r = a[0][0] > b[0][0];
                    }
                    return r === false ? -1 : 1;
                };
            },
        // used by edgeSortFunctions
            leftSort = function (a, b) {
                // first get adjusted values
                var p1 = a[0][0] < 0 ? -Math.PI - a[0][0] : Math.PI - a[0][0],
                    p2 = b[0][0] < 0 ? -Math.PI - b[0][0] : Math.PI - b[0][0];
                if (p1 > p2) {
                    return 1;
                }
                else {
                    return -1;
                }
            },
        // used by placeAnchors
            edgeSortFunctions = {
                "top": function (a, b) {
                    return a[0] > b[0] ? 1 : -1;
                },
                "right": currySort(true),
                "bottom": currySort(true),
                "left": leftSort
            },
        // used by placeAnchors
            _sortHelper = function (_array, _fn) {
                return _array.sort(_fn);
            },
        // used by AnchorManager.redraw
            placeAnchors = function (elementId, _anchorLists) {
                var cd = jsPlumbInstance.getCachedData(elementId), sS = cd.s, sO = cd.o,
                    placeSomeAnchors = function (desc, elementDimensions, elementPosition, unsortedConnections, isHorizontal, otherMultiplier, orientation) {
                        if (unsortedConnections.length > 0) {
                            var sc = _sortHelper(unsortedConnections, edgeSortFunctions[desc]), // puts them in order based on the target element's pos on screen
                                reverse = desc === "right" || desc === "top",
                                anchors = placeAnchorsOnLine(desc, elementDimensions,
                                    elementPosition, sc,
                                    isHorizontal, otherMultiplier, reverse);

                            // takes a computed anchor position and adjusts it for parent offset and scroll, then stores it.
                            var _setAnchorLocation = function (endpoint, anchorPos) {
                                continuousAnchorLocations[endpoint.id] = [ anchorPos[0], anchorPos[1], anchorPos[2], anchorPos[3] ];
                                continuousAnchorOrientations[endpoint.id] = orientation;
                            };

                            for (var i = 0; i < anchors.length; i++) {
                                var c = anchors[i][4], weAreSource = c.endpoints[0].elementId === elementId, weAreTarget = c.endpoints[1].elementId === elementId;
                                if (weAreSource) {
                                    _setAnchorLocation(c.endpoints[0], anchors[i]);
                                }
                                if (weAreTarget) {
                                    _setAnchorLocation(c.endpoints[1], anchors[i]);
                                }
                            }
                        }
                    };

                placeSomeAnchors("bottom", sS, [sO.left, sO.top], _anchorLists.bottom, true, 1, [0, 1]);
                placeSomeAnchors("top", sS, [sO.left, sO.top], _anchorLists.top, true, 0, [0, -1]);
                placeSomeAnchors("left", sS, [sO.left, sO.top], _anchorLists.left, false, 0, [-1, 0]);
                placeSomeAnchors("right", sS, [sO.left, sO.top], _anchorLists.right, false, 1, [1, 0]);
            };

        this.reset = function () {
            _amEndpoints = {};
            connectionsByElementId = {};
            anchorLists = {};
        };
        this.addFloatingConnection = function (key, conn) {
            floatingConnections[key] = conn;
        };
        this.removeFloatingConnection = function (key) {
            delete floatingConnections[key];
        };
        this.newConnection = function (conn) {
            var sourceId = conn.sourceId, targetId = conn.targetId,
                ep = conn.endpoints,
                doRegisterTarget = true,
                registerConnection = function (otherIndex, otherEndpoint, otherAnchor, elId, c) {
                    if ((sourceId === targetId) && otherAnchor.isContinuous) {
                        // remove the target endpoint's canvas.  we dont need it.
                        conn._jsPlumb.instance.removeElement(ep[1].canvas);
                        doRegisterTarget = false;
                    }
                    _ju.addToList(connectionsByElementId, elId, [c, otherEndpoint, otherAnchor.constructor === _jp.DynamicAnchor]);
                };

            registerConnection(0, ep[0], ep[0].anchor, targetId, conn);
            if (doRegisterTarget) {
                registerConnection(1, ep[1], ep[1].anchor, sourceId, conn);
            }
        };
        var removeEndpointFromAnchorLists = function (endpoint) {
            (function (list, eId) {
                if (list) {  // transient anchors dont get entries in this list.
                    var f = function (e) {
                        return e[4] === eId;
                    };
                    _ju.removeWithFunction(list.top, f);
                    _ju.removeWithFunction(list.left, f);
                    _ju.removeWithFunction(list.bottom, f);
                    _ju.removeWithFunction(list.right, f);
                }
            })(anchorLists[endpoint.elementId], endpoint.id);
        };
        this.connectionDetached = function (connInfo, doNotRedraw) {
            var connection = connInfo.connection || connInfo,
                sourceId = connInfo.sourceId,
                targetId = connInfo.targetId,
                ep = connection.endpoints,
                removeConnection = function (otherIndex, otherEndpoint, otherAnchor, elId, c) {
                   _ju.removeWithFunction(connectionsByElementId[elId], function (_c) {
                        return _c[0].id === c.id;
                    });
                };

            removeConnection(1, ep[1], ep[1].anchor, sourceId, connection);
            removeConnection(0, ep[0], ep[0].anchor, targetId, connection);
            if (connection.floatingId) {
                removeConnection(connection.floatingIndex, connection.floatingEndpoint, connection.floatingEndpoint.anchor, connection.floatingId, connection);
                removeEndpointFromAnchorLists(connection.floatingEndpoint);
            }

            // remove from anchorLists            
            removeEndpointFromAnchorLists(connection.endpoints[0]);
            removeEndpointFromAnchorLists(connection.endpoints[1]);

            if (!doNotRedraw) {
                self.redraw(connection.sourceId);
                if (connection.targetId !== connection.sourceId) {
                    self.redraw(connection.targetId);
                }
            }
        };
        this.add = function (endpoint, elementId) {
            _ju.addToList(_amEndpoints, elementId, endpoint);
        };
        this.changeId = function (oldId, newId) {
            connectionsByElementId[newId] = connectionsByElementId[oldId];
            _amEndpoints[newId] = _amEndpoints[oldId];
            delete connectionsByElementId[oldId];
            delete _amEndpoints[oldId];
        };
        this.getConnectionsFor = function (elementId) {
            return connectionsByElementId[elementId] || [];
        };
        this.getEndpointsFor = function (elementId) {
            return _amEndpoints[elementId] || [];
        };
        this.deleteEndpoint = function (endpoint) {
            _ju.removeWithFunction(_amEndpoints[endpoint.elementId], function (e) {
                return e.id === endpoint.id;
            });
            removeEndpointFromAnchorLists(endpoint);
        };
        this.clearFor = function (elementId) {
            delete _amEndpoints[elementId];
            _amEndpoints[elementId] = [];
        };
        // updates the given anchor list by either updating an existing anchor's info, or adding it. this function
        // also removes the anchor from its previous list, if the edge it is on has changed.
        // all connections found along the way (those that are connected to one of the faces this function
        // operates on) are added to the connsToPaint list, as are their endpoints. in this way we know to repaint
        // them wthout having to calculate anything else about them.
        var _updateAnchorList = function (lists, theta, order, conn, aBoolean, otherElId, idx, reverse, edgeId, elId, connsToPaint, endpointsToPaint) {
            // first try to find the exact match, but keep track of the first index of a matching element id along the way.s
            var exactIdx = -1,
                firstMatchingElIdx = -1,
                endpoint = conn.endpoints[idx],
                endpointId = endpoint.id,
                oIdx = [1, 0][idx],
                values = [
                    [ theta, order ],
                    conn,
                    aBoolean,
                    otherElId,
                    endpointId
                ],
                listToAddTo = lists[edgeId],
                listToRemoveFrom = endpoint._continuousAnchorEdge ? lists[endpoint._continuousAnchorEdge] : null,
                i,
                candidate;

            if (listToRemoveFrom) {
                var rIdx = _ju.findWithFunction(listToRemoveFrom, function (e) {
                    return e[4] === endpointId;
                });
                if (rIdx !== -1) {
                    listToRemoveFrom.splice(rIdx, 1);
                    // get all connections from this list
                    for (i = 0; i < listToRemoveFrom.length; i++) {
                        candidate = listToRemoveFrom[i][1];
                        _ju.addWithFunction(connsToPaint, candidate, function (c) {
                            return c.id === candidate.id;
                        });
                        _ju.addWithFunction(endpointsToPaint, listToRemoveFrom[i][1].endpoints[idx], function (e) {
                            return e.id === candidate.endpoints[idx].id;
                        });
                        _ju.addWithFunction(endpointsToPaint, listToRemoveFrom[i][1].endpoints[oIdx], function (e) {
                            return e.id === candidate.endpoints[oIdx].id;
                        });
                    }
                }
            }

            for (i = 0; i < listToAddTo.length; i++) {
                candidate = listToAddTo[i][1];
                if (params.idx === 1 && listToAddTo[i][3] === otherElId && firstMatchingElIdx === -1) {
                    firstMatchingElIdx = i;
                }
                _ju.addWithFunction(connsToPaint, candidate, function (c) {
                    return c.id === candidate.id;
                });
                _ju.addWithFunction(endpointsToPaint, listToAddTo[i][1].endpoints[idx], function (e) {
                    return e.id === candidate.endpoints[idx].id;
                });
                _ju.addWithFunction(endpointsToPaint, listToAddTo[i][1].endpoints[oIdx], function (e) {
                    return e.id === candidate.endpoints[oIdx].id;
                });
            }
            if (exactIdx !== -1) {
                listToAddTo[exactIdx] = values;
            }
            else {
                var insertIdx = reverse ? firstMatchingElIdx !== -1 ? firstMatchingElIdx : 0 : listToAddTo.length; // of course we will get this from having looked through the array shortly.
                listToAddTo.splice(insertIdx, 0, values);
            }

            // store this for next time.
            endpoint._continuousAnchorEdge = edgeId;
        };

        //
        // find the entry in an endpoint's list for this connection and update its target endpoint
        // with the current target in the connection.
        // This method and sourceChanged need to be folder into one.
        //
        this.updateOtherEndpoint = function (sourceElId, oldTargetId, newTargetId, connection) {
            var sIndex = _ju.findWithFunction(connectionsByElementId[sourceElId], function (i) {
                    return i[0].id === connection.id;
                }),
                tIndex = _ju.findWithFunction(connectionsByElementId[oldTargetId], function (i) {
                    return i[0].id === connection.id;
                });

            // update or add data for source
            if (sIndex !== -1) {
                connectionsByElementId[sourceElId][sIndex][0] = connection;
                connectionsByElementId[sourceElId][sIndex][1] = connection.endpoints[1];
                connectionsByElementId[sourceElId][sIndex][2] = connection.endpoints[1].anchor.constructor === _jp.DynamicAnchor;
            }

            // remove entry for previous target (if there)
            if (tIndex > -1) {
                connectionsByElementId[oldTargetId].splice(tIndex, 1);
                // add entry for new target
                _ju.addToList(connectionsByElementId, newTargetId, [connection, connection.endpoints[0], connection.endpoints[0].anchor.constructor === _jp.DynamicAnchor]);
            }

            connection.updateConnectedClass();
        };

        //
        // notification that the connection given has changed source from the originalId to the newId.
        // This involves:
        // 1. removing the connection from the list of connections stored for the originalId
        // 2. updating the source information for the target of the connection
        // 3. re-registering the connection in connectionsByElementId with the newId
        //
        this.sourceChanged = function (originalId, newId, connection, newElement) {
            if (originalId !== newId) {

                connection.sourceId = newId;
                connection.source = newElement;

                // remove the entry that points from the old source to the target
                _ju.removeWithFunction(connectionsByElementId[originalId], function (info) {
                    return info[0].id === connection.id;
                });
                // find entry for target and update it
                var tIdx = _ju.findWithFunction(connectionsByElementId[connection.targetId], function (i) {
                    return i[0].id === connection.id;
                });
                if (tIdx > -1) {
                    connectionsByElementId[connection.targetId][tIdx][0] = connection;
                    connectionsByElementId[connection.targetId][tIdx][1] = connection.endpoints[0];
                    connectionsByElementId[connection.targetId][tIdx][2] = connection.endpoints[0].anchor.constructor === _jp.DynamicAnchor;
                }
                // add entry for new source
                _ju.addToList(connectionsByElementId, newId, [connection, connection.endpoints[1], connection.endpoints[1].anchor.constructor === _jp.DynamicAnchor]);

                // TODO SP not final on this yet. when a user drags an existing connection and it turns into a self
                // loop, then this code hides the target endpoint (by removing it from the DOM) But I think this should
                // occur only if the anchor is Continuous
                if (connection.endpoints[1].anchor.isContinuous) {
                    if (connection.source === connection.target) {
                        connection._jsPlumb.instance.removeElement(connection.endpoints[1].canvas);
                    }
                    else {
                        if (connection.endpoints[1].canvas.parentNode == null) {
                            connection._jsPlumb.instance.appendElement(connection.endpoints[1].canvas);
                        }
                    }
                }

                connection.updateConnectedClass();
            }
        };

        //
        // moves the given endpoint from `currentId` to `element`.
        // This involves:
        //
        // 1. changing the key in _amEndpoints under which the endpoint is stored
        // 2. changing the source or target values in all of the endpoint's connections
        // 3. changing the array in connectionsByElementId in which the endpoint's connections
        //    are stored (done by either sourceChanged or updateOtherEndpoint)
        //
        this.rehomeEndpoint = function (ep, currentId, element) {
            var eps = _amEndpoints[currentId] || [],
                elementId = jsPlumbInstance.getId(element);

            if (elementId !== currentId) {
                var idx = eps.indexOf(ep);
                if (idx > -1) {
                    var _ep = eps.splice(idx, 1)[0];
                    self.add(_ep, elementId);
                }
            }

            for (var i = 0; i < ep.connections.length; i++) {
                if (ep.connections[i].sourceId === currentId) {
                    self.sourceChanged(currentId, ep.elementId, ep.connections[i], ep.element);
                }
                else if (ep.connections[i].targetId === currentId) {
                    ep.connections[i].targetId = ep.elementId;
                    ep.connections[i].target = ep.element;
                    self.updateOtherEndpoint(ep.connections[i].sourceId, currentId, ep.elementId, ep.connections[i]);
                }
            }
        };

        this.redraw = function (elementId, ui, timestamp, offsetToUI, clearEdits, doNotRecalcEndpoint) {

            if (!jsPlumbInstance.isSuspendDrawing()) {
                // get all the endpoints for this element
                var ep = _amEndpoints[elementId] || [],
                    endpointConnections = connectionsByElementId[elementId] || [],
                    connectionsToPaint = [],
                    endpointsToPaint = [],
                    anchorsToUpdate = [];

                timestamp = timestamp || jsPlumbInstance.timestamp();
                // offsetToUI are values that would have been calculated in the dragManager when registering
                // an endpoint for an element that had a parent (somewhere in the hierarchy) that had been
                // registered as draggable.
                offsetToUI = offsetToUI || {left: 0, top: 0};
                if (ui) {
                    ui = {
                        left: ui.left + offsetToUI.left,
                        top: ui.top + offsetToUI.top
                    };
                }

                // valid for one paint cycle.
                var myOffset = jsPlumbInstance.updateOffset({ elId: elementId, offset: ui, recalc: false, timestamp: timestamp }),
                    orientationCache = {};

                // actually, first we should compute the orientation of this element to all other elements to which
                // this element is connected with a continuous anchor (whether both ends of the connection have
                // a continuous anchor or just one)

                for (var i = 0; i < endpointConnections.length; i++) {
                    var conn = endpointConnections[i][0],
                        sourceId = conn.sourceId,
                        targetId = conn.targetId,
                        sourceContinuous = conn.endpoints[0].anchor.isContinuous,
                        targetContinuous = conn.endpoints[1].anchor.isContinuous;

                    if (sourceContinuous || targetContinuous) {
                        var oKey = sourceId + "_" + targetId,
                            o = orientationCache[oKey],
                            oIdx = conn.sourceId === elementId ? 1 : 0;

                        if (sourceContinuous && !anchorLists[sourceId]) {
                            anchorLists[sourceId] = { top: [], right: [], bottom: [], left: [] };
                        }
                        if (targetContinuous && !anchorLists[targetId]) {
                            anchorLists[targetId] = { top: [], right: [], bottom: [], left: [] };
                        }

                        if (elementId !== targetId) {
                            jsPlumbInstance.updateOffset({ elId: targetId, timestamp: timestamp });
                        }
                        if (elementId !== sourceId) {
                            jsPlumbInstance.updateOffset({ elId: sourceId, timestamp: timestamp });
                        }

                        var td = jsPlumbInstance.getCachedData(targetId),
                            sd = jsPlumbInstance.getCachedData(sourceId);

                        if (targetId === sourceId && (sourceContinuous || targetContinuous)) {
                            // here we may want to improve this by somehow determining the face we'd like
                            // to put the connector on.  ideally, when drawing, the face should be calculated
                            // by determining which face is closest to the point at which the mouse button
                            // was released.  for now, we're putting it on the top face.
                            _updateAnchorList( anchorLists[sourceId], -Math.PI / 2, 0, conn, false, targetId, 0, false, "top", sourceId, connectionsToPaint, endpointsToPaint);
                            _updateAnchorList( anchorLists[targetId], -Math.PI / 2, 0, conn, false, sourceId, 1, false, "top", targetId, connectionsToPaint, endpointsToPaint);
                        }
                        else {
                            if (!o) {
                                o = calculateOrientation(sourceId, targetId, sd.o, td.o, conn.endpoints[0].anchor, conn.endpoints[1].anchor);
                                orientationCache[oKey] = o;
                                // this would be a performance enhancement, but the computed angles need to be clamped to
                                //the (-PI/2 -> PI/2) range in order for the sorting to work properly.
                                /*  orientationCache[oKey2] = {
                                 orientation:o.orientation,
                                 a:[o.a[1], o.a[0]],
                                 theta:o.theta + Math.PI,
                                 theta2:o.theta2 + Math.PI
                                 };*/
                            }
                            if (sourceContinuous) {
                                _updateAnchorList(anchorLists[sourceId], o.theta, 0, conn, false, targetId, 0, false, o.a[0], sourceId, connectionsToPaint, endpointsToPaint);
                            }
                            if (targetContinuous) {
                                _updateAnchorList(anchorLists[targetId], o.theta2, -1, conn, true, sourceId, 1, true, o.a[1], targetId, connectionsToPaint, endpointsToPaint);
                            }
                        }

                        if (sourceContinuous) {
                            _ju.addWithFunction(anchorsToUpdate, sourceId, function (a) {
                                return a === sourceId;
                            });
                        }
                        if (targetContinuous) {
                            _ju.addWithFunction(anchorsToUpdate, targetId, function (a) {
                                return a === targetId;
                            });
                        }
                        _ju.addWithFunction(connectionsToPaint, conn, function (c) {
                            return c.id === conn.id;
                        });
                        if ((sourceContinuous && oIdx === 0) || (targetContinuous && oIdx === 1)) {
                            _ju.addWithFunction(endpointsToPaint, conn.endpoints[oIdx], function (e) {
                                return e.id === conn.endpoints[oIdx].id;
                            });
                        }
                    }
                }

                // place Endpoints whose anchors are continuous but have no Connections
                for (i = 0; i < ep.length; i++) {
                    if (ep[i].connections.length === 0 && ep[i].anchor.isContinuous) {
                        if (!anchorLists[elementId]) {
                            anchorLists[elementId] = { top: [], right: [], bottom: [], left: [] };
                        }
                        _updateAnchorList(anchorLists[elementId], -Math.PI / 2, 0, {endpoints: [ep[i], ep[i]], paint: function () {
                        }}, false, elementId, 0, false, ep[i].anchor.getDefaultFace(), elementId, connectionsToPaint, endpointsToPaint);
                        _ju.addWithFunction(anchorsToUpdate, elementId, function (a) {
                            return a === elementId;
                        });
                    }
                }

                // now place all the continuous anchors we need to;
                for (i = 0; i < anchorsToUpdate.length; i++) {
                    placeAnchors(anchorsToUpdate[i], anchorLists[anchorsToUpdate[i]]);
                }

                // now that continuous anchors have been placed, paint all the endpoints for this element
                // TODO performance: add the endpoint ids to a temp array, and then when iterating in the next
                // loop, check that we didn't just paint that endpoint. we can probably shave off a few more milliseconds this way.
                for (i = 0; i < ep.length; i++) {
                    ep[i].paint({ timestamp: timestamp, offset: myOffset, dimensions: myOffset.s, recalc: doNotRecalcEndpoint !== true });
                }

                // ... and any other endpoints we came across as a result of the continuous anchors.
                for (i = 0; i < endpointsToPaint.length; i++) {
                    var cd = jsPlumbInstance.getCachedData(endpointsToPaint[i].elementId);
                    endpointsToPaint[i].paint({ timestamp: timestamp, offset: cd, dimensions: cd.s });
                }

                // paint all the standard and "dynamic connections", which are connections whose other anchor is
                // static and therefore does need to be recomputed; we make sure that happens only one time.

                // TODO we could have compiled a list of these in the first pass through connections; might save some time.
                for (i = 0; i < endpointConnections.length; i++) {
                    var otherEndpoint = endpointConnections[i][1];
                    if (otherEndpoint.anchor.constructor === _jp.DynamicAnchor) {
                        otherEndpoint.paint({ elementWithPrecedence: elementId, timestamp: timestamp });
                        _ju.addWithFunction(connectionsToPaint, endpointConnections[i][0], function (c) {
                            return c.id === endpointConnections[i][0].id;
                        });
                        // all the connections for the other endpoint now need to be repainted
                        for (var k = 0; k < otherEndpoint.connections.length; k++) {
                            if (otherEndpoint.connections[k] !== endpointConnections[i][0]) {
                                _ju.addWithFunction(connectionsToPaint, otherEndpoint.connections[k], function (c) {
                                    return c.id === otherEndpoint.connections[k].id;
                                });
                            }
                        }
                    } else if (otherEndpoint.anchor.constructor === _jp.Anchor) {
                        _ju.addWithFunction(connectionsToPaint, endpointConnections[i][0], function (c) {
                            return c.id === endpointConnections[i][0].id;
                        });
                    }
                }

                // paint current floating connection for this element, if there is one.
                var fc = floatingConnections[elementId];
                if (fc) {
                    fc.paint({timestamp: timestamp, recalc: false, elId: elementId});
                }

                // paint all the connections
                for (i = 0; i < connectionsToPaint.length; i++) {
                    connectionsToPaint[i].paint({elId: elementId, timestamp: timestamp, recalc: false, clearEdits: clearEdits});
                }
            }
        };

        var ContinuousAnchor = function (anchorParams) {
            _ju.EventGenerator.apply(this);
            this.type = "Continuous";
            this.isDynamic = true;
            this.isContinuous = true;
            var faces = anchorParams.faces || ["top", "right", "bottom", "left"],
                clockwise = !(anchorParams.clockwise === false),
                availableFaces = { },
                opposites = { "top": "bottom", "right": "left", "left": "right", "bottom": "top" },
                clockwiseOptions = { "top": "right", "right": "bottom", "left": "top", "bottom": "left" },
                antiClockwiseOptions = { "top": "left", "right": "top", "left": "bottom", "bottom": "right" },
                secondBest = clockwise ? clockwiseOptions : antiClockwiseOptions,
                lastChoice = clockwise ? antiClockwiseOptions : clockwiseOptions,
                cssClass = anchorParams.cssClass || "";

            for (var i = 0; i < faces.length; i++) {
                availableFaces[faces[i]] = true;
            }

            this.getDefaultFace = function () {
                return faces.length === 0 ? "top" : faces[0];
            };

            // if the given edge is supported, returns it. otherwise looks for a substitute that _is_
            // supported. if none supported we also return the request edge.
            this.verifyEdge = function (edge) {
                if (availableFaces[edge]) {
                    return edge;
                }
                else if (availableFaces[opposites[edge]]) {
                    return opposites[edge];
                }
                else if (availableFaces[secondBest[edge]]) {
                    return secondBest[edge];
                }
                else if (availableFaces[lastChoice[edge]]) {
                    return lastChoice[edge];
                }
                return edge; // we have to give them something.
            };

            this.isEdgeSupported = function (edge) {
                return availableFaces[edge] === true;
            };

            this.compute = function (params) {
                return userDefinedContinuousAnchorLocations[params.element.id] || continuousAnchorLocations[params.element.id] || [0, 0];
            };
            this.getCurrentLocation = function (params) {
                return userDefinedContinuousAnchorLocations[params.element.id] || continuousAnchorLocations[params.element.id] || [0, 0];
            };
            this.getOrientation = function (endpoint) {
                return continuousAnchorOrientations[endpoint.id] || [0, 0];
            };
            this.clearUserDefinedLocation = function () {
                delete userDefinedContinuousAnchorLocations[anchorParams.elementId];
            };
            this.setUserDefinedLocation = function (loc) {
                userDefinedContinuousAnchorLocations[anchorParams.elementId] = loc;
            };
            this.getCssClass = function () {
                return cssClass;
            };
        };

        // continuous anchors
        jsPlumbInstance.continuousAnchorFactory = {
            get: function (params) {
                return new ContinuousAnchor(params);
            },
            clear: function (elementId) {
                delete userDefinedContinuousAnchorLocations[elementId];
                delete continuousAnchorLocations[elementId];
            }
        };
    };

    /**
     * Anchors model a position on some element at which an Endpoint may be located.  They began as a first class citizen of jsPlumb, ie. a user
     * was required to create these themselves, but over time this has been replaced by the concept of referring to them either by name (eg. "TopMiddle"),
     * or by an array describing their coordinates (eg. [ 0, 0.5, 0, -1 ], which is the same as "TopMiddle").  jsPlumb now handles all of the
     * creation of Anchors without user intervention.
     */
    _jp.Anchor = function (params) {
        this.x = params.x || 0;
        this.y = params.y || 0;
        this.elementId = params.elementId;
        this.cssClass = params.cssClass || "";
        this.userDefinedLocation = null;
        this.orientation = params.orientation || [ 0, 0 ];
        this.lastReturnValue = null;
        this.offsets = params.offsets || [ 0, 0 ];
        this.timestamp = null;

        _ju.EventGenerator.apply(this);

        this.compute = function (params) {

            var xy = params.xy, wh = params.wh, timestamp = params.timestamp;

            if (params.clearUserDefinedLocation) {
                this.userDefinedLocation = null;
            }

            if (timestamp && timestamp === this.timestamp) {
                return this.lastReturnValue;
            }

            if (this.userDefinedLocation != null) {
                this.lastReturnValue = this.userDefinedLocation;
            }
            else {
                this.lastReturnValue = [ xy[0] + (this.x * wh[0]) + this.offsets[0], xy[1] + (this.y * wh[1]) + this.offsets[1] ];
            }

            this.timestamp = timestamp;
            return this.lastReturnValue;
        };

        this.getCurrentLocation = function (params) {
            params = params || {};
            return (this.lastReturnValue == null || (params.timestamp != null && this.timestamp !== params.timestamp)) ? this.compute(params) : this.lastReturnValue;
        };
    };
    _ju.extend(_jp.Anchor, _ju.EventGenerator, {
        equals: function (anchor) {
            if (!anchor) {
                return false;
            }
            var ao = anchor.getOrientation(),
                o = this.getOrientation();
            return this.x === anchor.x && this.y === anchor.y && this.offsets[0] === anchor.offsets[0] && this.offsets[1] === anchor.offsets[1] && o[0] === ao[0] && o[1] === ao[1];
        },
        getUserDefinedLocation: function () {
            return this.userDefinedLocation;
        },
        setUserDefinedLocation: function (l) {
            this.userDefinedLocation = l;
        },
        clearUserDefinedLocation: function () {
            this.userDefinedLocation = null;
        },
        getOrientation: function () {
            return this.orientation;
        },
        getCssClass: function () {
            return this.cssClass;
        }
    });

    /**
     * An Anchor that floats. its orientation is computed dynamically from
     * its position relative to the anchor it is floating relative to.  It is used when creating
     * a connection through drag and drop.
     *
     * TODO FloatingAnchor could totally be refactored to extend Anchor just slightly.
     */
    _jp.FloatingAnchor = function (params) {

        _jp.Anchor.apply(this, arguments);

        // this is the anchor that this floating anchor is referenced to for
        // purposes of calculating the orientation.
        var ref = params.reference,
            // the canvas this refers to.
            refCanvas = params.referenceCanvas,
            size = _jp.getSize(refCanvas),
            // these are used to store the current relative position of our
            // anchor wrt the reference anchor. they only indicate
            // direction, so have a value of 1 or -1 (or, very rarely, 0). these
            // values are written by the compute method, and read
            // by the getOrientation method.
            xDir = 0, yDir = 0,
            // temporary member used to store an orientation when the floating
            // anchor is hovering over another anchor.
            orientation = null,
            _lastResult = null;

        // clear from parent. we want floating anchor orientation to always be computed.
        this.orientation = null;

        // set these to 0 each; they are used by certain types of connectors in the loopback case,
        // when the connector is trying to clear the element it is on. but for floating anchor it's not
        // very important.
        this.x = 0;
        this.y = 0;

        this.isFloating = true;

        this.compute = function (params) {
            var xy = params.xy,
                result = [ xy[0] + (size[0] / 2), xy[1] + (size[1] / 2) ]; // return origin of the element. we may wish to improve this so that any object can be the drag proxy.
            _lastResult = result;
            return result;
        };

        this.getOrientation = function (_endpoint) {
            if (orientation) {
                return orientation;
            }
            else {
                var o = ref.getOrientation(_endpoint);
                // here we take into account the orientation of the other
                // anchor: if it declares zero for some direction, we declare zero too. this might not be the most awesome. perhaps we can come
                // up with a better way. it's just so that the line we draw looks like it makes sense. maybe this wont make sense.
                return [ Math.abs(o[0]) * xDir * -1,
                        Math.abs(o[1]) * yDir * -1 ];
            }
        };

        /**
         * notification the endpoint associated with this anchor is hovering
         * over another anchor; we want to assume that anchor's orientation
         * for the duration of the hover.
         */
        this.over = function (anchor, endpoint) {
            orientation = anchor.getOrientation(endpoint);
        };

        /**
         * notification the endpoint associated with this anchor is no
         * longer hovering over another anchor; we should resume calculating
         * orientation as we normally do.
         */
        this.out = function () {
            orientation = null;
        };

        this.getCurrentLocation = function (params) {
            return _lastResult == null ? this.compute(params) : _lastResult;
        };
    };
    _ju.extend(_jp.FloatingAnchor, _jp.Anchor);

    var _convertAnchor = function (anchor, jsPlumbInstance, elementId) {
        return anchor.constructor === _jp.Anchor ? anchor : jsPlumbInstance.makeAnchor(anchor, elementId, jsPlumbInstance);
    };

    /* 
     * A DynamicAnchor is an Anchor that contains a list of other Anchors, which it cycles
     * through at compute time to find the one that is located closest to
     * the center of the target element, and returns that Anchor's compute
     * method result. this causes endpoints to follow each other with
     * respect to the orientation of their target elements, which is a useful
     * feature for some applications.
     * 
     */
    _jp.DynamicAnchor = function (params) {
        _jp.Anchor.apply(this, arguments);

        this.isDynamic = true;
        this.anchors = [];
        this.elementId = params.elementId;
        this.jsPlumbInstance = params.jsPlumbInstance;

        for (var i = 0; i < params.anchors.length; i++) {
            this.anchors[i] = _convertAnchor(params.anchors[i], this.jsPlumbInstance, this.elementId);
        }

        this.getAnchors = function () {
            return this.anchors;
        };
        this.locked = false;
        var _curAnchor = this.anchors.length > 0 ? this.anchors[0] : null,
            _lastAnchor = _curAnchor,
            self = this,

        // helper method to calculate the distance between the centers of the two elements.
            _distance = function (anchor, cx, cy, xy, wh) {
                var ax = xy[0] + (anchor.x * wh[0]), ay = xy[1] + (anchor.y * wh[1]),
                    acx = xy[0] + (wh[0] / 2), acy = xy[1] + (wh[1] / 2);
                return (Math.sqrt(Math.pow(cx - ax, 2) + Math.pow(cy - ay, 2)) +
                    Math.sqrt(Math.pow(acx - ax, 2) + Math.pow(acy - ay, 2)));
            },
        // default method uses distance between element centers.  you can provide your own method in the dynamic anchor
        // constructor (and also to jsPlumb.makeDynamicAnchor). the arguments to it are four arrays:
        // xy - xy loc of the anchor's element
        // wh - anchor's element's dimensions
        // txy - xy loc of the element of the other anchor in the connection
        // twh - dimensions of the element of the other anchor in the connection.
        // anchors - the list of selectable anchors
            _anchorSelector = params.selector || function (xy, wh, txy, twh, anchors) {
                var cx = txy[0] + (twh[0] / 2), cy = txy[1] + (twh[1] / 2);
                var minIdx = -1, minDist = Infinity;
                for (var i = 0; i < anchors.length; i++) {
                    var d = _distance(anchors[i], cx, cy, xy, wh);
                    if (d < minDist) {
                        minIdx = i + 0;
                        minDist = d;
                    }
                }
                return anchors[minIdx];
            };

        this.compute = function (params) {
            var xy = params.xy, wh = params.wh, txy = params.txy, twh = params.twh;

            this.timestamp = params.timestamp;

            var udl = self.getUserDefinedLocation();
            if (udl != null) {
                return udl;
            }

            // if anchor is locked or an opposite element was not given, we
            // maintain our state. anchor will be locked
            // if it is the source of a drag and drop.
            if (this.locked || txy == null || twh == null) {
                return _curAnchor.compute(params);
            }
            else {
                params.timestamp = null; // otherwise clear this, i think. we want the anchor to compute.
            }

            _curAnchor = _anchorSelector(xy, wh, txy, twh, this.anchors);
            this.x = _curAnchor.x;
            this.y = _curAnchor.y;

            if (_curAnchor !== _lastAnchor) {
                this.fire("anchorChanged", _curAnchor);
            }

            _lastAnchor = _curAnchor;

            return _curAnchor.compute(params);
        };

        this.getCurrentLocation = function (params) {
            return this.getUserDefinedLocation() || (_curAnchor != null ? _curAnchor.getCurrentLocation(params) : null);
        };

        this.getOrientation = function (_endpoint) {
            return _curAnchor != null ? _curAnchor.getOrientation(_endpoint) : [ 0, 0 ];
        };
        this.over = function (anchor, endpoint) {
            if (_curAnchor != null) {
                _curAnchor.over(anchor, endpoint);
            }
        };
        this.out = function () {
            if (_curAnchor != null) {
                _curAnchor.out();
            }
        };

        this.getCssClass = function () {
            return (_curAnchor && _curAnchor.getCssClass()) || "";
        };
    };
    _ju.extend(_jp.DynamicAnchor, _jp.Anchor);

// -------- basic anchors ------------------    
    var _curryAnchor = function (x, y, ox, oy, type, fnInit) {
        _jp.Anchors[type] = function (params) {
            var a = params.jsPlumbInstance.makeAnchor([ x, y, ox, oy, 0, 0 ], params.elementId, params.jsPlumbInstance);
            a.type = type;
            if (fnInit) {
                fnInit(a, params);
            }
            return a;
        };
    };

    _curryAnchor(0.5, 0, 0, -1, "TopCenter");
    _curryAnchor(0.5, 1, 0, 1, "BottomCenter");
    _curryAnchor(0, 0.5, -1, 0, "LeftMiddle");
    _curryAnchor(1, 0.5, 1, 0, "RightMiddle");

    _curryAnchor(0.5, 0, 0, -1, "Top");
    _curryAnchor(0.5, 1, 0, 1, "Bottom");
    _curryAnchor(0, 0.5, -1, 0, "Left");
    _curryAnchor(1, 0.5, 1, 0, "Right");
    _curryAnchor(0.5, 0.5, 0, 0, "Center");
    _curryAnchor(1, 0, 0, -1, "TopRight");
    _curryAnchor(1, 1, 0, 1, "BottomRight");
    _curryAnchor(0, 0, 0, -1, "TopLeft");
    _curryAnchor(0, 1, 0, 1, "BottomLeft");

// ------- dynamic anchors -------------------    

    // default dynamic anchors chooses from Top, Right, Bottom, Left
    _jp.Defaults.DynamicAnchors = function (params) {
        return params.jsPlumbInstance.makeAnchors(["TopCenter", "RightMiddle", "BottomCenter", "LeftMiddle"], params.elementId, params.jsPlumbInstance);
    };

    // default dynamic anchors bound to name 'AutoDefault'
    _jp.Anchors.AutoDefault = function (params) {
        var a = params.jsPlumbInstance.makeDynamicAnchor(_jp.Defaults.DynamicAnchors(params));
        a.type = "AutoDefault";
        return a;
    };

// ------- continuous anchors -------------------    

    var _curryContinuousAnchor = function (type, faces) {
        _jp.Anchors[type] = function (params) {
            var a = params.jsPlumbInstance.makeAnchor(["Continuous", { faces: faces }], params.elementId, params.jsPlumbInstance);
            a.type = type;
            return a;
        };
    };

    _jp.Anchors.Continuous = function (params) {
        return params.jsPlumbInstance.continuousAnchorFactory.get(params);
    };

    _curryContinuousAnchor("ContinuousLeft", ["left"]);
    _curryContinuousAnchor("ContinuousTop", ["top"]);
    _curryContinuousAnchor("ContinuousBottom", ["bottom"]);
    _curryContinuousAnchor("ContinuousRight", ["right"]);

// ------- position assign anchors -------------------    

    // this anchor type lets you assign the position at connection time.
    _curryAnchor(0, 0, 0, 0, "Assign", function (anchor, params) {
        // find what to use as the "position finder". the user may have supplied a String which represents
        // the id of a position finder in jsPlumb.AnchorPositionFinders, or the user may have supplied the
        // position finder as a function.  we find out what to use and then set it on the anchor.
        var pf = params.position || "Fixed";
        anchor.positionFinder = pf.constructor === String ? params.jsPlumbInstance.AnchorPositionFinders[pf] : pf;
        // always set the constructor params; the position finder might need them later (the Grid one does,
        // for example)
        anchor.constructorParams = params;
    });

    // these are the default anchor positions finders, which are used by the makeTarget function.  supplying
    // a position finder argument to that function allows you to specify where the resulting anchor will
    // be located
    root.jsPlumbInstance.prototype.AnchorPositionFinders = {
        "Fixed": function (dp, ep, es) {
            return [ (dp.left - ep.left) / es[0], (dp.top - ep.top) / es[1] ];
        },
        "Grid": function (dp, ep, es, params) {
            var dx = dp.left - ep.left, dy = dp.top - ep.top,
                gx = es[0] / (params.grid[0]), gy = es[1] / (params.grid[1]),
                mx = Math.floor(dx / gx), my = Math.floor(dy / gy);
            return [ ((mx * gx) + (gx / 2)) / es[0], ((my * gy) + (gy / 2)) / es[1] ];
        }
    };

// ------- perimeter anchors -------------------    

    _jp.Anchors.Perimeter = function (params) {
        params = params || {};
        var anchorCount = params.anchorCount || 60,
            shape = params.shape;

        if (!shape) {
            throw new Error("no shape supplied to Perimeter Anchor type");
        }

        var _circle = function () {
                var r = 0.5, step = Math.PI * 2 / anchorCount, current = 0, a = [];
                for (var i = 0; i < anchorCount; i++) {
                    var x = r + (r * Math.sin(current)),
                        y = r + (r * Math.cos(current));
                    a.push([ x, y, 0, 0 ]);
                    current += step;
                }
                return a;
            },
            _path = function (segments) {
                var anchorsPerFace = anchorCount / segments.length, a = [],
                    _computeFace = function (x1, y1, x2, y2, fractionalLength) {
                        anchorsPerFace = anchorCount * fractionalLength;
                        var dx = (x2 - x1) / anchorsPerFace, dy = (y2 - y1) / anchorsPerFace;
                        for (var i = 0; i < anchorsPerFace; i++) {
                            a.push([
                                    x1 + (dx * i),
                                    y1 + (dy * i),
                                0,
                                0
                            ]);
                        }
                    };

                for (var i = 0; i < segments.length; i++) {
                    _computeFace.apply(null, segments[i]);
                }

                return a;
            },
            _shape = function (faces) {
                var s = [];
                for (var i = 0; i < faces.length; i++) {
                    s.push([faces[i][0], faces[i][1], faces[i][2], faces[i][3], 1 / faces.length]);
                }
                return _path(s);
            },
            _rectangle = function () {
                return _shape([
                    [ 0, 0, 1, 0 ],
                    [ 1, 0, 1, 1 ],
                    [ 1, 1, 0, 1 ],
                    [ 0, 1, 0, 0 ]
                ]);
            };

        var _shapes = {
                "Circle": _circle,
                "Ellipse": _circle,
                "Diamond": function () {
                    return _shape([
                        [ 0.5, 0, 1, 0.5 ],
                        [ 1, 0.5, 0.5, 1 ],
                        [ 0.5, 1, 0, 0.5 ],
                        [ 0, 0.5, 0.5, 0 ]
                    ]);
                },
                "Rectangle": _rectangle,
                "Square": _rectangle,
                "Triangle": function () {
                    return _shape([
                        [ 0.5, 0, 1, 1 ],
                        [ 1, 1, 0, 1 ],
                        [ 0, 1, 0.5, 0]
                    ]);
                },
                "Path": function (params) {
                    var points = params.points, p = [], tl = 0;
                    for (var i = 0; i < points.length - 1; i++) {
                        var l = Math.sqrt(Math.pow(points[i][2] - points[i][0]) + Math.pow(points[i][3] - points[i][1]));
                        tl += l;
                        p.push([points[i][0], points[i][1], points[i + 1][0], points[i + 1][1], l]);
                    }
                    for (var j = 0; j < p.length; j++) {
                        p[j][4] = p[j][4] / tl;
                    }
                    return _path(p);
                }
            },
            _rotate = function (points, amountInDegrees) {
                var o = [], theta = amountInDegrees / 180 * Math.PI;
                for (var i = 0; i < points.length; i++) {
                    var _x = points[i][0] - 0.5,
                        _y = points[i][1] - 0.5;

                    o.push([
                            0.5 + ((_x * Math.cos(theta)) - (_y * Math.sin(theta))),
                            0.5 + ((_x * Math.sin(theta)) + (_y * Math.cos(theta))),
                        points[i][2],
                        points[i][3]
                    ]);
                }
                return o;
            };

        if (!_shapes[shape]) {
            throw new Error("Shape [" + shape + "] is unknown by Perimeter Anchor type");
        }

        var da = _shapes[shape](params);
        if (params.rotation) {
            da = _rotate(da, params.rotation);
        }
        var a = params.jsPlumbInstance.makeDynamicAnchor(da);
        a.type = "Perimeter";
        return a;
    };
}).call(typeof window !== 'undefined' ? window : this);
/*
 * jsPlumb Community Edition
 * 
 * Provides a way to visually connect elements on an HTML page, using SVG.
 * 
 * This file contains the default Connectors, Endpoint and Overlay definitions.
 *
 * Copyright (c) 2010 - 2017 jsPlumb (hello@jsplumbtoolkit.com)
 * 
 * https://jsplumbtoolkit.com
 * https://github.com/jsplumb/jsplumb
 * 
 * Dual licensed under the MIT and GPL2 licenses.
 */
;
(function () {

    "use strict";
    var root = this, _jp = root.jsPlumb, _ju = root.jsPlumbUtil, _jg = root.Biltong;

    _jp.Segments = {

        /*
         * Class: AbstractSegment
         * A Connector is made up of 1..N Segments, each of which has a Type, such as 'Straight', 'Arc',
         * 'Bezier'. This is new from 1.4.2, and gives us a lot more flexibility when drawing connections: things such
         * as rounded corners for flowchart connectors, for example, or a straight line stub for Bezier connections, are
         * much easier to do now.
         *
         * A Segment is responsible for providing coordinates for painting it, and also must be able to report its length.
         * 
         */
        AbstractSegment: function (params) {
            this.params = params;

            /**
             * Function: findClosestPointOnPath
             * Finds the closest point on this segment to the given [x, y],
             * returning both the x and y of the point plus its distance from
             * the supplied point, and its location along the length of the
             * path inscribed by the segment.  This implementation returns
             * Infinity for distance and null values for everything else;
             * subclasses are expected to override.
             */
            this.findClosestPointOnPath = function (x, y) {
                return {
                    d: Infinity,
                    x: null,
                    y: null,
                    l: null
                };
            };

            this.getBounds = function () {
                return {
                    minX: Math.min(params.x1, params.x2),
                    minY: Math.min(params.y1, params.y2),
                    maxX: Math.max(params.x1, params.x2),
                    maxY: Math.max(params.y1, params.y2)
                };
            };
        },
        Straight: function (params) {
            var _super = _jp.Segments.AbstractSegment.apply(this, arguments),
                length, m, m2, x1, x2, y1, y2,
                _recalc = function () {
                    length = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
                    m = _jg.gradient({x: x1, y: y1}, {x: x2, y: y2});
                    m2 = -1 / m;
                };

            this.type = "Straight";

            this.getLength = function () {
                return length;
            };
            this.getGradient = function () {
                return m;
            };

            this.getCoordinates = function () {
                return { x1: x1, y1: y1, x2: x2, y2: y2 };
            };
            this.setCoordinates = function (coords) {
                x1 = coords.x1;
                y1 = coords.y1;
                x2 = coords.x2;
                y2 = coords.y2;
                _recalc();
            };
            this.setCoordinates({x1: params.x1, y1: params.y1, x2: params.x2, y2: params.y2});

            this.getBounds = function () {
                return {
                    minX: Math.min(x1, x2),
                    minY: Math.min(y1, y2),
                    maxX: Math.max(x1, x2),
                    maxY: Math.max(y1, y2)
                };
            };

            /**
             * returns the point on the segment's path that is 'location' along the length of the path, where 'location' is a decimal from
             * 0 to 1 inclusive. for the straight line segment this is simple maths.
             */
            this.pointOnPath = function (location, absolute) {
                if (location === 0 && !absolute) {
                    return { x: x1, y: y1 };
                }
                else if (location === 1 && !absolute) {
                    return { x: x2, y: y2 };
                }
                else {
                    var l = absolute ? location > 0 ? location : length + location : location * length;
                    return _jg.pointOnLine({x: x1, y: y1}, {x: x2, y: y2}, l);
                }
            };

            /**
             * returns the gradient of the segment at the given point - which for us is constant.
             */
            this.gradientAtPoint = function (_) {
                return m;
            };

            /**
             * returns the point on the segment's path that is 'distance' along the length of the path from 'location', where
             * 'location' is a decimal from 0 to 1 inclusive, and 'distance' is a number of pixels.
             * this hands off to jsPlumbUtil to do the maths, supplying two points and the distance.
             */
            this.pointAlongPathFrom = function (location, distance, absolute) {
                var p = this.pointOnPath(location, absolute),
                    farAwayPoint = distance <= 0 ? {x: x1, y: y1} : {x: x2, y: y2 };

                /*
                 location == 1 ? {
                 x:x1 + ((x2 - x1) * 10),
                 y:y1 + ((y1 - y2) * 10)
                 } :
                 */

                if (distance <= 0 && Math.abs(distance) > 1) {
                    distance *= -1;
                }

                return _jg.pointOnLine(p, farAwayPoint, distance);
            };

            // is c between a and b?
            var within = function (a, b, c) {
                return c >= Math.min(a, b) && c <= Math.max(a, b);
            };
            // find which of a and b is closest to c
            var closest = function (a, b, c) {
                return Math.abs(c - a) < Math.abs(c - b) ? a : b;
            };

            /**
             Function: findClosestPointOnPath
             Finds the closest point on this segment to [x,y]. See
             notes on this method in AbstractSegment.
             */
            this.findClosestPointOnPath = function (x, y) {
                var out = {
                    d: Infinity,
                    x: null,
                    y: null,
                    l: null,
                    x1: x1,
                    x2: x2,
                    y1: y1,
                    y2: y2
                };

                if (m === 0) {
                    out.y = y1;
                    out.x = within(x1, x2, x) ? x : closest(x1, x2, x);
                }
                else if (m === Infinity || m === -Infinity) {
                    out.x = x1;
                    out.y = within(y1, y2, y) ? y : closest(y1, y2, y);
                }
                else {
                    // closest point lies on normal from given point to this line.  
                    var b = y1 - (m * x1),
                        b2 = y - (m2 * x),
                    // y1 = m.x1 + b and y1 = m2.x1 + b2
                    // so m.x1 + b = m2.x1 + b2
                    // x1(m - m2) = b2 - b
                    // x1 = (b2 - b) / (m - m2)
                        _x1 = (b2 - b) / (m - m2),
                        _y1 = (m * _x1) + b;

                    out.x = within(x1, x2, _x1) ? _x1 : closest(x1, x2, _x1);//_x1;
                    out.y = within(y1, y2, _y1) ? _y1 : closest(y1, y2, _y1);//_y1;
                }

                var fractionInSegment = _jg.lineLength([ out.x, out.y ], [ x1, y1 ]);
                out.d = _jg.lineLength([x, y], [out.x, out.y]);
                out.l = fractionInSegment / length;
                return out;
            };
        },

        /*
         Arc Segment. You need to supply:

         r   -   radius
         cx  -   center x for the arc
         cy  -   center y for the arc
         ac  -   whether the arc is anticlockwise or not. default is clockwise.

         and then either:

         startAngle  -   startAngle for the arc.
         endAngle    -   endAngle for the arc.

         or:

         x1          -   x for start point
         y1          -   y for start point
         x2          -   x for end point
         y2          -   y for end point

         */
        Arc: function (params) {
            var _super = _jp.Segments.AbstractSegment.apply(this, arguments),
                _calcAngle = function (_x, _y) {
                    return _jg.theta([params.cx, params.cy], [_x, _y]);
                },
                _calcAngleForLocation = function (segment, location) {
                    if (segment.anticlockwise) {
                        var sa = segment.startAngle < segment.endAngle ? segment.startAngle + TWO_PI : segment.startAngle,
                            s = Math.abs(sa - segment.endAngle);
                        return sa - (s * location);
                    }
                    else {
                        var ea = segment.endAngle < segment.startAngle ? segment.endAngle + TWO_PI : segment.endAngle,
                            ss = Math.abs(ea - segment.startAngle);

                        return segment.startAngle + (ss * location);
                    }
                },
                TWO_PI = 2 * Math.PI;

            this.radius = params.r;
            this.anticlockwise = params.ac;
            this.type = "Arc";

            if (params.startAngle && params.endAngle) {
                this.startAngle = params.startAngle;
                this.endAngle = params.endAngle;
                this.x1 = params.cx + (this.radius * Math.cos(params.startAngle));
                this.y1 = params.cy + (this.radius * Math.sin(params.startAngle));
                this.x2 = params.cx + (this.radius * Math.cos(params.endAngle));
                this.y2 = params.cy + (this.radius * Math.sin(params.endAngle));
            }
            else {
                this.startAngle = _calcAngle(params.x1, params.y1);
                this.endAngle = _calcAngle(params.x2, params.y2);
                this.x1 = params.x1;
                this.y1 = params.y1;
                this.x2 = params.x2;
                this.y2 = params.y2;
            }

            if (this.endAngle < 0) {
                this.endAngle += TWO_PI;
            }
            if (this.startAngle < 0) {
                this.startAngle += TWO_PI;
            }

            // segment is used by vml     
            //this.segment = _jg.quadrant([this.x1, this.y1], [this.x2, this.y2]);

            // we now have startAngle and endAngle as positive numbers, meaning the
            // absolute difference (|d|) between them is the sweep (s) of this arc, unless the
            // arc is 'anticlockwise' in which case 's' is given by 2PI - |d|.

            var ea = this.endAngle < this.startAngle ? this.endAngle + TWO_PI : this.endAngle;
            this.sweep = Math.abs(ea - this.startAngle);
            if (this.anticlockwise) {
                this.sweep = TWO_PI - this.sweep;
            }
            var circumference = 2 * Math.PI * this.radius,
                frac = this.sweep / TWO_PI,
                length = circumference * frac;

            this.getLength = function () {
                return length;
            };

            this.getBounds = function () {
                return {
                    minX: params.cx - params.r,
                    maxX: params.cx + params.r,
                    minY: params.cy - params.r,
                    maxY: params.cy + params.r
                };
            };

            var VERY_SMALL_VALUE = 0.0000000001,
                gentleRound = function (n) {
                    var f = Math.floor(n), r = Math.ceil(n);
                    if (n - f < VERY_SMALL_VALUE) {
                        return f;
                    }
                    else if (r - n < VERY_SMALL_VALUE) {
                        return r;
                    }
                    return n;
                };

            /**
             * returns the point on the segment's path that is 'location' along the length of the path, where 'location' is a decimal from
             * 0 to 1 inclusive.
             */
            this.pointOnPath = function (location, absolute) {

                if (location === 0) {
                    return { x: this.x1, y: this.y1, theta: this.startAngle };
                }
                else if (location === 1) {
                    return { x: this.x2, y: this.y2, theta: this.endAngle };
                }

                if (absolute) {
                    location = location / length;
                }

                var angle = _calcAngleForLocation(this, location),
                    _x = params.cx + (params.r * Math.cos(angle)),
                    _y = params.cy + (params.r * Math.sin(angle));

                return { x: gentleRound(_x), y: gentleRound(_y), theta: angle };
            };

            /**
             * returns the gradient of the segment at the given point.
             */
            this.gradientAtPoint = function (location, absolute) {
                var p = this.pointOnPath(location, absolute);
                var m = _jg.normal([ params.cx, params.cy ], [p.x, p.y ]);
                if (!this.anticlockwise && (m === Infinity || m === -Infinity)) {
                    m *= -1;
                }
                return m;
            };

            this.pointAlongPathFrom = function (location, distance, absolute) {
                var p = this.pointOnPath(location, absolute),
                    arcSpan = distance / circumference * 2 * Math.PI,
                    dir = this.anticlockwise ? -1 : 1,
                    startAngle = p.theta + (dir * arcSpan),
                    startX = params.cx + (this.radius * Math.cos(startAngle)),
                    startY = params.cy + (this.radius * Math.sin(startAngle));

                return {x: startX, y: startY};
            };
        },

        Bezier: function (params) {
            this.curve = [
                { x: params.x1, y: params.y1},
                { x: params.cp1x, y: params.cp1y },
                { x: params.cp2x, y: params.cp2y },
                { x: params.x2, y: params.y2 }
            ];

            var _super = _jp.Segments.AbstractSegment.apply(this, arguments);
            // although this is not a strictly rigorous determination of bounds
            // of a bezier curve, it works for the types of curves that this segment
            // type produces.
            this.bounds = {
                minX: Math.min(params.x1, params.x2, params.cp1x, params.cp2x),
                minY: Math.min(params.y1, params.y2, params.cp1y, params.cp2y),
                maxX: Math.max(params.x1, params.x2, params.cp1x, params.cp2x),
                maxY: Math.max(params.y1, params.y2, params.cp1y, params.cp2y)
            };

            this.type = "Bezier";

            var _translateLocation = function (_curve, location, absolute) {
                if (absolute) {
                    location = root.jsBezier.locationAlongCurveFrom(_curve, location > 0 ? 0 : 1, location);
                }

                return location;
            };

            /**
             * returns the point on the segment's path that is 'location' along the length of the path, where 'location' is a decimal from
             * 0 to 1 inclusive.
             */
            this.pointOnPath = function (location, absolute) {
                location = _translateLocation(this.curve, location, absolute);
                return root.jsBezier.pointOnCurve(this.curve, location);
            };

            /**
             * returns the gradient of the segment at the given point.
             */
            this.gradientAtPoint = function (location, absolute) {
                location = _translateLocation(this.curve, location, absolute);
                return root.jsBezier.gradientAtPoint(this.curve, location);
            };

            this.pointAlongPathFrom = function (location, distance, absolute) {
                location = _translateLocation(this.curve, location, absolute);
                return root.jsBezier.pointAlongCurveFrom(this.curve, location, distance);
            };

            this.getLength = function () {
                return root.jsBezier.getLength(this.curve);
            };

            this.getBounds = function () {
                return this.bounds;
            };
        }
    };

    _jp.SegmentRenderer = {
        getPath: function (segment) {
            return ({
                "Straight": function () {
                    var d = segment.getCoordinates();
                    return "M " + d.x1 + " " + d.y1 + " L " + d.x2 + " " + d.y2;
                },
                "Bezier": function () {
                    var d = segment.params;
                    return "M " + d.x1 + " " + d.y1 +
                        " C " + d.cp1x + " " + d.cp1y + " " + d.cp2x + " " + d.cp2y + " " + d.x2 + " " + d.y2;
                },
                "Arc": function () {
                    var d = segment.params,
                        laf = segment.sweep > Math.PI ? 1 : 0,
                        sf = segment.anticlockwise ? 0 : 1;

                    return "M" + segment.x1 + " " + segment.y1 + " A " + segment.radius + " " + d.r + " 0 " + laf + "," + sf + " " + segment.x2 + " " + segment.y2;
                }
            })[segment.type]();
        }
    };

    /*
     Class: AbstractComponent
     Superclass for AbstractConnector and AbstractEndpoint.
     */
    var AbstractComponent = function () {
        this.resetBounds = function () {
            this.bounds = { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity };
        };
        this.resetBounds();
    };

    /*
     * Class: AbstractConnector
     * Superclass for all Connectors; here is where Segments are managed.  This is exposed on jsPlumb just so it
     * can be accessed from other files. You should not try to instantiate one of these directly.
     *
     * When this class is asked for a pointOnPath, or gradient etc, it must first figure out which segment to dispatch
     * that request to. This is done by keeping track of the total connector length as segments are added, and also
     * their cumulative ratios to the total length.  Then when the right segment is found it is a simple case of dispatching
     * the request to it (and adjusting 'location' so that it is relative to the beginning of that segment.)
     */
    _jp.Connectors.AbstractConnector = function (params) {

        AbstractComponent.apply(this, arguments);

        var segments = [],
            totalLength = 0,
            segmentProportions = [],
            segmentProportionalLengths = [],
            stub = params.stub || 0,
            sourceStub = _ju.isArray(stub) ? stub[0] : stub,
            targetStub = _ju.isArray(stub) ? stub[1] : stub,
            gap = params.gap || 0,
            sourceGap = _ju.isArray(gap) ? gap[0] : gap,
            targetGap = _ju.isArray(gap) ? gap[1] : gap,
            userProvidedSegments = null,
            edited = false,
            paintInfo = null,
            geometry = null,
            editable = params.editable !== false && _jp.ConnectorEditors != null && _jp.ConnectorEditors[this.type] != null;

        var _setGeometry = this.setGeometry = function(g, internallyComputed) {
            edited = (!internallyComputed);
            geometry = g;
        };
        var _getGeometry = this.getGeometry = function() {
            return geometry;
        };

        this.getPathData = function() {
            var p = "";
            for (var i = 0; i < segments.length; i++) {
                p += _jp.SegmentRenderer.getPath(segments[i]);
                p += " ";
            }
            return p;
        };

        this.hasBeenEdited = function() { return edited; };
        this.isEditing = function() { return this.editor != null && this.editor.isActive(); };
        this.setEditable = function(e) {
            // if this connector has an editor already, or
            // if an editor for this connector's type is available, or
            // if the child declares an overrideSetEditable and it does not return false, editable is true.
            if (e && _jp.ConnectorEditors != null && _jp.ConnectorEditors[this.type] != null && (this.overrideSetEditable == null || this.overrideSetEditable())) {
                editable = e;
            } else {
                editable = false;
            }
            return editable;
        };
        this.isEditable = function() { return editable; };

        /**
         * Function: findSegmentForPoint
         * Returns the segment that is closest to the given [x,y],
         * null if nothing found.  This function returns a JS
         * object with:
         *
         *   d   -   distance from segment
         *   l   -   proportional location in segment
         *   x   -   x point on the segment
         *   y   -   y point on the segment
         *   s   -   the segment itself.
         */
        this.findSegmentForPoint = function (x, y) {
            var out = { d: Infinity, s: null, x: null, y: null, l: null };
            for (var i = 0; i < segments.length; i++) {
                var _s = segments[i].findClosestPointOnPath(x, y);
                if (_s.d < out.d) {
                    out.d = _s.d;
                    out.l = _s.l;
                    out.x = _s.x;
                    out.y = _s.y;
                    out.s = segments[i];
                    out.x1 = _s.x1;
                    out.x2 = _s.x2;
                    out.y1 = _s.y1;
                    out.y2 = _s.y2;
                    out.index = i;
                }
            }

            return out;
        };

        var _updateSegmentProportions = function () {
                var curLoc = 0;
                for (var i = 0; i < segments.length; i++) {
                    var sl = segments[i].getLength();
                    segmentProportionalLengths[i] = sl / totalLength;
                    segmentProportions[i] = [curLoc, (curLoc += (sl / totalLength)) ];
                }
            },

            /**
             * returns [segment, proportion of travel in segment, segment index] for the segment
             * that contains the point which is 'location' distance along the entire path, where
             * 'location' is a decimal between 0 and 1 inclusive. in this connector type, paths
             * are made up of a list of segments, each of which contributes some fraction to
             * the total length.
             * From 1.3.10 this also supports the 'absolute' property, which lets us specify a location
             * as the absolute distance in pixels, rather than a proportion of the total path.
             */
            _findSegmentForLocation = function (location, absolute) {
                if (absolute) {
                    location = location > 0 ? location / totalLength : (totalLength + location) / totalLength;
                }
                var idx = segmentProportions.length - 1, inSegmentProportion = 1;
                for (var i = 0; i < segmentProportions.length; i++) {
                    if (segmentProportions[i][1] >= location) {
                        idx = i;
                        // todo is this correct for all connector path types?
                        inSegmentProportion = location === 1 ? 1 : location === 0 ? 0 : (location - segmentProportions[i][0]) / segmentProportionalLengths[i];
                        break;
                    }
                }
                return { segment: segments[idx], proportion: inSegmentProportion, index: idx };
            },
            _addSegment = function (conn, type, params) {
                if (params.x1 === params.x2 && params.y1 === params.y2) {
                    return;
                }
                var s = new _jp.Segments[type](params);
                segments.push(s);
                totalLength += s.getLength();
                conn.updateBounds(s);
            },
            _clearSegments = function () {
                totalLength = segments.length = segmentProportions.length = segmentProportionalLengths.length = 0;
            };

        this.setSegments = function (_segs) {
            userProvidedSegments = [];
            totalLength = 0;
            for (var i = 0; i < _segs.length; i++) {
                userProvidedSegments.push(_segs[i]);
                totalLength += _segs[i].getLength();
            }
        };

        this.getLength = function() {
            return totalLength;
        };

        var _prepareCompute = function (params) {
            this.strokeWidth = params.strokeWidth;
            var segment = _jg.quadrant(params.sourcePos, params.targetPos),
                swapX = params.targetPos[0] < params.sourcePos[0],
                swapY = params.targetPos[1] < params.sourcePos[1],
                lw = params.strokeWidth || 1,
                so = params.sourceEndpoint.anchor.getOrientation(params.sourceEndpoint),
                to = params.targetEndpoint.anchor.getOrientation(params.targetEndpoint),
                x = swapX ? params.targetPos[0] : params.sourcePos[0],
                y = swapY ? params.targetPos[1] : params.sourcePos[1],
                w = Math.abs(params.targetPos[0] - params.sourcePos[0]),
                h = Math.abs(params.targetPos[1] - params.sourcePos[1]);

            // if either anchor does not have an orientation set, we derive one from their relative
            // positions.  we fix the axis to be the one in which the two elements are further apart, and
            // point each anchor at the other element.  this is also used when dragging a new connection.
            if (so[0] === 0 && so[1] === 0 || to[0] === 0 && to[1] === 0) {
                var index = w > h ? 0 : 1, oIndex = [1, 0][index];
                so = [];
                to = [];
                so[index] = params.sourcePos[index] > params.targetPos[index] ? -1 : 1;
                to[index] = params.sourcePos[index] > params.targetPos[index] ? 1 : -1;
                so[oIndex] = 0;
                to[oIndex] = 0;
            }

            var sx = swapX ? w + (sourceGap * so[0]) : sourceGap * so[0],
                sy = swapY ? h + (sourceGap * so[1]) : sourceGap * so[1],
                tx = swapX ? targetGap * to[0] : w + (targetGap * to[0]),
                ty = swapY ? targetGap * to[1] : h + (targetGap * to[1]),
                oProduct = ((so[0] * to[0]) + (so[1] * to[1]));

            var result = {
                sx: sx, sy: sy, tx: tx, ty: ty, lw: lw,
                xSpan: Math.abs(tx - sx),
                ySpan: Math.abs(ty - sy),
                mx: (sx + tx) / 2,
                my: (sy + ty) / 2,
                so: so, to: to, x: x, y: y, w: w, h: h,
                segment: segment,
                startStubX: sx + (so[0] * sourceStub),
                startStubY: sy + (so[1] * sourceStub),
                endStubX: tx + (to[0] * targetStub),
                endStubY: ty + (to[1] * targetStub),
                isXGreaterThanStubTimes2: Math.abs(sx - tx) > (sourceStub + targetStub),
                isYGreaterThanStubTimes2: Math.abs(sy - ty) > (sourceStub + targetStub),
                opposite: oProduct === -1,
                perpendicular: oProduct === 0,
                orthogonal: oProduct === 1,
                sourceAxis: so[0] === 0 ? "y" : "x",
                points: [x, y, w, h, sx, sy, tx, ty ]
            };
            result.anchorOrientation = result.opposite ? "opposite" : result.orthogonal ? "orthogonal" : "perpendicular";
            return result;
        };

        this.getSegments = function () {
            return segments;
        };

        this.updateBounds = function (segment) {
            var segBounds = segment.getBounds();
            this.bounds.minX = Math.min(this.bounds.minX, segBounds.minX);
            this.bounds.maxX = Math.max(this.bounds.maxX, segBounds.maxX);
            this.bounds.minY = Math.min(this.bounds.minY, segBounds.minY);
            this.bounds.maxY = Math.max(this.bounds.maxY, segBounds.maxY);
        };

        var dumpSegmentsToConsole = function () {
            console.log("SEGMENTS:");
            for (var i = 0; i < segments.length; i++) {
                console.log(segments[i].type, segments[i].getLength(), segmentProportions[i]);
            }
        };

        this.pointOnPath = function (location, absolute) {
            var seg = _findSegmentForLocation(location, absolute);
            return seg.segment && seg.segment.pointOnPath(seg.proportion, false) || [0, 0];
        };

        this.gradientAtPoint = function (location, absolute) {
            var seg = _findSegmentForLocation(location, absolute);
            return seg.segment && seg.segment.gradientAtPoint(seg.proportion, false) || 0;
        };

        this.pointAlongPathFrom = function (location, distance, absolute) {
            var seg = _findSegmentForLocation(location, absolute);
            // TODO what happens if this crosses to the next segment?
            return seg.segment && seg.segment.pointAlongPathFrom(seg.proportion, distance, false) || [0, 0];
        };

        this.compute = function (params) {
            paintInfo = _prepareCompute.call(this, params);

            _clearSegments();
            this._compute(paintInfo, params);
            this.x = paintInfo.points[0];
            this.y = paintInfo.points[1];
            this.w = paintInfo.points[2];
            this.h = paintInfo.points[3];
            this.segment = paintInfo.segment;
            _updateSegmentProportions();
        };

        return {
            addSegment: _addSegment,
            prepareCompute: _prepareCompute,
            sourceStub: sourceStub,
            targetStub: targetStub,
            maxStub: Math.max(sourceStub, targetStub),
            sourceGap: sourceGap,
            targetGap: targetGap,
            maxGap: Math.max(sourceGap, targetGap),
            setGeometry:_setGeometry,
            getGeometry:_getGeometry
        };
    };
    _ju.extend(_jp.Connectors.AbstractConnector, AbstractComponent);


    // ********************************* END OF CONNECTOR TYPES *******************************************************************

    // ********************************* ENDPOINT TYPES *******************************************************************

    _jp.Endpoints.AbstractEndpoint = function (params) {
        AbstractComponent.apply(this, arguments);
        var compute = this.compute = function (anchorPoint, orientation, endpointStyle, connectorPaintStyle) {
            var out = this._compute.apply(this, arguments);
            this.x = out[0];
            this.y = out[1];
            this.w = out[2];
            this.h = out[3];
            this.bounds.minX = this.x;
            this.bounds.minY = this.y;
            this.bounds.maxX = this.x + this.w;
            this.bounds.maxY = this.y + this.h;
            return out;
        };
        return {
            compute: compute,
            cssClass: params.cssClass
        };
    };
    _ju.extend(_jp.Endpoints.AbstractEndpoint, AbstractComponent);

    /**
     * Class: Endpoints.Dot
     * A round endpoint, with default radius 10 pixels.
     */

    /**
     * Function: Constructor
     *
     * Parameters:
     *
     *    radius    -    radius of the endpoint.  defaults to 10 pixels.
     */
    _jp.Endpoints.Dot = function (params) {
        this.type = "Dot";
        var _super = _jp.Endpoints.AbstractEndpoint.apply(this, arguments);
        params = params || {};
        this.radius = params.radius || 10;
        this.defaultOffset = 0.5 * this.radius;
        this.defaultInnerRadius = this.radius / 3;

        this._compute = function (anchorPoint, orientation, endpointStyle, connectorPaintStyle) {
            this.radius = endpointStyle.radius || this.radius;
            var x = anchorPoint[0] - this.radius,
                y = anchorPoint[1] - this.radius,
                w = this.radius * 2,
                h = this.radius * 2;

            if (endpointStyle.stroke) {
                var lw = endpointStyle.strokeWidth || 1;
                x -= lw;
                y -= lw;
                w += (lw * 2);
                h += (lw * 2);
            }
            return [ x, y, w, h, this.radius ];
        };
    };
    _ju.extend(_jp.Endpoints.Dot, _jp.Endpoints.AbstractEndpoint);

    _jp.Endpoints.Rectangle = function (params) {
        this.type = "Rectangle";
        var _super = _jp.Endpoints.AbstractEndpoint.apply(this, arguments);
        params = params || {};
        this.width = params.width || 20;
        this.height = params.height || 20;

        this._compute = function (anchorPoint, orientation, endpointStyle, connectorPaintStyle) {
            var width = endpointStyle.width || this.width,
                height = endpointStyle.height || this.height,
                x = anchorPoint[0] - (width / 2),
                y = anchorPoint[1] - (height / 2);

            return [ x, y, width, height];
        };
    };
    _ju.extend(_jp.Endpoints.Rectangle, _jp.Endpoints.AbstractEndpoint);

    var DOMElementEndpoint = function (params) {
        _jp.jsPlumbUIComponent.apply(this, arguments);
        this._jsPlumb.displayElements = [];
    };
    _ju.extend(DOMElementEndpoint, _jp.jsPlumbUIComponent, {
        getDisplayElements: function () {
            return this._jsPlumb.displayElements;
        },
        appendDisplayElement: function (el) {
            this._jsPlumb.displayElements.push(el);
        }
    });

    /**
     * Class: Endpoints.Image
     * Draws an image as the Endpoint.
     */
    /**
     * Function: Constructor
     *
     * Parameters:
     *
     *    src    -    location of the image to use.

     TODO: multiple references to self. not sure quite how to get rid of them entirely. perhaps self = null in the cleanup
     function will suffice

     TODO this class still might leak memory.

     */
    _jp.Endpoints.Image = function (params) {

        this.type = "Image";
        DOMElementEndpoint.apply(this, arguments);
        _jp.Endpoints.AbstractEndpoint.apply(this, arguments);

        var _onload = params.onload,
            src = params.src || params.url,
            clazz = params.cssClass ? " " + params.cssClass : "";

        this._jsPlumb.img = new Image();
        this._jsPlumb.ready = false;
        this._jsPlumb.initialized = false;
        this._jsPlumb.deleted = false;
        this._jsPlumb.widthToUse = params.width;
        this._jsPlumb.heightToUse = params.height;
        this._jsPlumb.endpoint = params.endpoint;

        this._jsPlumb.img.onload = function () {
            if (this._jsPlumb != null) {
                this._jsPlumb.ready = true;
                this._jsPlumb.widthToUse = this._jsPlumb.widthToUse || this._jsPlumb.img.width;
                this._jsPlumb.heightToUse = this._jsPlumb.heightToUse || this._jsPlumb.img.height;
                if (_onload) {
                    _onload(this);
                }
            }
        }.bind(this);

        /*
         Function: setImage
         Sets the Image to use in this Endpoint.

         Parameters:
         img         -   may be a URL or an Image object
         onload      -   optional; a callback to execute once the image has loaded.
         */
        this._jsPlumb.endpoint.setImage = function (_img, onload) {
            var s = _img.constructor === String ? _img : _img.src;
            _onload = onload;
            this._jsPlumb.img.src = s;

            if (this.canvas != null) {
                this.canvas.setAttribute("src", this._jsPlumb.img.src);
            }
        }.bind(this);

        this._jsPlumb.endpoint.setImage(src, _onload);
        this._compute = function (anchorPoint, orientation, endpointStyle, connectorPaintStyle) {
            this.anchorPoint = anchorPoint;
            if (this._jsPlumb.ready) {
                return [anchorPoint[0] - this._jsPlumb.widthToUse / 2, anchorPoint[1] - this._jsPlumb.heightToUse / 2,
                    this._jsPlumb.widthToUse, this._jsPlumb.heightToUse];
            }
            else {
                return [0, 0, 0, 0];
            }
        };

        this.canvas = _jp.createElement("img", {
            position:"absolute",
            margin:0,
            padding:0,
            outline:0
        }, this._jsPlumb.instance.endpointClass + clazz);

        if (this._jsPlumb.widthToUse) {
            this.canvas.setAttribute("width", this._jsPlumb.widthToUse);
        }
        if (this._jsPlumb.heightToUse) {
            this.canvas.setAttribute("height", this._jsPlumb.heightToUse);
        }
        this._jsPlumb.instance.appendElement(this.canvas);

        this.actuallyPaint = function (d, style, anchor) {
            if (!this._jsPlumb.deleted) {
                if (!this._jsPlumb.initialized) {
                    this.canvas.setAttribute("src", this._jsPlumb.img.src);
                    this.appendDisplayElement(this.canvas);
                    this._jsPlumb.initialized = true;
                }
                var x = this.anchorPoint[0] - (this._jsPlumb.widthToUse / 2),
                    y = this.anchorPoint[1] - (this._jsPlumb.heightToUse / 2);
                _ju.sizeElement(this.canvas, x, y, this._jsPlumb.widthToUse, this._jsPlumb.heightToUse);
            }
        };

        this.paint = function (style, anchor) {
            if (this._jsPlumb != null) {  // may have been deleted
                if (this._jsPlumb.ready) {
                    this.actuallyPaint(style, anchor);
                }
                else {
                    root.setTimeout(function () {
                        this.paint(style, anchor);
                    }.bind(this), 200);
                }
            }
        };
    };
    _ju.extend(_jp.Endpoints.Image, [ DOMElementEndpoint, _jp.Endpoints.AbstractEndpoint ], {
        cleanup: function (force) {
            if (force) {
                this._jsPlumb.deleted = true;
                if (this.canvas) {
                    this.canvas.parentNode.removeChild(this.canvas);
                }
                this.canvas = null;
            }
        }
    });

    /*
     * Class: Endpoints.Blank
     * An Endpoint that paints nothing (visible) on the screen.  Supports cssClass and hoverClass parameters like all Endpoints.
     */
    _jp.Endpoints.Blank = function (params) {
        var _super = _jp.Endpoints.AbstractEndpoint.apply(this, arguments);
        this.type = "Blank";
        DOMElementEndpoint.apply(this, arguments);
        this._compute = function (anchorPoint, orientation, endpointStyle, connectorPaintStyle) {
            return [anchorPoint[0], anchorPoint[1], 10, 0];
        };

        var clazz = params.cssClass ? " " + params.cssClass : "";

        this.canvas = _jp.createElement("div", {
            display: "block",
            width: "1px",
            height: "1px",
            background: "transparent",
            position: "absolute"
        }, this._jsPlumb.instance.endpointClass + clazz);

        this._jsPlumb.instance.appendElement(this.canvas);

        this.paint = function (style, anchor) {
            _ju.sizeElement(this.canvas, this.x, this.y, this.w, this.h);
        };
    };
    _ju.extend(_jp.Endpoints.Blank, [_jp.Endpoints.AbstractEndpoint, DOMElementEndpoint], {
        cleanup: function () {
            if (this.canvas && this.canvas.parentNode) {
                this.canvas.parentNode.removeChild(this.canvas);
            }
        }
    });

    /*
     * Class: Endpoints.Triangle
     * A triangular Endpoint.
     */
    /*
     * Function: Constructor
     *
     * Parameters:
     *
     * width   width of the triangle's base.  defaults to 55 pixels.
     * height  height of the triangle from base to apex.  defaults to 55 pixels.
     */
    _jp.Endpoints.Triangle = function (params) {
        this.type = "Triangle";
        _jp.Endpoints.AbstractEndpoint.apply(this, arguments);
        var self = this;
        params = params || {  };
        params.width = params.width || 55;
        params.height = params.height || 55;
        this.width = params.width;
        this.height = params.height;
        this._compute = function (anchorPoint, orientation, endpointStyle, connectorPaintStyle) {
            var width = endpointStyle.width || self.width,
                height = endpointStyle.height || self.height,
                x = anchorPoint[0] - (width / 2),
                y = anchorPoint[1] - (height / 2);
            return [ x, y, width, height ];
        };
    };
// ********************************* END OF ENDPOINT TYPES *******************************************************************


// ********************************* OVERLAY DEFINITIONS ***********************************************************************    

    var AbstractOverlay = _jp.Overlays.AbstractOverlay = function (params) {
        this.visible = true;
        this.isAppendedAtTopLevel = true;
        this.component = params.component;
        this.loc = params.location == null ? 0.5 : params.location;
        this.endpointLoc = params.endpointLocation == null ? [ 0.5, 0.5] : params.endpointLocation;
        this.visible = params.visible !== false;
    };
    AbstractOverlay.prototype = {
        cleanup: function (force) {
            if (force) {
                this.component = null;
                this.canvas = null;
                this.endpointLoc = null;
            }
        },
        reattach:function(instance, component) { },
        setVisible: function (val) {
            this.visible = val;
            this.component.repaint();
        },
        isVisible: function () {
            return this.visible;
        },
        hide: function () {
            this.setVisible(false);
        },
        show: function () {
            this.setVisible(true);
        },
        incrementLocation: function (amount) {
            this.loc += amount;
            this.component.repaint();
        },
        setLocation: function (l) {
            this.loc = l;
            this.component.repaint();
        },
        getLocation: function () {
            return this.loc;
        },
        updateFrom:function() { }
    };


    /*
     * Class: Overlays.Arrow
     *
     * An arrow overlay, defined by four points: the head, the two sides of the tail, and a 'foldback' point at some distance along the length
     * of the arrow that lines from each tail point converge into.  The foldback point is defined using a decimal that indicates some fraction
     * of the length of the arrow and has a default value of 0.623.  A foldback point value of 1 would mean that the arrow had a straight line
     * across the tail.
     */
    /*
     * @constructor
     *
     * @param {Object} params Constructor params.
     * @param {Number} [params.length] Distance in pixels from head to tail baseline. default 20.
     * @param {Number} [params.width] Width in pixels of the tail baseline. default 20.
     * @param {String} [params.fill] Style to use when filling the arrow.  defaults to "black".
     * @param {String} [params.stroke] Style to use when stroking the arrow. defaults to null, which means the arrow is not stroked.
     * @param {Number} [params.stroke-width] Line width to use when stroking the arrow. defaults to 1, but only used if stroke is not null.
     * @param {Number} [params.foldback] Distance (as a decimal from 0 to 1 inclusive) along the length of the arrow marking the point the tail points should fold back to.  defaults to 0.623.
     * @param {Number} [params.location] Distance (as a decimal from 0 to 1 inclusive) marking where the arrow should sit on the connector. defaults to 0.5.
     * @param {NUmber} [params.direction] Indicates the direction the arrow points in. valid values are -1 and 1; 1 is default.
     */
    _jp.Overlays.Arrow = function (params) {
        this.type = "Arrow";
        AbstractOverlay.apply(this, arguments);
        this.isAppendedAtTopLevel = false;
        params = params || {};
        var self = this;

        this.length = params.length || 20;
        this.width = params.width || 20;
        this.id = params.id;
        var direction = (params.direction || 1) < 0 ? -1 : 1,
            paintStyle = params.paintStyle || { "stroke-width": 1 },
        // how far along the arrow the lines folding back in come to. default is 62.3%.
            foldback = params.foldback || 0.623;

        this.computeMaxSize = function () {
            return self.width * 1.5;
        };

        this.elementCreated = function(p, component) {
            this.path = p;
            if (params.events) {
                for (var i in params.events) {
                    _jp.on(p, i, params.events[i]);
                }
            }
        };

        this.draw = function (component, currentConnectionPaintStyle) {

            var hxy, mid, txy, tail, cxy;
            if (component.pointAlongPathFrom) {

                if (_ju.isString(this.loc) || this.loc > 1 || this.loc < 0) {
                    var l = parseInt(this.loc, 10),
                        fromLoc = this.loc < 0 ? 1 : 0;
                    hxy = component.pointAlongPathFrom(fromLoc, l, false);
                    mid = component.pointAlongPathFrom(fromLoc, l - (direction * this.length / 2), false);
                    txy = _jg.pointOnLine(hxy, mid, this.length);
                }
                else if (this.loc === 1) {
                    hxy = component.pointOnPath(this.loc);
                    mid = component.pointAlongPathFrom(this.loc, -(this.length));
                    txy = _jg.pointOnLine(hxy, mid, this.length);

                    if (direction === -1) {
                        var _ = txy;
                        txy = hxy;
                        hxy = _;
                    }
                }
                else if (this.loc === 0) {
                    txy = component.pointOnPath(this.loc);
                    mid = component.pointAlongPathFrom(this.loc, this.length);
                    hxy = _jg.pointOnLine(txy, mid, this.length);
                    if (direction === -1) {
                        var __ = txy;
                        txy = hxy;
                        hxy = __;
                    }
                }
                else {
                    hxy = component.pointAlongPathFrom(this.loc, direction * this.length / 2);
                    mid = component.pointOnPath(this.loc);
                    txy = _jg.pointOnLine(hxy, mid, this.length);
                }

                tail = _jg.perpendicularLineTo(hxy, txy, this.width);
                cxy = _jg.pointOnLine(hxy, txy, foldback * this.length);

                var d = { hxy: hxy, tail: tail, cxy: cxy },
                    stroke = paintStyle.stroke || currentConnectionPaintStyle.stroke,
                    fill = paintStyle.fill || currentConnectionPaintStyle.stroke,
                    lineWidth = paintStyle.strokeWidth || currentConnectionPaintStyle.strokeWidth;

                return {
                    component: component,
                    d: d,
                    "stroke-width": lineWidth,
                    stroke: stroke,
                    fill: fill,
                    minX: Math.min(hxy.x, tail[0].x, tail[1].x),
                    maxX: Math.max(hxy.x, tail[0].x, tail[1].x),
                    minY: Math.min(hxy.y, tail[0].y, tail[1].y),
                    maxY: Math.max(hxy.y, tail[0].y, tail[1].y)
                };
            }
            else {
                return {component: component, minX: 0, maxX: 0, minY: 0, maxY: 0};
            }
        };
    };
    _ju.extend(_jp.Overlays.Arrow, AbstractOverlay, {
        updateFrom:function(d) {
            this.length = d.length || this.length;
            this.width = d.width|| this.width;
            this.direction = d.direction != null ? d.direction : this.direction;
            this.foldback = d.foldback|| this.foldback;
        }
    });

    /*
     * Class: Overlays.PlainArrow
     *
     * A basic arrow.  This is in fact just one instance of the more generic case in which the tail folds back on itself to some
     * point along the length of the arrow: in this case, that foldback point is the full length of the arrow.  so it just does
     * a 'call' to Arrow with foldback set appropriately.
     */
    /*
     * Function: Constructor
     * See <Overlays.Arrow> for allowed parameters for this overlay.
     */
    _jp.Overlays.PlainArrow = function (params) {
        params = params || {};
        var p = _jp.extend(params, {foldback: 1});
        _jp.Overlays.Arrow.call(this, p);
        this.type = "PlainArrow";
    };
    _ju.extend(_jp.Overlays.PlainArrow, _jp.Overlays.Arrow);

    /*
     * Class: Overlays.Diamond
     * 
     * A diamond. Like PlainArrow, this is a concrete case of the more generic case of the tail points converging on some point...it just
     * happens that in this case, that point is greater than the length of the the arrow.
     *
     *      this could probably do with some help with positioning...due to the way it reuses the Arrow paint code, what Arrow thinks is the
     *      center is actually 1/4 of the way along for this guy.  but we don't have any knowledge of pixels at this point, so we're kind of
     *      stuck when it comes to helping out the Arrow class. possibly we could pass in a 'transpose' parameter or something. the value
     *      would be -l/4 in this case - move along one quarter of the total length.
     */
    /*
     * Function: Constructor
     * See <Overlays.Arrow> for allowed parameters for this overlay.
     */
    _jp.Overlays.Diamond = function (params) {
        params = params || {};
        var l = params.length || 40,
            p = _jp.extend(params, {length: l / 2, foldback: 2});
        _jp.Overlays.Arrow.call(this, p);
        this.type = "Diamond";
    };
    _ju.extend(_jp.Overlays.Diamond, _jp.Overlays.Arrow);

    var _getDimensions = function (component, forceRefresh) {
        if (component._jsPlumb.cachedDimensions == null || forceRefresh) {
            component._jsPlumb.cachedDimensions = component.getDimensions();
        }
        return component._jsPlumb.cachedDimensions;
    };

    // abstract superclass for overlays that add an element to the DOM.
    var AbstractDOMOverlay = function (params) {
        _jp.jsPlumbUIComponent.apply(this, arguments);
        AbstractOverlay.apply(this, arguments);

        // hand off fired events to associated component.
        var _f = this.fire;
        this.fire = function () {
            _f.apply(this, arguments);
            if (this.component) {
                this.component.fire.apply(this.component, arguments);
            }
        };

        this.detached=false;
        this.id = params.id;
        this._jsPlumb.div = null;
        this._jsPlumb.initialised = false;
        this._jsPlumb.component = params.component;
        this._jsPlumb.cachedDimensions = null;
        this._jsPlumb.create = params.create;
        this._jsPlumb.initiallyInvisible = params.visible === false;

        this.getElement = function () {
            if (this._jsPlumb.div == null) {
                var div = this._jsPlumb.div = _jp.getElement(this._jsPlumb.create(this._jsPlumb.component));
                div.style.position = "absolute";
                div.className = this._jsPlumb.instance.overlayClass + " " +
                    (this.cssClass ? this.cssClass :
                        params.cssClass ? params.cssClass : "");
                this._jsPlumb.instance.appendElement(div);
                this._jsPlumb.instance.getId(div);
                this.canvas = div;

                // in IE the top left corner is what it placed at the desired location.  This will not
                // be fixed. IE8 is not going to be supported for much longer.
                var ts = "translate(-50%, -50%)";
                div.style.webkitTransform = ts;
                div.style.mozTransform = ts;
                div.style.msTransform = ts;
                div.style.oTransform = ts;
                div.style.transform = ts;

                // write the related component into the created element
                div._jsPlumb = this;

                if (params.visible === false) {
                    div.style.display = "none";
                }
            }
            return this._jsPlumb.div;
        };

        this.draw = function (component, currentConnectionPaintStyle, absolutePosition) {
            var td = _getDimensions(this);
            if (td != null && td.length === 2) {
                var cxy = { x: 0, y: 0 };

                // absolutePosition would have been set by a call to connection.setAbsoluteOverlayPosition.
                if (absolutePosition) {
                    cxy = { x: absolutePosition[0], y: absolutePosition[1] };
                }
                else if (component.pointOnPath) {
                    var loc = this.loc, absolute = false;
                    if (_ju.isString(this.loc) || this.loc < 0 || this.loc > 1) {
                        loc = parseInt(this.loc, 10);
                        absolute = true;
                    }
                    cxy = component.pointOnPath(loc, absolute);  // a connection
                }
                else {
                    var locToUse = this.loc.constructor === Array ? this.loc : this.endpointLoc;
                    cxy = { x: locToUse[0] * component.w,
                        y: locToUse[1] * component.h };
                }

                var minx = cxy.x - (td[0] / 2),
                    miny = cxy.y - (td[1] / 2);

                return {
                    component: component,
                    d: { minx: minx, miny: miny, td: td, cxy: cxy },
                    minX: minx,
                    maxX: minx + td[0],
                    minY: miny,
                    maxY: miny + td[1]
                };
            }
            else {
                return {minX: 0, maxX: 0, minY: 0, maxY: 0};
            }
        };
    };
    _ju.extend(AbstractDOMOverlay, [_jp.jsPlumbUIComponent, AbstractOverlay], {
        getDimensions: function () {
            return [1,1];
        },
        setVisible: function (state) {
            if (this._jsPlumb.div) {
                this._jsPlumb.div.style.display = state ? "block" : "none";
                // if initially invisible, dimensions are 0,0 and never get updated
                if (state && this._jsPlumb.initiallyInvisible) {
                    _getDimensions(this, true);
                    this.component.repaint();
                    this._jsPlumb.initiallyInvisible = false;
                }
            }
        },
        /*
         * Function: clearCachedDimensions
         * Clears the cached dimensions for the label. As a performance enhancement, label dimensions are
         * cached from 1.3.12 onwards. The cache is cleared when you change the label text, of course, but
         * there are other reasons why the text dimensions might change - if you make a change through CSS, for
         * example, you might change the font size.  in that case you should explicitly call this method.
         */
        clearCachedDimensions: function () {
            this._jsPlumb.cachedDimensions = null;
        },
        cleanup: function (force) {
            if (force) {
                if (this._jsPlumb.div != null) {
                    this._jsPlumb.div._jsPlumb = null;
                    this._jsPlumb.instance.removeElement(this._jsPlumb.div);
                }
            }
            else {
                // if not a forced cleanup, just detach child from parent for now.
                if (this._jsPlumb && this._jsPlumb.div && this._jsPlumb.div.parentNode) {
                    this._jsPlumb.div.parentNode.removeChild(this._jsPlumb.div);
                }
                this.detached = true;
            }

        },
        reattach:function(instance, component) {
            if (this._jsPlumb.div != null) {
                instance.getContainer().appendChild(this._jsPlumb.div);
            }
            this.detached = false;
        },
        computeMaxSize: function () {
            var td = _getDimensions(this);
            return Math.max(td[0], td[1]);
        },
        paint: function (p, containerExtents) {
            if (!this._jsPlumb.initialised) {
                this.getElement();
                p.component.appendDisplayElement(this._jsPlumb.div);
                this._jsPlumb.initialised = true;
                if (this.detached) {
                    this._jsPlumb.div.parentNode.removeChild(this._jsPlumb.div);
                }
            }
            this._jsPlumb.div.style.left = (p.component.x + p.d.minx) + "px";
            this._jsPlumb.div.style.top = (p.component.y + p.d.miny) + "px";
        }
    });

    /*
     * Class: Overlays.Custom
     * A Custom overlay. You supply a 'create' function which returns some DOM element, and jsPlumb positions it.
     * The 'create' function is passed a Connection or Endpoint.
     */
    /*
     * Function: Constructor
     * 
     * Parameters:
     * create - function for jsPlumb to call that returns a DOM element.
     * location - distance (as a decimal from 0 to 1 inclusive) marking where the label should sit on the connector. defaults to 0.5.
     * id - optional id to use for later retrieval of this overlay.
     *
     */
    _jp.Overlays.Custom = function (params) {
        this.type = "Custom";
        AbstractDOMOverlay.apply(this, arguments);
    };
    _ju.extend(_jp.Overlays.Custom, AbstractDOMOverlay);

    _jp.Overlays.GuideLines = function () {
        var self = this;
        self.length = 50;
        self.strokeWidth = 5;
        this.type = "GuideLines";
        AbstractOverlay.apply(this, arguments);
        _jp.jsPlumbUIComponent.apply(this, arguments);
        this.draw = function (connector, currentConnectionPaintStyle) {

            var head = connector.pointAlongPathFrom(self.loc, self.length / 2),
                mid = connector.pointOnPath(self.loc),
                tail = _jg.pointOnLine(head, mid, self.length),
                tailLine = _jg.perpendicularLineTo(head, tail, 40),
                headLine = _jg.perpendicularLineTo(tail, head, 20);

            return {
                connector: connector,
                head: head,
                tail: tail,
                headLine: headLine,
                tailLine: tailLine,
                minX: Math.min(head.x, tail.x, headLine[0].x, headLine[1].x),
                minY: Math.min(head.y, tail.y, headLine[0].y, headLine[1].y),
                maxX: Math.max(head.x, tail.x, headLine[0].x, headLine[1].x),
                maxY: Math.max(head.y, tail.y, headLine[0].y, headLine[1].y)
            };
        };

        // this.cleanup = function() { };  // nothing to clean up for GuideLines
    };

    /*
     * Class: Overlays.Label

     */
    /*
     * Function: Constructor
     * 
     * Parameters:
     * cssClass - optional css class string to append to css class. This string is appended "as-is", so you can of course have multiple classes
     *             defined.  This parameter is preferred to using labelStyle, borderWidth and borderStyle.
     * label - the label to paint.  May be a string or a function that returns a string.  Nothing will be painted if your label is null or your
     *         label function returns null.  empty strings _will_ be painted.
     * location - distance (as a decimal from 0 to 1 inclusive) marking where the label should sit on the connector. defaults to 0.5.
     * id - optional id to use for later retrieval of this overlay.
     * 
     *
     */
    _jp.Overlays.Label = function (params) {
        this.labelStyle = params.labelStyle;

        var labelWidth = null, labelHeight = null, labelText = null, labelPadding = null;
        this.cssClass = this.labelStyle != null ? this.labelStyle.cssClass : null;
        var p = _jp.extend({
            create: function () {
                return _jp.createElement("div");
            }}, params);
        _jp.Overlays.Custom.call(this, p);
        this.type = "Label";
        this.label = params.label || "";
        this.labelText = null;
        if (this.labelStyle) {
            var el = this.getElement();
            this.labelStyle.font = this.labelStyle.font || "12px sans-serif";
            el.style.font = this.labelStyle.font;
            el.style.color = this.labelStyle.color || "black";
            if (this.labelStyle.fill) {
                el.style.background = this.labelStyle.fill;
            }
            if (this.labelStyle.borderWidth > 0) {
                var dStyle = this.labelStyle.borderStyle ? this.labelStyle.borderStyle : "black";
                el.style.border = this.labelStyle.borderWidth + "px solid " + dStyle;
            }
            if (this.labelStyle.padding) {
                el.style.padding = this.labelStyle.padding;
            }
        }

    };
    _ju.extend(_jp.Overlays.Label, _jp.Overlays.Custom, {
        cleanup: function (force) {
            if (force) {
                this.div = null;
                this.label = null;
                this.labelText = null;
                this.cssClass = null;
                this.labelStyle = null;
            }
        },
        getLabel: function () {
            return this.label;
        },
        /*
         * Function: setLabel
         * sets the label's, um, label.  you would think i'd call this function
         * 'setText', but you can pass either a Function or a String to this, so
         * it makes more sense as 'setLabel'. This uses innerHTML on the label div, so keep
         * that in mind if you need escaped HTML.
         */
        setLabel: function (l) {
            this.label = l;
            this.labelText = null;
            this.clearCachedDimensions();
            this.update();
            this.component.repaint();
        },
        getDimensions: function () {
            this.update();
            return AbstractDOMOverlay.prototype.getDimensions.apply(this, arguments);
        },
        update: function () {
            if (typeof this.label === "function") {
                var lt = this.label(this);
                this.getElement().innerHTML = lt.replace(/\r\n/g, "<br/>");
            }
            else {
                if (this.labelText == null) {
                    this.labelText = this.label;
                    this.getElement().innerHTML = this.labelText.replace(/\r\n/g, "<br/>");
                }
            }
        },
        updateFrom:function(d) {
            if(d.label != null){
                this.setLabel(d.label);
            }
        }
    });

    // ********************************* END OF OVERLAY DEFINITIONS ***********************************************************************

}).call(typeof window !== 'undefined' ? window : this);

/*
 * jsPlumb Community Edition
 *
 * Provides a way to visually connect elements on an HTML page, using SVG.
 *
 * This file contains the base class for library adapters.
 *
 * Copyright (c) 2010 - 2017 jsPlumb (hello@jsplumbtoolkit.com)
 *
 * https://jsplumbtoolkit.com
 * https://github.com/jsplumb/jsplumb
 *
 * Dual licensed under the MIT and GPL2 licenses.
 */
;(function() {
    "use strict";
    var root = this,
        _jp = root.jsPlumb;

    var _getEventManager = function(instance) {
        var e = instance._mottle;
        if (!e) {
            e = instance._mottle = new root.Mottle();
        }
        return e;
    };

    _jp.extend(root.jsPlumbInstance.prototype, {
        getEventManager:function() {
            return _getEventManager(this);
        },
        on : function(el, event, callback) {
            // TODO: here we would like to map the tap event if we know its
            // an internal bind to a click. we have to know its internal because only
            // then can we be sure that the UP event wont be consumed (tap is a synthesized
            // event from a mousedown followed by a mouseup).
            //event = { "click":"tap", "dblclick":"dbltap"}[event] || event;
            this.getEventManager().on.apply(this, arguments);
            return this;
        },
        off : function(el, event, callback) {
            this.getEventManager().off.apply(this, arguments);
            return this;
        }
    });


}).call(typeof window !== 'undefined' ? window : this);
/*
 * jsPlumb Community Edition
 *
 * Provides a way to visually connect elements on an HTML page, using SVG.
 *
 * This file contains the code for working with Groups.
 *
 * Copyright (c) 2010 - 2017 jsPlumb (hello@jsplumbtoolkit.com)
 *
 * https://jsplumbtoolkit.com
 * https://github.com/jsplumb/jsplumb
 *
 * Dual licensed under the MIT and GPL2 licenses.
 */
;(function() {
    "use strict";

    var root = this,
        _ju = root.jsPlumbUtil,
        _jpi = root.jsPlumbInstance;

    var GROUP_COLLAPSED_CLASS = "jtk-group-collapsed";
    var GROUP_EXPANDED_CLASS = "jtk-group-expanded";
    var GROUP_CONTAINER_SELECTOR = "[jtk-group-content]";
    var ELEMENT_DRAGGABLE_EVENT = "elementDraggable";
    var STOP = "stop";
    var REVERT = "revert";
    var GROUP_MANAGER = "_groupManager";
    var GROUP = "_jsPlumbGroup";
    var GROUP_DRAG_SCOPE = "_jsPlumbGroupDrag";
    var EVT_CHILD_ADDED = "group:addMember";
    var EVT_CHILD_REMOVED = "group:removeMember";
    var EVT_GROUP_ADDED = "group:add";
    var EVT_GROUP_REMOVED = "group:remove";
    var EVT_EXPAND = "group:expand";
    var EVT_COLLAPSE = "group:collapse";
    var EVT_GROUP_DRAG_STOP = "groupDragStop";
    var EVT_CONNECTION_MOVED = "connectionMoved";
    var EVT_INTERNAL_CONNECTION_DETACHED = "internal.connectionDetached";

    var CMD_REMOVE_ALL = "removeAll";
    var CMD_ORPHAN_ALL = "orphanAll";
    var CMD_SHOW = "show";
    var CMD_HIDE = "hide";

    var GroupManager = function(_jsPlumb) {
        var _managedGroups = {}, _connectionSourceMap = {}, _connectionTargetMap = {}, self = this;

        _jsPlumb.bind("connection", function(p) {
            if (p.source[GROUP] != null && p.target[GROUP] != null && p.source[GROUP] === p.target[GROUP]) {
                _connectionSourceMap[p.connection.id] = p.source[GROUP];
                _connectionTargetMap[p.connection.id] = p.source[GROUP];
            }
            else {
                if (p.source[GROUP] != null) {
                    _ju.suggest(p.source[GROUP].connections.source, p.connection);
                    _connectionSourceMap[p.connection.id] = p.source[GROUP];
                }
                if (p.target[GROUP] != null) {
                    _ju.suggest(p.target[GROUP].connections.target, p.connection);
                    _connectionTargetMap[p.connection.id] = p.target[GROUP];
                }
            }
        });

        function _cleanupDetachedConnection(conn) {
            delete conn.proxies;
            var group = _connectionSourceMap[conn.id], f;
            if (group != null) {
                f = function(c) { return c.id === conn.id; };
                _ju.removeWithFunction(group.connections.source, f);
                _ju.removeWithFunction(group.connections.target, f);
                delete _connectionSourceMap[conn.id];
            }

            group = _connectionTargetMap[conn.id];
            if (group != null) {
                f = function(c) { return c.id === conn.id; };
                _ju.removeWithFunction(group.connections.source, f);
                _ju.removeWithFunction(group.connections.target, f);
                delete _connectionTargetMap[conn.id];
            }
        }

        _jsPlumb.bind(EVT_INTERNAL_CONNECTION_DETACHED, function(p) {
            _cleanupDetachedConnection(p.connection);
        });

        _jsPlumb.bind(EVT_CONNECTION_MOVED, function(p) {
            var connMap = p.index === 0 ? _connectionSourceMap : _connectionTargetMap;
            var group = connMap[p.connection.id];
            if (group) {
                var list = group.connections[p.index === 0 ? "source" : "target"];
                var idx = list.indexOf(p.connection);
                if (idx !== -1) {
                    list.splice(idx, 1);
                }
            }
        });

        this.addGroup = function(group) {
            _jsPlumb.addClass(group.getEl(), GROUP_EXPANDED_CLASS);
            _managedGroups[group.id] = group;
            group.manager = this;
            _updateConnectionsForGroup(group);
            _jsPlumb.fire(EVT_GROUP_ADDED, { group:group });
        };

        this.addToGroup = function(group, el, doNotFireEvent) {
            group = this.getGroup(group);
            if (group) {
                //group.add(el, doNotFireEvent);
                var groupEl = group.getEl();

                if (el._isJsPlumbGroup) {
                    return;
                }
                var currentGroup = el._jsPlumbGroup;
                // if already a member of this group, do nothing
                if (currentGroup !== group) {
                    var elpos = _jsPlumb.getOffset(el, true);
                    var cpos = group.collapsed ? _jsPlumb.getOffset(groupEl, true) : _jsPlumb.getOffset(group.getDragArea(), true);

                    // otherwise, transfer to this group.
                    if (currentGroup != null) {
                        currentGroup.remove(el, doNotFireEvent);
                        self.updateConnectionsForGroup(currentGroup);
                    }
                    group.add(el, doNotFireEvent);

                    var handleDroppedConnections = function (list, index) {
                        var oidx = index === 0 ? 1 : 0;
                        list.each(function (c) {
                            c.setVisible(false);
                            if (c.endpoints[oidx].element._jsPlumbGroup === group) {
                                c.endpoints[oidx].setVisible(false);
                                self.expandConnection(c, oidx, group);
                            }
                            else {
                                c.endpoints[index].setVisible(false);
                                self.collapseConnection(c, index, group);
                            }
                        });
                    };

                    if (group.collapsed) {
                        handleDroppedConnections(_jsPlumb.select({source: el}), 0);
                        handleDroppedConnections(_jsPlumb.select({target: el}), 1);
                    }

                    var elId = _jsPlumb.getId(el);
                    _jsPlumb.dragManager.setParent(el, elId, groupEl, _jsPlumb.getId(groupEl), elpos);

                    var newPosition = { left: elpos.left - cpos.left, top: elpos.top - cpos.top };

                    _jsPlumb.setPosition(el, newPosition);

                    _jsPlumb.dragManager.revalidateParent(el, elId, elpos);

                    self.updateConnectionsForGroup(group);

                    _jsPlumb.revalidate(elId);

                    setTimeout(function () {
                        _jsPlumb.fire(EVT_CHILD_ADDED, {group: group, el: el});
                    }, 0);
                }
            }
        };

        this.removeFromGroup = function(group, el, doNotFireEvent) {
            group = this.getGroup(group);
            if (group) {
                group.remove(el, null, doNotFireEvent);
            }
        };

        this.getGroup = function(groupId) {
            var group = groupId;
            if (_ju.isString(groupId)) {
                group = _managedGroups[groupId];
                if (group == null) {
                    throw new TypeError("No such group [" + groupId + "]");
                }
            }
            return group;
        };

        this.getGroups = function() {
            var o = [];
            for (var g in _managedGroups) {
                o.push(_managedGroups[g]);
            }
            return o;
        };

        this.removeGroup = function(group, deleteMembers, manipulateDOM, doNotFireEvent) {
            group = this.getGroup(group);
            this.expandGroup(group, true); // this reinstates any original connections and removes all proxies, but does not fire an event.
            group[deleteMembers ? CMD_REMOVE_ALL : CMD_ORPHAN_ALL](manipulateDOM, doNotFireEvent);
            _jsPlumb.remove(group.getEl());
            delete _managedGroups[group.id];
            delete _jsPlumb._groups[group.id];
            _jsPlumb.fire(EVT_GROUP_REMOVED, { group:group });
        };

        this.removeAllGroups = function(deleteMembers, manipulateDOM, doNotFireEvent) {
            for (var g in _managedGroups) {
                this.removeGroup(_managedGroups[g], deleteMembers, manipulateDOM, doNotFireEvent);
            }
        };

        function _setVisible(group, state) {
            var m = group.getMembers();
            for (var i = 0; i < m.length; i++) {
                _jsPlumb[state ? CMD_SHOW : CMD_HIDE](m[i], true);
            }
        }

        var _collapseConnection = this.collapseConnection = function(c, index, group) {

            var proxyEp, groupEl = group.getEl(), groupElId = _jsPlumb.getId(groupEl),
                originalElementId = c.endpoints[index].elementId;

            var otherEl = c.endpoints[index === 0 ? 1 : 0].element;
            if (otherEl[GROUP] && (!otherEl[GROUP].shouldProxy() && otherEl[GROUP].collapsed)) {
                return;
            }

            c.proxies = c.proxies || [];
            if(c.proxies[index]) {
                proxyEp = c.proxies[index].ep;
            }else {
                proxyEp = _jsPlumb.addEndpoint(groupEl, {
                    endpoint:group.getEndpoint(c, index),
                    anchor:group.getAnchor(c, index),
                    parameters:{
                        isProxyEndpoint:true
                    }
                });
            }
            proxyEp.setDeleteOnEmpty(true);

            // for this index, stash proxy info: the new EP, the original EP.
            c.proxies[index] = { ep:proxyEp, originalEp: c.endpoints[index] };

            // and advise the anchor manager
            if (index === 0) {
                // TODO why are there two differently named methods? Why is there not one method that says "some end of this
                // connection changed (you give the index), and here's the new element and element id."
                _jsPlumb.anchorManager.sourceChanged(originalElementId, groupElId, c, groupEl);
            }
            else {
                _jsPlumb.anchorManager.updateOtherEndpoint(c.endpoints[0].elementId, originalElementId, groupElId, c);
                c.target = groupEl;
                c.targetId = groupElId;
            }


            // detach the original EP from the connection.
            c.proxies[index].originalEp.detachFromConnection(c, null, true);

            // set the proxy as the new ep
            proxyEp.connections = [ c ];
            c.endpoints[index] = proxyEp;

            c.setVisible(true);
        };

        this.collapseGroup = function(group) {
            group = this.getGroup(group);
            if (group == null || group.collapsed) {
                return;
            }
            var groupEl = group.getEl();

            // todo remove old proxy endpoints first, just in case?
            //group.proxies.length = 0;

            // hide all connections
            _setVisible(group, false);

            if (group.shouldProxy()) {
                // collapses all connections in a group.
                var _collapseSet = function (conns, index) {
                    for (var i = 0; i < conns.length; i++) {
                        var c = conns[i];
                        _collapseConnection(c, index, group);
                    }
                };

                // setup proxies for sources and targets
                _collapseSet(group.connections.source, 0);
                _collapseSet(group.connections.target, 1);
            }

            group.collapsed = true;
            _jsPlumb.removeClass(groupEl, GROUP_EXPANDED_CLASS);
            _jsPlumb.addClass(groupEl, GROUP_COLLAPSED_CLASS);
            _jsPlumb.revalidate(groupEl);
            _jsPlumb.fire(EVT_COLLAPSE, { group:group  });
        };

        var _expandConnection = this.expandConnection = function(c, index, group) {

            // if no proxies or none for this end of the connection, abort.
            if (c.proxies == null || c.proxies[index] == null) {
                return;
            }

            var groupElId = _jsPlumb.getId(group.getEl()),
                originalElement = c.proxies[index].originalEp.element,
                originalElementId = c.proxies[index].originalEp.elementId;

            c.endpoints[index] = c.proxies[index].originalEp;
            // and advise the anchor manager
            if (index === 0) {
                // TODO why are there two differently named methods? Why is there not one method that says "some end of this
                // connection changed (you give the index), and here's the new element and element id."
                _jsPlumb.anchorManager.sourceChanged(groupElId, originalElementId, c, originalElement);
            }
            else {
                _jsPlumb.anchorManager.updateOtherEndpoint(c.endpoints[0].elementId, groupElId, originalElementId, c);
                c.target = originalElement;
                c.targetId = originalElementId;
            }

            // detach the proxy EP from the connection (which will cause it to be removed as we no longer need it)
            c.proxies[index].ep.detachFromConnection(c, null);

            c.proxies[index].originalEp.addConnection(c);

            // cleanup
            delete c.proxies[index];
        };

        this.expandGroup = function(group, doNotFireEvent) {

            group = this.getGroup(group);

            if (group == null || !group.collapsed) {
                return;
            }
            var groupEl = group.getEl();

            _setVisible(group, true);

            if (group.shouldProxy()) {
                // collapses all connections in a group.
                var _expandSet = function (conns, index) {
                    for (var i = 0; i < conns.length; i++) {
                        var c = conns[i];
                        _expandConnection(c, index, group);
                    }
                };

                // setup proxies for sources and targets
                _expandSet(group.connections.source, 0);
                _expandSet(group.connections.target, 1);
            }

            group.collapsed = false;
            _jsPlumb.addClass(groupEl, GROUP_EXPANDED_CLASS);
            _jsPlumb.removeClass(groupEl, GROUP_COLLAPSED_CLASS);
            _jsPlumb.revalidate(groupEl);
            this.repaintGroup(group);
            if (!doNotFireEvent) {
                _jsPlumb.fire(EVT_EXPAND, { group: group});
            }
        };

        this.repaintGroup = function(group) {
            group = this.getGroup(group);
            var m = group.getMembers();
            for (var i = 0; i < m.length; i++) {
                _jsPlumb.revalidate(m[i]);
            }
        };

        // TODO refactor this with the code that responds to `connection` events.
        function _updateConnectionsForGroup(group) {
            var members = group.getMembers();
            var c1 = _jsPlumb.getConnections({source:members}, true);
            var c2 = _jsPlumb.getConnections({target:members}, true);
            var processed = {};
            group.connections.source.length = 0;
            group.connections.target.length = 0;
            var oneSet = function(c) {
                for (var i = 0; i < c.length; i++) {
                    if (processed[c[i].id]) {
                        continue;
                    }
                    processed[c[i].id] = true;
                    if (c[i].source._jsPlumbGroup === group) {
                        if (c[i].target._jsPlumbGroup !== group) {
                            group.connections.source.push(c[i]);
                        }
                        _connectionSourceMap[c[i].id] = group;
                    }
                    else if (c[i].target._jsPlumbGroup === group) {
                        group.connections.target.push(c[i]);
                        _connectionTargetMap[c[i].id] = group;
                    }
                }
            };
            oneSet(c1); oneSet(c2);
        }

        this.updateConnectionsForGroup = _updateConnectionsForGroup;
        this.refreshAllGroups = function() {
            for (var g in _managedGroups) {
                _updateConnectionsForGroup(_managedGroups[g]);
                _jsPlumb.dragManager.updateOffsets(_jsPlumb.getId(_managedGroups[g].getEl()));
            }
        };
    };

    /**
     *
     * @param {jsPlumbInstance} _jsPlumb Associated jsPlumb instance.
     * @param {Object} params
     * @param {Element} params.el The DOM element representing the Group.
     * @param {String} [params.id] Optional ID for the Group. A UUID will be assigned as the Group's ID if you do not provide one.
     * @param {Boolean} [params.constrain=false] If true, child elements will not be able to be dragged outside of the Group container.
     * @param {Boolean} [params.revert=true] By default, child elements revert to the container if dragged outside. You can change this by setting `revert:false`. This behaviour is also overridden if you set `orphan` or `prune`.
     * @param {Boolean} [params.orphan=false] If true, child elements dropped outside of the Group container will be removed from the Group (but not from the DOM).
     * @param {Boolean} [params.prune=false] If true, child elements dropped outside of the Group container will be removed from the Group and also from the DOM.
     * @param {Boolean} [params.dropOverride=false] If true, a child element that has been dropped onto some other Group will not be subject to the controls imposed by `prune`, `revert` or `orphan`.
     * @constructor
     */
    var Group = function(_jsPlumb, params) {
        var self = this;
        var el = params.el;
        this.getEl = function() { return el; };
        this.id = params.id || _ju.uuid();
        el._isJsPlumbGroup = true;

        var getDragArea = this.getDragArea = function() {
            var da = _jsPlumb.getSelector(el, GROUP_CONTAINER_SELECTOR);
            return da && da.length > 0 ? da[0] : el;
        };

        var ghost = params.ghost === true;
        var constrain = ghost || (params.constrain === true);
        var revert = params.revert !== false;
        var orphan = params.orphan === true;
        var prune = params.prune === true;
        var dropOverride = params.dropOverride === true;
        var proxied = params.proxied !== false;
        var elements = [];
        this.connections = { source:[], target:[], internal:[] };

        // this function, and getEndpoint below, are stubs for a future setup in which we can choose endpoint
        // and anchor based upon the connection and the index (source/target) of the endpoint to be proxied.
        this.getAnchor = function(conn, endpointIndex) {
            return params.anchor || "Continuous";
        };

        this.getEndpoint = function(conn, endpointIndex) {
            return params.endpoint || [ "Dot", { radius:10 }];
        };

        this.collapsed = false;
        if (params.draggable !== false) {
            var opts = {
                stop:function(params) {
                    _jsPlumb.fire(EVT_GROUP_DRAG_STOP, jsPlumb.extend(params, {group:self}));
                },
                scope:GROUP_DRAG_SCOPE
            };
            if (params.dragOptions) {
                root.jsPlumb.extend(opts, params.dragOptions);
            }
            _jsPlumb.draggable(params.el, opts);
        }
        if (params.droppable !== false) {
            _jsPlumb.droppable(params.el, {
                drop:function(p) {
                    var el = p.drag.el;
                    if (el._isJsPlumbGroup) {
                        return;
                    }
                    var currentGroup = el._jsPlumbGroup;
                    if (currentGroup !== self) {
                        if (currentGroup != null) {
                            if (currentGroup.overrideDrop(el, self)) {
                                return;
                            }
                        }
                        _jsPlumb.getGroupManager().addToGroup(self, el, false);
                    }

                }
            });
        }
        var _each = function(_el, fn) {
            var els = _el.nodeType == null ?  _el : [ _el ];
            for (var i = 0; i < els.length; i++) {
                fn(els[i]);
            }
        };

        this.overrideDrop = function(_el, targetGroup) {
            return dropOverride && (revert || prune || orphan);
        };

        this.add = function(_el, doNotFireEvent) {
            var dragArea = getDragArea();
            _each(_el, function(__el) {

                if (__el._jsPlumbGroup != null) {
                    if (__el._jsPlumbGroup === self) {
                        return;
                    } else {
                        __el._jsPlumbGroup.remove(__el, true, doNotFireEvent, false);
                    }
                }

                __el._jsPlumbGroup = self;
                elements.push(__el);
                // test if draggable and add handlers if so.
                if (_jsPlumb.isAlreadyDraggable(__el)) {
                    _bindDragHandlers(__el);
                }

                if (__el.parentNode !== dragArea) {
                    dragArea.appendChild(__el);
                }

                if (!doNotFireEvent) {
                    _jsPlumb.fire(EVT_CHILD_ADDED, {group: self, el: __el});
                }
            });

            _jsPlumb.getGroupManager().updateConnectionsForGroup(self);
        };

        this.remove = function(el, manipulateDOM, doNotFireEvent, doNotUpdateConnections) {

            _each(el, function(__el) {
                delete __el._jsPlumbGroup;
                _ju.removeWithFunction(elements, function(e) {
                    return e === __el;
                });

                if (manipulateDOM) {
                    try { self.getDragArea().removeChild(__el); }
                    catch (e) {
                        jsPlumbUtil.log("Could not remove element from Group " + e);
                    }
                }
                _unbindDragHandlers(__el);
                if (!doNotFireEvent) {
                    _jsPlumb.fire(EVT_CHILD_REMOVED, {group: self, el: __el});
                }
            });
            if (!doNotUpdateConnections) {
                _jsPlumb.getGroupManager().updateConnectionsForGroup(self);
            }
        };
        this.removeAll = function(manipulateDOM, doNotFireEvent) {
            for (var i = 0, l = elements.length; i < l; i++) {
                self.remove(elements[0], manipulateDOM, doNotFireEvent, true);
            }
            elements.length = 0;
            _jsPlumb.getGroupManager().updateConnectionsForGroup(self);
        };
        this.orphanAll = function() {
            for (var i = 0; i < elements.length; i++) {
                _orphan(elements[i]);
            }
            elements.length = 0;
        };
        this.getMembers = function() { return elements; };

        el[GROUP] = this;

        _jsPlumb.bind(ELEMENT_DRAGGABLE_EVENT, function(dragParams) {
            // if its for the current group,
            if (dragParams.el._jsPlumbGroup === this) {
                _bindDragHandlers(dragParams.el);
            }
        }.bind(this));

        function _findParent(_el) {
            return _el.offsetParent;
        }

        function _isInsideParent(_el, pos) {
            var p = _findParent(_el),
                s = _jsPlumb.getSize(p),
                ss = _jsPlumb.getSize(_el),
                leftEdge = pos[0],
                rightEdge = leftEdge + ss[0],
                topEdge = pos[1],
                bottomEdge = topEdge + ss[1];

            return rightEdge > 0 && leftEdge < s[0] && bottomEdge > 0 && topEdge < s[1];
        }

        //
        // orphaning an element means taking it out of the group and adding it to the main jsplumb container.
        //
        function _orphan(_el) {
            var id = _jsPlumb.getId(_el);
            var pos = _jsPlumb.getOffset(_el);
            _el.parentNode.removeChild(_el);
            _jsPlumb.getContainer().appendChild(_el);
            _jsPlumb.setPosition(_el, pos);
            delete _el._jsPlumbGroup;
            _unbindDragHandlers(_el);
            _jsPlumb.dragManager.clearParent(_el, id);
        }

        //
        // remove an element from the group, then either prune it from the jsplumb instance, or just orphan it.
        //
        function _pruneOrOrphan(p) {
            if (!_isInsideParent(p.el, p.pos)) {
                var group = p.el._jsPlumbGroup;
                if (prune) {
                    _jsPlumb.remove(p.el);
                } else {
                    _orphan(p.el);
                }

                group.remove(p.el);
            }
        }

        //
        // redraws the element
        //
        function _revalidate(_el) {
            var id = _jsPlumb.getId(_el);
            _jsPlumb.revalidate(_el);
            _jsPlumb.dragManager.revalidateParent(_el, id);
        }

        //
        // unbind the group specific drag/revert handlers.
        //
        function _unbindDragHandlers(_el) {
            if (!_el._katavorioDrag) {
                return;
            }
            if (prune || orphan) {
                _el._katavorioDrag.off(STOP, _pruneOrOrphan);
            }
            if (!prune && !orphan && revert) {
                _el._katavorioDrag.off(REVERT, _revalidate);
                _el._katavorioDrag.setRevert(null);
            }
        }

        function _bindDragHandlers(_el) {
            if (!_el._katavorioDrag) {
                return;
            }
            if (prune || orphan) {
                _el._katavorioDrag.on(STOP, _pruneOrOrphan);
            }

            if (constrain) {
                _el._katavorioDrag.setConstrain(true);
            }

            if (ghost) {
                _el._katavorioDrag.setUseGhostProxy(true);
            }

            if (!prune && !orphan && revert) {
                _el._katavorioDrag.on(REVERT, _revalidate);
                _el._katavorioDrag.setRevert(function(__el, pos) {
                    return !_isInsideParent(__el, pos);
                });
            }
        }

        this.shouldProxy = function() {
            return proxied;
        };

        _jsPlumb.getGroupManager().addGroup(this);
    };

    /**
     * Adds a group to the jsPlumb instance.
     * @method addGroup
     * @param {Object} params
     * @return {Group} The newly created Group.
     */
    _jpi.prototype.addGroup = function(params) {
        var j = this;
        j._groups = j._groups || {};
        if (j._groups[params.id] != null) {
            throw new TypeError("cannot create Group [" + params.id + "]; a Group with that ID exists");
        }
        if (params.el[GROUP] != null) {
            throw new TypeError("cannot create Group [" + params.id + "]; the given element is already a Group");
        }
        var group = new Group(j, params);
        j._groups[group.id] = group;
        if (params.collapsed) {
            this.collapseGroup(group);
        }
        return group;
    };

    /**
     * Add an element to a group.
     * @method addToGroup
     * @param {String} group Group, or ID of the group, to add the element to.
     * @param {Element} el Element to add to the group.
     */
    _jpi.prototype.addToGroup = function(group, el, doNotFireEvent) {

        var _one = function(_el) {
            var id = this.getId(_el);
            this.manage(id, _el);
            this.getGroupManager().addToGroup(group, _el, doNotFireEvent);
        }.bind(this);

        if (Array.isArray(el)) {
            for (var i = 0; i < el.length; i++) {
                _one(el[i]);
            }
        } else {
            _one(el);
        }
    };

    /**
     * Remove an element from a group.
     * @method removeFromGroup
     * @param {String} group Group, or ID of the group, to remove the element from.
     * @param {Element} el Element to add to the group.
     */
    _jpi.prototype.removeFromGroup = function(group, el, doNotFireEvent) {
        this.getGroupManager().removeFromGroup(group, el, doNotFireEvent);
    };

    /**
     * Remove a group, and optionally remove its members from the jsPlumb instance.
     * @method removeGroup
     * @param {String|Group} group Group to delete, or ID of Group to delete.
     * @param {Boolean} [deleteMembers=false] If true, group members will be removed along with the group. Otherwise they will
     * just be 'orphaned' (returned to the main container).
     */
    _jpi.prototype.removeGroup = function(group, deleteMembers, manipulateDOM, doNotFireEvent) {
        this.getGroupManager().removeGroup(group, deleteMembers, manipulateDOM, doNotFireEvent);
    };

    /**
     * Remove all groups, and optionally remove their members from the jsPlumb instance.
     * @method removeAllGroup
     * @param {Boolean} [deleteMembers=false] If true, group members will be removed along with the groups. Otherwise they will
     * just be 'orphaned' (returned to the main container).
     */
    _jpi.prototype.removeAllGroups = function(deleteMembers, manipulateDOM, doNotFireEvent) {
        this.getGroupManager().removeAllGroups(deleteMembers, manipulateDOM, doNotFireEvent);
    };

    /**
     * Get a Group
     * @method getGroup
     * @param {String} groupId ID of the group to get
     * @return {Group} Group with the given ID, null if not found.
     */
    _jpi.prototype.getGroup = function(groupId) {
        return this.getGroupManager().getGroup(groupId);
    };

    /**
     * Gets all the Groups managed by the jsPlumb instance.
     * @returns {Group[]} List of Groups. Empty if none.
     */
    _jpi.prototype.getGroups = function() {
        return this.getGroupManager().getGroups();
    };

    /**
     * Expands a group element. jsPlumb doesn't do "everything" for you here, because what it means to expand a Group
     * will vary from application to application. jsPlumb does these things:
     *
     * - Hides any connections that are internal to the group (connections between members, and connections from member of
     * the group to the group itself)
     * - Proxies all connections for which the source or target is a member of the group.
     * - Hides the proxied connections.
     * - Adds the jtk-group-expanded class to the group's element
     * - Removes the jtk-group-collapsed class from the group's element.
     *
     * @method expandGroup
     * @param {String|Group} group Group to expand, or ID of Group to expand.
     */
    _jpi.prototype.expandGroup = function(group) {
        this.getGroupManager().expandGroup(group);
    };

    /**
     * Collapses a group element. jsPlumb doesn't do "everything" for you here, because what it means to collapse a Group
     * will vary from application to application. jsPlumb does these things:
     *
     * - Shows any connections that are internal to the group (connections between members, and connections from member of
     * the group to the group itself)
     * - Removes proxies for all connections for which the source or target is a member of the group.
     * - Shows the previously proxied connections.
     * - Adds the jtk-group-collapsed class to the group's element
     * - Removes the jtk-group-expanded class from the group's element.
     *
     * @method expandGroup
     * @param {String|Group} group Group to expand, or ID of Group to expand.
     */
    _jpi.prototype.collapseGroup = function(groupId) {
        this.getGroupManager().collapseGroup(groupId);
    };


    _jpi.prototype.repaintGroup = function(group) {
        this.getGroupManager().repaintGroup(group);
    };

    /**
     * Collapses or expands a group element depending on its current state. See notes in the collapseGroup and expandGroup method.
     *
     * @method toggleGroup
     * @param {String|Group} group Group to expand/collapse, or ID of Group to expand/collapse.
     */
    _jpi.prototype.toggleGroup = function(group) {
        group = this.getGroupManager().getGroup(group);
        if (group != null) {
            this.getGroupManager()[group.collapsed ? "expandGroup" : "collapseGroup"](group);
        }
    };

    //
    // lazy init a group manager for the given jsplumb instance.
    //
    _jpi.prototype.getGroupManager = function() {
        var mgr = this[GROUP_MANAGER];
        if (mgr == null) {
            mgr = this[GROUP_MANAGER] = new GroupManager(this);
        }
        return mgr;
    };

    _jpi.prototype.removeGroupManager = function() {
        delete this[GROUP_MANAGER];
    };

    /**
     * Gets the Group that the given element belongs to, null if none.
     * @method getGroupFor
     * @param {String|Element} el Element, or element ID.
     * @returns {Group} A Group, if found, or null.
     */
    _jpi.prototype.getGroupFor = function(el) {
        el = this.getElement(el);
        if (el) {
            return el[GROUP];
        }
    };

}).call(typeof window !== 'undefined' ? window : this);


/*
 * jsPlumb Community Edition
 * 
 * Provides a way to visually connect elements on an HTML page, using SVG.
 * 
 * This file contains the 'flowchart' connectors, consisting of vertical and horizontal line segments.
 *
 * Copyright (c) 2010 - 2017 jsPlumb (hello@jsplumbtoolkit.com)
 * 
 * https://jsplumbtoolkit.com
 * https://github.com/jsplumb/jsplumb
 * 
 * Dual licensed under the MIT and GPL2 licenses.
 */
;
(function () {

    "use strict";
    var root = this, _jp = root.jsPlumb, _ju = root.jsPlumbUtil;

    var Flowchart = function (params) {
        this.type = "Flowchart";
        params = params || {};
        params.stub = params.stub == null ? 30 : params.stub;
        var segments,
            _super = _jp.Connectors.AbstractConnector.apply(this, arguments),
            midpoint = params.midpoint == null ? 0.5 : params.midpoint,
            alwaysRespectStubs = params.alwaysRespectStubs === true,
            lastx = null, lasty = null, lastOrientation,
            cornerRadius = params.cornerRadius != null ? params.cornerRadius : 0,

            // TODO now common between this and AbstractBezierEditor; refactor into superclass?
            loopbackRadius = params.loopbackRadius || 25,
            isLoopbackCurrently = false,

            sgn = function (n) {
                return n < 0 ? -1 : n === 0 ? 0 : 1;
            },
            /**
             * helper method to add a segment.
             */
            addSegment = function (segments, x, y, paintInfo) {
                if (lastx === x && lasty === y) {
                    return;
                }
                var lx = lastx == null ? paintInfo.sx : lastx,
                    ly = lasty == null ? paintInfo.sy : lasty,
                    o = lx === x ? "v" : "h",
                    sgnx = sgn(x - lx),
                    sgny = sgn(y - ly);

                lastx = x;
                lasty = y;
                segments.push([lx, ly, x, y, o, sgnx, sgny]);
            },
            segLength = function (s) {
                return Math.sqrt(Math.pow(s[0] - s[2], 2) + Math.pow(s[1] - s[3], 2));
            },
            _cloneArray = function (a) {
                var _a = [];
                _a.push.apply(_a, a);
                return _a;
            },
            writeSegments = function (conn, segments, paintInfo) {
                var current = null, next;
                for (var i = 0; i < segments.length - 1; i++) {

                    current = current || _cloneArray(segments[i]);
                    next = _cloneArray(segments[i + 1]);
                    if (cornerRadius > 0 && current[4] !== next[4]) {
                        var radiusToUse = Math.min(cornerRadius, segLength(current), segLength(next));
                        // right angle. adjust current segment's end point, and next segment's start point.
                        current[2] -= current[5] * radiusToUse;
                        current[3] -= current[6] * radiusToUse;
                        next[0] += next[5] * radiusToUse;
                        next[1] += next[6] * radiusToUse;
                        var ac = (current[6] === next[5] && next[5] === 1) ||
                                ((current[6] === next[5] && next[5] === 0) && current[5] !== next[6]) ||
                                (current[6] === next[5] && next[5] === -1),
                            sgny = next[1] > current[3] ? 1 : -1,
                            sgnx = next[0] > current[2] ? 1 : -1,
                            sgnEqual = sgny === sgnx,
                            cx = (sgnEqual && ac || (!sgnEqual && !ac)) ? next[0] : current[2],
                            cy = (sgnEqual && ac || (!sgnEqual && !ac)) ? current[3] : next[1];

                        _super.addSegment(conn, "Straight", {
                            x1: current[0], y1: current[1], x2: current[2], y2: current[3]
                        });

                        _super.addSegment(conn, "Arc", {
                            r: radiusToUse,
                            x1: current[2],
                            y1: current[3],
                            x2: next[0],
                            y2: next[1],
                            cx: cx,
                            cy: cy,
                            ac: ac
                        });
                    }
                    else {
                        // dx + dy are used to adjust for line width.
                        var dx = (current[2] === current[0]) ? 0 : (current[2] > current[0]) ? (paintInfo.lw / 2) : -(paintInfo.lw / 2),
                            dy = (current[3] === current[1]) ? 0 : (current[3] > current[1]) ? (paintInfo.lw / 2) : -(paintInfo.lw / 2);
                        _super.addSegment(conn, "Straight", {
                            x1: current[0] - dx, y1: current[1] - dy, x2: current[2] + dx, y2: current[3] + dy
                        });
                    }
                    current = next;
                }
                if (next != null) {
                    // last segment
                    _super.addSegment(conn, "Straight", {
                        x1: next[0], y1: next[1], x2: next[2], y2: next[3]
                    });
                }
            };

        this._compute = function (paintInfo, params) {

            segments = [];
            lastx = null;
            lasty = null;
            lastOrientation = null;

            var commonStubCalculator = function () {
                return [ paintInfo.startStubX, paintInfo.startStubY, paintInfo.endStubX, paintInfo.endStubY ];
            },
                stubCalculators = {
                    perpendicular: commonStubCalculator,
                    orthogonal: commonStubCalculator,
                    opposite: function (axis) {
                        var pi = paintInfo,
                            idx = axis === "x" ? 0 : 1,
                            areInProximity = {
                                "x": function () {
                                    return ( (pi.so[idx] === 1 && (
                                        ( (pi.startStubX > pi.endStubX) && (pi.tx > pi.startStubX) ) ||
                                        ( (pi.sx > pi.endStubX) && (pi.tx > pi.sx))))) ||

                                        ( (pi.so[idx] === -1 && (
                                            ( (pi.startStubX < pi.endStubX) && (pi.tx < pi.startStubX) ) ||
                                            ( (pi.sx < pi.endStubX) && (pi.tx < pi.sx)))));
                                },
                                "y": function () {
                                    return ( (pi.so[idx] === 1 && (
                                        ( (pi.startStubY > pi.endStubY) && (pi.ty > pi.startStubY) ) ||
                                        ( (pi.sy > pi.endStubY) && (pi.ty > pi.sy))))) ||

                                        ( (pi.so[idx] === -1 && (
                                            ( (pi.startStubY < pi.endStubY) && (pi.ty < pi.startStubY) ) ||
                                            ( (pi.sy < pi.endStubY) && (pi.ty < pi.sy)))));
                                }
                            };

                        if (!alwaysRespectStubs && areInProximity[axis]()) {
                            return {
                                "x": [(paintInfo.sx + paintInfo.tx) / 2, paintInfo.startStubY, (paintInfo.sx + paintInfo.tx) / 2, paintInfo.endStubY],
                                "y": [paintInfo.startStubX, (paintInfo.sy + paintInfo.ty) / 2, paintInfo.endStubX, (paintInfo.sy + paintInfo.ty) / 2]
                            }[axis];
                        }
                        else {
                            return [ paintInfo.startStubX, paintInfo.startStubY, paintInfo.endStubX, paintInfo.endStubY ];
                        }
                    }
                };

            // calculate Stubs.
            var stubs = stubCalculators[paintInfo.anchorOrientation](paintInfo.sourceAxis),
                idx = paintInfo.sourceAxis === "x" ? 0 : 1,
                oidx = paintInfo.sourceAxis === "x" ? 1 : 0,
                ss = stubs[idx],
                oss = stubs[oidx],
                es = stubs[idx + 2],
                oes = stubs[oidx + 2];

            // add the start stub segment. use stubs for loopback as it will look better, with the loop spaced
            // away from the element.
            addSegment(segments, stubs[0], stubs[1], paintInfo);

            // if its a loopback and we should treat it differently.
            if (false) {

                // we use loopbackRadius here, as statemachine connectors do.
                // so we go radius to the left from stubs[0], then upwards by 2*radius, to the right by 2*radius,
                // down by 2*radius, left by radius.
                addSegment(segments, stubs[0] - loopbackRadius, stubs[1], paintInfo);
                addSegment(segments, stubs[0] - loopbackRadius, stubs[1] - (2 * loopbackRadius), paintInfo);
                addSegment(segments, stubs[0] + loopbackRadius, stubs[1] - (2 * loopbackRadius), paintInfo);
                addSegment(segments, stubs[0] + loopbackRadius, stubs[1], paintInfo);
                addSegment(segments, stubs[0], stubs[1], paintInfo);

            }
            else {


                var midx = paintInfo.startStubX + ((paintInfo.endStubX - paintInfo.startStubX) * midpoint),
                    midy = paintInfo.startStubY + ((paintInfo.endStubY - paintInfo.startStubY) * midpoint);

                var orientations = { x: [ 0, 1 ], y: [ 1, 0 ] },
                    lineCalculators = {
                        perpendicular: function (axis) {
                            var pi = paintInfo,
                                sis = {
                                    x: [
                                        [ [ 1, 2, 3, 4 ], null, [ 2, 1, 4, 3 ] ],
                                        null,
                                        [ [ 4, 3, 2, 1 ], null, [ 3, 4, 1, 2 ] ]
                                    ],
                                    y: [
                                        [ [ 3, 2, 1, 4 ], null, [ 2, 3, 4, 1 ] ],
                                        null,
                                        [ [ 4, 1, 2, 3 ], null, [ 1, 4, 3, 2 ] ]
                                    ]
                                },
                                stubs = {
                                    x: [ [ pi.startStubX, pi.endStubX ], null, [ pi.endStubX, pi.startStubX ] ],
                                    y: [ [ pi.startStubY, pi.endStubY ], null, [ pi.endStubY, pi.startStubY ] ]
                                },
                                midLines = {
                                    x: [ [ midx, pi.startStubY ], [ midx, pi.endStubY ] ],
                                    y: [ [ pi.startStubX, midy ], [ pi.endStubX, midy ] ]
                                },
                                linesToEnd = {
                                    x: [ [ pi.endStubX, pi.startStubY ] ],
                                    y: [ [ pi.startStubX, pi.endStubY ] ]
                                },
                                startToEnd = {
                                    x: [ [ pi.startStubX, pi.endStubY ], [ pi.endStubX, pi.endStubY ] ],
                                    y: [ [ pi.endStubX, pi.startStubY ], [ pi.endStubX, pi.endStubY ] ]
                                },
                                startToMidToEnd = {
                                    x: [ [ pi.startStubX, midy ], [ pi.endStubX, midy ], [ pi.endStubX, pi.endStubY ] ],
                                    y: [ [ midx, pi.startStubY ], [ midx, pi.endStubY ], [ pi.endStubX, pi.endStubY ] ]
                                },
                                otherStubs = {
                                    x: [ pi.startStubY, pi.endStubY ],
                                    y: [ pi.startStubX, pi.endStubX ]
                                },
                                soIdx = orientations[axis][0], toIdx = orientations[axis][1],
                                _so = pi.so[soIdx] + 1,
                                _to = pi.to[toIdx] + 1,
                                otherFlipped = (pi.to[toIdx] === -1 && (otherStubs[axis][1] < otherStubs[axis][0])) || (pi.to[toIdx] === 1 && (otherStubs[axis][1] > otherStubs[axis][0])),
                                stub1 = stubs[axis][_so][0],
                                stub2 = stubs[axis][_so][1],
                                segmentIndexes = sis[axis][_so][_to];

                            if (pi.segment === segmentIndexes[3] || (pi.segment === segmentIndexes[2] && otherFlipped)) {
                                return midLines[axis];
                            }
                            else if (pi.segment === segmentIndexes[2] && stub2 < stub1) {
                                return linesToEnd[axis];
                            }
                            else if ((pi.segment === segmentIndexes[2] && stub2 >= stub1) || (pi.segment === segmentIndexes[1] && !otherFlipped)) {
                                return startToMidToEnd[axis];
                            }
                            else if (pi.segment === segmentIndexes[0] || (pi.segment === segmentIndexes[1] && otherFlipped)) {
                                return startToEnd[axis];
                            }
                        },
                        orthogonal: function (axis, startStub, otherStartStub, endStub, otherEndStub) {
                            var pi = paintInfo,
                                extent = {
                                    "x": pi.so[0] === -1 ? Math.min(startStub, endStub) : Math.max(startStub, endStub),
                                    "y": pi.so[1] === -1 ? Math.min(startStub, endStub) : Math.max(startStub, endStub)
                                }[axis];

                            return {
                                "x": [
                                    [ extent, otherStartStub ],
                                    [ extent, otherEndStub ],
                                    [ endStub, otherEndStub ]
                                ],
                                "y": [
                                    [ otherStartStub, extent ],
                                    [ otherEndStub, extent ],
                                    [ otherEndStub, endStub ]
                                ]
                            }[axis];
                        },
                        opposite: function (axis, ss, oss, es) {
                            var pi = paintInfo,
                                otherAxis = {"x": "y", "y": "x"}[axis],
                                dim = {"x": "height", "y": "width"}[axis],
                                comparator = pi["is" + axis.toUpperCase() + "GreaterThanStubTimes2"];

                            if (params.sourceEndpoint.elementId === params.targetEndpoint.elementId) {
                                var _val = oss + ((1 - params.sourceEndpoint.anchor[otherAxis]) * params.sourceInfo[dim]) + _super.maxStub;
                                return {
                                    "x": [
                                        [ ss, _val ],
                                        [ es, _val ]
                                    ],
                                    "y": [
                                        [ _val, ss ],
                                        [ _val, es ]
                                    ]
                                }[axis];

                            }
                            else if (!comparator || (pi.so[idx] === 1 && ss > es) || (pi.so[idx] === -1 && ss < es)) {
                                return {
                                    "x": [
                                        [ ss, midy ],
                                        [ es, midy ]
                                    ],
                                    "y": [
                                        [ midx, ss ],
                                        [ midx, es ]
                                    ]
                                }[axis];
                            }
                            else if ((pi.so[idx] === 1 && ss < es) || (pi.so[idx] === -1 && ss > es)) {
                                return {
                                    "x": [
                                        [ midx, pi.sy ],
                                        [ midx, pi.ty ]
                                    ],
                                    "y": [
                                        [ pi.sx, midy ],
                                        [ pi.tx, midy ]
                                    ]
                                }[axis];
                            }
                        }
                    };

                // compute the rest of the line
                var p = lineCalculators[paintInfo.anchorOrientation](paintInfo.sourceAxis, ss, oss, es, oes);
                if (p) {
                    for (var i = 0; i < p.length; i++) {
                        addSegment(segments, p[i][0], p[i][1], paintInfo);
                    }
                }

                // line to end stub
                addSegment(segments, stubs[2], stubs[3], paintInfo);

            }

            // end stub to end (common)
            addSegment(segments, paintInfo.tx, paintInfo.ty, paintInfo);

            // write out the segments.
            writeSegments(this, segments, paintInfo);
        };

        /*this.getPath = function () {
            var _last = null, _lastAxis = null, s = [], segs = segments;
            for (var i = 0; i < segs.length; i++) {
                var seg = segs[i], axis = seg[4], axisIndex = (axis == "v" ? 3 : 2);
                if (_last != null && _lastAxis === axis) {
                    _last[axisIndex] = seg[axisIndex];
                }
                else {
                    if (seg[0] != seg[2] || seg[1] != seg[3]) {
                        s.push({
                            start: [ seg[0], seg[1] ],
                            end: [ seg[2], seg[3] ]
                        });
                        _last = seg;
                        _lastAxis = seg[4];
                    }
                }
            }
            return s;
        };*/
    };

    _ju.extend(Flowchart, _jp.Connectors.AbstractConnector);
    _jp.registerConnectorType(Flowchart, "Flowchart");
}).call(typeof window !== 'undefined' ? window : this);
/*
 * jsPlumb Community Edition
 *
 * Provides a way to visually connect elements on an HTML page, using SVG.
 *
 * This file contains the code for the Bezier connector type.
 *
 * Copyright (c) 2010 - 2017 jsPlumb (hello@jsplumbtoolkit.com)
 *
 * https://jsplumbtoolkit.com
 * https://github.com/jsplumb/jsplumb
 * 
 * Dual licensed under the MIT and GPL2 licenses.
 */
;
(function () {

    "use strict";
    var root = this, _jp = root.jsPlumb, _ju = root.jsPlumbUtil;

    _jp.Connectors.AbstractBezierConnector = function(params) {
        params = params || {};
        var showLoopback = params.showLoopback !== false,
            curviness = params.curviness || 10,
            margin = params.margin || 5,
            proximityLimit = params.proximityLimit || 80,
            clockwise = params.orientation && params.orientation === "clockwise",
            loopbackRadius = params.loopbackRadius || 25,
            isLoopbackCurrently = false,
            _super;

        this.overrideSetEditable = function() { return !isLoopbackCurrently; };

        this._compute = function (paintInfo, p) {

            var sp = p.sourcePos,
                tp = p.targetPos,
                _w = Math.abs(sp[0] - tp[0]),
                _h = Math.abs(sp[1] - tp[1]);

            if (!showLoopback || (p.sourceEndpoint.elementId !== p.targetEndpoint.elementId)) {
                isLoopbackCurrently = false;
                this._computeBezier(paintInfo, p, sp, tp, _w, _h);
            } else {
                isLoopbackCurrently = true;
                // a loopback connector.  draw an arc from one anchor to the other.
                var x1 = p.sourcePos[0], y1 = p.sourcePos[1] - margin,
                    cx = x1, cy = y1 - loopbackRadius,
                // canvas sizing stuff, to ensure the whole painted area is visible.
                    _x = cx - loopbackRadius,
                    _y = cy - loopbackRadius;

                _w = 2 * loopbackRadius;
                _h = 2 * loopbackRadius;

                paintInfo.points[0] = _x;
                paintInfo.points[1] = _y;
                paintInfo.points[2] = _w;
                paintInfo.points[3] = _h;

                // ADD AN ARC SEGMENT.
                _super.addSegment(this, "Arc", {
                    loopback: true,
                    x1: (x1 - _x) + 4,
                    y1: y1 - _y,
                    startAngle: 0,
                    endAngle: 2 * Math.PI,
                    r: loopbackRadius,
                    ac: !clockwise,
                    x2: (x1 - _x) - 4,
                    y2: y1 - _y,
                    cx: cx - _x,
                    cy: cy - _y
                });
            }
        };

        _super = _jp.Connectors.AbstractConnector.apply(this, arguments);
        return _super;
    };
    _ju.extend(_jp.Connectors.AbstractBezierConnector, _jp.Connectors.AbstractConnector);

    var Bezier = function (params) {
        params = params || {};
        this.type = "Bezier";

        var _super = _jp.Connectors.AbstractBezierConnector.apply(this, arguments),
            majorAnchor = params.curviness || 150,
            minorAnchor = 10;

        this.getCurviness = function () {
            return majorAnchor;
        };

        this._findControlPoint = function (point, sourceAnchorPosition, targetAnchorPosition, sourceEndpoint, targetEndpoint, soo, too) {
            // determine if the two anchors are perpendicular to each other in their orientation.  we swap the control
            // points around if so (code could be tightened up)
            var perpendicular = soo[0] !== too[0] || soo[1] === too[1],
                p = [];

            if (!perpendicular) {
                if (soo[0] === 0) {
                    p.push(sourceAnchorPosition[0] < targetAnchorPosition[0] ? point[0] + minorAnchor : point[0] - minorAnchor);
                }
                else {
                    p.push(point[0] - (majorAnchor * soo[0]));
                }

                if (soo[1] === 0) {
                    p.push(sourceAnchorPosition[1] < targetAnchorPosition[1] ? point[1] + minorAnchor : point[1] - minorAnchor);
                }
                else {
                    p.push(point[1] + (majorAnchor * too[1]));
                }
            }
            else {
                if (too[0] === 0) {
                    p.push(targetAnchorPosition[0] < sourceAnchorPosition[0] ? point[0] + minorAnchor : point[0] - minorAnchor);
                }
                else {
                    p.push(point[0] + (majorAnchor * too[0]));
                }

                if (too[1] === 0) {
                    p.push(targetAnchorPosition[1] < sourceAnchorPosition[1] ? point[1] + minorAnchor : point[1] - minorAnchor);
                }
                else {
                    p.push(point[1] + (majorAnchor * soo[1]));
                }
            }

            return p;
        };

        this._computeBezier = function (paintInfo, p, sp, tp, _w, _h) {

            var geometry = this.getGeometry(), _CP, _CP2,
                _sx = sp[0] < tp[0] ? _w : 0,
                _sy = sp[1] < tp[1] ? _h : 0,
                _tx = sp[0] < tp[0] ? 0 : _w,
                _ty = sp[1] < tp[1] ? 0 : _h;

            if ((this.hasBeenEdited() || this.isEditing()) && geometry != null && geometry.controlPoints != null && geometry.controlPoints[0] != null && geometry.controlPoints[1] != null) {
                _CP = geometry.controlPoints[0];
                _CP2 = geometry.controlPoints[1];
            }
            else {
                _CP = this._findControlPoint([_sx, _sy], sp, tp, p.sourceEndpoint, p.targetEndpoint, paintInfo.so, paintInfo.to);
                _CP2 = this._findControlPoint([_tx, _ty], tp, sp, p.targetEndpoint, p.sourceEndpoint, paintInfo.to, paintInfo.so);
            }

            _super.setGeometry({controlPoints:[_CP, _CP2]}, true);

            _super.addSegment(this, "Bezier", {
                x1: _sx, y1: _sy, x2: _tx, y2: _ty,
                cp1x: _CP[0], cp1y: _CP[1], cp2x: _CP2[0], cp2y: _CP2[1]
            });
        };


    };

    _ju.extend(Bezier, _jp.Connectors.AbstractBezierConnector);
    _jp.registerConnectorType(Bezier, "Bezier");

}).call(typeof window !== 'undefined' ? window : this);
/*
 * jsPlumb Community Edition
 *
 * Provides a way to visually connect elements on an HTML page, using SVG.
 *
 * This file contains the state machine connectors, which extend AbstractBezierConnector.
 *
 * Copyright (c) 2010 - 2017 jsPlumb (hello@jsplumbtoolkit.com)
 *
 * https://jsplumbtoolkit.com
 * https://github.com/jsplumb/jsplumb
 * 
 * Dual licensed under the MIT and GPL2 licenses.
 */
;
(function () {

    "use strict";
    var root = this, _jp = root.jsPlumb, _ju = root.jsPlumbUtil;

    var _segment = function (x1, y1, x2, y2) {
            if (x1 <= x2 && y2 <= y1) {
                return 1;
            }
            else if (x1 <= x2 && y1 <= y2) {
                return 2;
            }
            else if (x2 <= x1 && y2 >= y1) {
                return 3;
            }
            return 4;
        },

    // the control point we will use depends on the faces to which each end of the connection is assigned, specifically whether or not the
    // two faces are parallel or perpendicular.  if they are parallel then the control point lies on the midpoint of the axis in which they
    // are parellel and varies only in the other axis; this variation is proportional to the distance that the anchor points lie from the
    // center of that face.  if the two faces are perpendicular then the control point is at some distance from both the midpoints; the amount and
    // direction are dependent on the orientation of the two elements. 'seg', passed in to this method, tells you which segment the target element
    // lies in with respect to the source: 1 is top right, 2 is bottom right, 3 is bottom left, 4 is top left.
    //
    // sourcePos and targetPos are arrays of info about where on the source and target each anchor is located.  their contents are:
    //
    // 0 - absolute x
    // 1 - absolute y
    // 2 - proportional x in element (0 is left edge, 1 is right edge)
    // 3 - proportional y in element (0 is top edge, 1 is bottom edge)
    //
        _findControlPoint = function (midx, midy, segment, sourceEdge, targetEdge, dx, dy, distance, proximityLimit) {
            // TODO (maybe)
            // - if anchor pos is 0.5, make the control point take into account the relative position of the elements.
            if (distance <= proximityLimit) {
                return [midx, midy];
            }

            if (segment === 1) {
                if (sourceEdge[3] <= 0 && targetEdge[3] >= 1) {
                    return [ midx + (sourceEdge[2] < 0.5 ? -1 * dx : dx), midy ];
                }
                else if (sourceEdge[2] >= 1 && targetEdge[2] <= 0) {
                    return [ midx, midy + (sourceEdge[3] < 0.5 ? -1 * dy : dy) ];
                }
                else {
                    return [ midx + (-1 * dx) , midy + (-1 * dy) ];
                }
            }
            else if (segment === 2) {
                if (sourceEdge[3] >= 1 && targetEdge[3] <= 0) {
                    return [ midx + (sourceEdge[2] < 0.5 ? -1 * dx : dx), midy ];
                }
                else if (sourceEdge[2] >= 1 && targetEdge[2] <= 0) {
                    return [ midx, midy + (sourceEdge[3] < 0.5 ? -1 * dy : dy) ];
                }
                else {
                    return [ midx + dx, midy + (-1 * dy) ];
                }
            }
            else if (segment === 3) {
                if (sourceEdge[3] >= 1 && targetEdge[3] <= 0) {
                    return [ midx + (sourceEdge[2] < 0.5 ? -1 * dx : dx), midy ];
                }
                else if (sourceEdge[2] <= 0 && targetEdge[2] >= 1) {
                    return [ midx, midy + (sourceEdge[3] < 0.5 ? -1 * dy : dy) ];
                }
                else {
                    return [ midx + (-1 * dx) , midy + (-1 * dy) ];
                }
            }
            else if (segment === 4) {
                if (sourceEdge[3] <= 0 && targetEdge[3] >= 1) {
                    return [ midx + (sourceEdge[2] < 0.5 ? -1 * dx : dx), midy ];
                }
                else if (sourceEdge[2] <= 0 && targetEdge[2] >= 1) {
                    return [ midx, midy + (sourceEdge[3] < 0.5 ? -1 * dy : dy) ];
                }
                else {
                    return [ midx + dx , midy + (-1 * dy) ];
                }
            }

        };

    var StateMachine = function (params) {
        params = params || {};
        this.type = "StateMachine";

        var _super = _jp.Connectors.AbstractBezierConnector.apply(this, arguments),
            curviness = params.curviness || 10,
            margin = params.margin || 5,
            proximityLimit = params.proximityLimit || 80,
            clockwise = params.orientation && params.orientation === "clockwise",
            _controlPoint;

        this._computeBezier = function(paintInfo, params, sp, tp, w, h) {
            var _sx = params.sourcePos[0] < params.targetPos[0] ? 0 : w,
                _sy = params.sourcePos[1] < params.targetPos[1] ? 0 : h,
                _tx = params.sourcePos[0] < params.targetPos[0] ? w : 0,
                _ty = params.sourcePos[1] < params.targetPos[1] ? h : 0;

            // now adjust for the margin
            if (params.sourcePos[2] === 0) {
                _sx -= margin;
            }
            if (params.sourcePos[2] === 1) {
                _sx += margin;
            }
            if (params.sourcePos[3] === 0) {
                _sy -= margin;
            }
            if (params.sourcePos[3] === 1) {
                _sy += margin;
            }
            if (params.targetPos[2] === 0) {
                _tx -= margin;
            }
            if (params.targetPos[2] === 1) {
                _tx += margin;
            }
            if (params.targetPos[3] === 0) {
                _ty -= margin;
            }
            if (params.targetPos[3] === 1) {
                _ty += margin;
            }

            //
            // these connectors are quadratic bezier curves, having a single control point. if both anchors
            // are located at 0.5 on their respective faces, the control point is set to the midpoint and you
            // get a straight line.  this is also the case if the two anchors are within 'proximityLimit', since
            // it seems to make good aesthetic sense to do that. outside of that, the control point is positioned
            // at 'curviness' pixels away along the normal to the straight line connecting the two anchors.
            //
            // there may be two improvements to this.  firstly, we might actually support the notion of avoiding nodes
            // in the UI, or at least making a good effort at doing so.  if a connection would pass underneath some node,
            // for example, we might increase the distance the control point is away from the midpoint in a bid to
            // steer it around that node.  this will work within limits, but i think those limits would also be the likely
            // limits for, once again, aesthetic good sense in the layout of a chart using these connectors.
            //
            // the second possible change is actually two possible changes: firstly, it is possible we should gradually
            // decrease the 'curviness' as the distance between the anchors decreases; start tailing it off to 0 at some
            // point (which should be configurable).  secondly, we might slightly increase the 'curviness' for connectors
            // with respect to how far their anchor is from the center of its respective face. this could either look cool,
            // or stupid, and may indeed work only in a way that is so subtle as to have been a waste of time.
            //

            var _midx = (_sx + _tx) / 2,
                _midy = (_sy + _ty) / 2,
                segment = _segment(_sx, _sy, _tx, _ty),
                distance = Math.sqrt(Math.pow(_tx - _sx, 2) + Math.pow(_ty - _sy, 2)),
                cp1x, cp2x, cp1y, cp2y,
                geometry = _super.getGeometry();

            if ((this.hasBeenEdited() || this.isEditing()) && geometry != null) {
                cp1x = geometry.controlPoints[0][0];
                cp1y = geometry.controlPoints[0][1];
                cp2x = geometry.controlPoints[1][0];
                cp2y = geometry.controlPoints[1][1];
            }
            else {
                // calculate the control point.  this code will be where we'll put in a rudimentary element avoidance scheme; it
                // will work by extending the control point to force the curve to be, um, curvier.
                _controlPoint = _findControlPoint(_midx,
                    _midy,
                    segment,
                    params.sourcePos,
                    params.targetPos,
                    curviness, curviness,
                    distance,
                    proximityLimit);

                cp1x = _controlPoint[0];
                cp2x = _controlPoint[0];
                cp1y = _controlPoint[1];
                cp2y = _controlPoint[1];

                _super.setGeometry({controlPoints:[_controlPoint, _controlPoint]}, true);
            }

            _super.addSegment(this, "Bezier", {
                x1: _tx, y1: _ty, x2: _sx, y2: _sy,
                cp1x: cp1x, cp1y: cp1y,
                cp2x: cp2x, cp2y: cp2y
            });
        };
    };

    _ju.extend(StateMachine, _jp.Connectors.AbstractBezierConnector);
    _jp.registerConnectorType(StateMachine, "StateMachine");

}).call(typeof window !== 'undefined' ? window : this);
/*
 * jsPlumb Community Edition
 *
 * Provides a way to visually connect elements on an HTML page, using SVG.
 *
 * This file contains the 'flowchart' connectors, consisting of vertical and horizontal line segments.
 *
 * Copyright (c) 2010 - 2017 jsPlumb (hello@jsplumbtoolkit.com)
 *
 * https://jsplumbtoolkit.com
 * https://github.com/jsplumb/jsplumb
 *
 * Dual licensed under the MIT and GPL2 licenses.
 */
;
(function () {

    "use strict";
    var root = this, _jp = root.jsPlumb, _ju = root.jsPlumbUtil;
    var STRAIGHT = "Straight";

    var Straight = function (params) {
        this.type = STRAIGHT;
        var _super = _jp.Connectors.AbstractConnector.apply(this, arguments);

        this._compute = function (paintInfo, _) {
            _super.addSegment(this, STRAIGHT, {x1: paintInfo.sx, y1: paintInfo.sy, x2: paintInfo.startStubX, y2: paintInfo.startStubY});
            _super.addSegment(this, STRAIGHT, {x1: paintInfo.startStubX, y1: paintInfo.startStubY, x2: paintInfo.endStubX, y2: paintInfo.endStubY});
            _super.addSegment(this, STRAIGHT, {x1: paintInfo.endStubX, y1: paintInfo.endStubY, x2: paintInfo.tx, y2: paintInfo.ty});
        };
    };

    _ju.extend(Straight, _jp.Connectors.AbstractConnector);
    _jp.registerConnectorType(Straight, STRAIGHT);

}).call(typeof window !== 'undefined' ? window : this);
/*
 * jsPlumb Community Edition
 * 
 * Provides a way to visually connect elements on an HTML page, using SVG.
 * 
 * This file contains the SVG renderers.
 *
 * Copyright (c) 2010 - 2017 jsPlumb (hello@jsplumbtoolkit.com)
 * 
 * https://jsplumbtoolkit.com
 * https://github.com/jsplumb/jsplumb
 * 
 * Dual licensed under the MIT and GPL2 licenses.
 */
;
(function () {

// ************************** SVG utility methods ********************************************	

    "use strict";
    var root = this, _jp = root.jsPlumb, _ju = root.jsPlumbUtil;

    var svgAttributeMap = {
            "stroke-linejoin": "stroke-linejoin",
            "stroke-dashoffset": "stroke-dashoffset",
            "stroke-linecap": "stroke-linecap"
        },
        STROKE_DASHARRAY = "stroke-dasharray",
        DASHSTYLE = "dashstyle",
        LINEAR_GRADIENT = "linearGradient",
        RADIAL_GRADIENT = "radialGradient",
        DEFS = "defs",
        FILL = "fill",
        STOP = "stop",
        STROKE = "stroke",
        STROKE_WIDTH = "stroke-width",
        STYLE = "style",
        NONE = "none",
        JSPLUMB_GRADIENT = "jsplumb_gradient_",
        LINE_WIDTH = "strokeWidth",
        ns = {
            svg: "http://www.w3.org/2000/svg"
        },
        _attr = function (node, attributes) {
            for (var i in attributes) {
                node.setAttribute(i, "" + attributes[i]);
            }
        },
        _node = function (name, attributes) {
            attributes = attributes || {};
            attributes.version = "1.1";
            attributes.xmlns = ns.svg;
            return _jp.createElementNS(ns.svg, name, null, null, attributes);
        },
        _pos = function (d) {
            return "position:absolute;left:" + d[0] + "px;top:" + d[1] + "px";
        },
        _clearGradient = function (parent) {
            var els = parent.querySelectorAll(" defs,linearGradient,radialGradient");
            for (var i = 0; i < els.length; i++) {
                els[i].parentNode.removeChild(els[i]);
            }
        },
        _updateGradient = function (parent, node, style, dimensions, uiComponent) {
            var id = JSPLUMB_GRADIENT + uiComponent._jsPlumb.instance.idstamp();
            // first clear out any existing gradient
            _clearGradient(parent);
            // this checks for an 'offset' property in the gradient, and in the absence of it, assumes
            // we want a linear gradient. if it's there, we create a radial gradient.
            // it is possible that a more explicit means of defining the gradient type would be
            // better. relying on 'offset' means that we can never have a radial gradient that uses
            // some default offset, for instance.
            // issue 244 suggested the 'gradientUnits' attribute; without this, straight/flowchart connectors with gradients would
            // not show gradients when the line was perfectly horizontal or vertical.
            var g;
            if (!style.gradient.offset) {
                g = _node(LINEAR_GRADIENT, {id: id, gradientUnits: "userSpaceOnUse"});
            }
            else {
                g = _node(RADIAL_GRADIENT, { id: id });
            }

            var defs = _node(DEFS);
            parent.appendChild(defs);
            defs.appendChild(g);

            // the svg radial gradient seems to treat stops in the reverse
            // order to how canvas does it.  so we want to keep all the maths the same, but
            // iterate the actual style declarations in reverse order, if the x indexes are not in order.
            for (var i = 0; i < style.gradient.stops.length; i++) {
                var styleToUse = uiComponent.segment === 1 || uiComponent.segment === 2 ? i : style.gradient.stops.length - 1 - i,
                    stopColor = style.gradient.stops[styleToUse][1],
                    s = _node(STOP, {"offset": Math.floor(style.gradient.stops[i][0] * 100) + "%", "stop-color": stopColor});

                g.appendChild(s);
            }
            var applyGradientTo = style.stroke ? STROKE : FILL;
            node.setAttribute(applyGradientTo, "url(#" + id + ")");
        },
        _applyStyles = function (parent, node, style, dimensions, uiComponent) {

            node.setAttribute(FILL, style.fill ? style.fill : NONE);
            node.setAttribute(STROKE, style.stroke ? style.stroke : NONE);

            if (style.gradient) {
                _updateGradient(parent, node, style, dimensions, uiComponent);
            }
            else {
                // make sure we clear any existing gradient
                _clearGradient(parent);
                node.setAttribute(STYLE, "");
            }

            if (style.strokeWidth) {
                node.setAttribute(STROKE_WIDTH, style.strokeWidth);
            }

            // in SVG there is a stroke-dasharray attribute we can set, and its syntax looks like
            // the syntax in VML but is actually kind of nasty: values are given in the pixel
            // coordinate space, whereas in VML they are multiples of the width of the stroked
            // line, which makes a lot more sense.  for that reason, jsPlumb is supporting both
            // the native svg 'stroke-dasharray' attribute, and also the 'dashstyle' concept from
            // VML, which will be the preferred method.  the code below this converts a dashstyle
            // attribute given in terms of stroke width into a pixel representation, by using the
            // stroke's lineWidth.
            if (style[DASHSTYLE] && style[LINE_WIDTH] && !style[STROKE_DASHARRAY]) {
                var sep = style[DASHSTYLE].indexOf(",") === -1 ? " " : ",",
                    parts = style[DASHSTYLE].split(sep),
                    styleToUse = "";
                parts.forEach(function (p) {
                    styleToUse += (Math.floor(p * style.strokeWidth) + sep);
                });
                node.setAttribute(STROKE_DASHARRAY, styleToUse);
            }
            else if (style[STROKE_DASHARRAY]) {
                node.setAttribute(STROKE_DASHARRAY, style[STROKE_DASHARRAY]);
            }

            // extra attributes such as join type, dash offset.
            for (var i in svgAttributeMap) {
                if (style[i]) {
                    node.setAttribute(svgAttributeMap[i], style[i]);
                }
            }
        },
        _appendAtIndex = function (svg, path, idx) {
            if (svg.childNodes.length > idx) {
                svg.insertBefore(path, svg.childNodes[idx]);
            }
            else {
                svg.appendChild(path);
            }
        };

    /**
     utility methods for other objects to use.
     */
    _ju.svg = {
        node: _node,
        attr: _attr,
        pos: _pos
    };

    // ************************** / SVG utility methods ********************************************

    /*
     * Base class for SVG components.
     */
    var SvgComponent = function (params) {
        var pointerEventsSpec = params.pointerEventsSpec || "all", renderer = {};

        _jp.jsPlumbUIComponent.apply(this, params.originalArgs);
        this.canvas = null;
        this.path = null;
        this.svg = null;
        this.bgCanvas = null;

        var clazz = params.cssClass + " " + (params.originalArgs[0].cssClass || ""),
            svgParams = {
                "style": "",
                "width": 0,
                "height": 0,
                "pointer-events": pointerEventsSpec,
                "position": "absolute"
            };

        this.svg = _node("svg", svgParams);

        if (params.useDivWrapper) {
            this.canvas = _jp.createElement("div", { position : "absolute" });
            _ju.sizeElement(this.canvas, 0, 0, 1, 1);
            this.canvas.className = clazz;
        }
        else {
            _attr(this.svg, { "class": clazz });
            this.canvas = this.svg;
        }

        params._jsPlumb.appendElement(this.canvas, params.originalArgs[0].parent);
        if (params.useDivWrapper) {
            this.canvas.appendChild(this.svg);
        }

        var displayElements = [ this.canvas ];
        this.getDisplayElements = function () {
            return displayElements;
        };

        this.appendDisplayElement = function (el) {
            displayElements.push(el);
        };

        this.paint = function (style, anchor, extents) {
            if (style != null) {

                var xy = [ this.x, this.y ], wh = [ this.w, this.h ], p;
                if (extents != null) {
                    if (extents.xmin < 0) {
                        xy[0] += extents.xmin;
                    }
                    if (extents.ymin < 0) {
                        xy[1] += extents.ymin;
                    }
                    wh[0] = extents.xmax + ((extents.xmin < 0) ? -extents.xmin : 0);
                    wh[1] = extents.ymax + ((extents.ymin < 0) ? -extents.ymin : 0);
                }

                if (params.useDivWrapper) {
                    _ju.sizeElement(this.canvas, xy[0], xy[1], wh[0], wh[1]);
                    xy[0] = 0;
                    xy[1] = 0;
                    p = _pos([ 0, 0 ]);
                }
                else {
                    p = _pos([ xy[0], xy[1] ]);
                }

                renderer.paint.apply(this, arguments);

                _attr(this.svg, {
                    "style": p,
                    "width": wh[0] || 0,
                    "height": wh[1] || 0
                });
            }
        };

        return {
            renderer: renderer
        };
    };

    _ju.extend(SvgComponent, _jp.jsPlumbUIComponent, {
        cleanup: function (force) {
            if (force || this.typeId == null) {
                if (this.canvas) {
                    this.canvas._jsPlumb = null;
                }
                if (this.svg) {
                    this.svg._jsPlumb = null;
                }
                if (this.bgCanvas) {
                    this.bgCanvas._jsPlumb = null;
                }

                if (this.canvas && this.canvas.parentNode) {
                    this.canvas.parentNode.removeChild(this.canvas);
                }
                if (this.bgCanvas && this.bgCanvas.parentNode) {
                    this.canvas.parentNode.removeChild(this.canvas);
                }

                this.svg = null;
                this.canvas = null;
                this.path = null;
                this.group = null;
            }
            else {
                // if not a forced cleanup, just detach from DOM for now.
                if (this.canvas && this.canvas.parentNode) {
                    this.canvas.parentNode.removeChild(this.canvas);
                }
                if (this.bgCanvas && this.bgCanvas.parentNode) {
                    this.bgCanvas.parentNode.removeChild(this.bgCanvas);
                }
            }
        },
        reattach:function(instance) {
            var c = instance.getContainer();
            if (this.canvas && this.canvas.parentNode == null) {
                c.appendChild(this.canvas);
            }
            if (this.bgCanvas && this.bgCanvas.parentNode == null) {
                c.appendChild(this.bgCanvas);
            }
        },
        setVisible: function (v) {
            if (this.canvas) {
                this.canvas.style.display = v ? "block" : "none";
            }
        }
    });

    /*
     * Base class for SVG connectors.
     */
    _jp.ConnectorRenderers.svg = function (params) {
        var self = this,
            _super = SvgComponent.apply(this, [
                {
                    cssClass: params._jsPlumb.connectorClass + (this.isEditable() ? " " + params._jsPlumb.editableConnectorClass : ""),
                    originalArgs: arguments,
                    pointerEventsSpec: "none",
                    _jsPlumb: params._jsPlumb
                }
            ]);

        var _superSetEditable = this.setEditable;
        this.setEditable = function(e) {
            var result = _superSetEditable.apply(this, [e]);
            _jp[result ? "addClass" : "removeClass"](this.canvas, this._jsPlumb.instance.editableConnectorClass);
        };

        _super.renderer.paint = function (style, anchor, extents) {

            var segments = self.getSegments(), p = "", offset = [0, 0];
            if (extents.xmin < 0) {
                offset[0] = -extents.xmin;
            }
            if (extents.ymin < 0) {
                offset[1] = -extents.ymin;
            }

            if (segments.length > 0) {

                p = self.getPathData();

                var a = {
                        d: p,
                        transform: "translate(" + offset[0] + "," + offset[1] + ")",
                        "pointer-events": params["pointer-events"] || "visibleStroke"
                    },
                    outlineStyle = null,
                    d = [self.x, self.y, self.w, self.h];

                // outline style.  actually means drawing an svg object underneath the main one.
                if (style.outlineStroke) {
                    var outlineWidth = style.outlineWidth || 1,
                        outlineStrokeWidth = style.strokeWidth + (2 * outlineWidth);
                    outlineStyle = _jp.extend({}, style);
                    delete outlineStyle.gradient;
                    outlineStyle.stroke = style.outlineStroke;
                    outlineStyle.strokeWidth = outlineStrokeWidth;

                    if (self.bgPath == null) {
                        self.bgPath = _node("path", a);
                        _jp.addClass(self.bgPath, _jp.connectorOutlineClass);
                        _appendAtIndex(self.svg, self.bgPath, 0);
                    }
                    else {
                        _attr(self.bgPath, a);
                    }

                    _applyStyles(self.svg, self.bgPath, outlineStyle, d, self);
                }

                if (self.path == null) {
                    self.path = _node("path", a);
                    _appendAtIndex(self.svg, self.path, style.outlineStroke ? 1 : 0);
                }
                else {
                    _attr(self.path, a);
                }

                _applyStyles(self.svg, self.path, style, d, self);
            }
        };
    };
    _ju.extend(_jp.ConnectorRenderers.svg, SvgComponent);

// ******************************* svg segment renderer *****************************************************	


// ******************************* /svg segments *****************************************************

    /*
     * Base class for SVG endpoints.
     */
    var SvgEndpoint = _jp.SvgEndpoint = function (params) {
        var _super = SvgComponent.apply(this, [
            {
                cssClass: params._jsPlumb.endpointClass,
                originalArgs: arguments,
                pointerEventsSpec: "all",
                useDivWrapper: true,
                _jsPlumb: params._jsPlumb
            }
        ]);

        _super.renderer.paint = function (style) {
            var s = _jp.extend({}, style);
            if (s.outlineStroke) {
                s.stroke = s.outlineStroke;
            }

            if (this.node == null) {
                this.node = this.makeNode(s);
                this.svg.appendChild(this.node);
            }
            else if (this.updateNode != null) {
                this.updateNode(this.node);
            }
            _applyStyles(this.svg, this.node, s, [ this.x, this.y, this.w, this.h ], this);
            _pos(this.node, [ this.x, this.y ]);
        }.bind(this);

    };
    _ju.extend(SvgEndpoint, SvgComponent);

    /*
     * SVG Dot Endpoint
     */
    _jp.Endpoints.svg.Dot = function () {
        _jp.Endpoints.Dot.apply(this, arguments);
        SvgEndpoint.apply(this, arguments);
        this.makeNode = function (style) {
            return _node("circle", {
                "cx": this.w / 2,
                "cy": this.h / 2,
                "r": this.radius
            });
        };
        this.updateNode = function (node) {
            _attr(node, {
                "cx": this.w / 2,
                "cy": this.h / 2,
                "r": this.radius
            });
        };
    };
    _ju.extend(_jp.Endpoints.svg.Dot, [_jp.Endpoints.Dot, SvgEndpoint]);

    /*
     * SVG Rectangle Endpoint
     */
    _jp.Endpoints.svg.Rectangle = function () {
        _jp.Endpoints.Rectangle.apply(this, arguments);
        SvgEndpoint.apply(this, arguments);
        this.makeNode = function (style) {
            return _node("rect", {
                "width": this.w,
                "height": this.h
            });
        };
        this.updateNode = function (node) {
            _attr(node, {
                "width": this.w,
                "height": this.h
            });
        };
    };
    _ju.extend(_jp.Endpoints.svg.Rectangle, [_jp.Endpoints.Rectangle, SvgEndpoint]);

    /*
     * SVG Image Endpoint is the default image endpoint.
     */
    _jp.Endpoints.svg.Image = _jp.Endpoints.Image;
    /*
     * Blank endpoint in svg renderer is the default Blank endpoint.
     */
    _jp.Endpoints.svg.Blank = _jp.Endpoints.Blank;
    /*
     * Label overlay in svg renderer is the default Label overlay.
     */
    _jp.Overlays.svg.Label = _jp.Overlays.Label;
    /*
     * Custom overlay in svg renderer is the default Custom overlay.
     */
    _jp.Overlays.svg.Custom = _jp.Overlays.Custom;

    var AbstractSvgArrowOverlay = function (superclass, originalArgs) {
        superclass.apply(this, originalArgs);
        _jp.jsPlumbUIComponent.apply(this, originalArgs);
        this.isAppendedAtTopLevel = false;
        var self = this;
        this.path = null;
        this.paint = function (params, containerExtents) {
            // only draws on connections, not endpoints.
            if (params.component.svg && containerExtents) {
                if (this.path == null) {
                    this.path = _node("path", {
                        "pointer-events": "all"
                    });
                    params.component.svg.appendChild(this.path);
                    if (this.elementCreated) {
                        this.elementCreated(this.path, params.component);
                    }

                    this.canvas = params.component.svg; // for the sake of completeness; this behaves the same as other overlays
                }
                var clazz = originalArgs && (originalArgs.length === 1) ? (originalArgs[0].cssClass || "") : "",
                    offset = [0, 0];

                if (containerExtents.xmin < 0) {
                    offset[0] = -containerExtents.xmin;
                }
                if (containerExtents.ymin < 0) {
                    offset[1] = -containerExtents.ymin;
                }

                _attr(this.path, {
                    "d": makePath(params.d),
                    "class": clazz,
                    stroke: params.stroke ? params.stroke : null,
                    fill: params.fill ? params.fill : null,
                    transform: "translate(" + offset[0] + "," + offset[1] + ")"
                });
            }
        };
        var makePath = function (d) {
            return (isNaN(d.cxy.x) || isNaN(d.cxy.y)) ? "" : "M" + d.hxy.x + "," + d.hxy.y +
                " L" + d.tail[0].x + "," + d.tail[0].y +
                " L" + d.cxy.x + "," + d.cxy.y +
                " L" + d.tail[1].x + "," + d.tail[1].y +
                " L" + d.hxy.x + "," + d.hxy.y;
        };
        this.transfer = function(target) {
            if (target.canvas && this.path && this.path.parentNode) {
                this.path.parentNode.removeChild(this.path);
                target.canvas.appendChild(this.path);
            }
        };
    };
    _ju.extend(AbstractSvgArrowOverlay, [_jp.jsPlumbUIComponent, _jp.Overlays.AbstractOverlay], {
        cleanup: function (force) {
            if (this.path != null) {
                if (force) {
                    this._jsPlumb.instance.removeElement(this.path);
                }
                else {
                    if (this.path.parentNode) {
                        this.path.parentNode.removeChild(this.path);
                    }
                }
            }
        },
        reattach:function(instance, component) {
            if (this.path && component.canvas) {
                component.canvas.appendChild(this.path);
            }
        },
        setVisible: function (v) {
            if (this.path != null) {
                (this.path.style.display = (v ? "block" : "none"));
            }
        }
    });

    _jp.Overlays.svg.Arrow = function () {
        AbstractSvgArrowOverlay.apply(this, [_jp.Overlays.Arrow, arguments]);
    };
    _ju.extend(_jp.Overlays.svg.Arrow, [ _jp.Overlays.Arrow, AbstractSvgArrowOverlay ]);

    _jp.Overlays.svg.PlainArrow = function () {
        AbstractSvgArrowOverlay.apply(this, [_jp.Overlays.PlainArrow, arguments]);
    };
    _ju.extend(_jp.Overlays.svg.PlainArrow, [ _jp.Overlays.PlainArrow, AbstractSvgArrowOverlay ]);

    _jp.Overlays.svg.Diamond = function () {
        AbstractSvgArrowOverlay.apply(this, [_jp.Overlays.Diamond, arguments]);
    };
    _ju.extend(_jp.Overlays.svg.Diamond, [ _jp.Overlays.Diamond, AbstractSvgArrowOverlay ]);

    // a test
    _jp.Overlays.svg.GuideLines = function () {
        var path = null, self = this, p1_1, p1_2;
        _jp.Overlays.GuideLines.apply(this, arguments);
        this.paint = function (params, containerExtents) {
            if (path == null) {
                path = _node("path");
                params.connector.svg.appendChild(path);
                self.attachListeners(path, params.connector);
                self.attachListeners(path, self);

                p1_1 = _node("path");
                params.connector.svg.appendChild(p1_1);
                self.attachListeners(p1_1, params.connector);
                self.attachListeners(p1_1, self);

                p1_2 = _node("path");
                params.connector.svg.appendChild(p1_2);
                self.attachListeners(p1_2, params.connector);
                self.attachListeners(p1_2, self);
            }

            var offset = [0, 0];
            if (containerExtents.xmin < 0) {
                offset[0] = -containerExtents.xmin;
            }
            if (containerExtents.ymin < 0) {
                offset[1] = -containerExtents.ymin;
            }

            _attr(path, {
                "d": makePath(params.head, params.tail),
                stroke: "red",
                fill: null,
                transform: "translate(" + offset[0] + "," + offset[1] + ")"
            });

            _attr(p1_1, {
                "d": makePath(params.tailLine[0], params.tailLine[1]),
                stroke: "blue",
                fill: null,
                transform: "translate(" + offset[0] + "," + offset[1] + ")"
            });

            _attr(p1_2, {
                "d": makePath(params.headLine[0], params.headLine[1]),
                stroke: "green",
                fill: null,
                transform: "translate(" + offset[0] + "," + offset[1] + ")"
            });
        };

        var makePath = function (d1, d2) {
            return "M " + d1.x + "," + d1.y +
                " L" + d2.x + "," + d2.y;
        };
    };
    _ju.extend(_jp.Overlays.svg.GuideLines, _jp.Overlays.GuideLines);
}).call(typeof window !== 'undefined' ? window : this);

/*
 * jsPlumb Community Edition
 *
 * Provides a way to visually connect elements on an HTML page, using SVG.
 * 
 * This file contains the 'vanilla' adapter - having no external dependencies other than bundled libs.
 *
 * Copyright (c) 2010 - 2017 jsPlumb (hello@jsplumbtoolkit.com)
 * 
 * https://jsplumbtoolkit.com
 * https://github.com/jsplumb/jsplumb
 * 
 * Dual licensed under the MIT and GPL2 licenses.
 */
;
(function () {

    "use strict";
    var root = this, _jp = root.jsPlumb, _ju = root.jsPlumbUtil,
        _jk = root.Katavorio, _jg = root.Biltong;

    var _getDragManager = function (instance, category) {

        category = category || "main";
        var key = "_katavorio_" + category;
        var k = instance[key],
            e = instance.getEventManager();

        if (!k) {
            k = new _jk({
                bind: e.on,
                unbind: e.off,
                getSize: _jp.getSize,
                getPosition: function (el, relativeToRoot) {
                    // if this is a nested draggable then compute the offset against its own offsetParent, otherwise
                    // compute against the Container's origin. see also the getUIPosition method below.
                    var o = instance.getOffset(el, relativeToRoot, el._katavorioDrag ? el.offsetParent : null);
                    return [o.left, o.top];
                },
                setPosition: function (el, xy) {
                    el.style.left = xy[0] + "px";
                    el.style.top = xy[1] + "px";
                },
                addClass: _jp.addClass,
                removeClass: _jp.removeClass,
                intersects: _jg.intersects,
                indexOf: function(l, i) { return l.indexOf(i); },
                scope:instance.getDefaultScope(),
                css: {
                    noSelect: instance.dragSelectClass,
                    droppable: "jtk-droppable",
                    draggable: "jtk-draggable",
                    drag: "jtk-drag",
                    selected: "jtk-drag-selected",
                    active: "jtk-drag-active",
                    hover: "jtk-drag-hover",
                    ghostProxy:"jtk-ghost-proxy"
                }
            });
            k.setZoom(instance.getZoom());
            instance[key] = k;
            instance.bind("zoom", k.setZoom);
        }
        return k;
    };

    var _animProps = function (o, p) {
        var _one = function (pName) {
            if (p[pName] != null) {
                if (_ju.isString(p[pName])) {
                    var m = p[pName].match(/-=/) ? -1 : 1,
                        v = p[pName].substring(2);
                    return o[pName] + (m * v);
                }
                else {
                    return p[pName];
                }
            }
            else {
                return o[pName];
            }
        };
        return [ _one("left"), _one("top") ];
    };

    _jp.extend(root.jsPlumbInstance.prototype, {

        animationSupported:true,
        getElement: function (el) {
            if (el == null) {
                return null;
            }
            // here we pluck the first entry if el was a list of entries.
            // this is not my favourite thing to do, but previous versions of
            // jsplumb supported jquery selectors, and it is possible a selector
            // will be passed in here.
            el = typeof el === "string" ? el : el.length != null && el.enctype == null ? el[0] : el;
            return typeof el === "string" ? document.getElementById(el) : el;
        },
        removeElement: function (element) {
            _getDragManager(this).elementRemoved(element);
            this.getEventManager().remove(element);
        },
        //
        // this adapter supports a rudimentary animation function. no easing is supported.  only
        // left/top properties are supported. property delta args are expected to be in the form
        //
        // +=x.xxxx
        //
        // or
        //
        // -=x.xxxx
        //
        doAnimate: function (el, properties, options) {
            options = options || {};
            var o = this.getOffset(el),
                ap = _animProps(o, properties),
                ldist = ap[0] - o.left,
                tdist = ap[1] - o.top,
                d = options.duration || 250,
                step = 15, steps = d / step,
                linc = (step / d) * ldist,
                tinc = (step / d) * tdist,
                idx = 0,
                _int = setInterval(function () {
                    _jp.setPosition(el, {
                        left: o.left + (linc * (idx + 1)),
                        top: o.top + (tinc * (idx + 1))
                    });
                    if (options.step != null) {
                        options.step(idx, Math.ceil(steps));
                    }
                    idx++;
                    if (idx >= steps) {
                        window.clearInterval(_int);
                        if (options.complete != null) {
                            options.complete();
                        }
                    }
                }, step);
        },
        // DRAG/DROP
        destroyDraggable: function (el, category) {
            _getDragManager(this, category).destroyDraggable(el);
        },
        destroyDroppable: function (el, category) {
            _getDragManager(this, category).destroyDroppable(el);
        },
        initDraggable: function (el, options, category) {
            _getDragManager(this, category).draggable(el, options);
        },
        initDroppable: function (el, options, category) {
            _getDragManager(this, category).droppable(el, options);
        },
        isAlreadyDraggable: function (el) {
            return el._katavorioDrag != null;
        },
        isDragSupported: function (el, options) {
            return true;
        },
        isDropSupported: function (el, options) {
            return true;
        },
        isElementDraggable: function (el) {
            el = _jp.getElement(el);
            return el._katavorioDrag && el._katavorioDrag.isEnabled();
        },
        getDragObject: function (eventArgs) {
            return eventArgs[0].drag.getDragElement();
        },
        getDragScope: function (el) {
            return el._katavorioDrag && el._katavorioDrag.scopes.join(" ") || "";
        },
        getDropEvent: function (args) {
            return args[0].e;
        },
        getUIPosition: function (eventArgs, zoom) {
            // here the position reported to us by Katavorio is relative to the element's offsetParent. For top
            // level nodes that is fine, but if we have a nested draggable then its offsetParent is actually
            // not going to be the jsplumb container; it's going to be some child of that element. In that case
            // we want to adjust the UI position to account for the offsetParent's position relative to the Container
            // origin.
            var el = eventArgs[0].el;
            if (el.offsetParent == null) {
                return null;
            }
            var finalPos = eventArgs[0].finalPos || eventArgs[0].pos;
            var p = { left:finalPos[0], top:finalPos[1] };
            if (el._katavorioDrag && el.offsetParent !== this.getContainer()) {
                var oc = this.getOffset(el.offsetParent);
                p.left += oc.left;
                p.top += oc.top;
            }
            return p;
        },
        setDragFilter: function (el, filter, _exclude) {
            if (el._katavorioDrag) {
                el._katavorioDrag.setFilter(filter, _exclude);
            }
        },
        setElementDraggable: function (el, draggable) {
            el = _jp.getElement(el);
            if (el._katavorioDrag) {
                el._katavorioDrag.setEnabled(draggable);
            }
        },
        setDragScope: function (el, scope) {
            if (el._katavorioDrag) {
                el._katavorioDrag.k.setDragScope(el, scope);
            }
        },
        setDropScope:function(el, scope) {
            if (el._katavorioDrop && el._katavorioDrop.length > 0) {
                el._katavorioDrop[0].k.setDropScope(el, scope);
            }
        },
        addToPosse:function(el, spec) {
            var specs = Array.prototype.slice.call(arguments, 1);
            var dm = _getDragManager(this);
            _jp.each(el, function(_el) {
                _el = [ _jp.getElement(_el) ];
                _el.push.apply(_el, specs );
                dm.addToPosse.apply(dm, _el);
            });
        },
        setPosse:function(el, spec) {
            var specs = Array.prototype.slice.call(arguments, 1);
            var dm = _getDragManager(this);
            _jp.each(el, function(_el) {
                _el = [ _jp.getElement(_el) ];
                _el.push.apply(_el, specs );
                dm.setPosse.apply(dm, _el);
            });
        },
        removeFromPosse:function(el, posseId) {
            var specs = Array.prototype.slice.call(arguments, 1);
            var dm = _getDragManager(this);
            _jp.each(el, function(_el) {
                _el = [ _jp.getElement(_el) ];
                _el.push.apply(_el, specs );
                dm.removeFromPosse.apply(dm, _el);
            });
        },
        removeFromAllPosses:function(el) {
            var dm = _getDragManager(this);
            _jp.each(el, function(_el) { dm.removeFromAllPosses(_jp.getElement(_el)); });
        },
        setPosseState:function(el, posseId, state) {
            var dm = _getDragManager(this);
            _jp.each(el, function(_el) { dm.setPosseState(_jp.getElement(_el), posseId, state); });
        },
        dragEvents: {
            'start': 'start', 'stop': 'stop', 'drag': 'drag', 'step': 'step',
            'over': 'over', 'out': 'out', 'drop': 'drop', 'complete': 'complete',
            'beforeStart':'beforeStart'
        },
        animEvents: {
            'step': "step", 'complete': 'complete'
        },
        stopDrag: function (el) {
            if (el._katavorioDrag) {
                el._katavorioDrag.abort();
            }
        },
        addToDragSelection: function (spec) {
            _getDragManager(this).select(spec);
        },
        removeFromDragSelection: function (spec) {
            _getDragManager(this).deselect(spec);
        },
        clearDragSelection: function () {
            _getDragManager(this).deselectAll();
        },
        trigger: function (el, event, originalEvent, payload) {
            this.getEventManager().trigger(el, event, originalEvent, payload);
        },
        doReset:function() {
            // look for katavorio instances and reset each one if found.
            for (var key in this) {
                if (key.indexOf("_katavorio_") === 0) {
                    this[key].reset();
                }
            }
        }
    });

    var ready = function (f) {
        var _do = function () {
            if (/complete|loaded|interactive/.test(document.readyState) && typeof(document.body) !== "undefined" && document.body != null) {
                f();
            }
            else {
                setTimeout(_do, 9);
            }
        };

        _do();
    };
    ready(_jp.init);

}).call(typeof window !== 'undefined' ? window : this);


/***/ }),
/* 7 */,
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _v = __webpack_require__(5);

var _v2 = _interopRequireDefault(_v);

var _jsplumb = __webpack_require__(6);

var _pubsub = __webpack_require__(1);

var _pubsub2 = _interopRequireDefault(_pubsub);

var _state = __webpack_require__(27);

var _state2 = _interopRequireDefault(_state);

var _model_menu = __webpack_require__(29);

var _model_menu2 = _interopRequireDefault(_model_menu);

var _state_menu = __webpack_require__(33);

var _state_menu2 = _interopRequireDefault(_state_menu);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Main UI module
 */
var $statePanel = document.querySelector('#new-state-panel');
var $propsPanel = document.querySelector('#model-props-panel');
var $cadPane = document.querySelector('#cad-pane');
_jsplumb.jsPlumb.setContainer($cadPane);

/**
 * Listen to state name change in scheme
 * and set appropriate node text
 */
_pubsub2.default.subscribe('stateNameSet', function (_ref) {
  var id = _ref.id,
      name = _ref.name;

  var $name = document.querySelector('#state-' + id + ' .cad-state-name');
  $name.textContent = name;
});

_pubsub2.default.subscribe('currentStateSet', function (state) {
  _state_menu2.default.set(state);
});

var Scene = {
  // Handles menu-buttons clicks
  addState: function addState() {
    var _this = this;

    var id = (0, _v2.default)();
    var $stateNode = (0, _state2.default)(id);
    $stateNode.addEventListener('contextmenu', function (e) {
      _pubsub2.default.publish('stateSelected', id);
      e.preventDefault();
      _this.showStatePanel();
    });
    _jsplumb.jsPlumb.draggable($stateNode, { containment: true });
    $cadPane.appendChild($stateNode);
    _pubsub2.default.publish('stateCreated', id);
  },
  showStatePanel: function showStatePanel() {
    this.hidePropsPanel();
    $statePanel.classList.remove('is-hidden');
  },
  showPropsPanel: function showPropsPanel() {
    this.hideStatePanel();
    $propsPanel.classList.remove('is-hidden');
  },


  // Handle close-icons clicks
  hideStatePanel: function hideStatePanel() {
    $statePanel.classList.add('is-hidden');
  },
  hidePropsPanel: function hidePropsPanel() {
    $propsPanel.classList.add('is-hidden');
  },


  // set initial UI data
  init: function init(scheme) {
    _model_menu2.default.init(scheme);
  }
};

module.exports = Scene;

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Main CAD data handler
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */


var _pubsub = __webpack_require__(1);

var _pubsub2 = _interopRequireDefault(_pubsub);

var _config = __webpack_require__(3);

var _normalize = __webpack_require__(10);

var _normalize2 = _interopRequireDefault(_normalize);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Scheme = function () {
  function Scheme() {
    var _this = this;

    _classCallCheck(this, Scheme);

    // model data
    this.name = '';
    this.initialState = '';
    this.breakTime = 5;
    this.steps = 10;
    this.tools = {};
    this.states = {};
    this.parameters = {};
    this.actions = {};

    // util props
    this._cs = null; // Current state

    // non menu events
    _pubsub2.default.subscribe('stateCreated', this.addState.bind(this));
    _pubsub2.default.subscribe('stateSelected', this.setCurrentState.bind(this));

    // model menu events
    _pubsub2.default.subscribe('nameChanged', this.setName.bind(this));
    _pubsub2.default.subscribe('breakChanged', this.setBreakTime.bind(this));
    _pubsub2.default.subscribe('stepsChanged', this.setSteps.bind(this));

    // tool menu events
    _pubsub2.default.subscribe('toolCreated', this.addTool.bind(this));
    _pubsub2.default.subscribe('toolNameChanged', this.setToolName.bind(this));
    _pubsub2.default.subscribe('toolTypeChanged', this.setToolType.bind(this));
    _pubsub2.default.subscribe('toolRangeChanged', this.setToolRange.bind(this));

    // state menu events
    _pubsub2.default.subscribe('stateNameChanged', this.setStateName.bind(this));
    _pubsub2.default.subscribe('stateImageChanged', this.setStateImage.bind(this));
    _pubsub2.default.subscribe('initialStateChanged', this.setInitialState.bind(this));

    // event menu events
    _pubsub2.default.subscribe('eventNameChanged', this.setEventName.bind(this));
    _pubsub2.default.subscribe('eventDescChanged', this.setEventDesc.bind(this));

    // parameters menu events
    _pubsub2.default.subscribe('parameterCreated', this.addParameter.bind(this));
    _pubsub2.default.subscribe('parameterNameChanged', this.setParameterName.bind(this));
    _pubsub2.default.subscribe('parameterValueChanged', this.setParameterValue.bind(this));

    // actions menu events
    _pubsub2.default.subscribe('actionCreated', this.addAction.bind(this));
    _pubsub2.default.subscribe('actionNextStateChanged', this.setActionNextState.bind(this));
    _pubsub2.default.subscribe('actionTimeChanged', this.setActionTime.bind(this));
    _pubsub2.default.subscribe('actionToolChanged', this.setActionTool.bind(this));
    _pubsub2.default.subscribe('actionToolValueChanged', this.setActionToolValue.bind(this));
    _pubsub2.default.subscribe('inactiveActionSet', this.setInactiveAction.bind(this));

    // send states data to action creator
    // receive any payload and return it back with states array
    // and current state uuid
    _pubsub2.default.subscribe('schemeDataRequested', function (payload) {
      var states = Object.values(_this.states);
      var tools = Object.values(_this.tools);
      _pubsub2.default.publish('schemeDataSent', Object.assign({ states: states, tools: tools, currentState: _this._cs }, payload));
    });
  }

  // Returns normalized current scheme data


  _createClass(Scheme, [{
    key: 'getNormalized',
    value: function getNormalized() {
      return (0, _normalize2.default)(this);
    }

    // Non menu event-listeners

  }, {
    key: 'addState',
    value: function addState(id) {
      this.states[id] = {
        uuid: id,
        name: _config.DEFAULT_STATE_NAME,
        img: _config.DEFAULT_IMAGE_ID,
        parameters: [],
        event: { name: '', desc: '' },
        actions: []
      };
    }
  }, {
    key: 'setCurrentState',
    value: function setCurrentState(id) {
      var _this2 = this;

      this._cs = id;
      var cs = this.states[id];
      var parameters = cs.parameters.map(function (pId) {
        return _this2.parameters[pId];
      });
      var actions = cs.actions.map(function (aId) {
        return _this2.actions[aId];
      });
      _pubsub2.default.publish('currentStateSet', Object.assign({}, this.states[this._cs], { parameters: parameters }, { actions: actions }));
    }

    // Model menu event-listeners

  }, {
    key: 'setName',
    value: function setName(name) {
      this.name = name;
    }
  }, {
    key: 'setBreakTime',
    value: function setBreakTime(time) {
      this.breakTime = time;
    }
  }, {
    key: 'setSteps',
    value: function setSteps(steps) {
      this.steps = steps;
    }

    // Tool menu event-listeners

  }, {
    key: 'addTool',
    value: function addTool(id) {
      this.tools[id] = {
        uuid: id,
        name: _config.DEFAULT_TOOL_NAME,
        type: _config.DEFAULT_TOOL_TYPE,
        rangeValues: {}
      };
    }
  }, {
    key: 'setToolName',
    value: function setToolName(_ref) {
      var id = _ref.id,
          name = _ref.name;

      this.tools[id].name = name;
    }
  }, {
    key: 'setToolType',
    value: function setToolType(_ref2) {
      var id = _ref2.id,
          type = _ref2.type;

      this.tools[id].type = type;
    }
  }, {
    key: 'setToolRange',
    value: function setToolRange(_ref3) {
      var id = _ref3.id,
          values = _ref3.values;

      this.tools[id].rangeValues = values;
    }

    // State menu event-listeners

  }, {
    key: 'setStateName',
    value: function setStateName(name) {
      this.states[this._cs].name = name;
      _pubsub2.default.publish('stateNameSet', { id: this._cs, name: name });
    }
  }, {
    key: 'setStateImage',
    value: function setStateImage(img) {
      this.states[this._cs].img = img;
    }
  }, {
    key: 'setInitialState',
    value: function setInitialState(stateId) {
      this.initialState = stateId;
    }

    // Event menu event-listeners

  }, {
    key: 'setEventName',
    value: function setEventName(name) {
      this.states[this._cs].event.name = name;
    }
  }, {
    key: 'setEventDesc',
    value: function setEventDesc(desc) {
      this.states[this._cs].event.desc = desc;
    }

    // Parameters menu event-listeners

  }, {
    key: 'addParameter',
    value: function addParameter(id) {
      this.parameters[id] = {
        id: id,
        name: '',
        value: ''
      };
      this.states[this._cs].parameters.push(id);
    }
  }, {
    key: 'setParameterName',
    value: function setParameterName(_ref4) {
      var id = _ref4.id,
          name = _ref4.name;

      this.parameters[id].name = name;
    }
  }, {
    key: 'setParameterValue',
    value: function setParameterValue(_ref5) {
      var id = _ref5.id,
          value = _ref5.value;

      this.parameters[id].value = value;
    }

    // Action menu event-listeners

  }, {
    key: 'addAction',
    value: function addAction(id) {
      this.actions[id] = {
        id: id,
        nextState: '',
        time: { min: 0, max: 0 },
        tools: {}
      };
      this.states[this._cs].actions.push(id);
    }
  }, {
    key: 'setActionNextState',
    value: function setActionNextState(_ref6) {
      var id = _ref6.id,
          stateId = _ref6.stateId;

      this.actions[id].nextState = stateId;
    }
  }, {
    key: 'setActionTime',
    value: function setActionTime(_ref7) {
      var id = _ref7.id,
          time = _ref7.time;

      this.actions[id].time = time;
    }
  }, {
    key: 'setActionTool',
    value: function setActionTool(_ref8) {
      var id = _ref8.id,
          toolId = _ref8.toolId;

      var value = null;
      switch (this.tools[toolId].type) {
        case 'switch':
          value = false;
          break;
        case 'range':
          value = [0, 0];
          break;
        default:
          console.warn('Invalid tool type');
          value = null;
          break;
      }
      this.actions[id].tools[toolId] = {
        value: value,
        id: toolId
      };
    }
  }, {
    key: 'setActionToolValue',
    value: function setActionToolValue(_ref9) {
      var id = _ref9.id,
          toolId = _ref9.toolId,
          value = _ref9.value;

      this.actions[id].tools[toolId].value = value;
    }
  }, {
    key: 'setInactiveAction',
    value: function setInactiveAction(_ref10) {
      var id = _ref10.id,
          nextState = _ref10.nextState;

      this.actions[id] = {
        id: id,
        nextState: nextState,
        inactive: true
      };
    }
  }]);

  return Scheme;
}();

exports.default = Scheme;

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = normalize;
function normalize(source) {
  var result = {};

  result.name = source.name;
  result.initialState = source.initialState;
  result.steps = source.steps;
  result.breakTime = source.breakTime * 1000;
  result.tools = Object.values(source.tools);

  result.states = Object.values(source.states).map(function (sourceState) {
    var actions = extractActions(sourceState.actions, source);
    var parameters = extractParameters(sourceState.parameters, source);
    var last = actions.length === 0;
    return Object.assign({}, sourceState, { actions: actions, parameters: parameters, last: last });
  });

  return result;
}

function extractActions(actionIds, scheme) {
  return actionIds.map(function (aId) {
    var action = scheme.actions[aId];
    var result = {};
    result.nextState = action.nextState;
    result.inactive = action.inactive === undefined ? false : action.inactive;

    if (!action.tools) {
      return result;
    }

    result.time = {
      min: action.time.min * 1000,
      max: action.time.max * 1000
    };

    result.tools = Object.values(action.tools).map(function (_ref) {
      var id = _ref.id,
          value = _ref.value;

      var tool = scheme.tools[id];
      var res = {};

      res.type = tool.type;
      res.uuid = tool.uuid;

      switch (tool.type) {
        case 'switch':
          res.switchValue = value;
          break;
        case 'range':
          res.rangeValues = value;
          break;
        default:
          console.warn('Invalid tool type');
          break;
      }
      return res;
    });
    return result;
  });
}

function extractParameters(parameterIds, scheme) {
  return parameterIds.map(function (pId) {
    return scheme.parameters[pId];
  });
}

/***/ }),
/* 11 */,
/* 12 */,
/* 13 */,
/* 14 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 15 */,
/* 16 */,
/* 17 */,
/* 18 */,
/* 19 */,
/* 20 */,
/* 21 */,
/* 22 */,
/* 23 */,
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(14);

var _scene = __webpack_require__(8);

var _scene2 = _interopRequireDefault(_scene);

var _scheme = __webpack_require__(9);

var _scheme2 = _interopRequireDefault(_scheme);

var _api = __webpack_require__(70);

var _api2 = _interopRequireDefault(_api);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var $newStateButton = document.querySelector('#new-state-btn');
var $modelPropsButton = document.querySelector('#model-props-btn');

$newStateButton.addEventListener('click', function () {
  return _scene2.default.addState();
});
$modelPropsButton.addEventListener('click', function () {
  return _scene2.default.showPropsPanel();
});

var $stateCloseButton = document.querySelector('#new-state-panel .icon-close');
var $propsCloseButton = document.querySelector('#model-props-panel .icon-close');

$stateCloseButton.addEventListener('click', function () {
  return _scene2.default.hideStatePanel();
});
$propsCloseButton.addEventListener('click', function () {
  return _scene2.default.hidePropsPanel();
});

var scheme = new _scheme2.default();
_scene2.default.init(scheme);

var $saveModelBtn = document.getElementById('save-model-btn');

$saveModelBtn.addEventListener('click', function () {
  var model = scheme.getNormalized();
  _api2.default.sendModel(JSON.stringify(model)).then(function () {
    console.log('Model saved');
  }).catch(function (err) {
    console.log(err);
  });
});

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createAction = createAction;
exports.createInactiveAction = createInactiveAction;

var _jsplumb = __webpack_require__(6);

var _nodeFactory = __webpack_require__(2);

var _nodeFactory2 = _interopRequireDefault(_nodeFactory);

var _pubsub = __webpack_require__(1);

var _pubsub2 = _interopRequireDefault(_pubsub);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function createAction(id, _ref, action) {
  var states = _ref.states,
      tools = _ref.tools,
      currentState = _ref.currentState;

  var $actionWrapper = (0, _nodeFactory2.default)('div', { classList: ['panel-action'] });

  /**
   * Next state
   */
  var $nextStateLabel = (0, _nodeFactory2.default)('label', { textContent: 'Следующее состояние' });
  var $nextStateSelect = (0, _nodeFactory2.default)('select', { classList: ['next-state-select'] });
  if (!action) {
    var $defaultOption = (0, _nodeFactory2.default)('option', {
      textContent: 'Следующее состояние',
      attrs: { selected: true, disabled: true, hidden: true }
    });
    $nextStateSelect.appendChild($defaultOption);
  }
  states.forEach(function (_ref2) {
    var name = _ref2.name,
        uuid = _ref2.uuid;

    // skip current state
    if (uuid === currentState) {
      return;
    }
    var $option = (0, _nodeFactory2.default)('option', { attrs: { value: uuid }, textContent: name });
    $nextStateSelect.appendChild($option);
  });
  $nextStateSelect.addEventListener('change', function () {
    return setNextState(currentState, $nextStateSelect.value, id);
  });
  $actionWrapper.appendChild($nextStateLabel);
  $actionWrapper.appendChild($nextStateSelect);

  /**
   * Action time
   */
  var $time = (0, _nodeFactory2.default)('div', { classList: ['panel-action-time'] });
  createActionTimeNode($time, id);
  $actionWrapper.appendChild($time);

  /**
   * Tools
   */
  var $toolsHeader = (0, _nodeFactory2.default)('div', { classList: ['panel-action-tools-header'] });
  var $toolsHeaderLabel = (0, _nodeFactory2.default)('label', { textContent: 'Значения приборов' });
  var $toolsHeaderIcon = (0, _nodeFactory2.default)('i', { classList: ['icon', 'icon-add'] });
  $toolsHeaderIcon.addEventListener('click', function () {
    if (tools.length === 0) {
      return;
    }
    addActionTool(tools, $actionWrapper, id);
  });
  $toolsHeader.appendChild($toolsHeaderLabel);
  $toolsHeader.appendChild($toolsHeaderIcon);
  $actionWrapper.appendChild($toolsHeader);

  return $actionWrapper;
}

function setNextState(source, target, id, inactive) {
  if (source === target) {
    console.warn('Trying to connect with itself');
    return;
  }
  connect(source, target);
  _pubsub2.default.publish('actionNextStateChanged', { id: id, stateId: target });
}

function connect(source, target) {
  _jsplumb.jsPlumb.connect({
    source: 'state-' + source,
    target: 'state-' + target,
    anchor: ['Perimeter', { shape: 'Rectangle' }],
    endpoint: 'Blank',
    connector: ['Flowchart', { stub: 0, gap: 10, cornerRadius: 5 }],
    overlays: [['Arrow', { width: 10, length: 10, foldback: 0.7, location: 1 }]],
    detachable: false
  });
}

function createActionTimeNode($parent, id) {
  var $label = (0, _nodeFactory2.default)('label', { textContent: 'Время действия' });

  var $inputs = (0, _nodeFactory2.default)('div', { classList: ['panel-action-time-controls'] });
  var $inputMin = (0, _nodeFactory2.default)('input', { attrs: { placeholder: 'min' } });
  var $inputMax = (0, _nodeFactory2.default)('input', { attrs: { placeholder: 'max' } });

  var handleChange = function handleChange() {
    _pubsub2.default.publish('actionTimeChanged', {
      id: id,
      time: {
        min: parseInt($inputMin.value, 10),
        max: parseInt($inputMax.value, 10)
      }
    });
  };
  $inputMin.addEventListener('change', function () {
    return handleChange();
  });
  $inputMax.addEventListener('change', function () {
    return handleChange();
  });

  $inputs.appendChild($inputMin);
  $inputs.appendChild($inputMax);

  $parent.appendChild($label);
  $parent.appendChild($inputs);
}

/**
 * Action tools DOM
 */
function addActionTool(tools, $parent, id) {
  var $wrapper = (0, _nodeFactory2.default)('div', { classList: ['panel-action-tool'] });
  var $select = (0, _nodeFactory2.default)('select');
  var $defaultOption = (0, _nodeFactory2.default)('option', { textContent: 'Прибор', attrs: { selected: true, disabled: true, hidden: true } });
  $select.appendChild($defaultOption);
  fillToolsSelect($select, tools);

  var $inputWrapper = (0, _nodeFactory2.default)('div', { classList: ['panel-action-tool-value'] });
  $select.addEventListener('change', function (e) {
    _pubsub2.default.publish('actionToolChanged', { id: id, toolId: e.target.value });
    var currentOption = $select.options[$select.selectedIndex];
    var type = currentOption.dataset.type,
        toolId = currentOption.value;

    var $input = createActionToolInput(type, { id: id, toolId: toolId });
    $inputWrapper.innerHTML = '';
    $inputWrapper.appendChild($input);
  });

  $wrapper.appendChild($select);
  $wrapper.appendChild($inputWrapper);

  $parent.appendChild($wrapper);
}

function fillToolsSelect($sel, tools) {
  tools.forEach(function (_ref3) {
    var uuid = _ref3.uuid,
        name = _ref3.name,
        type = _ref3.type;

    var $opt = (0, _nodeFactory2.default)('option', { attrs: { value: uuid, 'data-type': type }, textContent: name });
    $sel.appendChild($opt);
  });
}

function createActionToolInput(type, ids) {
  switch (type) {
    case 'switch':
      return createSwitchInput(ids);
    case 'range':
      return createRangeInput(ids);
    default:
      console.warn('Invalid current tool option in action creator');
      return (0, _nodeFactory2.default)('div');
  }
}

function createSwitchInput(_ref4) {
  var id = _ref4.id,
      toolId = _ref4.toolId;

  // todo make ID's unique
  var $fragment = document.createDocumentFragment();
  var $label = (0, _nodeFactory2.default)('label', { attrs: { for: 'action-tool-checkbox' }, textContent: 'Включен?' });
  var $input = (0, _nodeFactory2.default)('input', { attrs: { type: 'checkbox', id: 'action-tool-checkbox' } });

  $input.addEventListener('change', function () {
    _pubsub2.default.publish('actionToolValueChanged', { id: id, toolId: toolId, value: $input.checked });
  });

  $fragment.appendChild($label);
  $fragment.appendChild($input);

  return $fragment;
}

function createRangeInput(_ref5) {
  var id = _ref5.id,
      toolId = _ref5.toolId;

  var $fragment = document.createDocumentFragment();
  var $inputMin = (0, _nodeFactory2.default)('input', {
    attrs: {
      type: 'text',
      placeholder: 'Минимум'
    }
  });

  var $inputMax = (0, _nodeFactory2.default)('input', {
    attrs: {
      type: 'text',
      placeholder: 'Максимум'
    }
  });

  var handleChange = function handleChange() {
    _pubsub2.default.publish('actionToolValueChanged', {
      id: id,
      toolId: toolId,
      value: [parseInt($inputMin.value, 10), parseInt($inputMax.value, 10)]
    });
  };

  $inputMin.addEventListener('change', function () {
    return handleChange();
  });
  $inputMax.addEventListener('change', function () {
    return handleChange();
  });

  $fragment.appendChild($inputMin);
  $fragment.appendChild($inputMax);

  return $fragment;
}

/**
 * Inactive action constructor
 */
function createInactiveAction(id, _ref6) {
  var currentState = _ref6.currentState,
      states = _ref6.states;

  var $wrapper = (0, _nodeFactory2.default)('div', { classList: ['panel-action'] });

  var $label = (0, _nodeFactory2.default)('label', { textContent: 'Переход при бездействии' });
  var $select = (0, _nodeFactory2.default)('select', { classList: ['next-state-select'] });
  var $defaultOption = (0, _nodeFactory2.default)('option', {
    textContent: 'Состояние',
    attrs: { disabled: true, hidden: true, selected: true }
  });
  $select.appendChild($defaultOption);

  states.forEach(function (_ref7) {
    var uuid = _ref7.uuid,
        name = _ref7.name;

    if (uuid === currentState) {
      return;
    }
    var $option = (0, _nodeFactory2.default)('option', { attrs: { value: uuid }, textContent: name });
    $select.appendChild($option);
  });

  $select.addEventListener('change', function () {
    var nextState = $select.value;
    connect(currentState, nextState);
    _pubsub2.default.publish('inactiveActionSet', { id: id, nextState: nextState });
  });

  $wrapper.appendChild($label);
  $wrapper.appendChild($select);

  return $wrapper;
}

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _pubsub = __webpack_require__(1);

var _pubsub2 = _interopRequireDefault(_pubsub);

var _nodeFactory = __webpack_require__(2);

var _nodeFactory2 = _interopRequireDefault(_nodeFactory);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function createParameter(id) {
  var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var $paramWrapper = (0, _nodeFactory2.default)('div', { classList: ['panel-param'] });

  var $nameInput = (0, _nodeFactory2.default)('input', {
    attrs: {
      type: 'text',
      placeholder: 'Name',
      value: data.name || ''
    }
  });
  $nameInput.addEventListener('change', function (e) {
    _pubsub2.default.publish('parameterNameChanged', { id: id, name: e.target.value });
  });

  var $valueInput = (0, _nodeFactory2.default)('input', {
    attrs: {
      type: 'text',
      placeholder: 'Value',
      value: data.value || ''
    }
  });
  $valueInput.addEventListener('change', function (e) {
    _pubsub2.default.publish('parameterValueChanged', { id: id, value: parseInt(e.target.value, 10) });
  });

  $paramWrapper.appendChild($nameInput);
  $paramWrapper.appendChild($valueInput);
  return $paramWrapper;
}

exports.default = createParameter;

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createState;

var _nodeFactory = __webpack_require__(2);

var _nodeFactory2 = _interopRequireDefault(_nodeFactory);

var _config = __webpack_require__(3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function createState(id) {
  var nodeId = 'state-' + id;
  var $node = (0, _nodeFactory2.default)('div', { classList: ['cad-state'], attrs: { id: nodeId } });
  var $stateName = (0, _nodeFactory2.default)('h5', { classList: ['cad-state-name'], textContent: _config.DEFAULT_STATE_NAME });
  $node.appendChild($stateName);
  return $node;
}

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createTool;

var _pubsub = __webpack_require__(1);

var _pubsub2 = _interopRequireDefault(_pubsub);

var _nodeFactory = __webpack_require__(2);

var _nodeFactory2 = _interopRequireDefault(_nodeFactory);

var _config = __webpack_require__(3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function createTool(id) {
  var $toolWrapper = (0, _nodeFactory2.default)('div', { classList: ['panel-tool'] });
  var $nameLabel = (0, _nodeFactory2.default)('label', { classList: ['panel-tool-name'], textContent: 'Название прибора' });
  var $nameInput = (0, _nodeFactory2.default)('input', { attrs: { type: 'text', value: _config.DEFAULT_TOOL_NAME } });
  $nameInput.addEventListener('change', function () {
    _pubsub2.default.publish('toolNameChanged', { id: id, name: $nameInput.value });
  });

  var $toolTypeWrapper = (0, _nodeFactory2.default)('div', { classList: ['panel-tool-type'] });
  var $toolTypeLabel = (0, _nodeFactory2.default)('label', { textContent: 'Тип прибора' });
  var $toolTypeSelect = (0, _nodeFactory2.default)('select');
  _config.TOOL_TYPES.forEach(function (toolType) {
    var $option = createOption(toolType);
    $toolTypeSelect.appendChild($option);
    if (toolType === _config.DEFAULT_TOOL_TYPE) {
      $option.selected = true;
    }
  });
  var $rangeValues = createRangeValues(id);

  $toolTypeSelect.addEventListener('change', function (e) {
    var type = e.target.value;
    _pubsub2.default.publish('toolTypeChanged', { id: id, type: type });
    if (type === 'range') {
      $rangeValues.style.display = 'flex';
    } else {
      $rangeValues.style.display = 'none';
    }
  });
  $toolTypeWrapper.appendChild($toolTypeLabel);
  $toolTypeWrapper.appendChild($toolTypeSelect);

  $toolWrapper.appendChild($nameLabel);
  $toolWrapper.appendChild($nameInput);
  $toolWrapper.appendChild($toolTypeWrapper);
  $toolWrapper.appendChild($rangeValues);

  return $toolWrapper;
}

function createOption(value, name) {
  return (0, _nodeFactory2.default)('option', {
    textContent: value,
    attrs: { name: name || value }
  });
}

function createRangeValues(id) {
  var $wrapper = (0, _nodeFactory2.default)('div', { classList: ['panel-tool-range-values'] });

  var $minInput = createRangeInput('Минимум');
  $wrapper.appendChild($minInput);

  var $maxInput = createRangeInput('Максимум');
  $wrapper.appendChild($maxInput);

  var handleValueChange = function handleValueChange() {
    var values = {
      min: parseInt($minInput.querySelector('input').value, 10),
      max: parseInt($maxInput.querySelector('input').value, 10)
    };
    _pubsub2.default.publish('toolRangeChanged', { id: id, values: values });
  };

  $minInput.addEventListener('change', function () {
    handleValueChange();
  });
  $maxInput.addEventListener('change', function () {
    handleValueChange();
  });

  return $wrapper;
}

function createRangeInput(name) {
  var $div = (0, _nodeFactory2.default)('div');
  var $label = (0, _nodeFactory2.default)('label', { textContent: name });
  var $input = (0, _nodeFactory2.default)('input', { attrs: { type: 'text' } });

  $div.appendChild($label);
  $div.appendChild($input);

  return $div;
}

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _pubsub = __webpack_require__(1);

var _pubsub2 = _interopRequireDefault(_pubsub);

var _toolsMenu = __webpack_require__(30);

var _toolsMenu2 = _interopRequireDefault(_toolsMenu);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var $modelName = document.querySelector('#model-name-input');
var $breakTime = document.querySelector('#break-time-input');
var $steps = document.querySelector('#steps-input');

$modelName.addEventListener('change', function () {
  _pubsub2.default.publish('nameChanged', $modelName.value);
});
$breakTime.addEventListener('change', function () {
  _pubsub2.default.publish('breakChanged', parseInt($breakTime.value, 10));
});
$steps.addEventListener('change', function () {
  _pubsub2.default.publish('stepsChanged', parseInt($steps.value, 10));
});

exports.default = {
  init: function init(_ref) {
    var name = _ref.name,
        breakTime = _ref.breakTime,
        steps = _ref.steps;

    $modelName.value = name;
    $breakTime.value = breakTime;
    $steps.value = steps;
  }
};

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _tool = __webpack_require__(28);

var _tool2 = _interopRequireDefault(_tool);

var _utils = __webpack_require__(4);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var $header = document.getElementById('panel-tools-open');
var $addBtn = document.getElementById('add-tool-btn');
var $toolsList = document.getElementById('panel-tools-list');

$header.addEventListener('click', function () {
  return (0, _utils.handleHeaderClick)($header, $toolsList);
});
$addBtn.addEventListener('click', function () {
  return (0, _utils.handleAddBtnClick)($header, $toolsList, _tool2.default, 'toolCreated');
});

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _v = __webpack_require__(5);

var _v2 = _interopRequireDefault(_v);

var _pubsub = __webpack_require__(1);

var _pubsub2 = _interopRequireDefault(_pubsub);

var _action = __webpack_require__(25);

var _utils = __webpack_require__(4);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var $header = document.getElementById('panel-actions-open');
var $addBtn = document.getElementById('add-action-btn');
var $actionsList = document.getElementById('panel-actions-list');

$header.addEventListener('click', function () {
  return (0, _utils.handleHeaderClick)($header, $actionsList);
});
$addBtn.addEventListener('click', function () {
  _pubsub2.default.publish('schemeDataRequested', { newAction: true });
  $actionsList.classList.remove('is-hidden');
  $header.querySelector('.icon').style.transform = 'rotate(90deg)';
});

_pubsub2.default.subscribe('schemeDataSent', function (data) {
  if (data.newAction) {
    var id = (0, _v2.default)();
    var $actionNode = (0, _action.createAction)(id, data);
    $actionsList.appendChild($actionNode);
    _pubsub2.default.publish('actionCreated', id);

    var inactiveId = (0, _v2.default)();
    $actionsList.appendChild((0, _action.createInactiveAction)(inactiveId, data));
    _pubsub2.default.publish('actionCreated', inactiveId);
  } else {
    data.actions.forEach(function (action) {
      var $actionNode = (0, _action.createAction)(action.id, data);
      $actionsList.appendChild($actionNode);
    });
  }
});

var ActionsMenu = {
  set: function set(actions) {
    $actionsList.innerHTML = '';
    _pubsub2.default.publish('schemeDataRequested', { newAction: false, actions: actions });
  }
};

exports.default = ActionsMenu;

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _pubsub = __webpack_require__(1);

var _pubsub2 = _interopRequireDefault(_pubsub);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var $name = document.getElementById('event-name-input');
var $desc = document.getElementById('event-description-input');

$name.addEventListener('change', function () {
  _pubsub2.default.publish('eventNameChanged', $name.value);
});

$desc.addEventListener('change', function () {
  _pubsub2.default.publish('eventDescChanged', $desc.value);
});

var EventMenu = {
  set: function set(_ref) {
    var name = _ref.name,
        desc = _ref.desc;

    $name.value = name;
    $desc.value = desc;
  }
};

exports.default = EventMenu;

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _pubsub = __webpack_require__(1);

var _pubsub2 = _interopRequireDefault(_pubsub);

var _eventMenu = __webpack_require__(32);

var _eventMenu2 = _interopRequireDefault(_eventMenu);

var _parametersMenu = __webpack_require__(34);

var _parametersMenu2 = _interopRequireDefault(_parametersMenu);

var _actionsMenu = __webpack_require__(31);

var _actionsMenu2 = _interopRequireDefault(_actionsMenu);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var $nameInput = document.getElementById('state-name-input');
$nameInput.addEventListener('change', function () {
  _pubsub2.default.publish('stateNameChanged', $nameInput.value);
});

var $imageSelect = document.getElementById('image-select');
$imageSelect.addEventListener('change', function () {
  _pubsub2.default.publish('stateImageChanged', $imageSelect.value);
});

var $initialState = document.getElementById('initial-state-checkbox');

var StateMenu = {
  set: function set(state) {
    $nameInput.value = state.name;
    $imageSelect.value = state.img;
    $initialState.checked = false;
    $initialState.onclick = function () {
      if ($initialState.checked) {
        _pubsub2.default.publish('initialStateChanged', state.uuid);
      }
    };
    _eventMenu2.default.set(state.event);
    _parametersMenu2.default.set(state.parameters);
    _actionsMenu2.default.set(state.actions);
  }
};

exports.default = StateMenu;

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _parameter = __webpack_require__(26);

var _parameter2 = _interopRequireDefault(_parameter);

var _utils = __webpack_require__(4);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var $header = document.getElementById('panel-params-open');
var $addBtn = document.getElementById('add-param-btn');
var $parametersList = document.getElementById('panel-params-list');

$header.addEventListener('click', function () {
  return (0, _utils.handleHeaderClick)($header, $parametersList);
});
$addBtn.addEventListener('click', function () {
  return (0, _utils.handleAddBtnClick)($header, $parametersList, _parameter2.default, 'parameterCreated');
});

var ParametersMenu = {
  set: function set(parameters) {
    $parametersList.innerHTML = '';
    parameters.forEach(function (p) {
      return $parametersList.appendChild((0, _parameter2.default)(p.id, p));
    });
  }
};

exports.default = ParametersMenu;

/***/ }),
/* 35 */,
/* 36 */,
/* 37 */,
/* 38 */,
/* 39 */,
/* 40 */,
/* 41 */,
/* 42 */,
/* 43 */,
/* 44 */,
/* 45 */
/***/ (function(module, exports) {

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
var byteToHex = [];
for (var i = 0; i < 256; ++i) {
  byteToHex[i] = (i + 0x100).toString(16).substr(1);
}

function bytesToUuid(buf, offset) {
  var i = offset || 0;
  var bth = byteToHex;
  return bth[buf[i++]] + bth[buf[i++]] +
          bth[buf[i++]] + bth[buf[i++]] + '-' +
          bth[buf[i++]] + bth[buf[i++]] + '-' +
          bth[buf[i++]] + bth[buf[i++]] + '-' +
          bth[buf[i++]] + bth[buf[i++]] + '-' +
          bth[buf[i++]] + bth[buf[i++]] +
          bth[buf[i++]] + bth[buf[i++]] +
          bth[buf[i++]] + bth[buf[i++]];
}

module.exports = bytesToUuid;


/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Unique ID creation requires a high quality random # generator.  In the
// browser this is a little complicated due to unknown quality of Math.random()
// and inconsistent support for the `crypto` API.  We do the best we can via
// feature-detection
var rng;

var crypto = global.crypto || global.msCrypto; // for IE 11
if (crypto && crypto.getRandomValues) {
  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto
  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef
  rng = function whatwgRNG() {
    crypto.getRandomValues(rnds8);
    return rnds8;
  };
}

if (!rng) {
  // Math.random()-based (RNG)
  //
  // If all else fails, use Math.random().  It's fast, but is of unspecified
  // quality.
  var rnds = new Array(16);
  rng = function() {
    for (var i = 0, r; i < 16; i++) {
      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
    }

    return rnds;
  };
}

module.exports = rng;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(47)))

/***/ }),
/* 47 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 48 */,
/* 49 */,
/* 50 */,
/* 51 */,
/* 52 */,
/* 53 */,
/* 54 */,
/* 55 */,
/* 56 */,
/* 57 */,
/* 58 */,
/* 59 */,
/* 60 */,
/* 61 */,
/* 62 */,
/* 63 */,
/* 64 */,
/* 65 */,
/* 66 */,
/* 67 */,
/* 68 */,
/* 69 */,
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _ajax = __webpack_require__(0);

var _ajax2 = _interopRequireDefault(_ajax);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var API = {
  sendModel: function sendModel(model) {
    return (0, _ajax2.default)('/cad/models/', {
      method: 'POST',
      data: model,
      headers: {
        'Content-type': 'application/json'
      }
    });
  }
};

exports.default = API;

/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgNDFhZTliNTc5NzA4MDkzZTIxODMiLCJ3ZWJwYWNrOi8vLy4vdXRpbHMvYWpheC5qcyIsIndlYnBhY2s6Ly8vLi91dGlscy9wdWJzdWIuanMiLCJ3ZWJwYWNrOi8vLy4vdXRpbHMvbm9kZUZhY3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy4vY2FkL2NvbmZpZy5qcyIsIndlYnBhY2s6Ly8vLi9jYWQvc2NlbmUvdXRpbHMuanMiLCJ3ZWJwYWNrOi8vL1o6L3dlYi9wcm9qZWN0cy9scGsvfi91dWlkL3Y0LmpzIiwid2VicGFjazovLy9aOi93ZWIvcHJvamVjdHMvbHBrL34vanNwbHVtYi9kaXN0L2pzL2pzcGx1bWIuanMiLCJ3ZWJwYWNrOi8vLy4vY2FkL3NjZW5lL2luZGV4LmpzIiwid2VicGFjazovLy8uL2NhZC9zY2hlbWUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vY2FkL3NjaGVtZS9ub3JtYWxpemUuanMiLCJ3ZWJwYWNrOi8vLy4uL3Nhc3MvY2FkLnNjc3MiLCJ3ZWJwYWNrOi8vLy4vY2FkL2luZGV4LmpzIiwid2VicGFjazovLy8uL2NhZC9zY2VuZS9VSUZhY3RvcnkvYWN0aW9uLmpzIiwid2VicGFjazovLy8uL2NhZC9zY2VuZS9VSUZhY3RvcnkvcGFyYW1ldGVyLmpzIiwid2VicGFjazovLy8uL2NhZC9zY2VuZS9VSUZhY3Rvcnkvc3RhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vY2FkL3NjZW5lL1VJRmFjdG9yeS90b29sLmpzIiwid2VicGFjazovLy8uL2NhZC9zY2VuZS9tb2RlbF9tZW51L2luZGV4LmpzIiwid2VicGFjazovLy8uL2NhZC9zY2VuZS9tb2RlbF9tZW51L3Rvb2xzTWVudS5qcyIsIndlYnBhY2s6Ly8vLi9jYWQvc2NlbmUvc3RhdGVfbWVudS9hY3Rpb25zTWVudS5qcyIsIndlYnBhY2s6Ly8vLi9jYWQvc2NlbmUvc3RhdGVfbWVudS9ldmVudE1lbnUuanMiLCJ3ZWJwYWNrOi8vLy4vY2FkL3NjZW5lL3N0YXRlX21lbnUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vY2FkL3NjZW5lL3N0YXRlX21lbnUvcGFyYW1ldGVyc01lbnUuanMiLCJ3ZWJwYWNrOi8vL1o6L3dlYi9wcm9qZWN0cy9scGsvfi91dWlkL2xpYi9ieXRlc1RvVXVpZC5qcyIsIndlYnBhY2s6Ly8vWjovd2ViL3Byb2plY3RzL2xway9+L3V1aWQvbGliL3JuZy1icm93c2VyLmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanMiLCJ3ZWJwYWNrOi8vLy4vY2FkL2FwaS5qcyJdLCJuYW1lcyI6WyJhamF4IiwicGF0aCIsIm9wdGlvbnMiLCJmdWxsUmVzcG9uc2UiLCJ4aHIiLCJYTUxIdHRwUmVxdWVzdCIsIm9wZW4iLCJtZXRob2QiLCJoZWFkZXJzIiwic2V0WEhSSGVhZGVycyIsInNlbmQiLCJkYXRhIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJvbnJlYWR5c3RhdGVjaGFuZ2UiLCJyZWFkeVN0YXRlIiwic3RhdHVzIiwicmVzcG9uc2VUZXh0Iiwic3RhdHVzVGV4dCIsImhlYWRlciIsInNldFJlcXVlc3RIZWFkZXIiLCJwdWJzdWIiLCJ0b3BpY3MiLCJzdWJzY3JpYmUiLCJ0b3BpYyIsImxpc3RlbmVyIiwicXVldWUiLCJpbmRleCIsInB1c2giLCJyZW1vdmUiLCJwdWJsaXNoIiwiaW5mbyIsImxlbmd0aCIsIml0ZW1zIiwiZm9yRWFjaCIsIml0ZW0iLCJub2RlRmFjdG9yeSIsInR5cGUiLCJwYXJhbXMiLCJub2RlIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiYXBwZW5kQ2xhc3NlcyIsImFwcGVuZEF0dHJzIiwiaW5zZXJ0VGV4dENvbnRlbnQiLCJjbGFzc0xpc3QiLCJhZGQiLCJjbGFzc05hbWUiLCJhdHRycyIsImF0dHJOYW1lcyIsIk9iamVjdCIsImtleXMiLCJzZXRBdHRyaWJ1dGUiLCJhdHRyTmFtZSIsInRleHRDb250ZW50IiwiREVGQVVMVF9TVEFURV9OQU1FIiwiREVGQVVMVF9UT09MX05BTUUiLCJUT09MX1RZUEVTIiwiREVGQVVMVF9UT09MX1RZUEUiLCJERUZBVUxUX0lNQUdFX0lEIiwiaGFuZGxlSGVhZGVyQ2xpY2siLCJoYW5kbGVBZGRCdG5DbGljayIsIiRoZWFkZXIiLCIkbGlzdCIsImNsb3NlZCIsInRvZ2dsZSIsIiRpY29uIiwicXVlcnlTZWxlY3RvciIsInN0eWxlIiwidHJhbnNmb3JtIiwiZmFjdG9yeSIsImV2ZW50TmFtZSIsImlkIiwiJG5vZGUiLCJhcHBlbmRDaGlsZCIsIiRzdGF0ZVBhbmVsIiwiJHByb3BzUGFuZWwiLCIkY2FkUGFuZSIsInNldENvbnRhaW5lciIsIm5hbWUiLCIkbmFtZSIsInN0YXRlIiwic2V0IiwiU2NlbmUiLCJhZGRTdGF0ZSIsIiRzdGF0ZU5vZGUiLCJhZGRFdmVudExpc3RlbmVyIiwiZSIsInByZXZlbnREZWZhdWx0Iiwic2hvd1N0YXRlUGFuZWwiLCJkcmFnZ2FibGUiLCJjb250YWlubWVudCIsImhpZGVQcm9wc1BhbmVsIiwic2hvd1Byb3BzUGFuZWwiLCJoaWRlU3RhdGVQYW5lbCIsImluaXQiLCJzY2hlbWUiLCJtb2R1bGUiLCJleHBvcnRzIiwiU2NoZW1lIiwiaW5pdGlhbFN0YXRlIiwiYnJlYWtUaW1lIiwic3RlcHMiLCJ0b29scyIsInN0YXRlcyIsInBhcmFtZXRlcnMiLCJhY3Rpb25zIiwiX2NzIiwiYmluZCIsInNldEN1cnJlbnRTdGF0ZSIsInNldE5hbWUiLCJzZXRCcmVha1RpbWUiLCJzZXRTdGVwcyIsImFkZFRvb2wiLCJzZXRUb29sTmFtZSIsInNldFRvb2xUeXBlIiwic2V0VG9vbFJhbmdlIiwic2V0U3RhdGVOYW1lIiwic2V0U3RhdGVJbWFnZSIsInNldEluaXRpYWxTdGF0ZSIsInNldEV2ZW50TmFtZSIsInNldEV2ZW50RGVzYyIsImFkZFBhcmFtZXRlciIsInNldFBhcmFtZXRlck5hbWUiLCJzZXRQYXJhbWV0ZXJWYWx1ZSIsImFkZEFjdGlvbiIsInNldEFjdGlvbk5leHRTdGF0ZSIsInNldEFjdGlvblRpbWUiLCJzZXRBY3Rpb25Ub29sIiwic2V0QWN0aW9uVG9vbFZhbHVlIiwic2V0SW5hY3RpdmVBY3Rpb24iLCJwYXlsb2FkIiwidmFsdWVzIiwiYXNzaWduIiwiY3VycmVudFN0YXRlIiwidXVpZCIsImltZyIsImV2ZW50IiwiZGVzYyIsImNzIiwibWFwIiwicElkIiwiYUlkIiwidGltZSIsInJhbmdlVmFsdWVzIiwic3RhdGVJZCIsInZhbHVlIiwibmV4dFN0YXRlIiwibWluIiwibWF4IiwidG9vbElkIiwiY29uc29sZSIsIndhcm4iLCJpbmFjdGl2ZSIsIm5vcm1hbGl6ZSIsInNvdXJjZSIsInJlc3VsdCIsInNvdXJjZVN0YXRlIiwiZXh0cmFjdEFjdGlvbnMiLCJleHRyYWN0UGFyYW1ldGVycyIsImxhc3QiLCJhY3Rpb25JZHMiLCJhY3Rpb24iLCJ1bmRlZmluZWQiLCJ0b29sIiwicmVzIiwic3dpdGNoVmFsdWUiLCJwYXJhbWV0ZXJJZHMiLCIkbmV3U3RhdGVCdXR0b24iLCIkbW9kZWxQcm9wc0J1dHRvbiIsIiRzdGF0ZUNsb3NlQnV0dG9uIiwiJHByb3BzQ2xvc2VCdXR0b24iLCIkc2F2ZU1vZGVsQnRuIiwiZ2V0RWxlbWVudEJ5SWQiLCJtb2RlbCIsImdldE5vcm1hbGl6ZWQiLCJzZW5kTW9kZWwiLCJKU09OIiwic3RyaW5naWZ5IiwidGhlbiIsImxvZyIsImNhdGNoIiwiZXJyIiwiY3JlYXRlQWN0aW9uIiwiY3JlYXRlSW5hY3RpdmVBY3Rpb24iLCIkYWN0aW9uV3JhcHBlciIsIiRuZXh0U3RhdGVMYWJlbCIsIiRuZXh0U3RhdGVTZWxlY3QiLCIkZGVmYXVsdE9wdGlvbiIsInNlbGVjdGVkIiwiZGlzYWJsZWQiLCJoaWRkZW4iLCIkb3B0aW9uIiwic2V0TmV4dFN0YXRlIiwiJHRpbWUiLCJjcmVhdGVBY3Rpb25UaW1lTm9kZSIsIiR0b29sc0hlYWRlciIsIiR0b29sc0hlYWRlckxhYmVsIiwiJHRvb2xzSGVhZGVySWNvbiIsImFkZEFjdGlvblRvb2wiLCJ0YXJnZXQiLCJjb25uZWN0IiwiYW5jaG9yIiwic2hhcGUiLCJlbmRwb2ludCIsImNvbm5lY3RvciIsInN0dWIiLCJnYXAiLCJjb3JuZXJSYWRpdXMiLCJvdmVybGF5cyIsIndpZHRoIiwiZm9sZGJhY2siLCJsb2NhdGlvbiIsImRldGFjaGFibGUiLCIkcGFyZW50IiwiJGxhYmVsIiwiJGlucHV0cyIsIiRpbnB1dE1pbiIsInBsYWNlaG9sZGVyIiwiJGlucHV0TWF4IiwiaGFuZGxlQ2hhbmdlIiwicGFyc2VJbnQiLCIkd3JhcHBlciIsIiRzZWxlY3QiLCJmaWxsVG9vbHNTZWxlY3QiLCIkaW5wdXRXcmFwcGVyIiwiY3VycmVudE9wdGlvbiIsInNlbGVjdGVkSW5kZXgiLCJkYXRhc2V0IiwiJGlucHV0IiwiY3JlYXRlQWN0aW9uVG9vbElucHV0IiwiaW5uZXJIVE1MIiwiJHNlbCIsIiRvcHQiLCJpZHMiLCJjcmVhdGVTd2l0Y2hJbnB1dCIsImNyZWF0ZVJhbmdlSW5wdXQiLCIkZnJhZ21lbnQiLCJjcmVhdGVEb2N1bWVudEZyYWdtZW50IiwiZm9yIiwiY2hlY2tlZCIsImNyZWF0ZVBhcmFtZXRlciIsIiRwYXJhbVdyYXBwZXIiLCIkbmFtZUlucHV0IiwiJHZhbHVlSW5wdXQiLCJjcmVhdGVTdGF0ZSIsIm5vZGVJZCIsIiRzdGF0ZU5hbWUiLCJjcmVhdGVUb29sIiwiJHRvb2xXcmFwcGVyIiwiJG5hbWVMYWJlbCIsIiR0b29sVHlwZVdyYXBwZXIiLCIkdG9vbFR5cGVMYWJlbCIsIiR0b29sVHlwZVNlbGVjdCIsInRvb2xUeXBlIiwiY3JlYXRlT3B0aW9uIiwiJHJhbmdlVmFsdWVzIiwiY3JlYXRlUmFuZ2VWYWx1ZXMiLCJkaXNwbGF5IiwiJG1pbklucHV0IiwiJG1heElucHV0IiwiaGFuZGxlVmFsdWVDaGFuZ2UiLCIkZGl2IiwiJG1vZGVsTmFtZSIsIiRicmVha1RpbWUiLCIkc3RlcHMiLCIkYWRkQnRuIiwiJHRvb2xzTGlzdCIsIiRhY3Rpb25zTGlzdCIsIm5ld0FjdGlvbiIsIiRhY3Rpb25Ob2RlIiwiaW5hY3RpdmVJZCIsIkFjdGlvbnNNZW51IiwiJGRlc2MiLCJFdmVudE1lbnUiLCIkaW1hZ2VTZWxlY3QiLCIkaW5pdGlhbFN0YXRlIiwiU3RhdGVNZW51Iiwib25jbGljayIsIiRwYXJhbWV0ZXJzTGlzdCIsIlBhcmFtZXRlcnNNZW51IiwicCIsIkFQSSJdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxtREFBMkMsY0FBYzs7QUFFekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBMkIsMEJBQTBCLEVBQUU7QUFDdkQseUNBQWlDLGVBQWU7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOERBQXNELCtEQUErRDs7QUFFckg7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDaEVBLFNBQVNBLElBQVQsR0FBNkQ7QUFBQSxNQUEvQ0MsSUFBK0MsdUVBQXhDLEVBQXdDO0FBQUEsTUFBcENDLE9BQW9DLHVFQUExQixFQUEwQjtBQUFBLE1BQXRCQyxZQUFzQix1RUFBUCxLQUFPOztBQUMzRCxNQUFNQyxNQUFNLElBQUlDLGNBQUosRUFBWjtBQUNBRCxNQUFJRSxJQUFKLENBQVNKLFFBQVFLLE1BQVIsSUFBa0IsS0FBM0IsRUFBa0NOLElBQWxDLEVBQXdDLElBQXhDO0FBQ0EsTUFBSUMsUUFBUU0sT0FBWixFQUFxQjtBQUFFQyxrQkFBY0wsR0FBZCxFQUFtQkYsUUFBUU0sT0FBM0I7QUFBc0M7QUFDN0RKLE1BQUlNLElBQUosQ0FBU1IsUUFBUVMsSUFBakI7O0FBRUEsU0FBTyxJQUFJQyxPQUFKLENBQVksVUFBQ0MsT0FBRCxFQUFVQyxNQUFWLEVBQXFCO0FBQ3RDVixRQUFJVyxrQkFBSixHQUF5QixZQUFXO0FB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a0JBQWtCO0FBQ2pEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isc0JBQXNCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSx3QkFBd0Isc0RBQXNEO0FBQzlFO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxPQUFPO0FBQ25FO0FBQ0EsNkVBQTZFO0FBQzdFO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSwyQkFBMkIsZ0JBQWdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0Esb0VBQW9FLE9BQU87QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0EsK0JBQStCLG9DQUFvQztBQUNuRTtBQUNBOztBQUVBLDJCQUEyQixjQUFjO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IseUJBQXlCO0FBQ3hEO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsT0FBTztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Es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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxRQUFRO0FBQ2xFLDZFQUE2RSxRQUFRO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsa0JBQWtCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGtCQUFrQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFFBQVE7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSw0QkFBNEIsOEJBQThCLDZCQUE2QjtBQUN2RjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLHlCQUF5QjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwrQkFBK0Isb0JBQW9CO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7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QTtBQUNBLHFGQUFxRjtBQUNyRiw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsaURBQWlELE9BQU87QUFDeEQ7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLHVGQUF1RixXQUFXO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7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QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkNBQTJDLG9CQUFvQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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RUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSwwRUFBMEU7QUFDMUU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsMkJBQTJCO0FBQ2xEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBLDRCQUE0QjtBQUM1Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHdCQUF3QjtBQUN4Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF3QjtBQUN4QjtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLGlCQUFpQiw0QkFBNEI7QUFDN0MsaUJBQWlCLGlDQUFpQztBQUNsRCxpQkFBaUIsaUNBQWlDO0FBQ2xELGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJCQUEyQixxQkFBcUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5Q0FBeUMsZUFBZTtBQUN4RCxxQ0FBcUMsc0RBQXNEO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxpQkFBaUI7O0FBRXZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLDJCQUEyQixxQkFBcUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQkFBK0IscUJBQXFCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLCtCQUErQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGtCQUFrQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQkFBMkIscUJBQXFCO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsZ0RBQWdELEVBQUU7QUFDbEQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVCwrQkFBK0I7QUFDL0I7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTywyRkFBMkY7QUFDakg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0Msb0JBQW9CO0FBQ25FO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHlCQUF5QixpQ0FBaUM7QUFDMUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxZQUFZO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQywyQkFBMkI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjs7QUFFM0I7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0IsMkNBQTJDO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNDQUFzQyxHQUFHO0FBQ3pDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixvQ0FBb0M7QUFDM0Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQ0FBZ0MsMEJBQTBCOztBQUUxRDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7OztBQUdBOztBQUVBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RCxtSUFBbUk7QUFDbkk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVEQUF1RCxpQ0FBaUM7QUFDeEY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMscUJBQXFCLEVBQUU7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0Esd0NBQXdDLDZDQUE2QyxFQUFFO0FBQ3ZGLFNBQVM7QUFDVDtBQUNBO0FBQ0Esd0NBQXdDLHVEQUF1RCxFQUFFO0FBQ2pHLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtB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QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFFBQVE7QUFDOUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7QUNoQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRDQUE0Qzs7QUFFNUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3BCQTs7Ozs7O0FBRUEsSUFBTUUsTUFBTTtBQUNWMUcsV0FEVSxxQkFDQUYsS0FEQSxFQUNPO0FBQ2YsV0FBTyxvQkFBSyxjQUFMLEVBQXFCO0FBQzFCeEssY0FBUSxNQURrQjtBQUUxQkksWUFBTW9LLEtBRm9CO0FBRzFCdkssZUFBUztBQUNQLHdCQUFnQjtBQURUO0FBSGlCLEtBQXJCLENBQVA7QUFPRDtBQVRTLENBQVo7O2tCQVllbVIsRyIsImZpbGUiOiJjYWQuYnVuZGxlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gaWRlbnRpdHkgZnVuY3Rpb24gZm9yIGNhbGxpbmcgaGFybW9ueSBpbXBvcnRzIHdpdGggdGhlIGNvcnJlY3QgY29udGV4dFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5pID0gZnVuY3Rpb24odmFsdWUpIHsgcmV0dXJuIHZhbHVlOyB9O1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbiBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbiBcdFx0XHR9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAyNCk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay9ib290c3RyYXAgNDFhZTliNTc5NzA4MDkzZTIxODMiLCJmdW5jdGlvbiBhamF4KHBhdGggPSAnJywgb3B0aW9ucyA9IHt9LCBmdWxsUmVzcG9uc2UgPSBmYWxzZSkge1xyXG4gIGNvbnN0IHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xyXG4gIHhoci5vcGVuKG9wdGlvbnMubWV0aG9kIHx8ICdHRVQnLCBwYXRoLCB0cnVlKTtcclxuICBpZiAob3B0aW9ucy5oZWFkZXJzKSB7IHNldFhIUkhlYWRlcnMoeGhyLCBvcHRpb25zLmhlYWRlcnMpOyB9XHJcbiAgeGhyLnNlbmQob3B0aW9ucy5kYXRhKTtcclxuXHJcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcclxuICAgICAgaWYgKHhoci5yZWFkeVN0YXRlID09IDQpIHtcclxuICAgICAgICBpZiAoeGhyLnN0YXR1cyA9PSAyMDApIHtcclxuICAgICAgICAgIGlmIChmdWxsUmVzcG9uc2UpIHtcclxuICAgICAgICAgICAgcmVzb2x2ZSh4aHIpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmVzb2x2ZSh4aHIucmVzcG9uc2VUZXh0KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgcmVqZWN0KHhoci5zdGF0dXNUZXh0KTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9KVxyXG59XHJcblxyXG5mdW5jdGlvbiBzZXRYSFJIZWFkZXJzKHhociwgaGVhZGVycykge1xyXG4gIGZvciAobGV0IGhlYWRlciBpbiBoZWFkZXJzKSB7XHJcbiAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihoZWFkZXIsIGhlYWRlcnNbaGVhZGVyXSk7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBhamF4O1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi91dGlscy9hamF4LmpzIiwiY29uc3QgcHVic3ViID0gKGZ1bmN0aW9uKCkge1xyXG5cclxuICBjb25zdCB0b3BpY3MgPSB7fTtcclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIHN1YnNjcmliZTogZnVuY3Rpb24odG9waWMsIGxpc3RlbmVyKSB7XHJcbiAgICAgIGlmICghdG9waWNzW3RvcGljXSkgdG9waWNzW3RvcGljXSA9IHsgcXVldWU6IFtdIH07XHJcblxyXG4gICAgICBjb25zdCBpbmRleCA9IHRvcGljc1t0b3BpY10ucXVldWUucHVzaChsaXN0ZW5lcikgLSAxO1xyXG4gICAgICAvLyBmdW5jdGlvbiB0byBkZWxldGUgdG9waWNcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgZGVsZXRlIHRvcGljc1t0b3BpY10ucXVldWVbaW5kZXhdO1xyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuICAgIH0sXHJcblxyXG4gICAgcHVibGlzaDogZnVuY3Rpb24odG9waWMsIGluZm8pIHtcclxuICAgICAgLy8gbm8gdGhlbWUgb3Igbm8gbGlzdGVuZXJzXHJcbiAgICAgIGlmICghdG9waWNzW3RvcGljXSB8fCAhdG9waWNzW3RvcGljXS5xdWV1ZS5sZW5ndGgpIHJldHVybjtcclxuXHJcbiAgICAgIGNvbnN0IGl0ZW1zID0gdG9waWNzW3RvcGljXS5xdWV1ZTtcclxuICAgICAgaXRlbXMuZm9yRWFjaChpdGVtID0+IHtcclxuICAgICAgICBpdGVtKGluZm8gfHwge30pO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9O1xyXG59KSgpO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgcHVic3ViO1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi91dGlscy9wdWJzdWIuanMiLCJjb25zdCBub2RlRmFjdG9yeSA9IGZ1bmN0aW9uKHR5cGUgPSAnZGl2JywgcGFyYW1zID0ge30pIHtcclxuICBjb25zdCBub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0eXBlKTtcclxuXHJcbiAgYXBwZW5kQ2xhc3Nlcyhub2RlLCBwYXJhbXMpO1xyXG4gIGFwcGVuZEF0dHJzKG5vZGUsIHBhcmFtcyk7XHJcbiAgaW5zZXJ0VGV4dENvbnRlbnQobm9kZSwgcGFyYW1zKTtcclxuXHJcbiAgcmV0dXJuIG5vZGU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFwcGVuZENsYXNzZXMobm9kZSwgeyBjbGFzc0xpc3QgfSkge1xyXG4gIGlmIChjbGFzc0xpc3QgJiYgY2xhc3NMaXN0LmZvckVhY2gpIHtcclxuICAgIGNsYXNzTGlzdC5mb3JFYWNoKGNsYXNzTmFtZSA9PiBub2RlLmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKSk7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBhcHBlbmRBdHRycyhub2RlLCB7IGF0dHJzIH0pIHtcclxuICBpZiAoYXR0cnMpIHtcclxuICAgIGNvbnN0IGF0dHJOYW1lcyA9IE9iamVjdC5rZXlzKGF0dHJzKTtcclxuICAgIGF0dHJOYW1lcy5mb3JFYWNoKGF0dHJOYW1lID0+IG5vZGUuc2V0QXR0cmlidXRlKGF0dHJOYW1lLCBhdHRyc1thdHRyTmFtZV0pKTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGluc2VydFRleHRDb250ZW50KG5vZGUsIHsgdGV4dENvbnRlbnQgPSBcIlwiIH0pIHtcclxuICBub2RlLnRleHRDb250ZW50ID0gdGV4dENvbnRlbnQ7XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IG5vZGVGYWN0b3J5O1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi91dGlscy9ub2RlRmFjdG9yeS5qcyIsImV4cG9ydCBjb25zdCBERUZBVUxUX1NUQVRFX05BTUUgPSAn0KHQvtGB0YLQvtGP0L3QuNC1JztcbmV4cG9ydCBjb25zdCBERUZBVUxUX1RPT0xfTkFNRSA9ICfQn9GA0LjQsdC+0YAnO1xuXG5leHBvcnQgY29uc3QgVE9PTF9UWVBFUyA9IFsgJ3N3aXRjaCcsICdyYW5nZScgXTtcbmV4cG9ydCBjb25zdCBERUZBVUxUX1RPT0xfVFlQRSA9IFRPT0xfVFlQRVNbMF07XG5cbmV4cG9ydCBjb25zdCBERUZBVUxUX0lNQUdFX0lEID0gJzU5YTZiZmQ0OWJkZjZjMjlkMGNlODJkMCc7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9jYWQvY29uZmlnLmpzIiwiaW1wb3J0IHV1aWQgZnJvbSAndXVpZC92NCc7XG5pbXBvcnQgcHVic3ViIGZyb20gJy4uLy4uL3V0aWxzL3B1YnN1Yic7XG5cbmV4cG9ydCBmdW5jdGlvbiBoYW5kbGVIZWFkZXJDbGljaygkaGVhZGVyLCAkbGlzdCkge1xuICBjb25zdCBjbG9zZWQgPSAkbGlzdC5jbGFzc0xpc3QudG9nZ2xlKCdpcy1oaWRkZW4nKTtcbiAgY29uc3QgJGljb24gPSAkaGVhZGVyLnF1ZXJ5U2VsZWN0b3IoJy5pY29uJyk7XG4gICRpY29uLnN0eWxlLnRyYW5zZm9ybSA9IGByb3RhdGUoJHtjbG9zZWQgPyAwIDogOTB9ZGVnKWA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoYW5kbGVBZGRCdG5DbGljaygkaGVhZGVyLCAkbGlzdCwgZmFjdG9yeSwgZXZlbnROYW1lKSB7XG4gICRsaXN0LmNsYXNzTGlzdC5yZW1vdmUoJ2lzLWhpZGRlbicpO1xuICAkaGVhZGVyLnF1ZXJ5U2VsZWN0b3IoJy5pY29uJykuc3R5bGUudHJhbnNmb3JtID0gJ3JvdGF0ZSg5MGRlZyknO1xuICBjb25zdCBpZCA9IHV1aWQoKTtcbiAgY29uc3QgJG5vZGUgPSBmYWN0b3J5KGlkKTtcbiAgJGxpc3QuYXBwZW5kQ2hpbGQoJG5vZGUpO1xuICBwdWJzdWIucHVibGlzaChldmVudE5hbWUsIGlkKTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NhZC9zY2VuZS91dGlscy5qcyIsInZhciBybmcgPSByZXF1aXJlKCcuL2xpYi9ybmcnKTtcbnZhciBieXRlc1RvVXVpZCA9IHJlcXVpcmUoJy4vbGliL2J5dGVzVG9VdWlkJyk7XG5cbmZ1bmN0aW9uIHY0KG9wdGlvbnMsIGJ1Ziwgb2Zmc2V0KSB7XG4gIHZhciBpID0gYnVmICYmIG9mZnNldCB8fCAwO1xuXG4gIGlmICh0eXBlb2Yob3B0aW9ucykgPT0gJ3N0cmluZycpIHtcbiAgICBidWYgPSBvcHRpb25zID09ICdiaW5hcnknID8gbmV3IEFycmF5KDE2KSA6IG51bGw7XG4gICAgb3B0aW9ucyA9IG51bGw7XG4gIH1cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgdmFyIHJuZHMgPSBvcHRpb25zLnJhbmRvbSB8fCAob3B0aW9ucy5ybmcgfHwgcm5nKSgpO1xuXG4gIC8vIFBlciA0LjQsIHNldCBiaXRzIGZvciB2ZXJzaW9uIGFuZCBgY2xvY2tfc2VxX2hpX2FuZF9yZXNlcnZlZGBcbiAgcm5kc1s2XSA9IChybmRzWzZdICYgMHgwZikgfCAweDQwO1xuICBybmRzWzhdID0gKHJuZHNbOF0gJiAweDNmKSB8IDB4ODA7XG5cbiAgLy8gQ29weSBieXRlcyB0byBidWZmZXIsIGlmIHByb3ZpZGVkXG4gIGlmIChidWYpIHtcbiAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgMTY7ICsraWkpIHtcbiAgICAgIGJ1ZltpICsgaWldID0gcm5kc1tpaV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ1ZiB8fCBieXRlc1RvVXVpZChybmRzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB2NDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIFo6L3dlYi9wcm9qZWN0cy9scGsvfi91dWlkL3Y0LmpzXG4vLyBtb2R1bGUgaWQgPSA1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICoganNCZXppZXJcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTAgLSAyMDE3IGpzUGx1bWIgKGhlbGxvQGpzcGx1bWJ0b29sa2l0LmNvbSlcbiAqXG4gKiBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gKlxuICogYSBzZXQgb2YgQmV6aWVyIGN1cnZlIGZ1bmN0aW9ucyB0aGF0IGRlYWwgd2l0aCBCZXppZXJzLCB1c2VkIGJ5IGpzUGx1bWIsIGFuZCBwZXJoYXBzIHVzZWZ1bCBmb3Igb3RoZXIgcGVvcGxlLiAgVGhlc2UgZnVuY3Rpb25zIHdvcmsgd2l0aCBCZXppZXJcbiAqIGN1cnZlcyBvZiBhcmJpdHJhcnkgZGVncmVlLlxuICpcbiAqIC0gZnVuY3Rpb25zIGFyZSBhbGwgaW4gdGhlICdqc0JlemllcicgbmFtZXNwYWNlLlxuICpcbiAqIC0gYWxsIGlucHV0IHBvaW50cyBzaG91bGQgYmUgaW4gdGhlIGZvcm1hdCB7eDouLiwgeTouLn0uIGFsbCBvdXRwdXQgcG9pbnRzIGFyZSBpbiB0aGlzIGZvcm1hdCB0b28uXG4gKlxuICogLSBhbGwgaW5wdXQgY3VydmVzIHNob3VsZCBiZSBpbiB0aGUgZm9ybWF0IFsge3g6Li4sIHk6Li59LCB7eDouLiwgeTouLn0sIHt4Oi4uLCB5Oi4ufSwge3g6Li4sIHk6Li59IF1cbiAqXG4gKiAtICdsb2NhdGlvbicgYXMgdXNlZCBhcyBhbiBpbnB1dCBoZXJlIHJlZmVycyB0byBhIGRlY2ltYWwgaW4gdGhlIHJhbmdlIDAtMSBpbmNsdXNpdmUsIHdoaWNoIGluZGljYXRlcyBhIHBvaW50IHNvbWUgcHJvcG9ydGlvbiBhbG9uZyB0aGUgbGVuZ3RoXG4gKiBvZiB0aGUgY3VydmUuICBsb2NhdGlvbiBhcyBvdXRwdXQgaGFzIHRoZSBzYW1lIGZvcm1hdCBhbmQgbWVhbmluZy5cbiAqXG4gKlxuICogRnVuY3Rpb24gTGlzdDpcbiAqIC0tLS0tLS0tLS0tLS0tXG4gKlxuICogZGlzdGFuY2VGcm9tQ3VydmUocG9pbnQsIGN1cnZlKVxuICpcbiAqIFx0Q2FsY3VsYXRlcyB0aGUgZGlzdGFuY2UgdGhhdCB0aGUgZ2l2ZW4gcG9pbnQgbGllcyBmcm9tIHRoZSBnaXZlbiBCZXppZXIuICBOb3RlIHRoYXQgaXQgaXMgY29tcHV0ZWQgcmVsYXRpdmUgdG8gdGhlIGNlbnRlciBvZiB0aGUgQmV6aWVyLFxuICogc28gaWYgeW91IGhhdmUgc3Ryb2tlZCB0aGUgY3VydmUgd2l0aCBhIHdpZGUgcGVuIHlvdSBtYXkgd2lzaCB0byB0YWtlIHRoYXQgaW50byBhY2NvdW50ISAgVGhlIGRpc3RhbmNlIHJldHVybmVkIGlzIHJlbGF0aXZlIHRvIHRoZSB2YWx1ZXNcbiAqIG9mIHRoZSBjdXJ2ZSBhbmQgdGhlIHBvaW50IC0gaXQgd2lsbCBtb3N0IGxpa2VseSBiZSBwaXhlbHMuXG4gKlxuICogZ3JhZGllbnRBdFBvaW50KGN1cnZlLCBsb2NhdGlvbilcbiAqXG4gKiBcdENhbGN1bGF0ZXMgdGhlIGdyYWRpZW50IHRvIHRoZSBjdXJ2ZSBhdCB0aGUgZ2l2ZW4gbG9jYXRpb24sIGFzIGEgZGVjaW1hbCBiZXR3ZWVuIDAgYW5kIDEgaW5jbHVzaXZlLlxuICpcbiAqIGdyYWRpZW50QXRQb2ludEFsb25nQ3VydmVGcm9tIChjdXJ2ZSwgbG9jYXRpb24pXG4gKlxuICpcdENhbGN1bGF0ZXMgdGhlIGdyYWRpZW50IGF0IHRoZSBwb2ludCBvbiB0aGUgZ2l2ZW4gY3VydmUgdGhhdCBpcyAnZGlzdGFuY2UnIHVuaXRzIGZyb20gbG9jYXRpb24uXG4gKlxuICogbmVhcmVzdFBvaW50T25DdXJ2ZShwb2ludCwgY3VydmUpXG4gKlxuICpcdENhbGN1bGF0ZXMgdGhlIG5lYXJlc3QgcG9pbnQgdG8gdGhlIGdpdmVuIHBvaW50IG9uIHRoZSBnaXZlbiBjdXJ2ZS4gIFRoZSByZXR1cm4gdmFsdWUgb2YgdGhpcyBpcyBhIEpTIG9iamVjdCBsaXRlcmFsLCBjb250YWluaW5nIGJvdGggdGhlXG4gKnBvaW50J3MgY29vcmRpbmF0ZXMgYW5kIGFsc28gdGhlICdsb2NhdGlvbicgb2YgdGhlIHBvaW50IChzZWUgYWJvdmUpLCBmb3IgZXhhbXBsZTogIHsgcG9pbnQ6e3g6NTUxLHk6MTUwfSwgbG9jYXRpb246MC4yNjMzNjUgfS5cbiAqXG4gKiBwb2ludE9uQ3VydmUoY3VydmUsIGxvY2F0aW9uKVxuICpcbiAqIFx0Q2FsY3VsYXRlcyB0aGUgY29vcmRpbmF0ZXMgb2YgdGhlIHBvaW50IG9uIHRoZSBnaXZlbiBCZXppZXIgY3VydmUgYXQgdGhlIGdpdmVuIGxvY2F0aW9uLlxuICpcbiAqIHBvaW50QWxvbmdDdXJ2ZUZyb20oY3VydmUsIGxvY2F0aW9uLCBkaXN0YW5jZSlcbiAqXG4gKiBcdENhbGN1bGF0ZXMgdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBwb2ludCBvbiB0aGUgZ2l2ZW4gY3VydmUgdGhhdCBpcyAnZGlzdGFuY2UnIHVuaXRzIGZyb20gbG9jYXRpb24uICAnZGlzdGFuY2UnIHNob3VsZCBiZSBpbiB0aGUgc2FtZSBjb29yZGluYXRlXG4gKiBzcGFjZSBhcyB0aGF0IHVzZWQgdG8gY29uc3RydWN0IHRoZSBCZXppZXIgY3VydmUuICBGb3IgYW4gSFRNTCBDYW52YXMgdXNhZ2UsIGZvciBleGFtcGxlLCBkaXN0YW5jZSB3b3VsZCBiZSBhIG1lYXN1cmUgb2YgcGl4ZWxzLlxuICpcbiAqIGxvY2F0aW9uQWxvbmdDdXJ2ZUZyb20oY3VydmUsIGxvY2F0aW9uLCBkaXN0YW5jZSlcbiAqXG4gKiBcdENhbGN1bGF0ZXMgdGhlIGxvY2F0aW9uIG9uIHRoZSBnaXZlbiBjdXJ2ZSB0aGF0IGlzICdkaXN0YW5jZScgdW5pdHMgZnJvbSBsb2NhdGlvbi4gICdkaXN0YW5jZScgc2hvdWxkIGJlIGluIHRoZSBzYW1lIGNvb3JkaW5hdGVcbiAqIHNwYWNlIGFzIHRoYXQgdXNlZCB0byBjb25zdHJ1Y3QgdGhlIEJlemllciBjdXJ2ZS4gIEZvciBhbiBIVE1MIENhbnZhcyB1c2FnZSwgZm9yIGV4YW1wbGUsIGRpc3RhbmNlIHdvdWxkIGJlIGEgbWVhc3VyZSBvZiBwaXhlbHMuXG4gKlxuICogcGVycGVuZGljdWxhclRvQ3VydmVBdChjdXJ2ZSwgbG9jYXRpb24sIGxlbmd0aCwgZGlzdGFuY2UpXG4gKlxuICogXHRDYWxjdWxhdGVzIHRoZSBwZXJwZW5kaWN1bGFyIHRvIHRoZSBnaXZlbiBjdXJ2ZSBhdCB0aGUgZ2l2ZW4gbG9jYXRpb24uICBsZW5ndGggaXMgdGhlIGxlbmd0aCBvZiB0aGUgbGluZSB5b3Ugd2lzaCBmb3IgKGl0IHdpbGwgYmUgY2VudGVyZWRcbiAqIG9uIHRoZSBwb2ludCBhdCAnbG9jYXRpb24nKS4gZGlzdGFuY2UgaXMgb3B0aW9uYWwsIGFuZCBhbGxvd3MgeW91IHRvIHNwZWNpZnkgYSBwb2ludCBhbG9uZyB0aGUgcGF0aCBmcm9tIHRoZSBnaXZlbiBsb2NhdGlvbiBhcyB0aGUgY2VudGVyIG9mXG4gKiB0aGUgcGVycGVuZGljdWxhciByZXR1cm5lZC4gIFRoZSByZXR1cm4gdmFsdWUgb2YgdGhpcyBpcyBhbiBhcnJheSBvZiB0d28gcG9pbnRzOiBbIHt4Oi4uLix5Oi4uLn0sIHt4Oi4uLix5Oi4uLn0gXS5cbiAqXG4gKlxuICovXG5cbihmdW5jdGlvbigpIHtcblxuICAgIHZhciByb290ID0gdGhpcztcblxuICAgIGlmKHR5cGVvZiBNYXRoLnNnbiA9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIE1hdGguc2duID0gZnVuY3Rpb24oeCkgeyByZXR1cm4geCA9PSAwID8gMCA6IHggPiAwID8gMSA6LTE7IH07XG4gICAgfVxuXG4gICAgdmFyIFZlY3RvcnMgPSB7XG4gICAgICAgICAgICBzdWJ0cmFjdCBcdDogXHRmdW5jdGlvbih2MSwgdjIpIHsgcmV0dXJuIHt4OnYxLnggLSB2Mi54LCB5OnYxLnkgLSB2Mi55IH07IH0sXG4gICAgICAgICAgICBkb3RQcm9kdWN0XHQ6IFx0ZnVuY3Rpb24odjEsIHYyKSB7IHJldHVybiAodjEueCAqIHYyLngpICArICh2MS55ICogdjIueSk7IH0sXG4gICAgICAgICAgICBzcXVhcmVcdFx0Olx0ZnVuY3Rpb24odikgeyByZXR1cm4gTWF0aC5zcXJ0KCh2LnggKiB2LngpICsgKHYueSAqIHYueSkpOyB9LFxuICAgICAgICAgICAgc2NhbGVcdFx0Olx0ZnVuY3Rpb24odiwgcykgeyByZXR1cm4ge3g6di54ICogcywgeTp2LnkgKiBzIH07IH1cbiAgICAgICAgfSxcblxuICAgICAgICBtYXhSZWN1cnNpb24gPSA2NCxcbiAgICAgICAgZmxhdG5lc3NUb2xlcmFuY2UgPSBNYXRoLnBvdygyLjAsLW1heFJlY3Vyc2lvbi0xKTtcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgdGhlIGRpc3RhbmNlIHRoYXQgdGhlIHBvaW50IGxpZXMgZnJvbSB0aGUgY3VydmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcG9pbnQgYSBwb2ludCBpbiB0aGUgZm9ybSB7eDo1NjcsIHk6MzM0Mn1cbiAgICAgKiBAcGFyYW0gY3VydmUgYSBCZXppZXIgY3VydmUgaW4gdGhlIGZvcm0gW3t4Oi4uLiwgeTouLi59LCB7eDouLi4sIHk6Li4ufSwge3g6Li4uLCB5Oi4uLn0sIHt4Oi4uLiwgeTouLi59XS4gIG5vdGUgdGhhdCB0aGlzIGlzIGN1cnJlbnRseVxuICAgICAqIGhhcmRjb2RlZCB0byBhc3N1bWUgY3ViaXogYmV6aWVycywgYnV0IHdvdWxkIGJlIGJldHRlciBvZmYgc3VwcG9ydGluZyBhbnkgZGVncmVlLlxuICAgICAqIEByZXR1cm4gYSBKUyBvYmplY3QgbGl0ZXJhbCBjb250YWluaW5nIGxvY2F0aW9uIGFuZCBkaXN0YW5jZSwgZm9yIGV4YW1wbGU6IHtsb2NhdGlvbjowLjM1LCBkaXN0YW5jZToxMH0uICBMb2NhdGlvbiBpcyBhbmFsb2dvdXMgdG8gdGhlIGxvY2F0aW9uXG4gICAgICogYXJndW1lbnQgeW91IHBhc3MgdG8gdGhlIHBvaW50T25QYXRoIGZ1bmN0aW9uOiBpdCBpcyBhIHJhdGlvIG9mIGRpc3RhbmNlIHRyYXZlbGxlZCBhbG9uZyB0aGUgY3VydmUuICBEaXN0YW5jZSBpcyB0aGUgZGlzdGFuY2UgaW4gcGl4ZWxzIGZyb21cbiAgICAgKiB0aGUgcG9pbnQgdG8gdGhlIGN1cnZlLlxuICAgICAqL1xuICAgIHZhciBfZGlzdGFuY2VGcm9tQ3VydmUgPSBmdW5jdGlvbihwb2ludCwgY3VydmUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZXMgPSBbXSxcbiAgICAgICAgICAgIHcgPSBfY29udmVydFRvQmV6aWVyKHBvaW50LCBjdXJ2ZSksXG4gICAgICAgICAgICBkZWdyZWUgPSBjdXJ2ZS5sZW5ndGggLSAxLCBoaWdoZXJEZWdyZWUgPSAoMiAqIGRlZ3JlZSkgLSAxLFxuICAgICAgICAgICAgbnVtU29sdXRpb25zID0gX2ZpbmRSb290cyh3LCBoaWdoZXJEZWdyZWUsIGNhbmRpZGF0ZXMsIDApLFxuICAgICAgICAgICAgdiA9IFZlY3RvcnMuc3VidHJhY3QocG9pbnQsIGN1cnZlWzBdKSwgZGlzdCA9IFZlY3RvcnMuc3F1YXJlKHYpLCB0ID0gMC4wO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtU29sdXRpb25zOyBpKyspIHtcbiAgICAgICAgICAgIHYgPSBWZWN0b3JzLnN1YnRyYWN0KHBvaW50LCBfYmV6aWVyKGN1cnZlLCBkZWdyZWUsIGNhbmRpZGF0ZXNbaV0sIG51bGwsIG51bGwpKTtcbiAgICAgICAgICAgIHZhciBuZXdEaXN0ID0gVmVjdG9ycy5zcXVhcmUodik7XG4gICAgICAgICAgICBpZiAobmV3RGlzdCA8IGRpc3QpIHtcbiAgICAgICAgICAgICAgICBkaXN0ID0gbmV3RGlzdDtcbiAgICAgICAgICAgICAgICB0ID0gY2FuZGlkYXRlc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2ID0gVmVjdG9ycy5zdWJ0cmFjdChwb2ludCwgY3VydmVbZGVncmVlXSk7XG4gICAgICAgIG5ld0Rpc3QgPSBWZWN0b3JzLnNxdWFyZSh2KTtcbiAgICAgICAgaWYgKG5ld0Rpc3QgPCBkaXN0KSB7XG4gICAgICAgICAgICBkaXN0ID0gbmV3RGlzdDtcbiAgICAgICAgICAgIHQgPSAxLjA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtsb2NhdGlvbjp0LCBkaXN0YW5jZTpkaXN0fTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIGZpbmRzIHRoZSBuZWFyZXN0IHBvaW50IG9uIHRoZSBjdXJ2ZSB0byB0aGUgZ2l2ZW4gcG9pbnQuXG4gICAgICovXG4gICAgdmFyIF9uZWFyZXN0UG9pbnRPbkN1cnZlID0gZnVuY3Rpb24ocG9pbnQsIGN1cnZlKSB7XG4gICAgICAgIHZhciB0ZCA9IF9kaXN0YW5jZUZyb21DdXJ2ZShwb2ludCwgY3VydmUpO1xuICAgICAgICByZXR1cm4ge3BvaW50Ol9iZXppZXIoY3VydmUsIGN1cnZlLmxlbmd0aCAtIDEsIHRkLmxvY2F0aW9uLCBudWxsLCBudWxsKSwgbG9jYXRpb246dGQubG9jYXRpb259O1xuICAgIH07XG4gICAgdmFyIF9jb252ZXJ0VG9CZXppZXIgPSBmdW5jdGlvbihwb2ludCwgY3VydmUpIHtcbiAgICAgICAgdmFyIGRlZ3JlZSA9IGN1cnZlLmxlbmd0aCAtIDEsIGhpZ2hlckRlZ3JlZSA9ICgyICogZGVncmVlKSAtIDEsXG4gICAgICAgICAgICBjID0gW10sIGQgPSBbXSwgY2RUYWJsZSA9IFtdLCB3ID0gW10sXG4gICAgICAgICAgICB6ID0gWyBbMS4wLCAwLjYsIDAuMywgMC4xXSwgWzAuNCwgMC42LCAwLjYsIDAuNF0sIFswLjEsIDAuMywgMC42LCAxLjBdIF07XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gZGVncmVlOyBpKyspIGNbaV0gPSBWZWN0b3JzLnN1YnRyYWN0KGN1cnZlW2ldLCBwb2ludCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IGRlZ3JlZSAtIDE7IGkrKykge1xuICAgICAgICAgICAgZFtpXSA9IFZlY3RvcnMuc3VidHJhY3QoY3VydmVbaSsxXSwgY3VydmVbaV0pO1xuICAgICAgICAgICAgZFtpXSA9IFZlY3RvcnMuc2NhbGUoZFtpXSwgMy4wKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciByb3cgPSAwOyByb3cgPD0gZGVncmVlIC0gMTsgcm93KyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGNvbHVtbiA9IDA7IGNvbHVtbiA8PSBkZWdyZWU7IGNvbHVtbisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjZFRhYmxlW3Jvd10pIGNkVGFibGVbcm93XSA9IFtdO1xuICAgICAgICAgICAgICAgIGNkVGFibGVbcm93XVtjb2x1bW5dID0gVmVjdG9ycy5kb3RQcm9kdWN0KGRbcm93XSwgY1tjb2x1bW5dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDw9IGhpZ2hlckRlZ3JlZTsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIXdbaV0pIHdbaV0gPSBbXTtcbiAgICAgICAgICAgIHdbaV0ueSA9IDAuMDtcbiAgICAgICAgICAgIHdbaV0ueCA9IHBhcnNlRmxvYXQoaSkgLyBoaWdoZXJEZWdyZWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG4gPSBkZWdyZWUsIG0gPSBkZWdyZWUtMTtcbiAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPD0gbiArIG07IGsrKykge1xuICAgICAgICAgICAgdmFyIGxiID0gTWF0aC5tYXgoMCwgayAtIG0pLFxuICAgICAgICAgICAgICAgIHViID0gTWF0aC5taW4oaywgbik7XG4gICAgICAgICAgICBmb3IgKGkgPSBsYjsgaSA8PSB1YjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaiA9IGsgLSBpO1xuICAgICAgICAgICAgICAgIHdbaStqXS55ICs9IGNkVGFibGVbal1baV0gKiB6W2pdW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogY291bnRzIGhvdyBtYW55IHJvb3RzIHRoZXJlIGFyZS5cbiAgICAgKi9cbiAgICB2YXIgX2ZpbmRSb290cyA9IGZ1bmN0aW9uKHcsIGRlZ3JlZSwgdCwgZGVwdGgpIHtcbiAgICAgICAgdmFyIGxlZnQgPSBbXSwgcmlnaHQgPSBbXSxcbiAgICAgICAgICAgIGxlZnRfY291bnQsIHJpZ2h0X2NvdW50LFxuICAgICAgICAgICAgbGVmdF90ID0gW10sIHJpZ2h0X3QgPSBbXTtcblxuICAgICAgICBzd2l0Y2ggKF9nZXRDcm9zc2luZ0NvdW50KHcsIGRlZ3JlZSkpIHtcbiAgICAgICAgICAgIGNhc2UgMCA6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgMSA6IHtcbiAgICAgICAgICAgICAgICBpZiAoZGVwdGggPj0gbWF4UmVjdXJzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHRbMF0gPSAod1swXS54ICsgd1tkZWdyZWVdLngpIC8gMi4wO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKF9pc0ZsYXRFbm91Z2godywgZGVncmVlKSkge1xuICAgICAgICAgICAgICAgICAgICB0WzBdID0gX2NvbXB1dGVYSW50ZXJjZXB0KHcsIGRlZ3JlZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBfYmV6aWVyKHcsIGRlZ3JlZSwgMC41LCBsZWZ0LCByaWdodCk7XG4gICAgICAgIGxlZnRfY291bnQgID0gX2ZpbmRSb290cyhsZWZ0LCAgZGVncmVlLCBsZWZ0X3QsIGRlcHRoKzEpO1xuICAgICAgICByaWdodF9jb3VudCA9IF9maW5kUm9vdHMocmlnaHQsIGRlZ3JlZSwgcmlnaHRfdCwgZGVwdGgrMSk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVmdF9jb3VudDsgaSsrKSB0W2ldID0gbGVmdF90W2ldO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJpZ2h0X2NvdW50OyBpKyspIHRbaStsZWZ0X2NvdW50XSA9IHJpZ2h0X3RbaV07XG4gICAgICAgIHJldHVybiAobGVmdF9jb3VudCtyaWdodF9jb3VudCk7XG4gICAgfTtcbiAgICB2YXIgX2dldENyb3NzaW5nQ291bnQgPSBmdW5jdGlvbihjdXJ2ZSwgZGVncmVlKSB7XG4gICAgICAgIHZhciBuX2Nyb3NzaW5ncyA9IDAsIHNpZ24sIG9sZF9zaWduO1xuICAgICAgICBzaWduID0gb2xkX3NpZ24gPSBNYXRoLnNnbihjdXJ2ZVswXS55KTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPD0gZGVncmVlOyBpKyspIHtcbiAgICAgICAgICAgIHNpZ24gPSBNYXRoLnNnbihjdXJ2ZVtpXS55KTtcbiAgICAgICAgICAgIGlmIChzaWduICE9IG9sZF9zaWduKSBuX2Nyb3NzaW5ncysrO1xuICAgICAgICAgICAgb2xkX3NpZ24gPSBzaWduO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuX2Nyb3NzaW5ncztcbiAgICB9O1xuICAgIHZhciBfaXNGbGF0RW5vdWdoID0gZnVuY3Rpb24oY3VydmUsIGRlZ3JlZSkge1xuICAgICAgICB2YXIgIGVycm9yLFxuICAgICAgICAgICAgaW50ZXJjZXB0XzEsIGludGVyY2VwdF8yLCBsZWZ0X2ludGVyY2VwdCwgcmlnaHRfaW50ZXJjZXB0LFxuICAgICAgICAgICAgYSwgYiwgYywgZGV0LCBkSW52LCBhMSwgYjEsIGMxLCBhMiwgYjIsIGMyO1xuICAgICAgICBhID0gY3VydmVbMF0ueSAtIGN1cnZlW2RlZ3JlZV0ueTtcbiAgICAgICAgYiA9IGN1cnZlW2RlZ3JlZV0ueCAtIGN1cnZlWzBdLng7XG4gICAgICAgIGMgPSBjdXJ2ZVswXS54ICogY3VydmVbZGVncmVlXS55IC0gY3VydmVbZGVncmVlXS54ICogY3VydmVbMF0ueTtcblxuICAgICAgICB2YXIgbWF4X2Rpc3RhbmNlX2Fib3ZlID0gbWF4X2Rpc3RhbmNlX2JlbG93ID0gMC4wO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgZGVncmVlOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGEgKiBjdXJ2ZVtpXS54ICsgYiAqIGN1cnZlW2ldLnkgKyBjO1xuICAgICAgICAgICAgaWYgKHZhbHVlID4gbWF4X2Rpc3RhbmNlX2Fib3ZlKVxuICAgICAgICAgICAgICAgIG1heF9kaXN0YW5jZV9hYm92ZSA9IHZhbHVlO1xuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgPCBtYXhfZGlzdGFuY2VfYmVsb3cpXG4gICAgICAgICAgICAgICAgbWF4X2Rpc3RhbmNlX2JlbG93ID0gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICBhMSA9IDAuMDsgYjEgPSAxLjA7IGMxID0gMC4wOyBhMiA9IGE7IGIyID0gYjtcbiAgICAgICAgYzIgPSBjIC0gbWF4X2Rpc3RhbmNlX2Fib3ZlO1xuICAgICAgICBkZXQgPSBhMSAqIGIyIC0gYTIgKiBiMTtcbiAgICAgICAgZEludiA9IDEuMC9kZXQ7XG4gICAgICAgIGludGVyY2VwdF8xID0gKGIxICogYzIgLSBiMiAqIGMxKSAqIGRJbnY7XG4gICAgICAgIGEyID0gYTsgYjIgPSBiOyBjMiA9IGMgLSBtYXhfZGlzdGFuY2VfYmVsb3c7XG4gICAgICAgIGRldCA9IGExICogYjIgLSBhMiAqIGIxO1xuICAgICAgICBkSW52ID0gMS4wL2RldDtcbiAgICAgICAgaW50ZXJjZXB0XzIgPSAoYjEgKiBjMiAtIGIyICogYzEpICogZEludjtcbiAgICAgICAgbGVmdF9pbnRlcmNlcHQgPSBNYXRoLm1pbihpbnRlcmNlcHRfMSwgaW50ZXJjZXB0XzIpO1xuICAgICAgICByaWdodF9pbnRlcmNlcHQgPSBNYXRoLm1heChpbnRlcmNlcHRfMSwgaW50ZXJjZXB0XzIpO1xuICAgICAgICBlcnJvciA9IHJpZ2h0X2ludGVyY2VwdCAtIGxlZnRfaW50ZXJjZXB0O1xuICAgICAgICByZXR1cm4gKGVycm9yIDwgZmxhdG5lc3NUb2xlcmFuY2UpPyAxIDogMDtcbiAgICB9O1xuICAgIHZhciBfY29tcHV0ZVhJbnRlcmNlcHQgPSBmdW5jdGlvbihjdXJ2ZSwgZGVncmVlKSB7XG4gICAgICAgIHZhciBYTEsgPSAxLjAsIFlMSyA9IDAuMCxcbiAgICAgICAgICAgIFhOTSA9IGN1cnZlW2RlZ3JlZV0ueCAtIGN1cnZlWzBdLngsIFlOTSA9IGN1cnZlW2RlZ3JlZV0ueSAtIGN1cnZlWzBdLnksXG4gICAgICAgICAgICBYTUsgPSBjdXJ2ZVswXS54IC0gMC4wLCBZTUsgPSBjdXJ2ZVswXS55IC0gMC4wLFxuICAgICAgICAgICAgZGV0ID0gWE5NKllMSyAtIFlOTSpYTEssIGRldEludiA9IDEuMC9kZXQsXG4gICAgICAgICAgICBTID0gKFhOTSpZTUsgLSBZTk0qWE1LKSAqIGRldEludjtcbiAgICAgICAgcmV0dXJuIDAuMCArIFhMSyAqIFM7XG4gICAgfTtcbiAgICB2YXIgX2JlemllciA9IGZ1bmN0aW9uKGN1cnZlLCBkZWdyZWUsIHQsIGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIHZhciB0ZW1wID0gW1tdXTtcbiAgICAgICAgZm9yICh2YXIgaiA9MDsgaiA8PSBkZWdyZWU7IGorKykgdGVtcFswXVtqXSA9IGN1cnZlW2pdO1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8PSBkZWdyZWU7IGkrKykge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9MCA7IGogPD0gZGVncmVlIC0gaTsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0ZW1wW2ldKSB0ZW1wW2ldID0gW107XG4gICAgICAgICAgICAgICAgaWYgKCF0ZW1wW2ldW2pdKSB0ZW1wW2ldW2pdID0ge307XG4gICAgICAgICAgICAgICAgdGVtcFtpXVtqXS54ID0gKDEuMCAtIHQpICogdGVtcFtpLTFdW2pdLnggKyB0ICogdGVtcFtpLTFdW2orMV0ueDtcbiAgICAgICAgICAgICAgICB0ZW1wW2ldW2pdLnkgPSAoMS4wIC0gdCkgKiB0ZW1wW2ktMV1bal0ueSArIHQgKiB0ZW1wW2ktMV1baisxXS55O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChsZWZ0ICE9IG51bGwpXG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDw9IGRlZ3JlZTsgaisrKSBsZWZ0W2pdICA9IHRlbXBbal1bMF07XG4gICAgICAgIGlmIChyaWdodCAhPSBudWxsKVxuICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8PSBkZWdyZWU7IGorKykgcmlnaHRbal0gPSB0ZW1wW2RlZ3JlZS1qXVtqXTtcblxuICAgICAgICByZXR1cm4gKHRlbXBbZGVncmVlXVswXSk7XG4gICAgfTtcblxuICAgIHZhciBfY3VydmVGdW5jdGlvbkNhY2hlID0ge307XG4gICAgdmFyIF9nZXRDdXJ2ZUZ1bmN0aW9ucyA9IGZ1bmN0aW9uKG9yZGVyKSB7XG4gICAgICAgIHZhciBmbnMgPSBfY3VydmVGdW5jdGlvbkNhY2hlW29yZGVyXTtcbiAgICAgICAgaWYgKCFmbnMpIHtcbiAgICAgICAgICAgIGZucyA9IFtdO1xuICAgICAgICAgICAgdmFyIGZfdGVybSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gZnVuY3Rpb24odCkgeyByZXR1cm4gTWF0aC5wb3codCwgb3JkZXIpOyB9OyB9LFxuICAgICAgICAgICAgICAgIGxfdGVybSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gZnVuY3Rpb24odCkgeyByZXR1cm4gTWF0aC5wb3coKDEtdCksIG9yZGVyKTsgfTsgfSxcbiAgICAgICAgICAgICAgICBjX3Rlcm0gPSBmdW5jdGlvbihjKSB7IHJldHVybiBmdW5jdGlvbih0KSB7IHJldHVybiBjOyB9OyB9LFxuICAgICAgICAgICAgICAgIHRfdGVybSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gZnVuY3Rpb24odCkgeyByZXR1cm4gdDsgfTsgfSxcbiAgICAgICAgICAgICAgICBvbmVfbWludXNfdF90ZXJtID0gZnVuY3Rpb24oKSB7IHJldHVybiBmdW5jdGlvbih0KSB7IHJldHVybiAxLXQ7IH07IH0sXG4gICAgICAgICAgICAgICAgX3Rlcm1GdW5jID0gZnVuY3Rpb24odGVybXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGVybXMubGVuZ3RoOyBpKyspIHAgPSBwICogdGVybXNbaV0odCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBmbnMucHVzaChuZXcgZl90ZXJtKCkpOyAgLy8gZmlyc3QgaXMgdCB0byB0aGUgcG93ZXIgb2YgdGhlIGN1cnZlIG9yZGVyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IG9yZGVyOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgdGVybXMgPSBbbmV3IGNfdGVybShvcmRlcildO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwIDsgaiA8IChvcmRlciAtIGkpOyBqKyspIHRlcm1zLnB1c2gobmV3IHRfdGVybSgpKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMCA7IGogPCBpOyBqKyspIHRlcm1zLnB1c2gobmV3IG9uZV9taW51c190X3Rlcm0oKSk7XG4gICAgICAgICAgICAgICAgZm5zLnB1c2gobmV3IF90ZXJtRnVuYyh0ZXJtcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm5zLnB1c2gobmV3IGxfdGVybSgpKTsgIC8vIGxhc3QgaXMgKDEtdCkgdG8gdGhlIHBvd2VyIG9mIHRoZSBjdXJ2ZSBvcmRlclxuXG4gICAgICAgICAgICBfY3VydmVGdW5jdGlvbkNhY2hlW29yZGVyXSA9IGZucztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmbnM7XG4gICAgfTtcblxuXG4gICAgLyoqXG4gICAgICogY2FsY3VsYXRlcyBhIHBvaW50IG9uIHRoZSBjdXJ2ZSwgZm9yIGEgQmV6aWVyIG9mIGFyYml0cmFyeSBvcmRlci5cbiAgICAgKiBAcGFyYW0gY3VydmUgYW4gYXJyYXkgb2YgY29udHJvbCBwb2ludHMsIGVnIFt7eDoxMCx5OjIwfSwge3g6NTAseTo1MH0sIHt4OjEwMCx5OjEwMH0sIHt4OjEyMCx5OjEwMH1dLiAgRm9yIGEgY3ViaWMgYmV6aWVyIHRoaXMgc2hvdWxkIGhhdmUgZm91ciBwb2ludHMuXG4gICAgICogQHBhcmFtIGxvY2F0aW9uIGEgZGVjaW1hbCBpbmRpY2F0aW5nIHRoZSBkaXN0YW5jZSBhbG9uZyB0aGUgY3VydmUgdGhlIHBvaW50IHNob3VsZCBiZSBsb2NhdGVkIGF0LiAgdGhpcyBpcyB0aGUgZGlzdGFuY2UgYWxvbmcgdGhlIGN1cnZlIGFzIGl0IHRyYXZlbHMsIHRha2luZyB0aGUgd2F5IGl0IGJlbmRzIGludG8gYWNjb3VudC4gIHNob3VsZCBiZSBhIG51bWJlciBmcm9tIDAgdG8gMSwgaW5jbHVzaXZlLlxuICAgICAqL1xuICAgIHZhciBfcG9pbnRPblBhdGggPSBmdW5jdGlvbihjdXJ2ZSwgbG9jYXRpb24pIHtcbiAgICAgICAgdmFyIGNjID0gX2dldEN1cnZlRnVuY3Rpb25zKGN1cnZlLmxlbmd0aCAtIDEpLFxuICAgICAgICAgICAgX3ggPSAwLCBfeSA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY3VydmUubGVuZ3RoIDsgaSsrKSB7XG4gICAgICAgICAgICBfeCA9IF94ICsgKGN1cnZlW2ldLnggKiBjY1tpXShsb2NhdGlvbikpO1xuICAgICAgICAgICAgX3kgPSBfeSArIChjdXJ2ZVtpXS55ICogY2NbaV0obG9jYXRpb24pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7eDpfeCwgeTpfeX07XG4gICAgfTtcblxuICAgIHZhciBfZGlzdCA9IGZ1bmN0aW9uKHAxLHAyKSB7XG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3cocDEueCAtIHAyLngsIDIpICsgTWF0aC5wb3cocDEueSAtIHAyLnksIDIpKTtcbiAgICB9O1xuXG4gICAgdmFyIF9pc1BvaW50ID0gZnVuY3Rpb24oY3VydmUpIHtcbiAgICAgICAgcmV0dXJuIGN1cnZlWzBdLnggPT0gY3VydmVbMV0ueCAmJiBjdXJ2ZVswXS55ID09IGN1cnZlWzFdLnk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGZpbmRzIHRoZSBwb2ludCB0aGF0IGlzICdkaXN0YW5jZScgYWxvbmcgdGhlIHBhdGggZnJvbSAnbG9jYXRpb24nLiAgdGhpcyBtZXRob2QgcmV0dXJucyBib3RoIHRoZSB4LHkgbG9jYXRpb24gb2YgdGhlIHBvaW50IGFuZCBhbHNvXG4gICAgICogaXRzICdsb2NhdGlvbicgKHByb3BvcnRpb24gb2YgdHJhdmVsIGFsb25nIHRoZSBwYXRoKTsgdGhlIG1ldGhvZCBiZWxvdyAtIF9wb2ludEFsb25nUGF0aEZyb20gLSBjYWxscyB0aGlzIG1ldGhvZCBhbmQganVzdCByZXR1cm5zIHRoZVxuICAgICAqIHBvaW50LlxuICAgICAqL1xuICAgIHZhciBfcG9pbnRBbG9uZ1BhdGggPSBmdW5jdGlvbihjdXJ2ZSwgbG9jYXRpb24sIGRpc3RhbmNlKSB7XG5cbiAgICAgICAgaWYgKF9pc1BvaW50KGN1cnZlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBwb2ludDpjdXJ2ZVswXSxcbiAgICAgICAgICAgICAgICBsb2NhdGlvbjpsb2NhdGlvblxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwcmV2ID0gX3BvaW50T25QYXRoKGN1cnZlLCBsb2NhdGlvbiksXG4gICAgICAgICAgICB0YWxseSA9IDAsXG4gICAgICAgICAgICBjdXJMb2MgPSBsb2NhdGlvbixcbiAgICAgICAgICAgIGRpcmVjdGlvbiA9IGRpc3RhbmNlID4gMCA/IDEgOiAtMSxcbiAgICAgICAgICAgIGN1ciA9IG51bGw7XG5cbiAgICAgICAgd2hpbGUgKHRhbGx5IDwgTWF0aC5hYnMoZGlzdGFuY2UpKSB7XG4gICAgICAgICAgICBjdXJMb2MgKz0gKDAuMDA1ICogZGlyZWN0aW9uKTtcbiAgICAgICAgICAgIGN1ciA9IF9wb2ludE9uUGF0aChjdXJ2ZSwgY3VyTG9jKTtcbiAgICAgICAgICAgIHRhbGx5ICs9IF9kaXN0KGN1ciwgcHJldik7XG4gICAgICAgICAgICBwcmV2ID0gY3VyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7cG9pbnQ6Y3VyLCBsb2NhdGlvbjpjdXJMb2N9O1xuICAgIH07XG5cbiAgICB2YXIgX2xlbmd0aCA9IGZ1bmN0aW9uKGN1cnZlKSB7XG4gICAgICAgIGlmIChfaXNQb2ludChjdXJ2ZSkpIHJldHVybiAwO1xuXG4gICAgICAgIHZhciBwcmV2ID0gX3BvaW50T25QYXRoKGN1cnZlLCAwKSxcbiAgICAgICAgICAgIHRhbGx5ID0gMCxcbiAgICAgICAgICAgIGN1ckxvYyA9IDAsXG4gICAgICAgICAgICBkaXJlY3Rpb24gPSAxLFxuICAgICAgICAgICAgY3VyID0gbnVsbDtcblxuICAgICAgICB3aGlsZSAoY3VyTG9jIDwgMSkge1xuICAgICAgICAgICAgY3VyTG9jICs9ICgwLjAwNSAqIGRpcmVjdGlvbik7XG4gICAgICAgICAgICBjdXIgPSBfcG9pbnRPblBhdGgoY3VydmUsIGN1ckxvYyk7XG4gICAgICAgICAgICB0YWxseSArPSBfZGlzdChjdXIsIHByZXYpO1xuICAgICAgICAgICAgcHJldiA9IGN1cjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFsbHk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGZpbmRzIHRoZSBwb2ludCB0aGF0IGlzICdkaXN0YW5jZScgYWxvbmcgdGhlIHBhdGggZnJvbSAnbG9jYXRpb24nLlxuICAgICAqL1xuICAgIHZhciBfcG9pbnRBbG9uZ1BhdGhGcm9tID0gZnVuY3Rpb24oY3VydmUsIGxvY2F0aW9uLCBkaXN0YW5jZSkge1xuICAgICAgICByZXR1cm4gX3BvaW50QWxvbmdQYXRoKGN1cnZlLCBsb2NhdGlvbiwgZGlzdGFuY2UpLnBvaW50O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBmaW5kcyB0aGUgbG9jYXRpb24gdGhhdCBpcyAnZGlzdGFuY2UnIGFsb25nIHRoZSBwYXRoIGZyb20gJ2xvY2F0aW9uJy5cbiAgICAgKi9cbiAgICB2YXIgX2xvY2F0aW9uQWxvbmdQYXRoRnJvbSA9IGZ1bmN0aW9uKGN1cnZlLCBsb2NhdGlvbiwgZGlzdGFuY2UpIHtcbiAgICAgICAgcmV0dXJuIF9wb2ludEFsb25nUGF0aChjdXJ2ZSwgbG9jYXRpb24sIGRpc3RhbmNlKS5sb2NhdGlvbjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogcmV0dXJucyB0aGUgZ3JhZGllbnQgb2YgdGhlIGN1cnZlIGF0IHRoZSBnaXZlbiBsb2NhdGlvbiwgd2hpY2ggaXMgYSBkZWNpbWFsIGJldHdlZW4gMCBhbmQgMSBpbmNsdXNpdmUuXG4gICAgICpcbiAgICAgKiB0aGFua3MgLy8gaHR0cDovL2JpbWl4dWFsLm9yZy9BbmltYXRpb25MaWJyYXJ5L2JlemllcnRhbmdlbnRzLmh0bWxcbiAgICAgKi9cbiAgICB2YXIgX2dyYWRpZW50QXRQb2ludCA9IGZ1bmN0aW9uKGN1cnZlLCBsb2NhdGlvbikge1xuICAgICAgICB2YXIgcDEgPSBfcG9pbnRPblBhdGgoY3VydmUsIGxvY2F0aW9uKSxcbiAgICAgICAgICAgIHAyID0gX3BvaW50T25QYXRoKGN1cnZlLnNsaWNlKDAsIGN1cnZlLmxlbmd0aCAtIDEpLCBsb2NhdGlvbiksXG4gICAgICAgICAgICBkeSA9IHAyLnkgLSBwMS55LCBkeCA9IHAyLnggLSBwMS54O1xuICAgICAgICByZXR1cm4gZHkgPT0gMCA/IEluZmluaXR5IDogTWF0aC5hdGFuKGR5IC8gZHgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgcmV0dXJucyB0aGUgZ3JhZGllbnQgb2YgdGhlIGN1cnZlIGF0IHRoZSBwb2ludCB3aGljaCBpcyAnZGlzdGFuY2UnIGZyb20gdGhlIGdpdmVuIGxvY2F0aW9uLlxuICAgICBpZiB0aGlzIHBvaW50IGlzIGdyZWF0ZXIgdGhhbiBsb2NhdGlvbiAxLCB0aGUgZ3JhZGllbnQgYXQgbG9jYXRpb24gMSBpcyByZXR1cm5lZC5cbiAgICAgaWYgdGhpcyBwb2ludCBpcyBsZXNzIHRoYW4gbG9jYXRpb24gMCwgdGhlIGdyYWRpZW50IGF0IGxvY2F0aW9uIDAgaXMgcmV0dXJuZWQuXG4gICAgICovXG4gICAgdmFyIF9ncmFkaWVudEF0UG9pbnRBbG9uZ1BhdGhGcm9tID0gZnVuY3Rpb24oY3VydmUsIGxvY2F0aW9uLCBkaXN0YW5jZSkge1xuICAgICAgICB2YXIgcCA9IF9wb2ludEFsb25nUGF0aChjdXJ2ZSwgbG9jYXRpb24sIGRpc3RhbmNlKTtcbiAgICAgICAgaWYgKHAubG9jYXRpb24gPiAxKSBwLmxvY2F0aW9uID0gMTtcbiAgICAgICAgaWYgKHAubG9jYXRpb24gPCAwKSBwLmxvY2F0aW9uID0gMDtcbiAgICAgICAgcmV0dXJuIF9ncmFkaWVudEF0UG9pbnQoY3VydmUsIHAubG9jYXRpb24pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBjYWxjdWxhdGVzIGEgbGluZSB0aGF0IGlzICdsZW5ndGgnIHBpeGVscyBsb25nLCBwZXJwZW5kaWN1bGFyIHRvLCBhbmQgY2VudGVyZWQgb24sIHRoZSBwYXRoIGF0ICdkaXN0YW5jZScgcGl4ZWxzIGZyb20gdGhlIGdpdmVuIGxvY2F0aW9uLlxuICAgICAqIGlmIGRpc3RhbmNlIGlzIG5vdCBzdXBwbGllZCwgdGhlIHBlcnBlbmRpY3VsYXIgZm9yIHRoZSBnaXZlbiBsb2NhdGlvbiBpcyBjb21wdXRlZCAoaWUuIHdlIHNldCBkaXN0YW5jZSB0byB6ZXJvKS5cbiAgICAgKi9cbiAgICB2YXIgX3BlcnBlbmRpY3VsYXJUb1BhdGhBdCA9IGZ1bmN0aW9uKGN1cnZlLCBsb2NhdGlvbiwgbGVuZ3RoLCBkaXN0YW5jZSkge1xuICAgICAgICBkaXN0YW5jZSA9IGRpc3RhbmNlID09IG51bGwgPyAwIDogZGlzdGFuY2U7XG4gICAgICAgIHZhciBwID0gX3BvaW50QWxvbmdQYXRoKGN1cnZlLCBsb2NhdGlvbiwgZGlzdGFuY2UpLFxuICAgICAgICAgICAgbSA9IF9ncmFkaWVudEF0UG9pbnQoY3VydmUsIHAubG9jYXRpb24pLFxuICAgICAgICAgICAgX3RoZXRhMiA9IE1hdGguYXRhbigtMSAvIG0pLFxuICAgICAgICAgICAgeSA9ICBsZW5ndGggLyAyICogTWF0aC5zaW4oX3RoZXRhMiksXG4gICAgICAgICAgICB4ID0gIGxlbmd0aCAvIDIgKiBNYXRoLmNvcyhfdGhldGEyKTtcbiAgICAgICAgcmV0dXJuIFt7eDpwLnBvaW50LnggKyB4LCB5OnAucG9pbnQueSArIHl9LCB7eDpwLnBvaW50LnggLSB4LCB5OnAucG9pbnQueSAtIHl9XTtcbiAgICB9O1xuXG4gICAgdmFyIGpzQmV6aWVyID0gdGhpcy5qc0JlemllciA9IHtcbiAgICAgICAgZGlzdGFuY2VGcm9tQ3VydmUgOiBfZGlzdGFuY2VGcm9tQ3VydmUsXG4gICAgICAgIGdyYWRpZW50QXRQb2ludCA6IF9ncmFkaWVudEF0UG9pbnQsXG4gICAgICAgIGdyYWRpZW50QXRQb2ludEFsb25nQ3VydmVGcm9tIDogX2dyYWRpZW50QXRQb2ludEFsb25nUGF0aEZyb20sXG4gICAgICAgIG5lYXJlc3RQb2ludE9uQ3VydmUgOiBfbmVhcmVzdFBvaW50T25DdXJ2ZSxcbiAgICAgICAgcG9pbnRPbkN1cnZlIDogX3BvaW50T25QYXRoLFxuICAgICAgICBwb2ludEFsb25nQ3VydmVGcm9tIDogX3BvaW50QWxvbmdQYXRoRnJvbSxcbiAgICAgICAgcGVycGVuZGljdWxhclRvQ3VydmVBdCA6IF9wZXJwZW5kaWN1bGFyVG9QYXRoQXQsXG4gICAgICAgIGxvY2F0aW9uQWxvbmdDdXJ2ZUZyb206X2xvY2F0aW9uQWxvbmdQYXRoRnJvbSxcbiAgICAgICAgZ2V0TGVuZ3RoOl9sZW5ndGgsXG4gICAgICAgIHZlcnNpb246XCIwLjkuMFwiXG4gICAgfTtcblxuICAgIGlmICh0eXBlb2YgZXhwb3J0cyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBleHBvcnRzLmpzQmV6aWVyID0ganNCZXppZXI7XG4gICAgfVxuXG59KS5jYWxsKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdGhpcyk7XG5cbi8qKlxuICogQmlsdG9uZyB2MC40LjBcbiAqXG4gKiBWYXJpb3VzIGdlb21ldHJ5IGZ1bmN0aW9ucyB3cml0dGVuIGFzIHBhcnQgb2YganNQbHVtYiBhbmQgcGVyaGFwcyB1c2VmdWwgZm9yIG90aGVycy5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcganNQbHVtYlxuICogaHR0cHM6Ly9qc3BsdW1idG9vbGtpdC5jb21cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICogb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb25cbiAqIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dFxuICogcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsXG4gKiBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlXG4gKiBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZ1xuICogY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICogaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAqIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFU1xuICogT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAqIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUXG4gKiBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSxcbiAqIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xuICogRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUlxuICogT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuICovXG47KGZ1bmN0aW9uKCkge1xuXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIHJvb3QgPSB0aGlzO1xuXG4gICAgdmFyIEJpbHRvbmcgPSByb290LkJpbHRvbmcgPSB7XG4gICAgICAgIHZlcnNpb246XCIwLjQuMFwiXG4gICAgfTtcblxuICAgIGlmICh0eXBlb2YgZXhwb3J0cyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBleHBvcnRzLkJpbHRvbmcgPSBCaWx0b25nO1xuICAgIH1cblxuICAgIHZhciBfaXNhID0gZnVuY3Rpb24oYSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGEpID09PSBcIltvYmplY3QgQXJyYXldXCI7IH0sXG4gICAgICAgIF9wb2ludEhlbHBlciA9IGZ1bmN0aW9uKHAxLCBwMiwgZm4pIHtcbiAgICAgICAgICAgIHAxID0gX2lzYShwMSkgPyBwMSA6IFtwMS54LCBwMS55XTtcbiAgICAgICAgICAgIHAyID0gX2lzYShwMikgPyBwMiA6IFtwMi54LCBwMi55XTtcbiAgICAgICAgICAgIHJldHVybiBmbihwMSwgcDIpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQG5hbWUgQmlsdG9uZy5ncmFkaWVudFxuICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICogQGRlc2MgQ2FsY3VsYXRlcyB0aGUgZ3JhZGllbnQgb2YgYSBsaW5lIGJldHdlZW4gdGhlIHR3byBwb2ludHMuXG4gICAgICAgICAqIEBwYXJhbSB7UG9pbnR9IHAxIEZpcnN0IHBvaW50LCBlaXRoZXIgYXMgYSAyIGVudHJ5IGFycmF5IG9yIG9iamVjdCB3aXRoIGBsZWZ0YCBhbmQgYHRvcGAgcHJvcGVydGllcy5cbiAgICAgICAgICogQHBhcmFtIHtQb2ludH0gcDIgU2Vjb25kIHBvaW50LCBlaXRoZXIgYXMgYSAyIGVudHJ5IGFycmF5IG9yIG9iamVjdCB3aXRoIGBsZWZ0YCBhbmQgYHRvcGAgcHJvcGVydGllcy5cbiAgICAgICAgICogQHJldHVybiB7RmxvYXR9IFRoZSBncmFkaWVudCBvZiBhIGxpbmUgYmV0d2VlbiB0aGUgdHdvIHBvaW50cy5cbiAgICAgICAgICovXG4gICAgICAgIF9ncmFkaWVudCA9IEJpbHRvbmcuZ3JhZGllbnQgPSBmdW5jdGlvbihwMSwgcDIpIHtcbiAgICAgICAgICAgIHJldHVybiBfcG9pbnRIZWxwZXIocDEsIHAyLCBmdW5jdGlvbihfcDEsIF9wMikge1xuICAgICAgICAgICAgICAgIGlmIChfcDJbMF0gPT0gX3AxWzBdKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3AyWzFdID4gX3AxWzFdID8gSW5maW5pdHkgOiAtSW5maW5pdHk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoX3AyWzFdID09IF9wMVsxXSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9wMlswXSA+IF9wMVswXSA/IDAgOiAtMDtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoX3AyWzFdIC0gX3AxWzFdKSAvIChfcDJbMF0gLSBfcDFbMF0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbmFtZSBCaWx0b25nLm5vcm1hbFxuICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICogQGRlc2MgQ2FsY3VsYXRlcyB0aGUgZ3JhZGllbnQgb2YgYSBub3JtYWwgdG8gYSBsaW5lIGJldHdlZW4gdGhlIHR3byBwb2ludHMuXG4gICAgICAgICAqIEBwYXJhbSB7UG9pbnR9IHAxIEZpcnN0IHBvaW50LCBlaXRoZXIgYXMgYSAyIGVudHJ5IGFycmF5IG9yIG9iamVjdCB3aXRoIGBsZWZ0YCBhbmQgYHRvcGAgcHJvcGVydGllcy5cbiAgICAgICAgICogQHBhcmFtIHtQb2ludH0gcDIgU2Vjb25kIHBvaW50LCBlaXRoZXIgYXMgYSAyIGVudHJ5IGFycmF5IG9yIG9iamVjdCB3aXRoIGBsZWZ0YCBhbmQgYHRvcGAgcHJvcGVydGllcy5cbiAgICAgICAgICogQHJldHVybiB7RmxvYXR9IFRoZSBncmFkaWVudCBvZiBhIG5vcm1hbCB0byBhIGxpbmUgYmV0d2VlbiB0aGUgdHdvIHBvaW50cy5cbiAgICAgICAgICovXG4gICAgICAgIF9ub3JtYWwgPSBCaWx0b25nLm5vcm1hbCA9IGZ1bmN0aW9uKHAxLCBwMikge1xuICAgICAgICAgICAgcmV0dXJuIC0xIC8gX2dyYWRpZW50KHAxLCBwMik7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbmFtZSBCaWx0b25nLmxpbmVMZW5ndGhcbiAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAqIEBkZXNjIENhbGN1bGF0ZXMgdGhlIGxlbmd0aCBvZiBhIGxpbmUgYmV0d2VlbiB0aGUgdHdvIHBvaW50cy5cbiAgICAgICAgICogQHBhcmFtIHtQb2ludH0gcDEgRmlyc3QgcG9pbnQsIGVpdGhlciBhcyBhIDIgZW50cnkgYXJyYXkgb3Igb2JqZWN0IHdpdGggYGxlZnRgIGFuZCBgdG9wYCBwcm9wZXJ0aWVzLlxuICAgICAgICAgKiBAcGFyYW0ge1BvaW50fSBwMiBTZWNvbmQgcG9pbnQsIGVpdGhlciBhcyBhIDIgZW50cnkgYXJyYXkgb3Igb2JqZWN0IHdpdGggYGxlZnRgIGFuZCBgdG9wYCBwcm9wZXJ0aWVzLlxuICAgICAgICAgKiBAcmV0dXJuIHtGbG9hdH0gVGhlIGxlbmd0aCBvZiBhIGxpbmUgYmV0d2VlbiB0aGUgdHdvIHBvaW50cy5cbiAgICAgICAgICovXG4gICAgICAgIF9saW5lTGVuZ3RoID0gQmlsdG9uZy5saW5lTGVuZ3RoID0gZnVuY3Rpb24ocDEsIHAyKSB7XG4gICAgICAgICAgICByZXR1cm4gX3BvaW50SGVscGVyKHAxLCBwMiwgZnVuY3Rpb24oX3AxLCBfcDIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KF9wMlsxXSAtIF9wMVsxXSwgMikgKyBNYXRoLnBvdyhfcDJbMF0gLSBfcDFbMF0sIDIpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQG5hbWUgQmlsdG9uZy5xdWFkcmFudFxuICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICogQGRlc2MgQ2FsY3VsYXRlcyB0aGUgcXVhZHJhbnQgaW4gd2hpY2ggdGhlIGFuZ2xlIGJldHdlZW4gdGhlIHR3byBwb2ludHMgbGllcy5cbiAgICAgICAgICogQHBhcmFtIHtQb2ludH0gcDEgRmlyc3QgcG9pbnQsIGVpdGhlciBhcyBhIDIgZW50cnkgYXJyYXkgb3Igb2JqZWN0IHdpdGggYGxlZnRgIGFuZCBgdG9wYCBwcm9wZXJ0aWVzLlxuICAgICAgICAgKiBAcGFyYW0ge1BvaW50fSBwMiBTZWNvbmQgcG9pbnQsIGVpdGhlciBhcyBhIDIgZW50cnkgYXJyYXkgb3Igb2JqZWN0IHdpdGggYGxlZnRgIGFuZCBgdG9wYCBwcm9wZXJ0aWVzLlxuICAgICAgICAgKiBAcmV0dXJuIHtJbnRlZ2VyfSBUaGUgcXVhZHJhbnQgLSAxIGZvciB1cHBlciByaWdodCwgMiBmb3IgbG93ZXIgcmlnaHQsIDMgZm9yIGxvd2VyIGxlZnQsIDQgZm9yIHVwcGVyIGxlZnQuXG4gICAgICAgICAqL1xuICAgICAgICBfcXVhZHJhbnQgPSBCaWx0b25nLnF1YWRyYW50ID0gZnVuY3Rpb24ocDEsIHAyKSB7XG4gICAgICAgICAgICByZXR1cm4gX3BvaW50SGVscGVyKHAxLCBwMiwgZnVuY3Rpb24oX3AxLCBfcDIpIHtcbiAgICAgICAgICAgICAgICBpZiAoX3AyWzBdID4gX3AxWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoX3AyWzFdID4gX3AxWzFdKSA/IDIgOiAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChfcDJbMF0gPT0gX3AxWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfcDJbMV0gPiBfcDFbMV0gPyAyIDogMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoX3AyWzFdID4gX3AxWzFdKSA/IDMgOiA0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQG5hbWUgQmlsdG9uZy50aGV0YVxuICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICogQGRlc2MgQ2FsY3VsYXRlcyB0aGUgYW5nbGUgYmV0d2VlbiB0aGUgdHdvIHBvaW50cy5cbiAgICAgICAgICogQHBhcmFtIHtQb2ludH0gcDEgRmlyc3QgcG9pbnQsIGVpdGhlciBhcyBhIDIgZW50cnkgYXJyYXkgb3Igb2JqZWN0IHdpdGggYGxlZnRgIGFuZCBgdG9wYCBwcm9wZXJ0aWVzLlxuICAgICAgICAgKiBAcGFyYW0ge1BvaW50fSBwMiBTZWNvbmQgcG9pbnQsIGVpdGhlciBhcyBhIDIgZW50cnkgYXJyYXkgb3Igb2JqZWN0IHdpdGggYGxlZnRgIGFuZCBgdG9wYCBwcm9wZXJ0aWVzLlxuICAgICAgICAgKiBAcmV0dXJuIHtGbG9hdH0gVGhlIGFuZ2xlIGJldHdlZW4gdGhlIHR3byBwb2ludHMuXG4gICAgICAgICAqL1xuICAgICAgICBfdGhldGEgPSBCaWx0b25nLnRoZXRhID0gZnVuY3Rpb24ocDEsIHAyKSB7XG4gICAgICAgICAgICByZXR1cm4gX3BvaW50SGVscGVyKHAxLCBwMiwgZnVuY3Rpb24oX3AxLCBfcDIpIHtcbiAgICAgICAgICAgICAgICB2YXIgbSA9IF9ncmFkaWVudChfcDEsIF9wMiksXG4gICAgICAgICAgICAgICAgICAgIHQgPSBNYXRoLmF0YW4obSksXG4gICAgICAgICAgICAgICAgICAgIHMgPSBfcXVhZHJhbnQoX3AxLCBfcDIpO1xuICAgICAgICAgICAgICAgIGlmICgocyA9PSA0IHx8IHM9PSAzKSkgdCArPSBNYXRoLlBJO1xuICAgICAgICAgICAgICAgIGlmICh0IDwgMCkgdCArPSAoMiAqIE1hdGguUEkpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBuYW1lIEJpbHRvbmcuaW50ZXJzZWN0c1xuICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICogQGRlc2MgQ2FsY3VsYXRlcyB3aGV0aGVyIG9yIG5vdCB0aGUgdHdvIHJlY3RhbmdsZXMgaW50ZXJzZWN0LlxuICAgICAgICAgKiBAcGFyYW0ge1JlY3RhbmdsZX0gcjEgRmlyc3QgcmVjdGFuZ2xlLCBhcyBhIGpzIG9iamVjdCBpbiB0aGUgZm9ybSBge3g6Li4sIHk6Li4sIHc6Li4sIGg6Li59YFxuICAgICAgICAgKiBAcGFyYW0ge1JlY3RhbmdsZX0gcjIgU2Vjb25kIHJlY3RhbmdsZSwgYXMgYSBqcyBvYmplY3QgaW4gdGhlIGZvcm0gYHt4Oi4uLCB5Oi4uLCB3Oi4uLCBoOi4ufWBcbiAgICAgICAgICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgcmVjdGFuZ2xlcyBpbnRlcnNlY3QsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgICAgICovXG4gICAgICAgIF9pbnRlcnNlY3RzID0gQmlsdG9uZy5pbnRlcnNlY3RzID0gZnVuY3Rpb24ocjEsIHIyKSB7XG4gICAgICAgICAgICB2YXIgeDEgPSByMS54LCB4MiA9IHIxLnggKyByMS53LCB5MSA9IHIxLnksIHkyID0gcjEueSArIHIxLmgsXG4gICAgICAgICAgICAgICAgYTEgPSByMi54LCBhMiA9IHIyLnggKyByMi53LCBiMSA9IHIyLnksIGIyID0gcjIueSArIHIyLmg7XG5cbiAgICAgICAgICAgIHJldHVybiAgKCAoeDEgPD0gYTEgJiYgYTEgPD0geDIpICYmICh5MSA8PSBiMSAmJiBiMSA8PSB5MikgKSB8fFxuICAgICAgICAgICAgICAgICggKHgxIDw9IGEyICYmIGEyIDw9IHgyKSAmJiAoeTEgPD0gYjEgJiYgYjEgPD0geTIpICkgfHxcbiAgICAgICAgICAgICAgICAoICh4MSA8PSBhMSAmJiBhMSA8PSB4MikgJiYgKHkxIDw9IGIyICYmIGIyIDw9IHkyKSApIHx8XG4gICAgICAgICAgICAgICAgKCAoeDEgPD0gYTIgJiYgYTEgPD0geDIpICYmICh5MSA8PSBiMiAmJiBiMiA8PSB5MikgKSB8fFxuICAgICAgICAgICAgICAgICggKGExIDw9IHgxICYmIHgxIDw9IGEyKSAmJiAoYjEgPD0geTEgJiYgeTEgPD0gYjIpICkgfHxcbiAgICAgICAgICAgICAgICAoIChhMSA8PSB4MiAmJiB4MiA8PSBhMikgJiYgKGIxIDw9IHkxICYmIHkxIDw9IGIyKSApIHx8XG4gICAgICAgICAgICAgICAgKCAoYTEgPD0geDEgJiYgeDEgPD0gYTIpICYmIChiMSA8PSB5MiAmJiB5MiA8PSBiMikgKSB8fFxuICAgICAgICAgICAgICAgICggKGExIDw9IHgyICYmIHgxIDw9IGEyKSAmJiAoYjEgPD0geTIgJiYgeTIgPD0gYjIpICk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbmFtZSBCaWx0b25nLmVuY2xvc2VzXG4gICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgKiBAZGVzYyBDYWxjdWxhdGVzIHdoZXRoZXIgb3Igbm90IHIyIGlzIGNvbXBsZXRlbHkgZW5jbG9zZWQgYnkgcjEuXG4gICAgICAgICAqIEBwYXJhbSB7UmVjdGFuZ2xlfSByMSBGaXJzdCByZWN0YW5nbGUsIGFzIGEganMgb2JqZWN0IGluIHRoZSBmb3JtIGB7eDouLiwgeTouLiwgdzouLiwgaDouLn1gXG4gICAgICAgICAqIEBwYXJhbSB7UmVjdGFuZ2xlfSByMiBTZWNvbmQgcmVjdGFuZ2xlLCBhcyBhIGpzIG9iamVjdCBpbiB0aGUgZm9ybSBge3g6Li4sIHk6Li4sIHc6Li4sIGg6Li59YFxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFthbGxvd1NoYXJlZEVkZ2VzPWZhbHNlXSBJZiB0cnVlLCB0aGUgY29uY2VwdCBvZiBlbmNsb3N1cmUgYWxsb3dzIGZvciBvbmUgb3IgbW9yZSBlZGdlcyB0byBiZSBzaGFyZWQgYnkgdGhlIHR3byByZWN0YW5nbGVzLlxuICAgICAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIHIxIGVuY2xvc2VzIHIyLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICAgICAqL1xuICAgICAgICBfZW5jbG9zZXMgPSBCaWx0b25nLmVuY2xvc2VzID0gZnVuY3Rpb24ocjEsIHIyLCBhbGxvd1NoYXJlZEVkZ2VzKSB7XG4gICAgICAgICAgICB2YXIgeDEgPSByMS54LCB4MiA9IHIxLnggKyByMS53LCB5MSA9IHIxLnksIHkyID0gcjEueSArIHIxLmgsXG4gICAgICAgICAgICAgICAgYTEgPSByMi54LCBhMiA9IHIyLnggKyByMi53LCBiMSA9IHIyLnksIGIyID0gcjIueSArIHIyLmgsXG4gICAgICAgICAgICAgICAgYyA9IGZ1bmN0aW9uKHYxLCB2MiwgdjMsIHY0KSB7IHJldHVybiBhbGxvd1NoYXJlZEVkZ2VzID8gdjEgPD0gdjIgJiYgdjM+PSB2NCA6IHYxIDwgdjIgJiYgdjMgPiB2NDsgfTtcblxuICAgICAgICAgICAgcmV0dXJuIGMoeDEsYTEseDIsYTIpICYmIGMoeTEsYjEseTIsYjIpO1xuICAgICAgICB9LFxuICAgICAgICBfc2VnbWVudE11bHRpcGxpZXJzID0gW251bGwsIFsxLCAtMV0sIFsxLCAxXSwgWy0xLCAxXSwgWy0xLCAtMV0gXSxcbiAgICAgICAgX2ludmVyc2VTZWdtZW50TXVsdGlwbGllcnMgPSBbbnVsbCwgWy0xLCAtMV0sIFstMSwgMV0sIFsxLCAxXSwgWzEsIC0xXSBdLFxuICAgICAgICAvKipcbiAgICAgICAgICogQG5hbWUgQmlsdG9uZy5wb2ludE9uTGluZVxuICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICogQGRlc2MgQ2FsY3VsYXRlcyBhIHBvaW50IG9uIHRoZSBsaW5lIGZyb20gYGZyb21Qb2ludGAgdG8gYHRvUG9pbnRgIHRoYXQgaXMgYGRpc3RhbmNlYCB1bml0cyBhbG9uZyB0aGUgbGVuZ3RoIG9mIHRoZSBsaW5lLlxuICAgICAgICAgKiBAcGFyYW0ge1BvaW50fSBwMSBGaXJzdCBwb2ludCwgZWl0aGVyIGFzIGEgMiBlbnRyeSBhcnJheSBvciBvYmplY3Qgd2l0aCBgbGVmdGAgYW5kIGB0b3BgIHByb3BlcnRpZXMuXG4gICAgICAgICAqIEBwYXJhbSB7UG9pbnR9IHAyIFNlY29uZCBwb2ludCwgZWl0aGVyIGFzIGEgMiBlbnRyeSBhcnJheSBvciBvYmplY3Qgd2l0aCBgbGVmdGAgYW5kIGB0b3BgIHByb3BlcnRpZXMuXG4gICAgICAgICAqIEByZXR1cm4ge1BvaW50fSBQb2ludCBvbiB0aGUgbGluZSwgaW4gdGhlIGZvcm0gYHsgeDouLi4sIHk6Li4uIH1gLlxuICAgICAgICAgKi9cbiAgICAgICAgX3BvaW50T25MaW5lID0gQmlsdG9uZy5wb2ludE9uTGluZSA9IGZ1bmN0aW9uKGZyb21Qb2ludCwgdG9Qb2ludCwgZGlzdGFuY2UpIHtcbiAgICAgICAgICAgIHZhciBtID0gX2dyYWRpZW50KGZyb21Qb2ludCwgdG9Qb2ludCksXG4gICAgICAgICAgICAgICAgcyA9IF9xdWFkcmFudChmcm9tUG9pbnQsIHRvUG9pbnQpLFxuICAgICAgICAgICAgICAgIHNlZ21lbnRNdWx0aXBsaWVyID0gZGlzdGFuY2UgPiAwID8gX3NlZ21lbnRNdWx0aXBsaWVyc1tzXSA6IF9pbnZlcnNlU2VnbWVudE11bHRpcGxpZXJzW3NdLFxuICAgICAgICAgICAgICAgIHRoZXRhID0gTWF0aC5hdGFuKG0pLFxuICAgICAgICAgICAgICAgIHkgPSBNYXRoLmFicyhkaXN0YW5jZSAqIE1hdGguc2luKHRoZXRhKSkgKiBzZWdtZW50TXVsdGlwbGllclsxXSxcbiAgICAgICAgICAgICAgICB4ID0gIE1hdGguYWJzKGRpc3RhbmNlICogTWF0aC5jb3ModGhldGEpKSAqIHNlZ21lbnRNdWx0aXBsaWVyWzBdO1xuICAgICAgICAgICAgcmV0dXJuIHsgeDpmcm9tUG9pbnQueCArIHgsIHk6ZnJvbVBvaW50LnkgKyB5IH07XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbmFtZSBCaWx0b25nLnBlcnBlbmRpY3VsYXJMaW5lVG9cbiAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAqIEBkZXNjIENhbGN1bGF0ZXMgYSBsaW5lIG9mIGxlbmd0aCBgbGVuZ3RoYCB0aGF0IGlzIHBlcnBlbmRpY3VsYXIgdG8gdGhlIGxpbmUgZnJvbSBgZnJvbVBvaW50YCB0byBgdG9Qb2ludGAgYW5kIHBhc3NlcyB0aHJvdWdoIGB0b1BvaW50YC5cbiAgICAgICAgICogQHBhcmFtIHtQb2ludH0gcDEgRmlyc3QgcG9pbnQsIGVpdGhlciBhcyBhIDIgZW50cnkgYXJyYXkgb3Igb2JqZWN0IHdpdGggYGxlZnRgIGFuZCBgdG9wYCBwcm9wZXJ0aWVzLlxuICAgICAgICAgKiBAcGFyYW0ge1BvaW50fSBwMiBTZWNvbmQgcG9pbnQsIGVpdGhlciBhcyBhIDIgZW50cnkgYXJyYXkgb3Igb2JqZWN0IHdpdGggYGxlZnRgIGFuZCBgdG9wYCBwcm9wZXJ0aWVzLlxuICAgICAgICAgKiBAcmV0dXJuIHtMaW5lfSBQZXJwZW5kaWN1bGFyIGxpbmUsIGluIHRoZSBmb3JtIGBbIHsgeDouLi4sIHk6Li4uIH0sIHsgeDouLi4sIHk6Li4uIH0gXWAuXG4gICAgICAgICAqL1xuICAgICAgICBfcGVycGVuZGljdWxhckxpbmVUbyA9IEJpbHRvbmcucGVycGVuZGljdWxhckxpbmVUbyA9IGZ1bmN0aW9uKGZyb21Qb2ludCwgdG9Qb2ludCwgbGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgbSA9IF9ncmFkaWVudChmcm9tUG9pbnQsIHRvUG9pbnQpLFxuICAgICAgICAgICAgICAgIHRoZXRhMiA9IE1hdGguYXRhbigtMSAvIG0pLFxuICAgICAgICAgICAgICAgIHkgPSAgbGVuZ3RoIC8gMiAqIE1hdGguc2luKHRoZXRhMiksXG4gICAgICAgICAgICAgICAgeCA9ICBsZW5ndGggLyAyICogTWF0aC5jb3ModGhldGEyKTtcbiAgICAgICAgICAgIHJldHVybiBbe3g6dG9Qb2ludC54ICsgeCwgeTp0b1BvaW50LnkgKyB5fSwge3g6dG9Qb2ludC54IC0geCwgeTp0b1BvaW50LnkgLSB5fV07XG4gICAgICAgIH07XG59KS5jYWxsKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdGhpcyk7XG47XG4oZnVuY3Rpb24gKCkge1xuXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICB2YXIgcm9vdCA9IHRoaXMsXG4gICAgICAgIFNuaWZmID0ge1xuICAgICAgICAgICAgYW5kcm9pZDogbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLmluZGV4T2YoXCJhbmRyb2lkXCIpID4gLTFcbiAgICAgICAgfSxcbiAgICAgICAgbWF0Y2hlc1NlbGVjdG9yID0gZnVuY3Rpb24gKGVsLCBzZWxlY3RvciwgY3R4KSB7XG4gICAgICAgICAgICBjdHggPSBjdHggfHwgZWwucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIHZhciBwb3NzaWJsZXMgPSBjdHgucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvc3NpYmxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChwb3NzaWJsZXNbaV0gPT09IGVsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSxcbiAgICAgICAgX2dlbCA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgcmV0dXJuICh0eXBlb2YgZWwgPT0gXCJzdHJpbmdcIiB8fCBlbC5jb25zdHJ1Y3RvciA9PT0gU3RyaW5nKSA/IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGVsKSA6IGVsO1xuICAgICAgICB9LFxuICAgICAgICBfdCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gZS5zcmNFbGVtZW50IHx8IGUudGFyZ2V0O1xuICAgICAgICB9LFxuICAgIC8vXG4gICAgLy8gZ2V0cyBwYXRoIGluZm8gZm9yIHRoZSBnaXZlbiBldmVudCAtIHRoZSBwYXRoIGZyb20gdGFyZ2V0IHRvIG9iaiwgaW4gdGhlIGV2ZW50J3MgYnViYmxlIGNoYWluLiBpZiBkb0NvbXB1dGVcbiAgICAvLyBpcyBmYWxzZSB3ZSBqdXN0IHJldHVybiB0YXJnZXQgZm9yIHRoZSBwYXRoLlxuICAgIC8vXG4gICAgICAgIF9waSA9IGZ1bmN0aW9uKGUsIHRhcmdldCwgb2JqLCBkb0NvbXB1dGUpIHtcbiAgICAgICAgICAgIGlmICghZG9Db21wdXRlKSByZXR1cm4geyBwYXRoOlt0YXJnZXRdLCBlbmQ6MSB9O1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGUucGF0aCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBlLnBhdGguaW5kZXhPZikge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHBhdGg6IGUucGF0aCwgZW5kOiBlLnBhdGguaW5kZXhPZihvYmopIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBvdXQgPSB7IHBhdGg6W10sIGVuZDotMSB9LCBfb25lID0gZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0LnBhdGgucHVzaChlbCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbCA9PT0gb2JqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXQuZW5kID0gb3V0LnBhdGgubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChlbC5wYXJlbnROb2RlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9vbmUoZWwucGFyZW50Tm9kZSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgX29uZSh0YXJnZXQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIF9kID0gZnVuY3Rpb24gKGwsIGZuKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaiA9IGwubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxbaV0gPT0gZm4pIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGkgPCBsLmxlbmd0aCkgbC5zcGxpY2UoaSwgMSk7XG4gICAgICAgIH0sXG4gICAgICAgIGd1aWQgPSAxLFxuICAgIC8vXG4gICAgLy8gdGhpcyBmdW5jdGlvbiBnZW5lcmF0ZXMgYSBndWlkIGZvciBldmVyeSBoYW5kbGVyLCBzZXRzIGl0IG9uIHRoZSBoYW5kbGVyLCB0aGVuIGFkZHNcbiAgICAvLyBpdCB0byB0aGUgYXNzb2NpYXRlZCBvYmplY3QncyBtYXAgb2YgaGFuZGxlcnMgZm9yIHRoZSBnaXZlbiBldmVudC4gdGhpcyBpcyB3aGF0IGVuYWJsZXMgdXNcbiAgICAvLyB0byB1bmJpbmQgYWxsIGV2ZW50cyBvZiBzb21lIHR5cGUsIG9yIGFsbCBldmVudHMgKHRoZSBzZWNvbmQgb2Ygd2hpY2ggY2FuIGJlIHJlcXVlc3RlZCBieSB0aGUgdXNlcixcbiAgICAvLyBidXQgaXQgYWxzbyB1c2VkIGJ5IE1vdHRsZSB3aGVuIGFuIGVsZW1lbnQgaXMgcmVtb3ZlZC4pXG4gICAgICAgIF9zdG9yZSA9IGZ1bmN0aW9uIChvYmosIGV2ZW50LCBmbikge1xuICAgICAgICAgICAgdmFyIGcgPSBndWlkKys7XG4gICAgICAgICAgICBvYmouX190YSA9IG9iai5fX3RhIHx8IHt9O1xuICAgICAgICAgICAgb2JqLl9fdGFbZXZlbnRdID0gb2JqLl9fdGFbZXZlbnRdIHx8IHt9O1xuICAgICAgICAgICAgLy8gc3RvcmUgZWFjaCBoYW5kbGVyIHdpdGggYSB1bmlxdWUgZ3VpZC5cbiAgICAgICAgICAgIG9iai5fX3RhW2V2ZW50XVtnXSA9IGZuO1xuICAgICAgICAgICAgLy8gc2V0IHRoZSBndWlkIG9uIHRoZSBoYW5kbGVyLlxuICAgICAgICAgICAgZm4uX190YXVpZCA9IGc7XG4gICAgICAgICAgICByZXR1cm4gZztcbiAgICAgICAgfSxcbiAgICAgICAgX3Vuc3RvcmUgPSBmdW5jdGlvbiAob2JqLCBldmVudCwgZm4pIHtcbiAgICAgICAgICAgIG9iai5fX3RhICYmIG9iai5fX3RhW2V2ZW50XSAmJiBkZWxldGUgb2JqLl9fdGFbZXZlbnRdW2ZuLl9fdGF1aWRdO1xuICAgICAgICAgICAgLy8gYSBoYW5kbGVyIG1pZ2h0IGhhdmUgYXR0YWNoZWQgZXh0cmEgZnVuY3Rpb25zLCBzbyB3ZSB1bmJpbmQgdGhvc2UgdG9vLlxuICAgICAgICAgICAgaWYgKGZuLl9fdGFFeHRyYSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZm4uX190YUV4dHJhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIF91bmJpbmQob2JqLCBmbi5fX3RhRXh0cmFbaV1bMF0sIGZuLl9fdGFFeHRyYVtpXVsxXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZuLl9fdGFFeHRyYS5sZW5ndGggPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYSBoYW5kbGVyIG1pZ2h0IGhhdmUgYXR0YWNoZWQgYW4gdW5zdG9yZSBjYWxsYmFja1xuICAgICAgICAgICAgZm4uX190YVVuc3RvcmUgJiYgZm4uX190YVVuc3RvcmUoKTtcbiAgICAgICAgfSxcbiAgICAgICAgX2N1cnJ5Q2hpbGRGaWx0ZXIgPSBmdW5jdGlvbiAoY2hpbGRyZW4sIG9iaiwgZm4sIGV2dCkge1xuICAgICAgICAgICAgaWYgKGNoaWxkcmVuID09IG51bGwpIHJldHVybiBmbjtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBjID0gY2hpbGRyZW4uc3BsaXQoXCIsXCIpLFxuICAgICAgICAgICAgICAgICAgICBfZm4gPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2ZuLl9fdGF1aWQgPSBmbi5fX3RhdWlkO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBfdChlKSwgdGFyZ2V0ID0gdDsgIC8vIHQgaXMgdGhlIHRhcmdldCBlbGVtZW50IG9uIHdoaWNoIHRoZSBldmVudCBvY2N1cnJlZC4gaXQgaXMgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBlbGVtZW50IHdlIHdpbGwgd2lzaCB0byBwYXNzIHRvIGFueSBjYWxsYmFja3MuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGF0aEluZm8gPSBfcGkoZSwgdCwgb2JqLCBjaGlsZHJlbiAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhdGhJbmZvLmVuZCAhPSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHAgPSAwOyBwIDwgcGF0aEluZm8uZW5kOyBwKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0ID0gcGF0aEluZm8ucGF0aFtwXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2hlc1NlbGVjdG9yKHRhcmdldCwgY1tpXSwgb2JqKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZuLmFwcGx5KHRhcmdldCwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZWdpc3RlckV4dHJhRnVuY3Rpb24oZm4sIGV2dCwgX2ZuKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2ZuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIC8vXG4gICAgLy8gcmVnaXN0ZXJzIGFuICdleHRyYScgZnVuY3Rpb24gb24gc29tZSBldmVudCBsaXN0ZW5lciBmdW5jdGlvbiB3ZSB3ZXJlIGdpdmVuIC0gYSBmdW5jdGlvbiB0aGF0IHdlXG4gICAgLy8gY3JlYXRlZCBhbmQgYm91bmQgdG8gdGhlIGVsZW1lbnQgYXMgcGFydCBvZiBvdXIgaG91c2VrZWVwaW5nLCBhbmQgd2hpY2ggd2Ugd2FudCB0byB1bmJpbmQgYW5kIHJlbW92ZVxuICAgIC8vIHdoZW5ldmVyIHRoZSBnaXZlbiBmdW5jdGlvbiBpcyB1bmJvdW5kLlxuICAgICAgICByZWdpc3RlckV4dHJhRnVuY3Rpb24gPSBmdW5jdGlvbiAoZm4sIGV2dCwgbmV3Rm4pIHtcbiAgICAgICAgICAgIGZuLl9fdGFFeHRyYSA9IGZuLl9fdGFFeHRyYSB8fCBbXTtcbiAgICAgICAgICAgIGZuLl9fdGFFeHRyYS5wdXNoKFtldnQsIG5ld0ZuXSk7XG4gICAgICAgIH0sXG4gICAgICAgIERlZmF1bHRIYW5kbGVyID0gZnVuY3Rpb24gKG9iaiwgZXZ0LCBmbiwgY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGlmIChpc1RvdWNoRGV2aWNlICYmIHRvdWNoTWFwW2V2dF0pIHtcbiAgICAgICAgICAgICAgICB2YXIgdGZuID0gX2N1cnJ5Q2hpbGRGaWx0ZXIoY2hpbGRyZW4sIG9iaiwgZm4sIHRvdWNoTWFwW2V2dF0pO1xuICAgICAgICAgICAgICAgIF9iaW5kKG9iaiwgdG91Y2hNYXBbZXZ0XSwgdGZuICwgZm4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGV2dCA9PT0gXCJmb2N1c1wiICYmIG9iai5nZXRBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiKSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgb2JqLnNldEF0dHJpYnV0ZShcInRhYmluZGV4XCIsIFwiMVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9iaW5kKG9iaiwgZXZ0LCBfY3VycnlDaGlsZEZpbHRlcihjaGlsZHJlbiwgb2JqLCBmbiwgZXZ0KSwgZm4pO1xuICAgICAgICB9LFxuICAgICAgICBTbWFydENsaWNrSGFuZGxlciA9IGZ1bmN0aW9uIChvYmosIGV2dCwgZm4sIGNoaWxkcmVuKSB7XG4gICAgICAgICAgICBpZiAob2JqLl9fdGFTbWFydENsaWNrcyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRvd24gPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JqLl9fdGFkID0gX3BhZ2VMb2NhdGlvbihlKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgdXAgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JqLl9fdGF1ID0gX3BhZ2VMb2NhdGlvbihlKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgY2xpY2sgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9iai5fX3RhZCAmJiBvYmouX190YXUgJiYgb2JqLl9fdGFkWzBdID09PSBvYmouX190YXVbMF0gJiYgb2JqLl9fdGFkWzFdID09PSBvYmouX190YXVbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iai5fX3RhU21hcnRDbGlja3MubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iai5fX3RhU21hcnRDbGlja3NbaV0uYXBwbHkoX3QoZSksIFsgZSBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBEZWZhdWx0SGFuZGxlcihvYmosIFwibW91c2Vkb3duXCIsIGRvd24sIGNoaWxkcmVuKTtcbiAgICAgICAgICAgICAgICBEZWZhdWx0SGFuZGxlcihvYmosIFwibW91c2V1cFwiLCB1cCwgY2hpbGRyZW4pO1xuICAgICAgICAgICAgICAgIERlZmF1bHRIYW5kbGVyKG9iaiwgXCJjbGlja1wiLCBjbGljaywgY2hpbGRyZW4pO1xuICAgICAgICAgICAgICAgIG9iai5fX3RhU21hcnRDbGlja3MgPSBbXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gc3RvcmUgaW4gdGhlIGxpc3Qgb2YgY2FsbGJhY2tzXG4gICAgICAgICAgICBvYmouX190YVNtYXJ0Q2xpY2tzLnB1c2goZm4pO1xuICAgICAgICAgICAgLy8gdGhlIHVuc3RvcmUgZnVuY3Rpb24gcmVtb3ZlcyB0aGlzIGZ1bmN0aW9uIGZyb20gdGhlIG9iamVjdCdzIGxpc3RlbmVyIGxpc3QgZm9yIHRoaXMgdHlwZS5cbiAgICAgICAgICAgIGZuLl9fdGFVbnN0b3JlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF9kKG9iai5fX3RhU21hcnRDbGlja3MsIGZuKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIF90YXBQcm9maWxlcyA9IHtcbiAgICAgICAgICAgIFwidGFwXCI6IHt0b3VjaGVzOiAxLCB0YXBzOiAxfSxcbiAgICAgICAgICAgIFwiZGJsdGFwXCI6IHt0b3VjaGVzOiAxLCB0YXBzOiAyfSxcbiAgICAgICAgICAgIFwiY29udGV4dG1lbnVcIjoge3RvdWNoZXM6IDIsIHRhcHM6IDF9XG4gICAgICAgIH0sXG4gICAgICAgIFRhcEhhbmRsZXIgPSBmdW5jdGlvbiAoY2xpY2tUaHJlc2hvbGQsIGRibENsaWNrVGhyZXNob2xkKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG9iaiwgZXZ0LCBmbiwgY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICAvLyBpZiBldmVudCBpcyBjb250ZXh0bWVudSwgZm9yIGRldmljZXMgd2hpY2ggYXJlIG1vdXNlIG9ubHksIHdlIHdhbnQgdG9cbiAgICAgICAgICAgICAgICAvLyB1c2UgdGhlIGRlZmF1bHQgYmluZC5cbiAgICAgICAgICAgICAgICBpZiAoZXZ0ID09IFwiY29udGV4dG1lbnVcIiAmJiBpc01vdXNlRGV2aWNlKVxuICAgICAgICAgICAgICAgICAgICBEZWZhdWx0SGFuZGxlcihvYmosIGV2dCwgZm4sIGNoaWxkcmVuKTtcbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGlzc3VlIGhlcmUgaXMgdGhhdCB0aGlzIGRvd24gaGFuZGxlciBnZXRzIHJlZ2lzdGVyZWQgb25seSBmb3IgdGhlXG4gICAgICAgICAgICAgICAgICAgIC8vIGNoaWxkIG5vZGVzIGluIHRoZSBmaXJzdCByZWdpc3RyYXRpb24uIGluIGZhY3QgaXQgc2hvdWxkIGJlIHJlZ2lzdGVyZWQgd2l0aFxuICAgICAgICAgICAgICAgICAgICAvLyBubyBjaGlsZCBzZWxlY3RvciBhbmQgdGhlbiBvbiBkb3duIHdlIHNob3VsZCBjeWNsZSB0aHJvdWdoIHRoZSByZWdpc3RlcmVkXG4gICAgICAgICAgICAgICAgICAgIC8vIGZ1bmN0aW9ucyB0byBzZWUgaWYgb25lIG9mIHRoZW0gbWF0Y2hlcy4gb24gbW91c2V1cCB3ZSBzaG91bGQgZXhlY3V0ZSBBTEwgb2ZcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGZ1bmN0aW9ucyB3aG9zZSBjaGlsZHJlbiBhcmUgZWl0aGVyIG51bGwgb3IgbWF0Y2ggdGhlIGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgICAgIGlmIChvYmouX190YVRhcEhhbmRsZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHR0ID0gb2JqLl9fdGFUYXBIYW5kbGVyID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcDogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGJsdGFwOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0bWVudTogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG93bjogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFwczogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3duU2VsZWN0b3JzOiBbXVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkb3duID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRhcmdldCA9IF90KGUpLCBwYXRoSW5mbyA9IF9waShlLCB0YXJnZXQsIG9iaiwgY2hpbGRyZW4gIT0gbnVsbCksIGZpbmlzaGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHAgPSAwOyBwIDwgcGF0aEluZm8uZW5kOyBwKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaW5pc2hlZCkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0ID0gcGF0aEluZm8ucGF0aFtwXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHQuZG93blNlbGVjdG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0dC5kb3duU2VsZWN0b3JzW2ldID09IG51bGwgfHwgbWF0Y2hlc1NlbGVjdG9yKHRhcmdldCwgdHQuZG93blNlbGVjdG9yc1tpXSwgb2JqKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0dC5kb3duID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChjbGVhclNpbmdsZSwgY2xpY2tUaHJlc2hvbGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGNsZWFyRG91YmxlLCBkYmxDbGlja1RocmVzaG9sZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7IC8vIHdlIG9ubHkgbmVlZCBvbmUgbWF0Y2ggb24gbW91c2Vkb3duXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0dC5kb3duKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0ID0gX3QoZSksIGN1cnJlbnRUYXJnZXQsIHBhdGhJbmZvO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHQudGFwcysrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRjID0gX3RvdWNoQ291bnQoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBldmVudElkIGluIF90YXBQcm9maWxlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdGFwUHJvZmlsZXMuaGFzT3duUHJvcGVydHkoZXZlbnRJZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHAgPSBfdGFwUHJvZmlsZXNbZXZlbnRJZF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwLnRvdWNoZXMgPT09IHRjICYmIChwLnRhcHMgPT09IDEgfHwgcC50YXBzID09PSB0dC50YXBzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0dFtldmVudElkXS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhJbmZvID0gX3BpKGUsIHRhcmdldCwgb2JqLCB0dFtldmVudElkXVtpXVsxXSAhPSBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBwTG9vcCA9IDA7IHBMb29wIDwgcGF0aEluZm8uZW5kOyBwTG9vcCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUYXJnZXQgPSBwYXRoSW5mby5wYXRoW3BMb29wXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBpcyBhIHNpbmdsZSBldmVudCByZWdpc3RyYXRpb24gaGFuZGxlci5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR0W2V2ZW50SWRdW2ldWzFdID09IG51bGwgfHwgbWF0Y2hlc1NlbGVjdG9yKGN1cnJlbnRUYXJnZXQsIHR0W2V2ZW50SWRdW2ldWzFdLCBvYmopKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0dFtldmVudElkXVtpXVswXS5hcHBseShjdXJyZW50VGFyZ2V0LCBbIGUgXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJTaW5nbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR0LmRvd24gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyRG91YmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0dC50YXBzID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBEZWZhdWx0SGFuZGxlcihvYmosIFwibW91c2Vkb3duXCIsIGRvd24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgRGVmYXVsdEhhbmRsZXIob2JqLCBcIm1vdXNldXBcIiwgdXApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIGFkZCB0aGlzIGNoaWxkIHNlbGVjdG9yIChpdCBjYW4gYmUgbnVsbCwgdGhhdCdzIGZpbmUpLlxuICAgICAgICAgICAgICAgICAgICBvYmouX190YVRhcEhhbmRsZXIuZG93blNlbGVjdG9ycy5wdXNoKGNoaWxkcmVuKTtcblxuICAgICAgICAgICAgICAgICAgICBvYmouX190YVRhcEhhbmRsZXJbZXZ0XS5wdXNoKFtmbiwgY2hpbGRyZW5dKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHVuc3RvcmUgZnVuY3Rpb24gcmVtb3ZlcyB0aGlzIGZ1bmN0aW9uIGZyb20gdGhlIG9iamVjdCdzIGxpc3RlbmVyIGxpc3QgZm9yIHRoaXMgdHlwZS5cbiAgICAgICAgICAgICAgICAgICAgZm4uX190YVVuc3RvcmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfZChvYmouX190YVRhcEhhbmRsZXJbZXZ0XSwgZm4pO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIG1lZUhlbHBlciA9IGZ1bmN0aW9uICh0eXBlLCBldnQsIG9iaiwgdGFyZ2V0KSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpIGluIG9iai5fX3RhbWVlW3R5cGVdKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9iai5fX3RhbWVlW3R5cGVdLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgICAgICAgICAgIG9iai5fX3RhbWVlW3R5cGVdW2ldLmFwcGx5KHRhcmdldCwgWyBldnQgXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBNb3VzZUVudGVyRXhpdEhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYWN0aXZlRWxlbWVudHMgPSBbXTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAob2JqLCBldnQsIGZuLCBjaGlsZHJlbikge1xuICAgICAgICAgICAgICAgIGlmICghb2JqLl9fdGFtZWUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gX190YW1lZSBob2xkcyBhIGZsYWcgc2F5aW5nIHdoZXRoZXIgdGhlIG1vdXNlIGlzIGN1cnJlbnRseSBcImluXCIgdGhlIGVsZW1lbnQsIGFuZCBhIGxpc3Qgb2ZcbiAgICAgICAgICAgICAgICAgICAgLy8gYm90aCBtb3VzZWVudGVyIGFuZCBtb3VzZWV4aXQgZnVuY3Rpb25zLlxuICAgICAgICAgICAgICAgICAgICBvYmouX190YW1lZSA9IHsgb3ZlcjogZmFsc2UsIG1vdXNlZW50ZXI6IFtdLCBtb3VzZWV4aXQ6IFtdIH07XG4gICAgICAgICAgICAgICAgICAgIC8vIHJlZ2lzdGVyIG92ZXIgYW5kIG91dCBmdW5jdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgdmFyIG92ZXIgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ID0gX3QoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChjaGlsZHJlbiA9PSBudWxsICYmICh0ID09IG9iaiAmJiAhb2JqLl9fdGFtZWUub3ZlcikpIHx8IChtYXRjaGVzU2VsZWN0b3IodCwgY2hpbGRyZW4sIG9iaikgJiYgKHQuX190YW1lZSA9PSBudWxsIHx8ICF0Ll9fdGFtZWUub3ZlcikpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lZUhlbHBlcihcIm1vdXNlZW50ZXJcIiwgZSwgb2JqLCB0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdC5fX3RhbWVlID0gdC5fX3RhbWVlIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0Ll9fdGFtZWUub3ZlciA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZUVsZW1lbnRzLnB1c2godCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBfdChlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpcyB0aGUgY3VycmVudCB0YXJnZXQgb25lIG9mIHRoZSBhY3RpdmVFbGVtZW50cz8gYW5kIGlzIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlbGF0ZWQgdGFyZ2V0IE5PVCBhIGRlc2NlbmRhbnQgb2YgaXQ/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhY3RpdmVFbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodCA9PSBhY3RpdmVFbGVtZW50c1tpXSAmJiAhbWF0Y2hlc1NlbGVjdG9yKChlLnJlbGF0ZWRUYXJnZXQgfHwgZS50b0VsZW1lbnQpLCBcIipcIiwgdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQuX190YW1lZS5vdmVyID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmVFbGVtZW50cy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZWVIZWxwZXIoXCJtb3VzZWV4aXRcIiwgZSwgb2JqLCB0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgX2JpbmQob2JqLCBcIm1vdXNlb3ZlclwiLCBfY3VycnlDaGlsZEZpbHRlcihjaGlsZHJlbiwgb2JqLCBvdmVyLCBcIm1vdXNlb3ZlclwiKSwgb3Zlcik7XG4gICAgICAgICAgICAgICAgICAgIF9iaW5kKG9iaiwgXCJtb3VzZW91dFwiLCBfY3VycnlDaGlsZEZpbHRlcihjaGlsZHJlbiwgb2JqLCBvdXQsIFwibW91c2VvdXRcIiksIG91dCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm4uX190YVVuc3RvcmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvYmouX190YW1lZVtldnRdW2ZuLl9fdGF1aWRdO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBfc3RvcmUob2JqLCBldnQsIGZuKTtcbiAgICAgICAgICAgICAgICBvYmouX190YW1lZVtldnRdW2ZuLl9fdGF1aWRdID0gZm47XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBpc1RvdWNoRGV2aWNlID0gXCJvbnRvdWNoc3RhcnRcIiBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsXG4gICAgICAgIGlzTW91c2VEZXZpY2UgPSBcIm9ubW91c2Vkb3duXCIgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LFxuICAgICAgICB0b3VjaE1hcCA9IHsgXCJtb3VzZWRvd25cIjogXCJ0b3VjaHN0YXJ0XCIsIFwibW91c2V1cFwiOiBcInRvdWNoZW5kXCIsIFwibW91c2Vtb3ZlXCI6IFwidG91Y2htb3ZlXCIgfSxcbiAgICAgICAgdG91Y2hzdGFydCA9IFwidG91Y2hzdGFydFwiLCB0b3VjaGVuZCA9IFwidG91Y2hlbmRcIiwgdG91Y2htb3ZlID0gXCJ0b3VjaG1vdmVcIixcbiAgICAgICAgaWV2ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBydiA9IC0xO1xuICAgICAgICAgICAgaWYgKG5hdmlnYXRvci5hcHBOYW1lID09ICdNaWNyb3NvZnQgSW50ZXJuZXQgRXhwbG9yZXInKSB7XG4gICAgICAgICAgICAgICAgdmFyIHVhID0gbmF2aWdhdG9yLnVzZXJBZ2VudCxcbiAgICAgICAgICAgICAgICAgICAgcmUgPSBuZXcgUmVnRXhwKFwiTVNJRSAoWzAtOV17MSx9W1xcLjAtOV17MCx9KVwiKTtcbiAgICAgICAgICAgICAgICBpZiAocmUuZXhlYyh1YSkgIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgcnYgPSBwYXJzZUZsb2F0KFJlZ0V4cC4kMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcnY7XG4gICAgICAgIH0pKCksXG4gICAgICAgIGlzSUVMVDkgPSBpZXYgPiAtMSAmJiBpZXYgPCA5LFxuICAgICAgICBfZ2VuTG9jID0gZnVuY3Rpb24gKGUsIHByZWZpeCkge1xuICAgICAgICAgICAgaWYgKGUgPT0gbnVsbCkgcmV0dXJuIFsgMCwgMCBdO1xuICAgICAgICAgICAgdmFyIHRzID0gX3RvdWNoZXMoZSksIHQgPSBfZ2V0VG91Y2godHMsIDApO1xuICAgICAgICAgICAgcmV0dXJuIFt0W3ByZWZpeCArIFwiWFwiXSwgdFtwcmVmaXggKyBcIllcIl1dO1xuICAgICAgICB9LFxuICAgICAgICBfcGFnZUxvY2F0aW9uID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGlmIChlID09IG51bGwpIHJldHVybiBbIDAsIDAgXTtcbiAgICAgICAgICAgIGlmIChpc0lFTFQ5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsgZS5jbGllbnRYICsgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQsIGUuY2xpZW50WSArIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBfZ2VuTG9jKGUsIFwicGFnZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgX3NjcmVlbkxvY2F0aW9uID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBfZ2VuTG9jKGUsIFwic2NyZWVuXCIpO1xuICAgICAgICB9LFxuICAgICAgICBfY2xpZW50TG9jYXRpb24gPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIF9nZW5Mb2MoZSwgXCJjbGllbnRcIik7XG4gICAgICAgIH0sXG4gICAgICAgIF9nZXRUb3VjaCA9IGZ1bmN0aW9uICh0b3VjaGVzLCBpZHgpIHtcbiAgICAgICAgICAgIHJldHVybiB0b3VjaGVzLml0ZW0gPyB0b3VjaGVzLml0ZW0oaWR4KSA6IHRvdWNoZXNbaWR4XTtcbiAgICAgICAgfSxcbiAgICAgICAgX3RvdWNoZXMgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIGUudG91Y2hlcyAmJiBlLnRvdWNoZXMubGVuZ3RoID4gMCA/IGUudG91Y2hlcyA6XG4gICAgICAgICAgICAgICAgICAgIGUuY2hhbmdlZFRvdWNoZXMgJiYgZS5jaGFuZ2VkVG91Y2hlcy5sZW5ndGggPiAwID8gZS5jaGFuZ2VkVG91Y2hlcyA6XG4gICAgICAgICAgICAgICAgICAgIGUudGFyZ2V0VG91Y2hlcyAmJiBlLnRhcmdldFRvdWNoZXMubGVuZ3RoID4gMCA/IGUudGFyZ2V0VG91Y2hlcyA6XG4gICAgICAgICAgICAgICAgWyBlIF07XG4gICAgICAgIH0sXG4gICAgICAgIF90b3VjaENvdW50ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBfdG91Y2hlcyhlKS5sZW5ndGg7XG4gICAgICAgIH0sXG4gICAgLy9odHRwOi8vd3d3LnF1aXJrc21vZGUub3JnL2Jsb2cvYXJjaGl2ZXMvMjAwNS8xMC9fYW5kX3RoZV93aW5uZXJfMS5odG1sXG4gICAgICAgIF9iaW5kID0gZnVuY3Rpb24gKG9iaiwgdHlwZSwgZm4sIG9yaWdpbmFsRm4pIHtcbiAgICAgICAgICAgIF9zdG9yZShvYmosIHR5cGUsIGZuKTtcbiAgICAgICAgICAgIG9yaWdpbmFsRm4uX190YXVpZCA9IGZuLl9fdGF1aWQ7XG4gICAgICAgICAgICBpZiAob2JqLmFkZEV2ZW50TGlzdGVuZXIpXG4gICAgICAgICAgICAgICAgb2JqLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgZm4sIGZhbHNlKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKG9iai5hdHRhY2hFdmVudCkge1xuICAgICAgICAgICAgICAgIHZhciBrZXkgPSB0eXBlICsgZm4uX190YXVpZDtcbiAgICAgICAgICAgICAgICBvYmpbXCJlXCIgKyBrZXldID0gZm47XG4gICAgICAgICAgICAgICAgLy8gVE9ETyBsb29rIGF0IHJlcGxhY2luZyB3aXRoIC5jYWxsKC4uKVxuICAgICAgICAgICAgICAgIG9ialtrZXldID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBvYmpbXCJlXCIgKyBrZXldICYmIG9ialtcImVcIiArIGtleV0od2luZG93LmV2ZW50KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIG9iai5hdHRhY2hFdmVudChcIm9uXCIgKyB0eXBlLCBvYmpba2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIF91bmJpbmQgPSBmdW5jdGlvbiAob2JqLCB0eXBlLCBmbikge1xuICAgICAgICAgICAgaWYgKGZuID09IG51bGwpIHJldHVybjtcbiAgICAgICAgICAgIF9lYWNoKG9iaiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBfZWwgPSBfZ2VsKHRoaXMpO1xuICAgICAgICAgICAgICAgIF91bnN0b3JlKF9lbCwgdHlwZSwgZm4pO1xuICAgICAgICAgICAgICAgIC8vIGl0IGhhcyBiZWVuIGJvdW5kIGlmIHRoZXJlIGlzIGEgdGF1aWQuIG90aGVyd2lzZSBpdCB3YXMgbm90IGJvdW5kIGFuZCB3ZSBjYW4gaWdub3JlIGl0LlxuICAgICAgICAgICAgICAgIGlmIChmbi5fX3RhdWlkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9lbC5yZW1vdmVFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBmbiwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzVG91Y2hEZXZpY2UgJiYgdG91Y2hNYXBbdHlwZV0pIF9lbC5yZW1vdmVFdmVudExpc3RlbmVyKHRvdWNoTWFwW3R5cGVdLCBmbiwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuZGV0YWNoRXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSB0eXBlICsgZm4uX190YXVpZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9lbFtrZXldICYmIF9lbC5kZXRhY2hFdmVudChcIm9uXCIgKyB0eXBlLCBfZWxba2V5XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfZWxba2V5XSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBfZWxbXCJlXCIgKyBrZXldID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGlmIGEgdG91Y2ggZXZlbnQgd2FzIGFsc28gcmVnaXN0ZXJlZCwgZGVyZWdpc3RlciBub3cuXG4gICAgICAgICAgICAgICAgaWYgKGZuLl9fdGFUb3VjaFByb3h5KSB7XG4gICAgICAgICAgICAgICAgICAgIF91bmJpbmQob2JqLCBmbi5fX3RhVG91Y2hQcm94eVsxXSwgZm4uX190YVRvdWNoUHJveHlbMF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBfZWFjaCA9IGZ1bmN0aW9uIChvYmosIGZuKSB7XG4gICAgICAgICAgICBpZiAob2JqID09IG51bGwpIHJldHVybjtcbiAgICAgICAgICAgIC8vIGlmIGEgbGlzdCAob3IgbGlzdC1saWtlKSwgdXNlIGl0LiBpZiBhIHN0cmluZywgZ2V0IGEgbGlzdFxuICAgICAgICAgICAgLy8gYnkgcnVubmluZyB0aGUgc3RyaW5nIHRocm91Z2ggcXVlcnlTZWxlY3RvckFsbC4gZWxzZSwgYXNzdW1lXG4gICAgICAgICAgICAvLyBpdCdzIGFuIEVsZW1lbnQuXG4gICAgICAgICAgICAvLyBvYmoudG9wIGlzIFwidW5rbm93blwiIGluIElFOC5cbiAgICAgICAgICAgIG9iaiA9ICh0eXBlb2YgV2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmICh0eXBlb2Ygb2JqLnRvcCAhPT0gXCJ1bmtub3duXCIgJiYgb2JqID09IG9iai50b3ApKSA/IFsgb2JqIF0gOlxuICAgICAgICAgICAgICAgICAgICAodHlwZW9mIG9iaiAhPT0gXCJzdHJpbmdcIikgJiYgKG9iai50YWdOYW1lID09IG51bGwgJiYgb2JqLmxlbmd0aCAhPSBudWxsKSA/IG9iaiA6XG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiBvYmogPT09IFwic3RyaW5nXCIgPyBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKG9iailcbiAgICAgICAgICAgICAgICA6IFsgb2JqIF07XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIGZuLmFwcGx5KG9ialtpXSk7XG4gICAgICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBNb3R0bGUgb2ZmZXJzIHN1cHBvcnQgZm9yIGFic3RyYWN0aW5nIG91dCB0aGUgZGlmZmVyZW5jZXNcbiAgICAgKiBiZXR3ZWVuIHRvdWNoIGFuZCBtb3VzZSBkZXZpY2VzLCBwbHVzIFwic21hcnQgY2xpY2tcIiBmdW5jdGlvbmFsaXR5XG4gICAgICogKGRvbid0IGZpcmUgY2xpY2sgaWYgdGhlIG1vdXNlIGhhcyBtb3ZlZCBiZXR3ZWVuIG1vdXNlZG93biBhbmQgbW91c2V1cCksXG4gICAgICogYW5kIHN5bnRoZXNpemVkIGNsaWNrL3RhcCBldmVudHMuXG4gICAgICogQGNsYXNzIE1vdHRsZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgQ29uc3RydWN0b3IgcGFyYW1zXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtwYXJhbXMuY2xpY2tUaHJlc2hvbGQ9MjUwXSBUaHJlc2hvbGQsIGluIG1pbGxpc2Vjb25kcyBiZXlvbmQgd2hpY2ggYSB0b3VjaHN0YXJ0IGZvbGxvd2VkIGJ5IGEgdG91Y2hlbmQgaXMgbm90IGNvbnNpZGVyZWQgdG8gYmUgYSBjbGljay5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3BhcmFtcy5kYmxDbGlja1RocmVzaG9sZD00NTBdIFRocmVzaG9sZCwgaW4gbWlsbGlzZWNvbmRzIGJleW9uZCB3aGljaCB0d28gc3VjY2Vzc2l2ZSB0YXAgZXZlbnRzIGFyZSBub3QgY29uc2lkZXJlZCB0byBiZSBhIGNsaWNrLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3BhcmFtcy5zbWFydENsaWNrcz1mYWxzZV0gSWYgdHJ1ZSwgd29uJ3QgZmlyZSBjbGljayBldmVudHMgaWYgdGhlIG1vdXNlIGhhcyBtb3ZlZCBiZXR3ZWVuIG1vdXNlZG93biBhbmQgbW91c2V1cC4gTm90ZSB0aGF0IHRoaXMgZnVuY3Rpb25hbGl0eVxuICAgICAqIHJlcXVpcmVzIHRoYXQgTW90dGxlIGNvbnN1bWUgdGhlIG1vdXNlZG93biBldmVudCwgYW5kIHNvIG1heSBub3QgYmUgdmlhYmxlIGluIGFsbCB1c2UgY2FzZXMuXG4gICAgICovXG4gICAgcm9vdC5Nb3R0bGUgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgICAgICAgdmFyIGNsaWNrVGhyZXNob2xkID0gcGFyYW1zLmNsaWNrVGhyZXNob2xkIHx8IDI1MCxcbiAgICAgICAgICAgIGRibENsaWNrVGhyZXNob2xkID0gcGFyYW1zLmRibENsaWNrVGhyZXNob2xkIHx8IDQ1MCxcbiAgICAgICAgICAgIG1vdXNlRW50ZXJFeGl0SGFuZGxlciA9IG5ldyBNb3VzZUVudGVyRXhpdEhhbmRsZXIoKSxcbiAgICAgICAgICAgIHRhcEhhbmRsZXIgPSBuZXcgVGFwSGFuZGxlcihjbGlja1RocmVzaG9sZCwgZGJsQ2xpY2tUaHJlc2hvbGQpLFxuICAgICAgICAgICAgX3NtYXJ0Q2xpY2tzID0gcGFyYW1zLnNtYXJ0Q2xpY2tzLFxuICAgICAgICAgICAgX2RvQmluZCA9IGZ1bmN0aW9uIChvYmosIGV2dCwgZm4sIGNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZuID09IG51bGwpIHJldHVybjtcbiAgICAgICAgICAgICAgICBfZWFjaChvYmosIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9lbCA9IF9nZWwodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfc21hcnRDbGlja3MgJiYgZXZ0ID09PSBcImNsaWNrXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBTbWFydENsaWNrSGFuZGxlcihfZWwsIGV2dCwgZm4sIGNoaWxkcmVuKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZXZ0ID09PSBcInRhcFwiIHx8IGV2dCA9PT0gXCJkYmx0YXBcIiB8fCBldnQgPT09IFwiY29udGV4dG1lbnVcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFwSGFuZGxlcihfZWwsIGV2dCwgZm4sIGNoaWxkcmVuKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChldnQgPT09IFwibW91c2VlbnRlclwiIHx8IGV2dCA9PSBcIm1vdXNlZXhpdFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgbW91c2VFbnRlckV4aXRIYW5kbGVyKF9lbCwgZXZ0LCBmbiwgY2hpbGRyZW4pO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBEZWZhdWx0SGFuZGxlcihfZWwsIGV2dCwgZm4sIGNoaWxkcmVuKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW92ZXMgYW4gZWxlbWVudCBmcm9tIHRoZSBET00sIGFuZCBkZXJlZ2lzdGVycyBhbGwgZXZlbnQgaGFuZGxlcnMgZm9yIGl0LiBZb3Ugc2hvdWxkIHVzZSB0aGlzXG4gICAgICAgICAqIHRvIGVuc3VyZSB5b3UgZG9uJ3QgbGVhayBtZW1vcnkuXG4gICAgICAgICAqIEBtZXRob2QgcmVtb3ZlXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfEVsZW1lbnR9IGVsIEVsZW1lbnQsIG9yIGlkIG9mIHRoZSBlbGVtZW50LCB0byByZW1vdmUuXG4gICAgICAgICAqIEByZXR1cm4ge01vdHRsZX0gVGhlIGN1cnJlbnQgTW90dGxlIGluc3RhbmNlOyB5b3UgY2FuIGNoYWluIHRoaXMgbWV0aG9kLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZW1vdmUgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIF9lYWNoKGVsLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9lbCA9IF9nZWwodGhpcyk7XG4gICAgICAgICAgICAgICAgaWYgKF9lbC5fX3RhKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGV2dCBpbiBfZWwuX190YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9lbC5fX3RhLmhhc093blByb3BlcnR5KGV2dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBoIGluIF9lbC5fX3RhW2V2dF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9lbC5fX3RhW2V2dF0uaGFzT3duUHJvcGVydHkoaCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdW5iaW5kKF9lbCwgZXZ0LCBfZWwuX190YVtldnRdW2hdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX2VsLnBhcmVudE5vZGUgJiYgX2VsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoX2VsKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlZ2lzdGVyIGFuIGV2ZW50IGhhbmRsZXIsIG9wdGlvbmFsbHkgYXMgYSBkZWxlZ2F0ZSBmb3Igc29tZSBzZXQgb2YgZGVzY2VuZGFudCBlbGVtZW50cy4gTm90ZVxuICAgICAgICAgKiB0aGF0IHRoaXMgbWV0aG9kIHRha2VzIGVpdGhlciAzIG9yIDQgYXJndW1lbnRzIC0gaWYgeW91IHN1cHBseSAzIGFyZ3VtZW50cyBpdCBpcyBhc3N1bWVkIHlvdSBoYXZlXG4gICAgICAgICAqIG9taXR0ZWQgdGhlIGBjaGlsZHJlbmAgcGFyYW1ldGVyLCBhbmQgdGhhdCB0aGUgZXZlbnQgaGFuZGxlciBzaG91bGQgYmUgYm91bmQgZGlyZWN0bHkgdG8gdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICAgICAqIEBtZXRob2Qgb25cbiAgICAgICAgICogQHBhcmFtIHtFbGVtZW50W118RWxlbWVudHxTdHJpbmd9IGVsIEVpdGhlciBhbiBFbGVtZW50LCBvciBhIENTUyBzcGVjIGZvciBhIGxpc3Qgb2YgZWxlbWVudHMsIG9yIGFuIGFycmF5IG9mIEVsZW1lbnRzLlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NoaWxkcmVuXSBDb21tYS1kZWxpbWl0ZWQgbGlzdCBvZiBzZWxlY3RvcnMgaWRlbnRpZnlpbmcgYWxsb3dlZCBjaGlsZHJlbi5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IEV2ZW50IElELlxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBFdmVudCBoYW5kbGVyIGZ1bmN0aW9uLlxuICAgICAgICAgKiBAcmV0dXJuIHtNb3R0bGV9IFRoZSBjdXJyZW50IE1vdHRsZSBpbnN0YW5jZTsgeW91IGNhbiBjaGFpbiB0aGlzIG1ldGhvZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub24gPSBmdW5jdGlvbiAoZWwsIGV2ZW50LCBjaGlsZHJlbiwgZm4pIHtcbiAgICAgICAgICAgIHZhciBfZWwgPSBhcmd1bWVudHNbMF0sXG4gICAgICAgICAgICAgICAgX2MgPSBhcmd1bWVudHMubGVuZ3RoID09IDQgPyBhcmd1bWVudHNbMl0gOiBudWxsLFxuICAgICAgICAgICAgICAgIF9lID0gYXJndW1lbnRzWzFdLFxuICAgICAgICAgICAgICAgIF9mID0gYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGggLSAxXTtcblxuICAgICAgICAgICAgX2RvQmluZChfZWwsIF9lLCBfZiwgX2MpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbmNlbCBkZWxlZ2F0ZSBldmVudCBoYW5kbGluZyBmb3IgdGhlIGdpdmVuIGZ1bmN0aW9uLiBOb3RlIHRoYXQgdW5saWtlIHdpdGggJ29uJyB5b3UgZG8gbm90IHN1cHBseVxuICAgICAgICAgKiBhIGxpc3Qgb2YgY2hpbGQgc2VsZWN0b3JzIGhlcmU6IGl0IHJlbW92ZXMgZXZlbnQgZGVsZWdhdGlvbiBmcm9tIGFsbCBvZiB0aGUgY2hpbGQgc2VsZWN0b3JzIGZvciB3aGljaCB0aGVcbiAgICAgICAgICogZ2l2ZW4gZnVuY3Rpb24gd2FzIHJlZ2lzdGVyZWQgKGlmIGFueSkuXG4gICAgICAgICAqIEBtZXRob2Qgb2ZmXG4gICAgICAgICAqIEBwYXJhbSB7RWxlbWVudFtdfEVsZW1lbnR8U3RyaW5nfSBlbCBFbGVtZW50IC0gb3IgSUQgb2YgZWxlbWVudCAtIGZyb20gd2hpY2ggdG8gcmVtb3ZlIGV2ZW50IGxpc3RlbmVyLlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQgRXZlbnQgSUQuXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIEV2ZW50IGhhbmRsZXIgZnVuY3Rpb24uXG4gICAgICAgICAqIEByZXR1cm4ge01vdHRsZX0gVGhlIGN1cnJlbnQgTW90dGxlIGluc3RhbmNlOyB5b3UgY2FuIGNoYWluIHRoaXMgbWV0aG9kLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vZmYgPSBmdW5jdGlvbiAoZWwsIGV2ZW50LCBmbikge1xuICAgICAgICAgICAgX3VuYmluZChlbCwgZXZlbnQsIGZuKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcmlnZ2VycyBzb21lIGV2ZW50IGZvciBhIGdpdmVuIGVsZW1lbnQuXG4gICAgICAgICAqIEBtZXRob2QgdHJpZ2dlclxuICAgICAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsIEVsZW1lbnQgZm9yIHdoaWNoIHRvIHRyaWdnZXIgdGhlIGV2ZW50LlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQgRXZlbnQgSUQuXG4gICAgICAgICAqIEBwYXJhbSB7RXZlbnR9IG9yaWdpbmFsRXZlbnQgVGhlIG9yaWdpbmFsIGV2ZW50LiBTaG91bGQgYmUgb3B0aW9uYWwgb2YgY291cnNlLCBidXQgY3VycmVudGx5IGlzIG5vdCwgZHVlXG4gICAgICAgICAqIHRvIHRoZSBqc1BsdW1iIHVzZSBjYXNlIHRoYXQgY2F1c2VkIHRoaXMgbWV0aG9kIHRvIGJlIGFkZGVkLlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gW3BheWxvYWRdIE9wdGlvbmFsIG9iamVjdCB0byBzZXQgYXMgYHBheWxvYWRgIG9uIHRoZSBnZW5lcmF0ZWQgZXZlbnQ7IHVzZWZ1bCBmb3IgbWVzc2FnZSBwYXNzaW5nLlxuICAgICAgICAgKiBAcmV0dXJuIHtNb3R0bGV9IFRoZSBjdXJyZW50IE1vdHRsZSBpbnN0YW5jZTsgeW91IGNhbiBjaGFpbiB0aGlzIG1ldGhvZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudHJpZ2dlciA9IGZ1bmN0aW9uIChlbCwgZXZlbnQsIG9yaWdpbmFsRXZlbnQsIHBheWxvYWQpIHtcbiAgICAgICAgICAgIC8vIE1vdXNlRXZlbnQgdW5kZWZpbmVkIGluIG9sZCBJRTsgdGhhdCdzIGhvdyB3ZSBrbm93IGl0J3MgYSBtb3VzZSBldmVudC4gIEEgZmluZSBNaWNyb3NvZnQgcGFyYWRveC5cbiAgICAgICAgICAgIHZhciBvcmlnaW5hbElzTW91c2UgPSBpc01vdXNlRGV2aWNlICYmICh0eXBlb2YgTW91c2VFdmVudCA9PT0gXCJ1bmRlZmluZWRcIiB8fCBvcmlnaW5hbEV2ZW50ID09IG51bGwgfHwgb3JpZ2luYWxFdmVudC5jb25zdHJ1Y3RvciA9PT0gTW91c2VFdmVudCk7XG5cbiAgICAgICAgICAgIHZhciBldmVudFRvQmluZCA9IChpc1RvdWNoRGV2aWNlICYmICFpc01vdXNlRGV2aWNlICYmIHRvdWNoTWFwW2V2ZW50XSkgPyB0b3VjaE1hcFtldmVudF0gOiBldmVudCxcbiAgICAgICAgICAgICAgICBiaW5kaW5nQU1vdXNlRXZlbnQgPSAhKGlzVG91Y2hEZXZpY2UgJiYgIWlzTW91c2VEZXZpY2UgJiYgdG91Y2hNYXBbZXZlbnRdKTtcblxuICAgICAgICAgICAgdmFyIHBsID0gX3BhZ2VMb2NhdGlvbihvcmlnaW5hbEV2ZW50KSwgc2wgPSBfc2NyZWVuTG9jYXRpb24ob3JpZ2luYWxFdmVudCksIGNsID0gX2NsaWVudExvY2F0aW9uKG9yaWdpbmFsRXZlbnQpO1xuICAgICAgICAgICAgX2VhY2goZWwsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2VsID0gX2dlbCh0aGlzKSwgZXZ0O1xuICAgICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQgPSBvcmlnaW5hbEV2ZW50IHx8IHtcbiAgICAgICAgICAgICAgICAgICAgc2NyZWVuWDogc2xbMF0sXG4gICAgICAgICAgICAgICAgICAgIHNjcmVlblk6IHNsWzFdLFxuICAgICAgICAgICAgICAgICAgICBjbGllbnRYOiBjbFswXSxcbiAgICAgICAgICAgICAgICAgICAgY2xpZW50WTogY2xbMV1cbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgdmFyIF9kZWNvcmF0ZSA9IGZ1bmN0aW9uIChfZXZ0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXlsb2FkKSBfZXZ0LnBheWxvYWQgPSBwYXlsb2FkO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICB2YXIgZXZlbnRHZW5lcmF0b3JzID0ge1xuICAgICAgICAgICAgICAgICAgICBcIlRvdWNoRXZlbnRcIjogZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRvdWNoID0gZG9jdW1lbnQuY3JlYXRlVG91Y2god2luZG93LCBfZWwsIDAsIHBsWzBdLCBwbFsxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbFswXSwgc2xbMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xbMF0sIGNsWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAsIDAsIDAsIDApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9zc3RlcGhlbnNvbi80NDg4MDhcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0b3VjaGVzID0gZG9jdW1lbnQuY3JlYXRlVG91Y2hMaXN0KHRvdWNoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0YXJnZXRUb3VjaGVzID0gZG9jdW1lbnQuY3JlYXRlVG91Y2hMaXN0KHRvdWNoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjaGFuZ2VkVG91Y2hlcyA9IGRvY3VtZW50LmNyZWF0ZVRvdWNoTGlzdCh0b3VjaCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBldnQuaW5pdFRvdWNoRXZlbnQoZXZlbnRUb0JpbmQsIHRydWUsIHRydWUsIHdpbmRvdywgbnVsbCwgc2xbMF0sIHNsWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsWzBdLCBjbFsxXSwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG91Y2hlcywgdGFyZ2V0VG91Y2hlcywgY2hhbmdlZFRvdWNoZXMsIDEsIDApO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBcIk1vdXNlRXZlbnRzXCI6IGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2dC5pbml0TW91c2VFdmVudChldmVudFRvQmluZCwgdHJ1ZSwgdHJ1ZSwgd2luZG93LCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNsWzBdLCBzbFsxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbFswXSwgY2xbMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIDEsIF9lbCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChTbmlmZi5hbmRyb2lkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQW5kcm9pZCdzIHRvdWNoIGV2ZW50cyBhcmUgbm90IHN0YW5kYXJkLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ID0gZG9jdW1lbnQuY3JlYXRlVG91Y2god2luZG93LCBfZWwsIDAsIHBsWzBdLCBwbFsxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2xbMF0sIHNsWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbFswXSwgY2xbMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAsIDAsIDAsIDApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZ0LnRvdWNoZXMgPSBldnQudGFyZ2V0VG91Y2hlcyA9IGV2dC5jaGFuZ2VkVG91Y2hlcyA9IGRvY3VtZW50LmNyZWF0ZVRvdWNoTGlzdCh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBpZiAoZG9jdW1lbnQuY3JlYXRlRXZlbnQpIHtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgaXRlID0gIWJpbmRpbmdBTW91c2VFdmVudCAmJiAhb3JpZ2luYWxJc01vdXNlICYmIChpc1RvdWNoRGV2aWNlICYmIHRvdWNoTWFwW2V2ZW50XSAmJiAhU25pZmYuYW5kcm9pZCksXG4gICAgICAgICAgICAgICAgICAgICAgICBldnROYW1lID0gaXRlID8gXCJUb3VjaEV2ZW50XCIgOiBcIk1vdXNlRXZlbnRzXCI7XG5cbiAgICAgICAgICAgICAgICAgICAgZXZ0ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoZXZ0TmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50R2VuZXJhdG9yc1tldnROYW1lXShldnQpO1xuICAgICAgICAgICAgICAgICAgICBfZGVjb3JhdGUoZXZ0KTtcbiAgICAgICAgICAgICAgICAgICAgX2VsLmRpc3BhdGNoRXZlbnQoZXZ0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZG9jdW1lbnQuY3JlYXRlRXZlbnRPYmplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgZXZ0ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnRPYmplY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgZXZ0LmV2ZW50VHlwZSA9IGV2dC5ldmVudE5hbWUgPSBldmVudFRvQmluZDtcbiAgICAgICAgICAgICAgICAgICAgZXZ0LnNjcmVlblggPSBzbFswXTtcbiAgICAgICAgICAgICAgICAgICAgZXZ0LnNjcmVlblkgPSBzbFsxXTtcbiAgICAgICAgICAgICAgICAgICAgZXZ0LmNsaWVudFggPSBjbFswXTtcbiAgICAgICAgICAgICAgICAgICAgZXZ0LmNsaWVudFkgPSBjbFsxXTtcbiAgICAgICAgICAgICAgICAgICAgX2RlY29yYXRlKGV2dCk7XG4gICAgICAgICAgICAgICAgICAgIF9lbC5maXJlRXZlbnQoJ29uJyArIGV2ZW50VG9CaW5kLCBldnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU3RhdGljIG1ldGhvZCB0byBhc3Npc3QgaW4gJ2NvbnN1bWluZycgYW4gZWxlbWVudDogdXNlcyBgc3RvcFByb3BhZ2F0aW9uYCB3aGVyZSBhdmFpbGFibGUsIG9yIHNldHNcbiAgICAgKiBgZS5yZXR1cm5WYWx1ZT1mYWxzZWAgd2hlcmUgaXQgaXMgbm90LlxuICAgICAqIEBtZXRob2QgTW90dGxlLmNvbnN1bWVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IHRvIGNvbnN1bWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtkb05vdFByZXZlbnREZWZhdWx0PWZhbHNlXSBJZiB0cnVlLCBkb2VzIG5vdCBjYWxsIGBwcmV2ZW50RGVmYXVsdCgpYCBvbiB0aGUgZXZlbnQuXG4gICAgICovXG4gICAgcm9vdC5Nb3R0bGUuY29uc3VtZSA9IGZ1bmN0aW9uIChlLCBkb05vdFByZXZlbnREZWZhdWx0KSB7XG4gICAgICAgIGlmIChlLnN0b3BQcm9wYWdhdGlvbilcbiAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGUucmV0dXJuVmFsdWUgPSBmYWxzZTtcblxuICAgICAgICBpZiAoIWRvTm90UHJldmVudERlZmF1bHQgJiYgZS5wcmV2ZW50RGVmYXVsdClcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgcGFnZSBsb2NhdGlvbiBjb3JyZXNwb25kaW5nIHRvIHRoZSBnaXZlbiBldmVudC4gRm9yIHRvdWNoIGV2ZW50cyB0aGlzIG1lYW5zIGdldCB0aGUgcGFnZSBsb2NhdGlvbiBvZiB0aGUgZmlyc3QgdG91Y2guXG4gICAgICogQG1ldGhvZCBNb3R0bGUucGFnZUxvY2F0aW9uXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCB0byBnZXQgcGFnZSBsb2NhdGlvbiBmb3IuXG4gICAgICogQHJldHVybiB7TnVtYmVyW119IFtsZWZ0LCB0b3BdIGZvciB0aGUgZ2l2ZW4gZXZlbnQuXG4gICAgICovXG4gICAgcm9vdC5Nb3R0bGUucGFnZUxvY2F0aW9uID0gX3BhZ2VMb2NhdGlvbjtcblxuICAgIC8qKlxuICAgICAqIEZvcmNlcyB0b3VjaCBldmVudHMgdG8gYmUgdHVybmVkIFwib25cIi4gVXNlZnVsIGZvciB0ZXN0aW5nOiBldmVuIGlmIHlvdSBkb24ndCBoYXZlIGEgdG91Y2ggZGV2aWNlLCB5b3UgY2FuIHN0aWxsXG4gICAgICogdHJpZ2dlciBhIHRvdWNoIGV2ZW50IHdoZW4gdGhpcyBpcyBzd2l0Y2hlZCBvbiBhbmQgaXQgd2lsbCBiZSBjYXB0dXJlZCBhbmQgYWN0ZWQgb24uXG4gICAgICogQG1ldGhvZCBzZXRGb3JjZVRvdWNoRXZlbnRzXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZSBJZiB0cnVlLCBmb3JjZSB0b3VjaCBldmVudHMgdG8gYmUgb24uXG4gICAgICovXG4gICAgcm9vdC5Nb3R0bGUuc2V0Rm9yY2VUb3VjaEV2ZW50cyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpc1RvdWNoRGV2aWNlID0gdmFsdWU7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEZvcmNlcyBtb3VzZSBldmVudHMgdG8gYmUgdHVybmVkIFwib25cIi4gVXNlZnVsIGZvciB0ZXN0aW5nOiBldmVuIGlmIHlvdSBkb24ndCBoYXZlIGEgbW91c2UsIHlvdSBjYW4gc3RpbGxcbiAgICAgKiB0cmlnZ2VyIGEgbW91c2UgZXZlbnQgd2hlbiB0aGlzIGlzIHN3aXRjaGVkIG9uIGFuZCBpdCB3aWxsIGJlIGNhcHR1cmVkIGFuZCBhY3RlZCBvbi5cbiAgICAgKiBAbWV0aG9kIHNldEZvcmNlTW91c2VFdmVudHNcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlIElmIHRydWUsIGZvcmNlIG1vdXNlIGV2ZW50cyB0byBiZSBvbi5cbiAgICAgKi9cbiAgICByb290Lk1vdHRsZS5zZXRGb3JjZU1vdXNlRXZlbnRzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlzTW91c2VEZXZpY2UgPSB2YWx1ZTtcbiAgICB9O1xuXG4gICAgcm9vdC5Nb3R0bGUudmVyc2lvbiA9IFwiMC44LjBcIjtcblxuICAgIGlmICh0eXBlb2YgZXhwb3J0cyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBleHBvcnRzLk1vdHRsZSA9IHJvb3QuTW90dGxlO1xuICAgIH1cblxufSkuY2FsbCh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiID8gdGhpcyA6IHdpbmRvdyk7XG5cbi8qKlxuIGRyYWcvZHJvcCBmdW5jdGlvbmFsaXR5IGZvciB1c2Ugd2l0aCBqc1BsdW1iIGJ1dCB3aXRoXG4gbm8ga25vd2xlZGdlIG9mIGpzUGx1bWIuIHN1cHBvcnRzIG11bHRpcGxlIHNjb3BlcyAoc2VwYXJhdGVkIGJ5IHdoaXRlc3BhY2UpLCBkcmFnZ2luZ1xuIG11bHRpcGxlIGVsZW1lbnRzLCBjb25zdHJhaW4gdG8gcGFyZW50LCBkcm9wIGZpbHRlcnMsIGRyYWcgc3RhcnQgZmlsdGVycywgY3VzdG9tXG4gY3NzIGNsYXNzZXMuXG5cbiBhIGxvdCBvZiB0aGUgZnVuY3Rpb25hbGl0eSBvZiB0aGlzIHNjcmlwdCBpcyBleHBlY3RlZCB0byBiZSBwbHVnZ2VkIGluOlxuXG4gYWRkQ2xhc3NcbiByZW1vdmVDbGFzc1xuXG4gYWRkRXZlbnRcbiByZW1vdmVFdmVudFxuXG4gZ2V0UG9zaXRpb25cbiBzZXRQb3NpdGlvblxuIGdldFNpemVcblxuIGluZGV4T2ZcbiBpbnRlcnNlY3RzXG5cbiB0aGUgbmFtZSBjYW1lIGZyb20gaGVyZTpcblxuIGh0dHA6Ly9tcnNoYXJwb2JsdW50by5naXRodWIuaW8vZm9zd2lnLmpzL1xuXG4gY29weXJpZ2h0IDIwMTYganNQbHVtYlxuICovXG5cbjsoZnVuY3Rpb24oKSB7XG5cbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgcm9vdCA9IHRoaXM7XG5cbiAgICB2YXIgX3N1Z2dlc3QgPSBmdW5jdGlvbihsaXN0LCBpdGVtLCBoZWFkKSB7XG4gICAgICAgIGlmIChsaXN0LmluZGV4T2YoaXRlbSkgPT09IC0xKSB7XG4gICAgICAgICAgICBoZWFkID8gbGlzdC51bnNoaWZ0KGl0ZW0pIDogbGlzdC5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICB2YXIgX3ZhbnF1aXNoID0gZnVuY3Rpb24obGlzdCwgaXRlbSkge1xuICAgICAgICB2YXIgaWR4ID0gbGlzdC5pbmRleE9mKGl0ZW0pO1xuICAgICAgICBpZiAoaWR4ICE9IC0xKSBsaXN0LnNwbGljZShpZHgsIDEpO1xuICAgIH07XG5cbiAgICB2YXIgX2RpZmZlcmVuY2UgPSBmdW5jdGlvbihsMSwgbDIpIHtcbiAgICAgICAgdmFyIGQgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsMS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGwyLmluZGV4T2YobDFbaV0pID09IC0xKVxuICAgICAgICAgICAgICAgIGQucHVzaChsMVtpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGQ7XG4gICAgfTtcblxuICAgIHZhciBfaXNTdHJpbmcgPSBmdW5jdGlvbihmKSB7XG4gICAgICAgIHJldHVybiBmID09IG51bGwgPyBmYWxzZSA6ICh0eXBlb2YgZiA9PT0gXCJzdHJpbmdcIiB8fCBmLmNvbnN0cnVjdG9yID09IFN0cmluZyk7XG4gICAgfTtcblxuICAgIHZhciBnZXRPZmZzZXRSZWN0ID0gZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgLy8gKDEpXG4gICAgICAgIHZhciBib3ggPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgICAgICAgYm9keSA9IGRvY3VtZW50LmJvZHksXG4gICAgICAgICAgICBkb2NFbGVtID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LFxuICAgICAgICAvLyAoMilcbiAgICAgICAgICAgIHNjcm9sbFRvcCA9IHdpbmRvdy5wYWdlWU9mZnNldCB8fCBkb2NFbGVtLnNjcm9sbFRvcCB8fCBib2R5LnNjcm9sbFRvcCxcbiAgICAgICAgICAgIHNjcm9sbExlZnQgPSB3aW5kb3cucGFnZVhPZmZzZXQgfHwgZG9jRWxlbS5zY3JvbGxMZWZ0IHx8IGJvZHkuc2Nyb2xsTGVmdCxcbiAgICAgICAgLy8gKDMpXG4gICAgICAgICAgICBjbGllbnRUb3AgPSBkb2NFbGVtLmNsaWVudFRvcCB8fCBib2R5LmNsaWVudFRvcCB8fCAwLFxuICAgICAgICAgICAgY2xpZW50TGVmdCA9IGRvY0VsZW0uY2xpZW50TGVmdCB8fCBib2R5LmNsaWVudExlZnQgfHwgMCxcbiAgICAgICAgLy8gKDQpXG4gICAgICAgICAgICB0b3AgID0gYm94LnRvcCArICBzY3JvbGxUb3AgLSBjbGllbnRUb3AsXG4gICAgICAgICAgICBsZWZ0ID0gYm94LmxlZnQgKyBzY3JvbGxMZWZ0IC0gY2xpZW50TGVmdDtcblxuICAgICAgICByZXR1cm4geyB0b3A6IE1hdGgucm91bmQodG9wKSwgbGVmdDogTWF0aC5yb3VuZChsZWZ0KSB9O1xuICAgIH07XG5cbiAgICB2YXIgbWF0Y2hlc1NlbGVjdG9yID0gZnVuY3Rpb24oZWwsIHNlbGVjdG9yLCBjdHgpIHtcbiAgICAgICAgY3R4ID0gY3R4IHx8IGVsLnBhcmVudE5vZGU7XG4gICAgICAgIHZhciBwb3NzaWJsZXMgPSBjdHgucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9zc2libGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAocG9zc2libGVzW2ldID09PSBlbClcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIHZhciBpZXYgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgcnYgPSAtMTtcbiAgICAgICAgICAgIGlmIChuYXZpZ2F0b3IuYXBwTmFtZSA9PSAnTWljcm9zb2Z0IEludGVybmV0IEV4cGxvcmVyJykge1xuICAgICAgICAgICAgICAgIHZhciB1YSA9IG5hdmlnYXRvci51c2VyQWdlbnQsXG4gICAgICAgICAgICAgICAgICAgIHJlID0gbmV3IFJlZ0V4cChcIk1TSUUgKFswLTldezEsfVtcXC4wLTldezAsfSlcIik7XG4gICAgICAgICAgICAgICAgaWYgKHJlLmV4ZWModWEpICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIHJ2ID0gcGFyc2VGbG9hdChSZWdFeHAuJDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJ2O1xuICAgICAgICB9KSgpLFxuICAgICAgICBERUZBVUxUX0dSSURfWCA9IDUwLFxuICAgICAgICBERUZBVUxUX0dSSURfWSA9IDUwLFxuICAgICAgICBpc0lFTFQ5ID0gaWV2ID4gLTEgJiYgaWV2IDwgOSxcbiAgICAgICAgaXNJRTkgPSBpZXYgPT0gOSxcbiAgICAgICAgX3BsID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgaWYgKGlzSUVMVDkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWyBlLmNsaWVudFggKyBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCwgZS5jbGllbnRZICsgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHRzID0gX3RvdWNoZXMoZSksIHQgPSBfZ2V0VG91Y2godHMsIDApO1xuICAgICAgICAgICAgICAgIC8vIGZvciBJRTkgcGFnZVggbWlnaHQgYmUgbnVsbCBpZiB0aGUgZXZlbnQgd2FzIHN5bnRoZXNpemVkLiBXZSB0cnkgZm9yIHBhZ2VYL3BhZ2VZIGZpcnN0LFxuICAgICAgICAgICAgICAgIC8vIGZhbGxpbmcgYmFjayB0byBjbGllbnRYL2NsaWVudFkgaWYgbmVjZXNzYXJ5LiBJbiBldmVyeSBvdGhlciBicm93c2VyIHdlIHdhbnQgdG8gdXNlIHBhZ2VYL3BhZ2VZLlxuICAgICAgICAgICAgICAgIHJldHVybiBpc0lFOSA/IFt0LnBhZ2VYIHx8IHQuY2xpZW50WCwgdC5wYWdlWSB8fCB0LmNsaWVudFldIDogW3QucGFnZVgsIHQucGFnZVldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBfZ2V0VG91Y2ggPSBmdW5jdGlvbih0b3VjaGVzLCBpZHgpIHsgcmV0dXJuIHRvdWNoZXMuaXRlbSA/IHRvdWNoZXMuaXRlbShpZHgpIDogdG91Y2hlc1tpZHhdOyB9LFxuICAgICAgICBfdG91Y2hlcyA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBlLnRvdWNoZXMgJiYgZS50b3VjaGVzLmxlbmd0aCA+IDAgPyBlLnRvdWNoZXMgOlxuICAgICAgICAgICAgICAgICAgICBlLmNoYW5nZWRUb3VjaGVzICYmIGUuY2hhbmdlZFRvdWNoZXMubGVuZ3RoID4gMCA/IGUuY2hhbmdlZFRvdWNoZXMgOlxuICAgICAgICAgICAgICAgICAgICBlLnRhcmdldFRvdWNoZXMgJiYgZS50YXJnZXRUb3VjaGVzLmxlbmd0aCA+IDAgPyBlLnRhcmdldFRvdWNoZXMgOlxuICAgICAgICAgICAgICAgIFsgZSBdO1xuICAgICAgICB9LFxuICAgICAgICBfY2xhc3NlcyA9IHtcbiAgICAgICAgICAgIGRyYWdnYWJsZTpcImthdGF2b3Jpby1kcmFnZ2FibGVcIiwgICAgLy8gZHJhZ2dhYmxlIGVsZW1lbnRzXG4gICAgICAgICAgICBkcm9wcGFibGU6XCJrYXRhdm9yaW8tZHJvcHBhYmxlXCIsICAgIC8vIGRyb3BwYWJsZSBlbGVtZW50c1xuICAgICAgICAgICAgZHJhZyA6IFwia2F0YXZvcmlvLWRyYWdcIiwgICAgICAgICAgICAvLyBlbGVtZW50cyBjdXJyZW50bHkgYmVpbmcgZHJhZ2dlZFxuICAgICAgICAgICAgc2VsZWN0ZWQ6XCJrYXRhdm9yaW8tZHJhZy1zZWxlY3RlZFwiLCAvLyBlbGVtZW50cyBpbiBjdXJyZW50IGRyYWcgc2VsZWN0aW9uXG4gICAgICAgICAgICBhY3RpdmUgOiBcImthdGF2b3Jpby1kcmFnLWFjdGl2ZVwiLCAgIC8vIGRyb3BwYWJsZXMgdGhhdCBhcmUgdGFyZ2V0cyBvZiBhIGN1cnJlbnRseSBkcmFnZ2VkIGVsZW1lbnRcbiAgICAgICAgICAgIGhvdmVyIDogXCJrYXRhdm9yaW8tZHJhZy1ob3ZlclwiLCAgICAgLy8gZHJvcHBhYmxlcyBvdmVyIHdoaWNoIGEgbWF0Y2hpbmcgZHJhZyBlbGVtZW50IGlzIGhvdmVyaW5nXG4gICAgICAgICAgICBub1NlbGVjdCA6IFwia2F0YXZvcmlvLWRyYWctbm8tc2VsZWN0XCIsIC8vIGFkZGVkIHRvIHRoZSBib2R5IHRvIHByb3ZpZGUgYSBob29rIHRvIHN1cHByZXNzIHRleHQgc2VsZWN0aW9uXG4gICAgICAgICAgICBnaG9zdFByb3h5Olwia2F0YXZvcmlvLWdob3N0LXByb3h5XCIgIC8vIGFkZGVkIHRvIGEgZ2hvc3QgcHJveHkgZWxlbWVudCBpbiB1c2Ugd2hlbiBhIGRyYWcgaGFzIGV4aXRlZCB0aGUgYm91bmRzIG9mIGl0cyBwYXJlbnQuXG4gICAgICAgIH0sXG4gICAgICAgIF9kZWZhdWx0U2NvcGUgPSBcImthdGF2b3Jpby1kcmFnLXNjb3BlXCIsXG4gICAgICAgIF9ldmVudHMgPSBbIFwic3RvcFwiLCBcInN0YXJ0XCIsIFwiZHJhZ1wiLCBcImRyb3BcIiwgXCJvdmVyXCIsIFwib3V0XCIsIFwiYmVmb3JlU3RhcnRcIiBdLFxuICAgICAgICBfZGV2TnVsbCA9IGZ1bmN0aW9uKCkge30sXG4gICAgICAgIF90cnVlID0gZnVuY3Rpb24oKSB7IHJldHVybiB0cnVlOyB9LFxuICAgICAgICBfZm9yZWFjaCA9IGZ1bmN0aW9uKGwsIGZuLCBmcm9tKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAobFtpXSAhPSBmcm9tKVxuICAgICAgICAgICAgICAgICAgICBmbihsW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgX3NldERyb3BwYWJsZXNBY3RpdmUgPSBmdW5jdGlvbihkZCwgdmFsLCBhbmRIb3ZlciwgZHJhZykge1xuICAgICAgICAgICAgX2ZvcmVhY2goZGQsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICBlLnNldEFjdGl2ZSh2YWwpO1xuICAgICAgICAgICAgICAgIGlmICh2YWwpIGUudXBkYXRlUG9zaXRpb24oKTtcbiAgICAgICAgICAgICAgICBpZiAoYW5kSG92ZXIpIGUuc2V0SG92ZXIoZHJhZywgdmFsKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBfZWFjaCA9IGZ1bmN0aW9uKG9iaiwgZm4pIHtcbiAgICAgICAgICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuO1xuICAgICAgICAgICAgb2JqID0gIV9pc1N0cmluZyhvYmopICYmIChvYmoudGFnTmFtZSA9PSBudWxsICYmIG9iai5sZW5ndGggIT0gbnVsbCkgPyBvYmogOiBbIG9iaiBdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmoubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgZm4uYXBwbHkob2JqW2ldLCBbIG9ialtpXSBdKTtcbiAgICAgICAgfSxcbiAgICAgICAgX2NvbnN1bWUgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBpZiAoZS5zdG9wUHJvcGFnYXRpb24pIHtcbiAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGUucmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgX2RlZmF1bHRJbnB1dEZpbHRlclNlbGVjdG9yID0gXCJpbnB1dCx0ZXh0YXJlYSxzZWxlY3QsYnV0dG9uLG9wdGlvblwiLFxuICAgIC8vXG4gICAgLy8gZmlsdGVycyBvdXQgZXZlbnRzIG9uIGFsbCBpbnB1dCBlbGVtZW50cywgbGlrZSB0ZXh0YXJlYSwgY2hlY2tib3gsIGlucHV0LCBzZWxlY3QuXG4gICAgICAgIF9pbnB1dEZpbHRlciA9IGZ1bmN0aW9uKGUsIGVsLCBfa2F0YXZvcmlvKSB7XG4gICAgICAgICAgICB2YXIgdCA9IGUuc3JjRWxlbWVudCB8fCBlLnRhcmdldDtcbiAgICAgICAgICAgIHJldHVybiAhbWF0Y2hlc1NlbGVjdG9yKHQsIF9rYXRhdm9yaW8uZ2V0SW5wdXRGaWx0ZXJTZWxlY3RvcigpLCBlbCk7XG4gICAgICAgIH07XG5cbiAgICB2YXIgU3VwZXIgPSBmdW5jdGlvbihlbCwgcGFyYW1zLCBjc3MsIHNjb3BlKSB7XG4gICAgICAgIHRoaXMucGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICAgICAgICB0aGlzLmVsID0gZWw7XG4gICAgICAgIHRoaXMucGFyYW1zLmFkZENsYXNzKHRoaXMuZWwsIHRoaXMuX2NsYXNzKTtcbiAgICAgICAgdGhpcy51dWlkID0gX3V1aWQoKTtcbiAgICAgICAgdmFyIGVuYWJsZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLnNldEVuYWJsZWQgPSBmdW5jdGlvbihlKSB7IGVuYWJsZWQgPSBlOyB9O1xuICAgICAgICB0aGlzLmlzRW5hYmxlZCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gZW5hYmxlZDsgfTtcbiAgICAgICAgdGhpcy50b2dnbGVFbmFibGVkID0gZnVuY3Rpb24oKSB7IGVuYWJsZWQgPSAhZW5hYmxlZDsgfTtcbiAgICAgICAgdGhpcy5zZXRTY29wZSA9IGZ1bmN0aW9uKHNjb3Blcykge1xuICAgICAgICAgICAgdGhpcy5zY29wZXMgPSBzY29wZXMgPyBzY29wZXMuc3BsaXQoL1xccysvKSA6IFsgc2NvcGUgXTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5hZGRTY29wZSA9IGZ1bmN0aW9uKHNjb3Blcykge1xuICAgICAgICAgICAgdmFyIG0gPSB7fTtcbiAgICAgICAgICAgIF9lYWNoKHRoaXMuc2NvcGVzLCBmdW5jdGlvbihzKSB7IG1bc10gPSB0cnVlO30pO1xuICAgICAgICAgICAgX2VhY2goc2NvcGVzID8gc2NvcGVzLnNwbGl0KC9cXHMrLykgOiBbXSwgZnVuY3Rpb24ocykgeyBtW3NdID0gdHJ1ZTt9KTtcbiAgICAgICAgICAgIHRoaXMuc2NvcGVzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpIGluIG0pIHRoaXMuc2NvcGVzLnB1c2goaSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucmVtb3ZlU2NvcGUgPSBmdW5jdGlvbihzY29wZXMpIHtcbiAgICAgICAgICAgIHZhciBtID0ge307XG4gICAgICAgICAgICBfZWFjaCh0aGlzLnNjb3BlcywgZnVuY3Rpb24ocykgeyBtW3NdID0gdHJ1ZTt9KTtcbiAgICAgICAgICAgIF9lYWNoKHNjb3BlcyA/IHNjb3Blcy5zcGxpdCgvXFxzKy8pIDogW10sIGZ1bmN0aW9uKHMpIHsgZGVsZXRlIG1bc107fSk7XG4gICAgICAgICAgICB0aGlzLnNjb3BlcyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSBpbiBtKSB0aGlzLnNjb3Blcy5wdXNoKGkpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnRvZ2dsZVNjb3BlID0gZnVuY3Rpb24oc2NvcGVzKSB7XG4gICAgICAgICAgICB2YXIgbSA9IHt9O1xuICAgICAgICAgICAgX2VhY2godGhpcy5zY29wZXMsIGZ1bmN0aW9uKHMpIHsgbVtzXSA9IHRydWU7fSk7XG4gICAgICAgICAgICBfZWFjaChzY29wZXMgPyBzY29wZXMuc3BsaXQoL1xccysvKSA6IFtdLCBmdW5jdGlvbihzKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1bc10pIGRlbGV0ZSBtW3NdO1xuICAgICAgICAgICAgICAgIGVsc2UgbVtzXSA9IHRydWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuc2NvcGVzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpIGluIG0pIHRoaXMuc2NvcGVzLnB1c2goaSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc2V0U2NvcGUocGFyYW1zLnNjb3BlKTtcbiAgICAgICAgdGhpcy5rID0gcGFyYW1zLmthdGF2b3JpbztcbiAgICAgICAgcmV0dXJuIHBhcmFtcy5rYXRhdm9yaW87XG4gICAgfTtcblxuICAgIHZhciBUUlVFID0gZnVuY3Rpb24oKSB7IHJldHVybiB0cnVlOyB9O1xuICAgIHZhciBGQUxTRSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gZmFsc2U7IH07XG5cbiAgICB2YXIgRHJhZyA9IGZ1bmN0aW9uKGVsLCBwYXJhbXMsIGNzcywgc2NvcGUpIHtcbiAgICAgICAgdGhpcy5fY2xhc3MgPSBjc3MuZHJhZ2dhYmxlO1xuICAgICAgICB2YXIgayA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMucmlnaHRCdXR0b25DYW5EcmFnID0gdGhpcy5wYXJhbXMucmlnaHRCdXR0b25DYW5EcmFnO1xuICAgICAgICB2YXIgZG93bkF0ID0gWzAsMF0sIHBvc0F0RG93biA9IG51bGwsIHBhZ2VQb3NBdERvd24gPSBudWxsLCBwYWdlRGVsdGEgPSBbMCwwXSwgbW92aW5nID0gZmFsc2UsXG4gICAgICAgICAgICBjb25zdW1lU3RhcnRFdmVudCA9IHRoaXMucGFyYW1zLmNvbnN1bWVTdGFydEV2ZW50ICE9PSBmYWxzZSxcbiAgICAgICAgICAgIGRyYWdFbCA9IHRoaXMuZWwsXG4gICAgICAgICAgICBjbG9uZSA9IHRoaXMucGFyYW1zLmNsb25lLFxuICAgICAgICAgICAgc2Nyb2xsID0gdGhpcy5wYXJhbXMuc2Nyb2xsLFxuICAgICAgICAgICAgX211bHRpcGxlRHJvcCA9IHBhcmFtcy5tdWx0aXBsZURyb3AgIT09IGZhbHNlLFxuICAgICAgICAgICAgaXNDb25zdHJhaW5lZCA9IGZhbHNlLFxuICAgICAgICAgICAgdXNlR2hvc3RQcm94eSA9IHBhcmFtcy5naG9zdFByb3h5ID09PSB0cnVlID8gVFJVRSA6IHBhcmFtcy5naG9zdFByb3h5ICYmIHR5cGVvZiBwYXJhbXMuZ2hvc3RQcm94eSA9PT0gXCJmdW5jdGlvblwiID8gcGFyYW1zLmdob3N0UHJveHkgOiBGQUxTRSxcbiAgICAgICAgICAgIGdob3N0UHJveHkgPSBmdW5jdGlvbihlbCkgeyByZXR1cm4gZWwuY2xvbmVOb2RlKHRydWUpOyB9O1xuXG4gICAgICAgIHZhciBzbmFwVGhyZXNob2xkID0gcGFyYW1zLnNuYXBUaHJlc2hvbGQgfHwgNSxcbiAgICAgICAgICAgIF9zbmFwID0gZnVuY3Rpb24ocG9zLCB4LCB5LCB0aHJlc2hvbGRYLCB0aHJlc2hvbGRZKSB7XG4gICAgICAgICAgICAgICAgdGhyZXNob2xkWCA9IHRocmVzaG9sZFggfHwgc25hcFRocmVzaG9sZDtcbiAgICAgICAgICAgICAgICB0aHJlc2hvbGRZID0gdGhyZXNob2xkWSB8fCBzbmFwVGhyZXNob2xkO1xuICAgICAgICAgICAgICAgIHZhciBfZHggPSBNYXRoLmZsb29yKHBvc1swXSAvIHgpLFxuICAgICAgICAgICAgICAgICAgICBfZHhsID0geCAqIF9keCxcbiAgICAgICAgICAgICAgICAgICAgX2R4dCA9IF9keGwgKyB4LFxuICAgICAgICAgICAgICAgICAgICBfeCA9IE1hdGguYWJzKHBvc1swXSAtIF9keGwpIDw9IHRocmVzaG9sZFggPyBfZHhsIDogTWF0aC5hYnMoX2R4dCAtIHBvc1swXSkgPD0gdGhyZXNob2xkWCA/IF9keHQgOiBwb3NbMF07XG5cbiAgICAgICAgICAgICAgICB2YXIgX2R5ID0gTWF0aC5mbG9vcihwb3NbMV0gLyB5KSxcbiAgICAgICAgICAgICAgICAgICAgX2R5bCA9IHkgKiBfZHksXG4gICAgICAgICAgICAgICAgICAgIF9keXQgPSBfZHlsICsgeSxcbiAgICAgICAgICAgICAgICAgICAgX3kgPSBNYXRoLmFicyhwb3NbMV0gLSBfZHlsKSA8PSB0aHJlc2hvbGRZID8gX2R5bCA6IE1hdGguYWJzKF9keXQgLSBwb3NbMV0pIDw9IHRocmVzaG9sZFkgPyBfZHl0IDogcG9zWzFdO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIFsgX3gsIF95XTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5wb3NzZXMgPSBbXTtcbiAgICAgICAgdGhpcy5wb3NzZVJvbGVzID0ge307XG5cbiAgICAgICAgdGhpcy50b0dyaWQgPSBmdW5jdGlvbihwb3MpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBhcmFtcy5ncmlkID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcG9zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9zbmFwKHBvcywgdGhpcy5wYXJhbXMuZ3JpZFswXSwgdGhpcy5wYXJhbXMuZ3JpZFsxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5zbmFwID0gZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICAgICAgaWYgKGRyYWdFbCA9PSBudWxsKSByZXR1cm47XG4gICAgICAgICAgICB4ID0geCB8fCAodGhpcy5wYXJhbXMuZ3JpZCA/IHRoaXMucGFyYW1zLmdyaWRbMF0gOiBERUZBVUxUX0dSSURfWCk7XG4gICAgICAgICAgICB5ID0geSB8fCAodGhpcy5wYXJhbXMuZ3JpZCA/IHRoaXMucGFyYW1zLmdyaWRbMV0gOiBERUZBVUxUX0dSSURfWSk7XG4gICAgICAgICAgICB2YXIgcCA9IHRoaXMucGFyYW1zLmdldFBvc2l0aW9uKGRyYWdFbCk7XG4gICAgICAgICAgICB0aGlzLnBhcmFtcy5zZXRQb3NpdGlvbihkcmFnRWwsIF9zbmFwKHAsIHgsIHksIHgsIHkpKTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLnNldFVzZUdob3N0UHJveHkgPSBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICAgIHVzZUdob3N0UHJveHkgPSB2YWwgPyBUUlVFIDogRkFMU0U7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGNvbnN0cmFpbjtcbiAgICAgICAgdmFyIG5lZ2F0aXZlRmlsdGVyID0gZnVuY3Rpb24ocG9zKSB7XG4gICAgICAgICAgICByZXR1cm4gKHBhcmFtcy5hbGxvd05lZ2F0aXZlID09PSBmYWxzZSkgPyBbIE1hdGgubWF4ICgwLCBwb3NbMF0pLCBNYXRoLm1heCgwLCBwb3NbMV0pIF0gOiBwb3M7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIF9zZXRDb25zdHJhaW4gPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgY29uc3RyYWluID0gdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIgPyB2YWx1ZSA6IHZhbHVlID8gZnVuY3Rpb24ocG9zKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5lZ2F0aXZlRmlsdGVyKFtcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5tYXgoMCwgTWF0aC5taW4oY29uc3RyYWluUmVjdC53IC0gdGhpcy5zaXplWzBdLCBwb3NbMF0pKSxcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5tYXgoMCwgTWF0aC5taW4oY29uc3RyYWluUmVjdC5oIC0gdGhpcy5zaXplWzFdLCBwb3NbMV0pKVxuICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgfS5iaW5kKHRoaXMpIDogZnVuY3Rpb24ocG9zKSB7IHJldHVybiBuZWdhdGl2ZUZpbHRlcihwb3MpOyB9O1xuICAgICAgICB9LmJpbmQodGhpcyk7XG5cbiAgICAgICAgX3NldENvbnN0cmFpbih0eXBlb2YgdGhpcy5wYXJhbXMuY29uc3RyYWluID09PSBcImZ1bmN0aW9uXCIgPyB0aGlzLnBhcmFtcy5jb25zdHJhaW4gIDogKHRoaXMucGFyYW1zLmNvbnN0cmFpbiB8fCB0aGlzLnBhcmFtcy5jb250YWlubWVudCkpO1xuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgd2hldGhlciBvciBub3QgdGhlIERyYWcgaXMgY29uc3RyYWluZWQuIEEgdmFsdWUgb2YgJ3RydWUnIG1lYW5zIGNvbnN0cmFpbiB0byBwYXJlbnQgYm91bmRzOyBhIGZ1bmN0aW9uXG4gICAgICAgICAqIHdpbGwgYmUgZXhlY3V0ZWQgYW5kIHJldHVybnMgdHJ1ZSBpZiB0aGUgcG9zaXRpb24gaXMgYWxsb3dlZC5cbiAgICAgICAgICogQHBhcmFtIHZhbHVlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNldENvbnN0cmFpbiA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICBfc2V0Q29uc3RyYWluKHZhbHVlKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgcmV2ZXJ0RnVuY3Rpb247XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIGEgZnVuY3Rpb24gdG8gY2FsbCBvbiBkcmFnIHN0b3AsIHdoaWNoLCBpZiBpdCByZXR1cm5zIHRydWUsIGluZGljYXRlcyB0aGF0IHRoZSBnaXZlbiBlbGVtZW50IHNob3VsZFxuICAgICAgICAgKiByZXZlcnQgdG8gaXRzIHBvc2l0aW9uIGJlZm9yZSB0aGUgcHJldmlvdXMgZHJhZy5cbiAgICAgICAgICogQHBhcmFtIGZuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNldFJldmVydCA9IGZ1bmN0aW9uKGZuKSB7XG4gICAgICAgICAgICByZXZlcnRGdW5jdGlvbiA9IGZuO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBfYXNzaWduSWQgPSBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iaiA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqLl9rYXRhdm9yaW9JZCA9IF91dWlkKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvYmouX2thdGF2b3Jpb0lkO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgLy8gYSBtYXAgb2YgeyBzcGVjIC0+IFsgZm4sIGV4Y2x1c2lvbiBdIH0gZW50cmllcy5cbiAgICAgICAgICAgIF9maWx0ZXJzID0ge30sXG4gICAgICAgICAgICBfdGVzdEZpbHRlciA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gX2ZpbHRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGYgPSBfZmlsdGVyc1trZXldO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcnYgPSBmWzBdKGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZlsxXSkgcnYgPSAhcnY7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcnYpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3NldEZpbHRlciA9IHRoaXMuc2V0RmlsdGVyID0gZnVuY3Rpb24oZiwgX2V4Y2x1ZGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoZikge1xuICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0gX2Fzc2lnbklkKGYpO1xuICAgICAgICAgICAgICAgICAgICBfZmlsdGVyc1trZXldID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ID0gZS5zcmNFbGVtZW50IHx8IGUudGFyZ2V0LCBtO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaXNTdHJpbmcoZikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbSA9IG1hdGNoZXNTZWxlY3Rvcih0LCBmLCBlbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBmID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbSA9IGYoZSwgZWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2V4Y2x1ZGUgIT09IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIF07XG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2FkZEZpbHRlciA9IHRoaXMuYWRkRmlsdGVyID0gX3NldEZpbHRlcixcbiAgICAgICAgICAgIF9yZW1vdmVGaWx0ZXIgPSB0aGlzLnJlbW92ZUZpbHRlciA9IGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gdHlwZW9mIGYgPT0gXCJmdW5jdGlvblwiID8gZi5fa2F0YXZvcmlvSWQgOiBmO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBfZmlsdGVyc1trZXldO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmNsZWFyQWxsRmlsdGVycyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgX2ZpbHRlcnMgPSB7fTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmNhbkRyYWcgPSB0aGlzLnBhcmFtcy5jYW5EcmFnIHx8IF90cnVlO1xuXG4gICAgICAgIHZhciBjb25zdHJhaW5SZWN0LFxuICAgICAgICAgICAgbWF0Y2hpbmdEcm9wcGFibGVzID0gW10sIGludGVyc2VjdGluZ0Ryb3BwYWJsZXMgPSBbXTtcblxuICAgICAgICB0aGlzLmRvd25MaXN0ZW5lciA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIHZhciBpc05vdFJpZ2h0Q2xpY2sgPSB0aGlzLnJpZ2h0QnV0dG9uQ2FuRHJhZyB8fCAoZS53aGljaCAhPT0gMyAmJiBlLmJ1dHRvbiAhPT0gMik7XG4gICAgICAgICAgICBpZiAoaXNOb3RSaWdodENsaWNrICYmIHRoaXMuaXNFbmFibGVkKCkgJiYgdGhpcy5jYW5EcmFnKCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2YgPSAgX3Rlc3RGaWx0ZXIoZSkgJiYgX2lucHV0RmlsdGVyKGUsIHRoaXMuZWwsIHRoaXMuayk7XG4gICAgICAgICAgICAgICAgaWYgKF9mKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY2xvbmUpXG4gICAgICAgICAgICAgICAgICAgICAgICBkcmFnRWwgPSB0aGlzLmVsO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyYWdFbCA9IHRoaXMuZWwuY2xvbmVOb2RlKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZHJhZ0VsLnNldEF0dHJpYnV0ZShcImlkXCIsIG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZHJhZ0VsLnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGNsb25lIG5vZGUgaXMgYWRkZWQgdG8gdGhlIGJvZHk7IGdldE9mZnNldFJlY3QgZ2l2ZXMgdXMgYSB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVsYXRpdmUgdG8gdGhlIGJvZHkuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYiA9IGdldE9mZnNldFJlY3QodGhpcy5lbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkcmFnRWwuc3R5bGUubGVmdCA9IGIubGVmdCArIFwicHhcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyYWdFbC5zdHlsZS50b3AgPSBiLnRvcCArIFwicHhcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZHJhZ0VsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdW1lU3RhcnRFdmVudCAmJiBfY29uc3VtZShlKTtcbiAgICAgICAgICAgICAgICAgICAgZG93bkF0ID0gX3BsKGUpO1xuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmFtcy5iaW5kKGRvY3VtZW50LCBcIm1vdXNlbW92ZVwiLCB0aGlzLm1vdmVMaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyYW1zLmJpbmQoZG9jdW1lbnQsIFwibW91c2V1cFwiLCB0aGlzLnVwTGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgICAgICBrLm1hcmtTZWxlY3Rpb24odGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIGsubWFya1Bvc3Nlcyh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJhbXMuYWRkQ2xhc3MoZG9jdW1lbnQuYm9keSwgY3NzLm5vU2VsZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgX2Rpc3BhdGNoKFwiYmVmb3JlU3RhcnRcIiwge2VsOnRoaXMuZWwsIHBvczpwb3NBdERvd24sIGU6ZSwgZHJhZzp0aGlzfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMucGFyYW1zLmNvbnN1bWVGaWx0ZXJlZEV2ZW50cykge1xuICAgICAgICAgICAgICAgICAgICBfY29uc3VtZShlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0uYmluZCh0aGlzKTtcblxuICAgICAgICB0aGlzLm1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGlmIChkb3duQXQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIW1vdmluZykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2NvbnRpbnVlID0gX2Rpc3BhdGNoKFwic3RhcnRcIiwge2VsOnRoaXMuZWwsIHBvczpwb3NBdERvd24sIGU6ZSwgZHJhZzp0aGlzfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfY29udGludWUgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWRvd25BdCkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXJrKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbW92aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGl0IGlzIHBvc3NpYmxlIHRoYXQgdGhlIHN0YXJ0IGV2ZW50IGNhdXNlZCB0aGUgZHJhZyB0byBiZSBhYm9ydGVkLiBTbyB3ZSBjaGVja1xuICAgICAgICAgICAgICAgIC8vIGFnYWluIHRoYXQgd2UgYXJlIGN1cnJlbnRseSBkcmFnZ2luZy5cbiAgICAgICAgICAgICAgICBpZiAoZG93bkF0KSB7XG4gICAgICAgICAgICAgICAgICAgIGludGVyc2VjdGluZ0Ryb3BwYWJsZXMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBvcyA9IF9wbChlKSwgZHggPSBwb3NbMF0gLSBkb3duQXRbMF0sIGR5ID0gcG9zWzFdIC0gZG93bkF0WzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgeiA9IHRoaXMucGFyYW1zLmlnbm9yZVpvb20gPyAxIDogay5nZXRab29tKCk7XG4gICAgICAgICAgICAgICAgICAgIGR4IC89IHo7XG4gICAgICAgICAgICAgICAgICAgIGR5IC89IHo7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubW92ZUJ5KGR4LCBkeSwgZSk7XG4gICAgICAgICAgICAgICAgICAgIGsudXBkYXRlU2VsZWN0aW9uKGR4LCBkeSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIGsudXBkYXRlUG9zc2VzKGR4LCBkeSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LmJpbmQodGhpcyk7XG5cbiAgICAgICAgdGhpcy51cExpc3RlbmVyID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgaWYgKGRvd25BdCkge1xuICAgICAgICAgICAgICAgIGRvd25BdCA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJhbXMudW5iaW5kKGRvY3VtZW50LCBcIm1vdXNlbW92ZVwiLCB0aGlzLm1vdmVMaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJhbXMudW5iaW5kKGRvY3VtZW50LCBcIm1vdXNldXBcIiwgdGhpcy51cExpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmFtcy5yZW1vdmVDbGFzcyhkb2N1bWVudC5ib2R5LCBjc3Mubm9TZWxlY3QpO1xuICAgICAgICAgICAgICAgIHRoaXMudW5tYXJrKGUpO1xuICAgICAgICAgICAgICAgIGsudW5tYXJrU2VsZWN0aW9uKHRoaXMsIGUpO1xuICAgICAgICAgICAgICAgIGsudW5tYXJrUG9zc2VzKHRoaXMsIGUpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RvcChlKTtcbiAgICAgICAgICAgICAgICBrLm5vdGlmeVNlbGVjdGlvbkRyYWdTdG9wKHRoaXMsIGUpO1xuICAgICAgICAgICAgICAgIGsubm90aWZ5UG9zc2VEcmFnU3RvcCh0aGlzLCBlKTtcbiAgICAgICAgICAgICAgICBtb3ZpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAoY2xvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgZHJhZ0VsICYmIGRyYWdFbC5wYXJlbnROb2RlICYmIGRyYWdFbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGRyYWdFbCk7XG4gICAgICAgICAgICAgICAgICAgIGRyYWdFbCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaW50ZXJzZWN0aW5nRHJvcHBhYmxlcy5sZW5ndGggPSAwO1xuXG4gICAgICAgICAgICAgICAgaWYgKHJldmVydEZ1bmN0aW9uICYmIHJldmVydEZ1bmN0aW9uKHRoaXMuZWwsIHRoaXMucGFyYW1zLmdldFBvc2l0aW9uKHRoaXMuZWwpKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmFtcy5zZXRQb3NpdGlvbih0aGlzLmVsLCBwb3NBdERvd24pO1xuICAgICAgICAgICAgICAgICAgICBfZGlzcGF0Y2goXCJyZXZlcnRcIiwgdGhpcy5lbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LmJpbmQodGhpcyk7XG5cbiAgICAgICAgdGhpcy5nZXRGaWx0ZXJzID0gZnVuY3Rpb24oKSB7IHJldHVybiBfZmlsdGVyczsgfTtcblxuICAgICAgICB0aGlzLmFib3J0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoZG93bkF0ICE9IG51bGwpXG4gICAgICAgICAgICAgICAgdGhpcy51cExpc3RlbmVyKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5nZXREcmFnRWxlbWVudCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGRyYWdFbCB8fCB0aGlzLmVsO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBsaXN0ZW5lcnMgPSB7XCJzdGFydFwiOltdLCBcImRyYWdcIjpbXSwgXCJzdG9wXCI6W10sIFwib3ZlclwiOltdLCBcIm91dFwiOltdLCBcImJlZm9yZVN0YXJ0XCI6W10sIFwicmV2ZXJ0XCI6W10gfTtcbiAgICAgICAgaWYgKHBhcmFtcy5ldmVudHMuc3RhcnQpIGxpc3RlbmVycy5zdGFydC5wdXNoKHBhcmFtcy5ldmVudHMuc3RhcnQpO1xuICAgICAgICBpZiAocGFyYW1zLmV2ZW50cy5iZWZvcmVTdGFydCkgbGlzdGVuZXJzLmJlZm9yZVN0YXJ0LnB1c2gocGFyYW1zLmV2ZW50cy5iZWZvcmVTdGFydCk7XG4gICAgICAgIGlmIChwYXJhbXMuZXZlbnRzLnN0b3ApIGxpc3RlbmVycy5zdG9wLnB1c2gocGFyYW1zLmV2ZW50cy5zdG9wKTtcbiAgICAgICAgaWYgKHBhcmFtcy5ldmVudHMuZHJhZykgbGlzdGVuZXJzLmRyYWcucHVzaChwYXJhbXMuZXZlbnRzLmRyYWcpO1xuICAgICAgICBpZiAocGFyYW1zLmV2ZW50cy5yZXZlcnQpIGxpc3RlbmVycy5yZXZlcnQucHVzaChwYXJhbXMuZXZlbnRzLnJldmVydCk7XG5cbiAgICAgICAgdGhpcy5vbiA9IGZ1bmN0aW9uKGV2dCwgZm4pIHtcbiAgICAgICAgICAgIGlmIChsaXN0ZW5lcnNbZXZ0XSkgbGlzdGVuZXJzW2V2dF0ucHVzaChmbik7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5vZmYgPSBmdW5jdGlvbihldnQsIGZuKSB7XG4gICAgICAgICAgICBpZiAobGlzdGVuZXJzW2V2dF0pIHtcbiAgICAgICAgICAgICAgICB2YXIgbCA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdGVuZXJzW2V2dF0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxpc3RlbmVyc1tldnRdW2ldICE9PSBmbikgbC5wdXNoKGxpc3RlbmVyc1tldnRdW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzW2V2dF0gPSBsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBfZGlzcGF0Y2ggPSBmdW5jdGlvbihldnQsIHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAobGlzdGVuZXJzW2V2dF0pIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3RlbmVyc1tldnRdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnNbZXZ0XVtpXSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHsgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLm5vdGlmeVN0YXJ0ID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgX2Rpc3BhdGNoKFwic3RhcnRcIiwge2VsOnRoaXMuZWwsIHBvczp0aGlzLnBhcmFtcy5nZXRQb3NpdGlvbihkcmFnRWwpLCBlOmUsIGRyYWc6dGhpc30pO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuc3RvcCA9IGZ1bmN0aW9uKGUsIGZvcmNlKSB7XG4gICAgICAgICAgICBpZiAoZm9yY2UgfHwgbW92aW5nKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBvc2l0aW9ucyA9IFtdLFxuICAgICAgICAgICAgICAgICAgICBzZWwgPSBrLmdldFNlbGVjdGlvbigpLFxuICAgICAgICAgICAgICAgICAgICBkUG9zID0gdGhpcy5wYXJhbXMuZ2V0UG9zaXRpb24oZHJhZ0VsKTtcblxuICAgICAgICAgICAgICAgIGlmIChzZWwubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHAgPSB0aGlzLnBhcmFtcy5nZXRQb3NpdGlvbihzZWxbaV0uZWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25zLnB1c2goWyBzZWxbaV0uZWwsIHsgbGVmdDogcFswXSwgdG9wOiBwWzFdIH0sIHNlbFtpXSBdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25zLnB1c2goWyBkcmFnRWwsIHtsZWZ0OmRQb3NbMF0sIHRvcDpkUG9zWzFdfSwgdGhpcyBdKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBfZGlzcGF0Y2goXCJzdG9wXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgZWw6IGRyYWdFbCxcbiAgICAgICAgICAgICAgICAgICAgcG9zOiBnaG9zdFByb3h5T2Zmc2V0cyB8fCBkUG9zLFxuICAgICAgICAgICAgICAgICAgICBmaW5hbFBvczpkUG9zLFxuICAgICAgICAgICAgICAgICAgICBlOiBlLFxuICAgICAgICAgICAgICAgICAgICBkcmFnOiB0aGlzLFxuICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb246cG9zaXRpb25zXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5tYXJrID0gZnVuY3Rpb24oYW5kTm90aWZ5KSB7XG4gICAgICAgICAgICBwb3NBdERvd24gPSB0aGlzLnBhcmFtcy5nZXRQb3NpdGlvbihkcmFnRWwpO1xuICAgICAgICAgICAgcGFnZVBvc0F0RG93biA9IHRoaXMucGFyYW1zLmdldFBvc2l0aW9uKGRyYWdFbCwgdHJ1ZSk7XG4gICAgICAgICAgICBwYWdlRGVsdGEgPSBbcGFnZVBvc0F0RG93blswXSAtIHBvc0F0RG93blswXSwgcGFnZVBvc0F0RG93blsxXSAtIHBvc0F0RG93blsxXV07XG4gICAgICAgICAgICB0aGlzLnNpemUgPSB0aGlzLnBhcmFtcy5nZXRTaXplKGRyYWdFbCk7XG4gICAgICAgICAgICBtYXRjaGluZ0Ryb3BwYWJsZXMgPSBrLmdldE1hdGNoaW5nRHJvcHBhYmxlcyh0aGlzKTtcbiAgICAgICAgICAgIF9zZXREcm9wcGFibGVzQWN0aXZlKG1hdGNoaW5nRHJvcHBhYmxlcywgdHJ1ZSwgZmFsc2UsIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5wYXJhbXMuYWRkQ2xhc3MoZHJhZ0VsLCB0aGlzLnBhcmFtcy5kcmFnQ2xhc3MgfHwgY3NzLmRyYWcpO1xuICAgICAgICAgICAgLy9pZiAodGhpcy5wYXJhbXMuY29uc3RyYWluIHx8IHRoaXMucGFyYW1zLmNvbnRhaW5tZW50KSB7XG4gICAgICAgICAgICB2YXIgY3MgPSB0aGlzLnBhcmFtcy5nZXRTaXplKGRyYWdFbC5wYXJlbnROb2RlKTtcbiAgICAgICAgICAgIGNvbnN0cmFpblJlY3QgPSB7IHc6Y3NbMF0sIGg6Y3NbMV0gfTtcbiAgICAgICAgICAgIC8vfVxuICAgICAgICAgICAgaWYgKGFuZE5vdGlmeSkge1xuICAgICAgICAgICAgICAgIGsubm90aWZ5U2VsZWN0aW9uRHJhZ1N0YXJ0KHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgZ2hvc3RQcm94eU9mZnNldHM7XG4gICAgICAgIHRoaXMudW5tYXJrID0gZnVuY3Rpb24oZSwgZG9Ob3RDaGVja0Ryb3BwYWJsZXMpIHtcbiAgICAgICAgICAgIF9zZXREcm9wcGFibGVzQWN0aXZlKG1hdGNoaW5nRHJvcHBhYmxlcywgZmFsc2UsIHRydWUsIHRoaXMpO1xuXG5cbiAgICAgICAgICAgIGlmIChpc0NvbnN0cmFpbmVkICYmIHVzZUdob3N0UHJveHkodGhpcy5lbCkpIHtcbiAgICAgICAgICAgICAgICBnaG9zdFByb3h5T2Zmc2V0cyA9IFtkcmFnRWwub2Zmc2V0TGVmdCwgZHJhZ0VsLm9mZnNldFRvcF07XG4gICAgICAgICAgICAgICAgdGhpcy5lbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGRyYWdFbCk7XG4gICAgICAgICAgICAgICAgZHJhZ0VsID0gdGhpcy5lbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGdob3N0UHJveHlPZmZzZXRzID0gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5wYXJhbXMucmVtb3ZlQ2xhc3MoZHJhZ0VsLCB0aGlzLnBhcmFtcy5kcmFnQ2xhc3MgfHwgY3NzLmRyYWcpO1xuICAgICAgICAgICAgbWF0Y2hpbmdEcm9wcGFibGVzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICBpc0NvbnN0cmFpbmVkID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoIWRvTm90Q2hlY2tEcm9wcGFibGVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGludGVyc2VjdGluZ0Ryb3BwYWJsZXMubGVuZ3RoID4gMCAmJiBnaG9zdFByb3h5T2Zmc2V0cykge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbXMuc2V0UG9zaXRpb24odGhpcy5lbCwgZ2hvc3RQcm94eU9mZnNldHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbnRlcnNlY3RpbmdEcm9wcGFibGVzLnNvcnQoX3JhbmtTb3J0KTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGludGVyc2VjdGluZ0Ryb3BwYWJsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJldFZhbCA9IGludGVyc2VjdGluZ0Ryb3BwYWJsZXNbaV0uZHJvcCh0aGlzLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJldFZhbCA9PT0gdHJ1ZSkgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm1vdmVCeSA9IGZ1bmN0aW9uKGR4LCBkeSwgZSkge1xuICAgICAgICAgICAgaW50ZXJzZWN0aW5nRHJvcHBhYmxlcy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgdmFyIGRlc2lyZWRMb2MgPSB0aGlzLnRvR3JpZChbcG9zQXREb3duWzBdICsgZHgsIHBvc0F0RG93blsxXSArIGR5XSksXG4gICAgICAgICAgICAgICAgY1BvcyA9IGNvbnN0cmFpbihkZXNpcmVkTG9jLCBkcmFnRWwpO1xuXG4gICAgICAgICAgICBpZiAodXNlR2hvc3RQcm94eSh0aGlzLmVsKSkge1xuICAgICAgICAgICAgICAgIGlmIChkZXNpcmVkTG9jWzBdICE9IGNQb3NbMF0gfHwgZGVzaXJlZExvY1sxXSAhPSBjUG9zWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNDb25zdHJhaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGdwID0gZ2hvc3RQcm94eSh0aGlzLmVsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcy5hZGRDbGFzcyhncCwgX2NsYXNzZXMuZ2hvc3RQcm94eSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVsLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQoZ3ApO1xuICAgICAgICAgICAgICAgICAgICAgICAgZHJhZ0VsID0gZ3A7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0NvbnN0cmFpbmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjUG9zID0gZGVzaXJlZExvYztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0NvbnN0cmFpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZHJhZ0VsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyYWdFbCA9IHRoaXMuZWw7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0NvbnN0cmFpbmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciByZWN0ID0geyB4OmNQb3NbMF0sIHk6Y1Bvc1sxXSwgdzp0aGlzLnNpemVbMF0sIGg6dGhpcy5zaXplWzFdfSxcbiAgICAgICAgICAgICAgICBwYWdlUmVjdCA9IHsgeDpyZWN0LnggKyBwYWdlRGVsdGFbMF0sIHk6cmVjdC55ICsgcGFnZURlbHRhWzFdLCB3OnJlY3QudywgaDpyZWN0Lmh9LFxuICAgICAgICAgICAgICAgIGZvY3VzRHJvcEVsZW1lbnQgPSBudWxsO1xuXG5cblxuICAgICAgICAgICAgdGhpcy5wYXJhbXMuc2V0UG9zaXRpb24oZHJhZ0VsLCBjUG9zKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWF0Y2hpbmdEcm9wcGFibGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHIyID0geyB4Om1hdGNoaW5nRHJvcHBhYmxlc1tpXS5wYWdlUG9zaXRpb25bMF0sIHk6bWF0Y2hpbmdEcm9wcGFibGVzW2ldLnBhZ2VQb3NpdGlvblsxXSwgdzptYXRjaGluZ0Ryb3BwYWJsZXNbaV0uc2l6ZVswXSwgaDptYXRjaGluZ0Ryb3BwYWJsZXNbaV0uc2l6ZVsxXX07XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGFyYW1zLmludGVyc2VjdHMocGFnZVJlY3QsIHIyKSAmJiAoX211bHRpcGxlRHJvcCB8fCBmb2N1c0Ryb3BFbGVtZW50ID09IG51bGwgfHwgZm9jdXNEcm9wRWxlbWVudCA9PSBtYXRjaGluZ0Ryb3BwYWJsZXNbaV0uZWwpICYmIG1hdGNoaW5nRHJvcHBhYmxlc1tpXS5jYW5Ecm9wKHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZm9jdXNEcm9wRWxlbWVudCkgZm9jdXNEcm9wRWxlbWVudCA9IG1hdGNoaW5nRHJvcHBhYmxlc1tpXS5lbDtcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJzZWN0aW5nRHJvcHBhYmxlcy5wdXNoKG1hdGNoaW5nRHJvcHBhYmxlc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoaW5nRHJvcHBhYmxlc1tpXS5zZXRIb3Zlcih0aGlzLCB0cnVlLCBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobWF0Y2hpbmdEcm9wcGFibGVzW2ldLmlzSG92ZXIoKSkge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaGluZ0Ryb3BwYWJsZXNbaV0uc2V0SG92ZXIodGhpcywgZmFsc2UsIGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2Rpc3BhdGNoKFwiZHJhZ1wiLCB7ZWw6dGhpcy5lbCwgcG9zOmNQb3MsIGU6ZSwgZHJhZzp0aGlzfSk7XG5cbiAgICAgICAgICAgIC8qIHRlc3QgdG8gc2VlIGlmIHRoZSBwYXJlbnQgbmVlZHMgdG8gYmUgc2Nyb2xsZWQgKGZ1dHVyZSlcbiAgICAgICAgICAgICBpZiAoc2Nyb2xsKSB7XG4gICAgICAgICAgICAgdmFyIHBuc2wgPSBkcmFnRWwucGFyZW50Tm9kZS5zY3JvbGxMZWZ0LCBwbnN0ID0gZHJhZ0VsLnBhcmVudE5vZGUuc2Nyb2xsVG9wO1xuICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwic2Nyb2xsIVwiLCBwbnNsLCBwbnN0KTtcbiAgICAgICAgICAgICB9Ki9cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLnBhcmFtcy51bmJpbmQodGhpcy5lbCwgXCJtb3VzZWRvd25cIiwgdGhpcy5kb3duTGlzdGVuZXIpO1xuICAgICAgICAgICAgdGhpcy5wYXJhbXMudW5iaW5kKGRvY3VtZW50LCBcIm1vdXNlbW92ZVwiLCB0aGlzLm1vdmVMaXN0ZW5lcik7XG4gICAgICAgICAgICB0aGlzLnBhcmFtcy51bmJpbmQoZG9jdW1lbnQsIFwibW91c2V1cFwiLCB0aGlzLnVwTGlzdGVuZXIpO1xuICAgICAgICAgICAgdGhpcy5kb3duTGlzdGVuZXIgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy51cExpc3RlbmVyID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMubW92ZUxpc3RlbmVyID0gbnVsbDtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBpbml0OnJlZ2lzdGVyIG1vdXNlZG93biwgYW5kIHBlcmhhcHMgc2V0IGEgZmlsdGVyXG4gICAgICAgIHRoaXMucGFyYW1zLmJpbmQodGhpcy5lbCwgXCJtb3VzZWRvd25cIiwgdGhpcy5kb3duTGlzdGVuZXIpO1xuXG4gICAgICAgIC8vIGlmIGhhbmRsZSBwcm92ZGVkLCB1c2UgdGhhdC4gIG90aGVyd2lzZSwgdHJ5IHRvIHNldCBhIGZpbHRlci5cbiAgICAgICAgLy8gbm90ZSB0aGF0IGEgYGhhbmRsZWAgc2VsZWN0b3IgYWx3YXlzIHJlc3VsdHMgaW4gZmlsdGVyRXhjbHVkZSBiZWluZyBzZXQgdG8gZmFsc2UsIGllLlxuICAgICAgICAvLyB0aGUgc2VsZWN0b3IgZGVmaW5lcyB0aGUgaGFuZGxlIGVsZW1lbnQocykuXG4gICAgICAgIGlmICh0aGlzLnBhcmFtcy5oYW5kbGUpXG4gICAgICAgICAgICBfc2V0RmlsdGVyKHRoaXMucGFyYW1zLmhhbmRsZSwgZmFsc2UpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBfc2V0RmlsdGVyKHRoaXMucGFyYW1zLmZpbHRlciwgdGhpcy5wYXJhbXMuZmlsdGVyRXhjbHVkZSk7XG4gICAgfTtcblxuICAgIHZhciBEcm9wID0gZnVuY3Rpb24oZWwsIHBhcmFtcywgY3NzLCBzY29wZSkge1xuICAgICAgICB0aGlzLl9jbGFzcyA9IGNzcy5kcm9wcGFibGU7XG4gICAgICAgIHRoaXMucGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICAgICAgICB0aGlzLnJhbmsgPSBwYXJhbXMucmFuayB8fCAwO1xuICAgICAgICB0aGlzLl9hY3RpdmVDbGFzcyA9IHRoaXMucGFyYW1zLmFjdGl2ZUNsYXNzIHx8IGNzcy5hY3RpdmU7XG4gICAgICAgIHRoaXMuX2hvdmVyQ2xhc3MgPSB0aGlzLnBhcmFtcy5ob3ZlckNsYXNzIHx8IGNzcy5ob3ZlcjtcbiAgICAgICAgU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgdmFyIGhvdmVyID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYWxsb3dMb29wYmFjayA9IHRoaXMucGFyYW1zLmFsbG93TG9vcGJhY2sgIT09IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuc2V0QWN0aXZlID0gZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICB0aGlzLnBhcmFtc1t2YWwgPyBcImFkZENsYXNzXCIgOiBcInJlbW92ZUNsYXNzXCJdKHRoaXMuZWwsIHRoaXMuX2FjdGl2ZUNsYXNzKTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLnVwZGF0ZVBvc2l0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uID0gdGhpcy5wYXJhbXMuZ2V0UG9zaXRpb24odGhpcy5lbCk7XG4gICAgICAgICAgICB0aGlzLnBhZ2VQb3NpdGlvbiA9IHRoaXMucGFyYW1zLmdldFBvc2l0aW9uKHRoaXMuZWwsIHRydWUpO1xuICAgICAgICAgICAgdGhpcy5zaXplID0gdGhpcy5wYXJhbXMuZ2V0U2l6ZSh0aGlzLmVsKTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmNhbkRyb3AgPSB0aGlzLnBhcmFtcy5jYW5Ecm9wIHx8IGZ1bmN0aW9uKGRyYWcpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuaXNIb3ZlciA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gaG92ZXI7IH07XG5cbiAgICAgICAgdGhpcy5zZXRIb3ZlciA9IGZ1bmN0aW9uKGRyYWcsIHZhbCwgZSkge1xuICAgICAgICAgICAgLy8gaWYgdHVybmluZyBvZmYgaG92ZXIgYnV0IHRoaXMgd2FzIG5vdCB0aGUgZHJhZyB0aGF0IGNhdXNlZCB0aGUgaG92ZXIsIGlnbm9yZS5cbiAgICAgICAgICAgIGlmICh2YWwgfHwgdGhpcy5lbC5fa2F0YXZvcmlvRHJhZ0hvdmVyID09IG51bGwgfHwgdGhpcy5lbC5fa2F0YXZvcmlvRHJhZ0hvdmVyID09IGRyYWcuZWwuX2thdGF2b3Jpbykge1xuICAgICAgICAgICAgICAgIHRoaXMucGFyYW1zW3ZhbCA/IFwiYWRkQ2xhc3NcIiA6IFwicmVtb3ZlQ2xhc3NcIl0odGhpcy5lbCwgdGhpcy5faG92ZXJDbGFzcyk7XG4gICAgICAgICAgICAgICAgLy90aGlzLmVsLl9rYXRhdm9yaW9EcmFnSG92ZXIgPSB2YWwgPyBkcmFnLmVsLl9rYXRhdm9yaW8gOiBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuZWwuX2thdGF2b3Jpb0RyYWdIb3ZlciA9IHZhbCA/IGRyYWcuZWwuX2thdGF2b3JpbyA6IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKGhvdmVyICE9PSB2YWwpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyYW1zLmV2ZW50c1t2YWwgPyBcIm92ZXJcIiA6IFwib3V0XCJdKHtlbDp0aGlzLmVsLCBlOmUsIGRyYWc6ZHJhZywgZHJvcDp0aGlzfSk7XG4gICAgICAgICAgICAgICAgaG92ZXIgPSB2YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5kcm9wID0gZnVuY3Rpb24oZHJhZywgZXZlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmFtcy5ldmVudHNbXCJkcm9wXCJdKHsgZHJhZzpkcmFnLCBlOmV2ZW50LCBkcm9wOnRoaXMgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLl9jbGFzcyA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9hY3RpdmVDbGFzcyA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9ob3ZlckNsYXNzID0gbnVsbDtcbiAgICAgICAgICAgIC8vdGhpcy5wYXJhbXMgPSBudWxsO1xuICAgICAgICAgICAgaG92ZXIgPSBudWxsO1xuICAgICAgICAgICAgLy90aGlzLmVsID0gbnVsbDtcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIF91dWlkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAoJ3h4eHh4eHh4LXh4eHgtNHh4eC15eHh4LXh4eHh4eHh4eHh4eCcucmVwbGFjZSgvW3h5XS9nLCBmdW5jdGlvbihjKSB7XG4gICAgICAgICAgICB2YXIgciA9IE1hdGgucmFuZG9tKCkqMTZ8MCwgdiA9IGMgPT0gJ3gnID8gciA6IChyJjB4M3wweDgpO1xuICAgICAgICAgICAgcmV0dXJuIHYudG9TdHJpbmcoMTYpO1xuICAgICAgICB9KSk7XG4gICAgfTtcblxuICAgIHZhciBfcmFua1NvcnQgPSBmdW5jdGlvbihhLGIpIHtcbiAgICAgICAgcmV0dXJuIGEucmFuayA8IGIucmFuayA/IDEgOiBhLnJhbmsgPiBiLnJhbmsgPyAtMSA6IDA7XG4gICAgfTtcblxuICAgIHZhciBfZ2VsID0gZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgaWYgKGVsID09IG51bGwpIHJldHVybiBudWxsO1xuICAgICAgICBlbCA9ICh0eXBlb2YgZWwgPT09IFwic3RyaW5nXCIgfHwgZWwuY29uc3RydWN0b3IgPT0gU3RyaW5nKSAgPyBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlbCkgOiBlbDtcbiAgICAgICAgaWYgKGVsID09IG51bGwpIHJldHVybiBudWxsO1xuICAgICAgICBlbC5fa2F0YXZvcmlvID0gZWwuX2thdGF2b3JpbyB8fCBfdXVpZCgpO1xuICAgICAgICByZXR1cm4gZWw7XG4gICAgfTtcblxuICAgIHJvb3QuS2F0YXZvcmlvID0gZnVuY3Rpb24oa2F0YXZvcmlvUGFyYW1zKSB7XG5cbiAgICAgICAgdmFyIF9zZWxlY3Rpb24gPSBbXSxcbiAgICAgICAgICAgIF9zZWxlY3Rpb25NYXAgPSB7fTtcblxuICAgICAgICB0aGlzLl9kcmFnc0J5U2NvcGUgPSB7fTtcbiAgICAgICAgdGhpcy5fZHJvcHNCeVNjb3BlID0ge307XG4gICAgICAgIHZhciBfem9vbSA9IDEsXG4gICAgICAgICAgICBfcmVnID0gZnVuY3Rpb24ob2JqLCBtYXApIHtcbiAgICAgICAgICAgICAgICBfZWFjaChvYmosIGZ1bmN0aW9uKF9vYmopIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IF9vYmouc2NvcGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXBbX29iai5zY29wZXNbaV1dID0gbWFwW19vYmouc2NvcGVzW2ldXSB8fCBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcFtfb2JqLnNjb3Blc1tpXV0ucHVzaChfb2JqKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF91bnJlZyA9IGZ1bmN0aW9uKG9iaiwgbWFwKSB7XG4gICAgICAgICAgICAgICAgdmFyIGMgPSAwO1xuICAgICAgICAgICAgICAgIF9lYWNoKG9iaiwgZnVuY3Rpb24oX29iaikge1xuICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgX29iai5zY29wZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXBbX29iai5zY29wZXNbaV1dKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlkeCA9IGthdGF2b3Jpb1BhcmFtcy5pbmRleE9mKG1hcFtfb2JqLnNjb3Blc1tpXV0sIF9vYmopO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpZHggIT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwW19vYmouc2NvcGVzW2ldXS5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYysrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGMgPiAwIDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfZ2V0TWF0Y2hpbmdEcm9wcGFibGVzID0gdGhpcy5nZXRNYXRjaGluZ0Ryb3BwYWJsZXMgPSBmdW5jdGlvbihkcmFnKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRkID0gW10sIF9tID0ge307XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkcmFnLnNjb3Blcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2RkID0gdGhpcy5fZHJvcHNCeVNjb3BlW2RyYWcuc2NvcGVzW2ldXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9kZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBfZGQubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2RkW2pdLmNhbkRyb3AoZHJhZykgJiYgICFfbVtfZGRbal0udXVpZF0gJiYgKF9kZFtqXS5hbGxvd0xvb3BiYWNrIHx8IF9kZFtqXS5lbCAhPT0gZHJhZy5lbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX21bX2RkW2pdLnV1aWRdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGQucHVzaChfZGRbal0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZC5zb3J0KF9yYW5rU29ydCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRkO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9wcmVwYXJlUGFyYW1zID0gZnVuY3Rpb24ocCkge1xuICAgICAgICAgICAgICAgIHAgPSBwIHx8IHt9O1xuICAgICAgICAgICAgICAgIHZhciBfcCA9IHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRzOnt9XG4gICAgICAgICAgICAgICAgfSwgaTtcbiAgICAgICAgICAgICAgICBmb3IgKGkgaW4ga2F0YXZvcmlvUGFyYW1zKSBfcFtpXSA9IGthdGF2b3Jpb1BhcmFtc1tpXTtcbiAgICAgICAgICAgICAgICBmb3IgKGkgaW4gcCkgX3BbaV0gPSBwW2ldO1xuICAgICAgICAgICAgICAgIC8vIGV2ZW50c1xuXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IF9ldmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgX3AuZXZlbnRzW19ldmVudHNbaV1dID0gcFtfZXZlbnRzW2ldXSB8fCBfZGV2TnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3Aua2F0YXZvcmlvID0gdGhpcztcbiAgICAgICAgICAgICAgICByZXR1cm4gX3A7XG4gICAgICAgICAgICB9LmJpbmQodGhpcyksXG4gICAgICAgICAgICBfbWlzdGxldG9lID0gZnVuY3Rpb24oZXhpc3RpbmdEcmFnLCBwYXJhbXMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF9ldmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtc1tfZXZlbnRzW2ldXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmdEcmFnLm9uKF9ldmVudHNbaV0sIHBhcmFtc1tfZXZlbnRzW2ldXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LmJpbmQodGhpcyksXG4gICAgICAgICAgICBfY3NzID0ge30sXG4gICAgICAgICAgICBvdmVycmlkZUNzcyA9IGthdGF2b3Jpb1BhcmFtcy5jc3MgfHwge30sXG4gICAgICAgICAgICBfc2NvcGUgPSBrYXRhdm9yaW9QYXJhbXMuc2NvcGUgfHwgX2RlZmF1bHRTY29wZTtcblxuICAgICAgICAvLyBwcmVwYXJlIG1hcCBvZiBjc3MgY2xhc3NlcyBiYXNlZCBvbiBkZWZhdWx0cyBmcnN0LCB0aGVuIG9wdGlvbmFsIG92ZXJyaWRlc1xuICAgICAgICBmb3IgKHZhciBpIGluIF9jbGFzc2VzKSBfY3NzW2ldID0gX2NsYXNzZXNbaV07XG4gICAgICAgIGZvciAodmFyIGkgaW4gb3ZlcnJpZGVDc3MpIF9jc3NbaV0gPSBvdmVycmlkZUNzc1tpXTtcblxuICAgICAgICB2YXIgaW5wdXRGaWx0ZXJTZWxlY3RvciA9IGthdGF2b3Jpb1BhcmFtcy5pbnB1dEZpbHRlclNlbGVjdG9yIHx8IF9kZWZhdWx0SW5wdXRGaWx0ZXJTZWxlY3RvcjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgdGhlIHNlbGVjdG9yIGlkZW50aWZ5aW5nIHdoaWNoIGlucHV0IGVsZW1lbnRzIHRvIGZpbHRlciBmcm9tIGRyYWcgZXZlbnRzLlxuICAgICAgICAgKiBAbWV0aG9kIGdldElucHV0RmlsdGVyU2VsZWN0b3JcbiAgICAgICAgICogQHJldHVybiB7U3RyaW5nfSBDdXJyZW50IGlucHV0IGZpbHRlciBzZWxlY3Rvci5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ2V0SW5wdXRGaWx0ZXJTZWxlY3RvciA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gaW5wdXRGaWx0ZXJTZWxlY3RvcjsgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyB0aGUgc2VsZWN0b3IgaWRlbnRpZnlpbmcgd2hpY2ggaW5wdXQgZWxlbWVudHMgdG8gZmlsdGVyIGZyb20gZHJhZyBldmVudHMuXG4gICAgICAgICAqIEBtZXRob2Qgc2V0SW5wdXRGaWx0ZXJTZWxlY3RvclxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2VsZWN0b3IgSW5wdXQgZmlsdGVyIHNlbGVjdG9yIHRvIHNldC5cbiAgICAgICAgICogQHJldHVybiB7S2F0YXZvcmlvfSBDdXJyZW50IGluc3RhbmNlOyBtZXRob2QgbWF5IGJlIGNoYWluZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNldElucHV0RmlsdGVyU2VsZWN0b3IgPSBmdW5jdGlvbihzZWxlY3Rvcikge1xuICAgICAgICAgICAgaW5wdXRGaWx0ZXJTZWxlY3RvciA9IHNlbGVjdG9yO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5kcmFnZ2FibGUgPSBmdW5jdGlvbihlbCwgcGFyYW1zKSB7XG4gICAgICAgICAgICB2YXIgbyA9IFtdO1xuICAgICAgICAgICAgX2VhY2goZWwsIGZ1bmN0aW9uKF9lbCkge1xuICAgICAgICAgICAgICAgIF9lbCA9IF9nZWwoX2VsKTtcbiAgICAgICAgICAgICAgICBpZiAoX2VsICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9lbC5fa2F0YXZvcmlvRHJhZyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IF9wcmVwYXJlUGFyYW1zKHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfZWwuX2thdGF2b3Jpb0RyYWcgPSBuZXcgRHJhZyhfZWwsIHAsIF9jc3MsIF9zY29wZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfcmVnKF9lbC5fa2F0YXZvcmlvRHJhZywgdGhpcy5fZHJhZ3NCeVNjb3BlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG8ucHVzaChfZWwuX2thdGF2b3Jpb0RyYWcpO1xuICAgICAgICAgICAgICAgICAgICAgICAga2F0YXZvcmlvUGFyYW1zLmFkZENsYXNzKF9lbCwgX2Nzcy5kcmFnZ2FibGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgX21pc3RsZXRvZShfZWwuX2thdGF2b3Jpb0RyYWcsIHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICAgICAgcmV0dXJuIG87XG5cbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmRyb3BwYWJsZSA9IGZ1bmN0aW9uKGVsLCBwYXJhbXMpIHtcbiAgICAgICAgICAgIHZhciBvID0gW107XG4gICAgICAgICAgICBfZWFjaChlbCwgZnVuY3Rpb24oX2VsKSB7XG4gICAgICAgICAgICAgICAgX2VsID0gX2dlbChfZWwpO1xuICAgICAgICAgICAgICAgIGlmIChfZWwgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZHJvcCA9IG5ldyBEcm9wKF9lbCwgX3ByZXBhcmVQYXJhbXMocGFyYW1zKSwgX2NzcywgX3Njb3BlKTtcbiAgICAgICAgICAgICAgICAgICAgX2VsLl9rYXRhdm9yaW9Ecm9wID0gX2VsLl9rYXRhdm9yaW9Ecm9wIHx8IFtdO1xuICAgICAgICAgICAgICAgICAgICBfZWwuX2thdGF2b3Jpb0Ryb3AucHVzaChkcm9wKTtcbiAgICAgICAgICAgICAgICAgICAgX3JlZyhkcm9wLCB0aGlzLl9kcm9wc0J5U2NvcGUpO1xuICAgICAgICAgICAgICAgICAgICBvLnB1c2goZHJvcCk7XG4gICAgICAgICAgICAgICAgICAgIGthdGF2b3Jpb1BhcmFtcy5hZGRDbGFzcyhfZWwsIF9jc3MuZHJvcHBhYmxlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICAgICAgcmV0dXJuIG87XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBuYW1lIEthdGF2b3JpbyNzZWxlY3RcbiAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAqIEBkZXNjIEFkZHMgYW4gZWxlbWVudCB0byB0aGUgY3VycmVudCBzZWxlY3Rpb24gKGZvciBtdWx0aXBsZSBub2RlIGRyYWcpXG4gICAgICAgICAqIEBwYXJhbSB7RWxlbWVudHxTdHJpbmd9IERPTSBlbGVtZW50IC0gb3IgaWQgb2YgdGhlIGVsZW1lbnQgLSB0byBhZGQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNlbGVjdCA9IGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgICAgICBfZWFjaChlbCwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9lbCA9IF9nZWwodGhpcyk7XG4gICAgICAgICAgICAgICAgaWYgKF9lbCAmJiBfZWwuX2thdGF2b3Jpb0RyYWcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFfc2VsZWN0aW9uTWFwW19lbC5fa2F0YXZvcmlvXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3NlbGVjdGlvbi5wdXNoKF9lbC5fa2F0YXZvcmlvRHJhZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfc2VsZWN0aW9uTWFwW19lbC5fa2F0YXZvcmlvXSA9IFsgX2VsLCBfc2VsZWN0aW9uLmxlbmd0aCAtIDEgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGthdGF2b3Jpb1BhcmFtcy5hZGRDbGFzcyhfZWwsIF9jc3Muc2VsZWN0ZWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG5hbWUgS2F0YXZvcmlvI2Rlc2VsZWN0XG4gICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgKiBAZGVzYyBSZW1vdmVzIGFuIGVsZW1lbnQgZnJvbSB0aGUgY3VycmVudCBzZWxlY3Rpb24gKGZvciBtdWx0aXBsZSBub2RlIGRyYWcpXG4gICAgICAgICAqIEBwYXJhbSB7RWxlbWVudHxTdHJpbmd9IERPTSBlbGVtZW50IC0gb3IgaWQgb2YgdGhlIGVsZW1lbnQgLSB0byByZW1vdmUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRlc2VsZWN0ID0gZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgICAgIF9lYWNoKGVsLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2VsID0gX2dlbCh0aGlzKTtcbiAgICAgICAgICAgICAgICBpZiAoX2VsICYmIF9lbC5fa2F0YXZvcmlvKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlID0gX3NlbGVjdGlvbk1hcFtfZWwuX2thdGF2b3Jpb107XG4gICAgICAgICAgICAgICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3MgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX3NlbGVjdGlvbi5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3NlbGVjdGlvbltpXS5lbCAhPT0gX2VsKSBfcy5wdXNoKF9zZWxlY3Rpb25baV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3NlbGVjdGlvbiA9IF9zO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIF9zZWxlY3Rpb25NYXBbX2VsLl9rYXRhdm9yaW9dO1xuICAgICAgICAgICAgICAgICAgICAgICAga2F0YXZvcmlvUGFyYW1zLnJlbW92ZUNsYXNzKF9lbCwgX2Nzcy5zZWxlY3RlZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuZGVzZWxlY3RBbGwgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgaW4gX3NlbGVjdGlvbk1hcCkge1xuICAgICAgICAgICAgICAgIHZhciBkID0gX3NlbGVjdGlvbk1hcFtpXTtcbiAgICAgICAgICAgICAgICBrYXRhdm9yaW9QYXJhbXMucmVtb3ZlQ2xhc3MoZFswXSwgX2Nzcy5zZWxlY3RlZCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9zZWxlY3Rpb24ubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIF9zZWxlY3Rpb25NYXAgPSB7fTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLm1hcmtTZWxlY3Rpb24gPSBmdW5jdGlvbihkcmFnKSB7XG4gICAgICAgICAgICBfZm9yZWFjaChfc2VsZWN0aW9uLCBmdW5jdGlvbihlKSB7IGUubWFyaygpOyB9LCBkcmFnKTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLm1hcmtQb3NzZXMgPSBmdW5jdGlvbihkcmFnKSB7XG4gICAgICAgICAgICBpZiAoZHJhZy5wb3NzZXMpIHtcbiAgICAgICAgICAgICAgICBfZWFjaChkcmFnLnBvc3NlcywgZnVuY3Rpb24ocCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZHJhZy5wb3NzZVJvbGVzW3BdICYmIF9wb3NzZXNbcF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9mb3JlYWNoKF9wb3NzZXNbcF0ubWVtYmVycywgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkLm1hcmsoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIGRyYWcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLnVubWFya1NlbGVjdGlvbiA9IGZ1bmN0aW9uKGRyYWcsIGV2ZW50KSB7XG4gICAgICAgICAgICBfZm9yZWFjaChfc2VsZWN0aW9uLCBmdW5jdGlvbihlKSB7IGUudW5tYXJrKGV2ZW50KTsgfSwgZHJhZyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy51bm1hcmtQb3NzZXMgPSBmdW5jdGlvbihkcmFnLCBldmVudCkge1xuICAgICAgICAgICAgaWYgKGRyYWcucG9zc2VzKSB7XG4gICAgICAgICAgICAgICAgX2VhY2goZHJhZy5wb3NzZXMsIGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRyYWcucG9zc2VSb2xlc1twXSAmJiBfcG9zc2VzW3BdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfZm9yZWFjaChfcG9zc2VzW3BdLm1lbWJlcnMsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZC51bm1hcmsoZXZlbnQsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgZHJhZyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmdldFNlbGVjdGlvbiA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gX3NlbGVjdGlvbi5zbGljZSgwKTsgfTtcblxuICAgICAgICB0aGlzLnVwZGF0ZVNlbGVjdGlvbiA9IGZ1bmN0aW9uKGR4LCBkeSwgZHJhZykge1xuICAgICAgICAgICAgX2ZvcmVhY2goX3NlbGVjdGlvbiwgZnVuY3Rpb24oZSkgeyBlLm1vdmVCeShkeCwgZHkpOyB9LCBkcmFnKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgX3Bvc3NlQWN0aW9uID0gZnVuY3Rpb24oZm4sIGRyYWcpIHtcbiAgICAgICAgICAgIGlmIChkcmFnLnBvc3Nlcykge1xuICAgICAgICAgICAgICAgIF9lYWNoKGRyYWcucG9zc2VzLCBmdW5jdGlvbihwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkcmFnLnBvc3NlUm9sZXNbcF0gJiYgX3Bvc3Nlc1twXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2ZvcmVhY2goX3Bvc3Nlc1twXS5tZW1iZXJzLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZuKGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgZHJhZyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLnVwZGF0ZVBvc3NlcyA9IGZ1bmN0aW9uKGR4LCBkeSwgZHJhZykge1xuICAgICAgICAgICAgX3Bvc3NlQWN0aW9uKGZ1bmN0aW9uKGUpIHsgZS5tb3ZlQnkoZHgsIGR5KTsgfSwgZHJhZyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5ub3RpZnlQb3NzZURyYWdTdG9wID0gZnVuY3Rpb24oZHJhZywgZXZ0KSB7XG4gICAgICAgICAgICBfcG9zc2VBY3Rpb24oZnVuY3Rpb24oZSkgeyBlLnN0b3AoZXZ0LCB0cnVlKTsgfSwgZHJhZyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5ub3RpZnlTZWxlY3Rpb25EcmFnU3RvcCA9IGZ1bmN0aW9uKGRyYWcsIGV2dCkge1xuICAgICAgICAgICAgX2ZvcmVhY2goX3NlbGVjdGlvbiwgZnVuY3Rpb24oZSkgeyBlLnN0b3AoZXZ0LCB0cnVlKTsgfSwgZHJhZyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5ub3RpZnlTZWxlY3Rpb25EcmFnU3RhcnQgPSBmdW5jdGlvbihkcmFnLCBldnQpIHtcbiAgICAgICAgICAgIF9mb3JlYWNoKF9zZWxlY3Rpb24sIGZ1bmN0aW9uKGUpIHsgZS5ub3RpZnlTdGFydChldnQpO30sIGRyYWcpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuc2V0Wm9vbSA9IGZ1bmN0aW9uKHopIHsgX3pvb20gPSB6OyB9O1xuICAgICAgICB0aGlzLmdldFpvb20gPSBmdW5jdGlvbigpIHsgcmV0dXJuIF96b29tOyB9O1xuXG4gICAgICAgIC8vIGRvZXMgdGhlIHdvcmsgb2YgY2hhbmdpbmcgc2NvcGVzXG4gICAgICAgIHZhciBfc2NvcGVNYW5pcCA9IGZ1bmN0aW9uKGtPYmosIHNjb3BlcywgbWFwLCBmbikge1xuICAgICAgICAgICAgX2VhY2goa09iaiwgZnVuY3Rpb24oX2tPYmopIHtcbiAgICAgICAgICAgICAgICBfdW5yZWcoX2tPYmosIG1hcCk7ICAvLyBkZXJlZ2lzdGVyIGV4aXN0aW5nIHNjb3Blc1xuICAgICAgICAgICAgICAgIF9rT2JqW2ZuXShzY29wZXMpOyAvLyBzZXQgc2NvcGVzXG4gICAgICAgICAgICAgICAgX3JlZyhfa09iaiwgbWFwKTsgLy8gcmVnaXN0ZXIgbmV3IG9uZXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIF9lYWNoKFsgXCJzZXRcIiwgXCJhZGRcIiwgXCJyZW1vdmVcIiwgXCJ0b2dnbGVcIl0sIGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgIHRoaXNbdiArIFwiU2NvcGVcIl0gPSBmdW5jdGlvbihlbCwgc2NvcGVzKSB7XG4gICAgICAgICAgICAgICAgX3Njb3BlTWFuaXAoZWwuX2thdGF2b3Jpb0RyYWcsIHNjb3BlcywgdGhpcy5fZHJhZ3NCeVNjb3BlLCB2ICsgXCJTY29wZVwiKTtcbiAgICAgICAgICAgICAgICBfc2NvcGVNYW5pcChlbC5fa2F0YXZvcmlvRHJvcCwgc2NvcGVzLCB0aGlzLl9kcm9wc0J5U2NvcGUsIHYgKyBcIlNjb3BlXCIpO1xuICAgICAgICAgICAgfS5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgdGhpc1t2ICsgXCJEcmFnU2NvcGVcIl0gPSBmdW5jdGlvbihlbCwgc2NvcGVzKSB7XG4gICAgICAgICAgICAgICAgX3Njb3BlTWFuaXAoZWwuY29uc3RydWN0b3IgPT09IERyYWcgPyBlbCA6IGVsLl9rYXRhdm9yaW9EcmFnLCBzY29wZXMsIHRoaXMuX2RyYWdzQnlTY29wZSwgdiArIFwiU2NvcGVcIik7XG4gICAgICAgICAgICB9LmJpbmQodGhpcyk7XG4gICAgICAgICAgICB0aGlzW3YgKyBcIkRyb3BTY29wZVwiXSA9IGZ1bmN0aW9uKGVsLCBzY29wZXMpIHtcbiAgICAgICAgICAgICAgICBfc2NvcGVNYW5pcChlbC5jb25zdHJ1Y3RvciA9PT0gRHJvcCA/IGVsIDogZWwuX2thdGF2b3Jpb0Ryb3AsIHNjb3BlcywgdGhpcy5fZHJvcHNCeVNjb3BlLCB2ICsgXCJTY29wZVwiKTtcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcblxuICAgICAgICB0aGlzLnNuYXBUb0dyaWQgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgICAgICBmb3IgKHZhciBzIGluIHRoaXMuX2RyYWdzQnlTY29wZSkge1xuICAgICAgICAgICAgICAgIF9mb3JlYWNoKHRoaXMuX2RyYWdzQnlTY29wZVtzXSwgZnVuY3Rpb24oZCkgeyBkLnNuYXAoeCwgeSk7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuZ2V0RHJhZ3NGb3JTY29wZSA9IGZ1bmN0aW9uKHMpIHsgcmV0dXJuIHRoaXMuX2RyYWdzQnlTY29wZVtzXTsgfTtcbiAgICAgICAgdGhpcy5nZXREcm9wc0ZvclNjb3BlID0gZnVuY3Rpb24ocykgeyByZXR1cm4gdGhpcy5fZHJvcHNCeVNjb3BlW3NdOyB9O1xuXG4gICAgICAgIHZhciBfZGVzdHJveSA9IGZ1bmN0aW9uKGVsLCB0eXBlLCBtYXApIHtcbiAgICAgICAgICAgIGVsID0gX2dlbChlbCk7XG4gICAgICAgICAgICBpZiAoZWxbdHlwZV0pIHtcblxuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBmcm9tIHNlbGVjdGlvbiwgaWYgcHJlc2VudC5cbiAgICAgICAgICAgICAgICB2YXIgc2VsSWR4ID0gX3NlbGVjdGlvbi5pbmRleE9mKGVsW3R5cGVdKTtcbiAgICAgICAgICAgICAgICBpZiAoc2VsSWR4ID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgX3NlbGVjdGlvbi5zcGxpY2Uoc2VsSWR4LCAxKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoX3VucmVnKGVsW3R5cGVdLCBtYXApKSB7XG4gICAgICAgICAgICAgICAgICAgIF9lYWNoKGVsW3R5cGVdLCBmdW5jdGlvbihrT2JqKSB7IGtPYmouZGVzdHJveSgpIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGRlbGV0ZSBlbFt0eXBlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmVsZW1lbnRSZW1vdmVkID0gZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdHJveURyYWdnYWJsZShlbCk7XG4gICAgICAgICAgICB0aGlzLmRlc3Ryb3lEcm9wcGFibGUoZWwpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuZGVzdHJveURyYWdnYWJsZSA9IGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgICAgICBfZGVzdHJveShlbCwgXCJfa2F0YXZvcmlvRHJhZ1wiLCB0aGlzLl9kcmFnc0J5U2NvcGUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuZGVzdHJveURyb3BwYWJsZSA9IGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgICAgICBfZGVzdHJveShlbCwgXCJfa2F0YXZvcmlvRHJvcFwiLCB0aGlzLl9kcm9wc0J5U2NvcGUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMucmVzZXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuX2RyYWdzQnlTY29wZSA9IHt9O1xuICAgICAgICAgICAgdGhpcy5fZHJvcHNCeVNjb3BlID0ge307XG4gICAgICAgICAgICBfc2VsZWN0aW9uID0gW107XG4gICAgICAgICAgICBfc2VsZWN0aW9uTWFwID0ge307XG4gICAgICAgICAgICBfcG9zc2VzID0ge307XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gLS0tLS0gZ3JvdXBzXG4gICAgICAgIHZhciBfcG9zc2VzID0ge307XG5cbiAgICAgICAgdmFyIF9wcm9jZXNzT25lU3BlYyA9IGZ1bmN0aW9uKGVsLCBfc3BlYywgZG9udEFkZEV4aXN0aW5nKSB7XG4gICAgICAgICAgICB2YXIgcG9zc2VJZCA9IF9pc1N0cmluZyhfc3BlYykgPyBfc3BlYyA6IF9zcGVjLmlkO1xuICAgICAgICAgICAgdmFyIGFjdGl2ZSA9IF9pc1N0cmluZyhfc3BlYykgPyB0cnVlIDogX3NwZWMuYWN0aXZlICE9PSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBwb3NzZSA9IF9wb3NzZXNbcG9zc2VJZF0gfHwgKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBnID0ge25hbWU6cG9zc2VJZCwgbWVtYmVyczpbXX07XG4gICAgICAgICAgICAgICAgX3Bvc3Nlc1twb3NzZUlkXSA9IGc7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGc7XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgX2VhY2goZWwsIGZ1bmN0aW9uKF9lbCkge1xuICAgICAgICAgICAgICAgIGlmIChfZWwuX2thdGF2b3Jpb0RyYWcpIHtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoZG9udEFkZEV4aXN0aW5nICYmIF9lbC5fa2F0YXZvcmlvRHJhZy5wb3NzZVJvbGVzW3Bvc3NlLm5hbWVdICE9IG51bGwpIHJldHVybjtcblxuICAgICAgICAgICAgICAgICAgICBfc3VnZ2VzdChwb3NzZS5tZW1iZXJzLCBfZWwuX2thdGF2b3Jpb0RyYWcpO1xuICAgICAgICAgICAgICAgICAgICBfc3VnZ2VzdChfZWwuX2thdGF2b3Jpb0RyYWcucG9zc2VzLCBwb3NzZS5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgX2VsLl9rYXRhdm9yaW9EcmFnLnBvc3NlUm9sZXNbcG9zc2UubmFtZV0gPSBhY3RpdmU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcG9zc2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZCB0aGUgZ2l2ZW4gZWxlbWVudCB0byB0aGUgcG9zc2Ugd2l0aCB0aGUgZ2l2ZW4gaWQsIGNyZWF0aW5nIHRoZSBncm91cCBpZiBpdCBhdCBmaXJzdCBkb2VzIG5vdCBleGlzdC5cbiAgICAgICAgICogQG1ldGhvZCBhZGRUb1Bvc3NlXG4gICAgICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWwgRWxlbWVudCB0byBhZGQuXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nLi4ufE9iamVjdC4uLn0gc3BlYyBWYXJpYWJsZSBhcmdzIHBhcmFtZXRlcnMuIEVhY2ggYXJndW1lbnQgY2FuIGJlIGEgZWl0aGVyIGEgU3RyaW5nLCBpbmRpY2F0aW5nXG4gICAgICAgICAqIHRoZSBJRCBvZiBhIFBvc3NlIHRvIHdoaWNoIHRoZSBlbGVtZW50IHNob3VsZCBiZSBhZGRlZCBhcyBhbiBhY3RpdmUgcGFydGljaXBhbnQsIG9yIGFuIE9iamVjdCBjb250YWluaW5nXG4gICAgICAgICAqIGB7IGlkOlwicG9zc2VJZFwiLCBhY3RpdmU6ZmFsc2UvdHJ1ZX1gLiBJbiB0aGUgbGF0dGVyIGNhc2UsIGlmIGBhY3RpdmVgIGlzIG5vdCBwcm92aWRlZCBpdCBpcyBhc3N1bWVkIHRvIGJlXG4gICAgICAgICAqIHRydWUuXG4gICAgICAgICAqIEByZXR1cm5zIHtQb3NzZXxQb3NzZVtdfSBUaGUgUG9zc2UocykgdG8gd2hpY2ggdGhlIGVsZW1lbnQocykgd2FzL3dlcmUgYWRkZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmFkZFRvUG9zc2UgPSBmdW5jdGlvbihlbCwgc3BlYykge1xuXG4gICAgICAgICAgICB2YXIgcG9zc2VzID0gW107XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcG9zc2VzLnB1c2goX3Byb2Nlc3NPbmVTcGVjKGVsLCBhcmd1bWVudHNbaV0pKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHBvc3Nlcy5sZW5ndGggPT0gMSA/IHBvc3Nlc1swXSA6IHBvc3NlcztcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyB0aGUgcG9zc2UocykgZm9yIHRoZSBlbGVtZW50IHdpdGggdGhlIGdpdmVuIGlkLCBjcmVhdGluZyB0aG9zZSB0aGF0IGRvIG5vdCB5ZXQgZXhpc3QsIGFuZCByZW1vdmluZyBmcm9tXG4gICAgICAgICAqIHRoZSBlbGVtZW50IGFueSBjdXJyZW50IFBvc3NlcyB0aGF0IGFyZSBub3Qgc3BlY2lmaWVkIGJ5IHRoaXMgbWV0aG9kIGNhbGwuIFRoaXMgbWV0aG9kIHdpbGwgbm90IGNoYW5nZSB0aGVcbiAgICAgICAgICogYWN0aXZlL3Bhc3NpdmUgc3RhdGUgaWYgaXQgaXMgZ2l2ZW4gYSBwb3NzZSBpbiB3aGljaCB0aGUgZWxlbWVudCBpcyBhbHJlYWR5IGEgbWVtYmVyLlxuICAgICAgICAgKiBAbWV0aG9kIHNldFBvc3NlXG4gICAgICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWwgRWxlbWVudCB0byBzZXQgcG9zc2Uocykgb24uXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nLi4ufE9iamVjdC4uLn0gc3BlYyBWYXJpYWJsZSBhcmdzIHBhcmFtZXRlcnMuIEVhY2ggYXJndW1lbnQgY2FuIGJlIGEgZWl0aGVyIGEgU3RyaW5nLCBpbmRpY2F0aW5nXG4gICAgICAgICAqIHRoZSBJRCBvZiBhIFBvc3NlIHRvIHdoaWNoIHRoZSBlbGVtZW50IHNob3VsZCBiZSBhZGRlZCBhcyBhbiBhY3RpdmUgcGFydGljaXBhbnQsIG9yIGFuIE9iamVjdCBjb250YWluaW5nXG4gICAgICAgICAqIGB7IGlkOlwicG9zc2VJZFwiLCBhY3RpdmU6ZmFsc2UvdHJ1ZX1gLiBJbiB0aGUgbGF0dGVyIGNhc2UsIGlmIGBhY3RpdmVgIGlzIG5vdCBwcm92aWRlZCBpdCBpcyBhc3N1bWVkIHRvIGJlXG4gICAgICAgICAqIHRydWUuXG4gICAgICAgICAqIEByZXR1cm5zIHtQb3NzZXxQb3NzZVtdfSBUaGUgUG9zc2UocykgdG8gd2hpY2ggdGhlIGVsZW1lbnQocykgbm93IGJlbG9uZ3MuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNldFBvc3NlID0gZnVuY3Rpb24oZWwsIHNwZWMpIHtcblxuICAgICAgICAgICAgdmFyIHBvc3NlcyA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHBvc3Nlcy5wdXNoKF9wcm9jZXNzT25lU3BlYyhlbCwgYXJndW1lbnRzW2ldLCB0cnVlKS5uYW1lKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2VhY2goZWwsIGZ1bmN0aW9uKF9lbCkge1xuICAgICAgICAgICAgICAgIGlmIChfZWwuX2thdGF2b3Jpb0RyYWcpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRpZmYgPSBfZGlmZmVyZW5jZShfZWwuX2thdGF2b3Jpb0RyYWcucG9zc2VzLCBwb3NzZXMpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShwLCBfZWwuX2thdGF2b3Jpb0RyYWcucG9zc2VzKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaWZmLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUZyb21Qb3NzZShfZWwsIGRpZmZbaV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcblxuICAgICAgICAgICAgcmV0dXJuIHBvc3Nlcy5sZW5ndGggPT0gMSA/IHBvc3Nlc1swXSA6IHBvc3NlcztcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVtb3ZlIHRoZSBnaXZlbiBlbGVtZW50IGZyb20gdGhlIGdpdmVuIHBvc3NlKHMpLlxuICAgICAgICAgKiBAbWV0aG9kIHJlbW92ZUZyb21Qb3NzZVxuICAgICAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsIEVsZW1lbnQgdG8gcmVtb3ZlLlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZy4uLn0gcG9zc2VJZCBWYXJhcmdzIHBhcmFtZXRlcjogb25lIHZhbHVlIGZvciBlYWNoIHBvc3NlIHRvIHJlbW92ZSB0aGUgZWxlbWVudCBmcm9tLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZW1vdmVGcm9tUG9zc2UgPSBmdW5jdGlvbihlbCwgcG9zc2VJZCkge1xuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiTm8gcG9zc2UgaWQgcHJvdmlkZWQgZm9yIHJlbW92ZSBvcGVyYXRpb25cIik7XG4gICAgICAgICAgICBmb3IodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcG9zc2VJZCA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgICAgICBfZWFjaChlbCwgZnVuY3Rpb24gKF9lbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX2VsLl9rYXRhdm9yaW9EcmFnICYmIF9lbC5fa2F0YXZvcmlvRHJhZy5wb3NzZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkID0gX2VsLl9rYXRhdm9yaW9EcmFnO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2VhY2gocG9zc2VJZCwgZnVuY3Rpb24gKHApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdmFucXVpc2goX3Bvc3Nlc1twXS5tZW1iZXJzLCBkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdmFucXVpc2goZC5wb3NzZXMsIHApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBkLnBvc3NlUm9sZXNbcF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdmUgdGhlIGdpdmVuIGVsZW1lbnQgZnJvbSBhbGwgUG9zc2VzIHRvIHdoaWNoIGl0IGJlbG9uZ3MuXG4gICAgICAgICAqIEBtZXRob2QgcmVtb3ZlRnJvbUFsbFBvc3Nlc1xuICAgICAgICAgKiBAcGFyYW0ge0VsZW1lbnR8RWxlbWVudFtdfSBlbCBFbGVtZW50IHRvIHJlbW92ZSBmcm9tIFBvc3Nlcy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVtb3ZlRnJvbUFsbFBvc3NlcyA9IGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgICAgICBfZWFjaChlbCwgZnVuY3Rpb24oX2VsKSB7XG4gICAgICAgICAgICAgICAgaWYgKF9lbC5fa2F0YXZvcmlvRHJhZyAmJiBfZWwuX2thdGF2b3Jpb0RyYWcucG9zc2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkID0gX2VsLl9rYXRhdm9yaW9EcmFnO1xuICAgICAgICAgICAgICAgICAgICBfZWFjaChkLnBvc3NlcywgZnVuY3Rpb24ocCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3ZhbnF1aXNoKF9wb3NzZXNbcF0ubWVtYmVycywgZCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBkLnBvc3Nlcy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgICAgICBkLnBvc3NlUm9sZXMgPSB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2hhbmdlcyB0aGUgcGFydGljaXBhdGlvbiBzdGF0ZSBmb3IgdGhlIGVsZW1lbnQgaW4gdGhlIFBvc3NlIHdpdGggdGhlIGdpdmVuIElELlxuICAgICAgICAgKiBAcGFyYW0ge0VsZW1lbnR8RWxlbWVudFtdfSBlbCBFbGVtZW50KHMpIHRvIGNoYW5nZSBzdGF0ZSBmb3IuXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwb3NzZUlkIElEIG9mIHRoZSBQb3NzZSB0byBjaGFuZ2UgZWxlbWVudCBzdGF0ZSBmb3IuXG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gc3RhdGUgVHJ1ZSB0byBtYWtlIGFjdGl2ZSwgZmFsc2UgdG8gbWFrZSBwYXNzaXZlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zZXRQb3NzZVN0YXRlID0gZnVuY3Rpb24oZWwsIHBvc3NlSWQsIHN0YXRlKSB7XG4gICAgICAgICAgICB2YXIgcG9zc2UgPSBfcG9zc2VzW3Bvc3NlSWRdO1xuICAgICAgICAgICAgaWYgKHBvc3NlKSB7XG4gICAgICAgICAgICAgICAgX2VhY2goZWwsIGZ1bmN0aW9uKF9lbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX2VsLl9rYXRhdm9yaW9EcmFnICYmIF9lbC5fa2F0YXZvcmlvRHJhZy5wb3NzZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9lbC5fa2F0YXZvcmlvRHJhZy5wb3NzZVJvbGVzW3Bvc3NlLm5hbWVdID0gc3RhdGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgIH07XG5cbiAgICByb290LkthdGF2b3Jpby52ZXJzaW9uID0gXCIwLjE5LjJcIjtcblxuICAgIGlmICh0eXBlb2YgZXhwb3J0cyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBleHBvcnRzLkthdGF2b3JpbyA9IHJvb3QuS2F0YXZvcmlvO1xuICAgIH1cblxufSkuY2FsbCh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHRoaXMpO1xuXG4vKlxuICoganNQbHVtYlxuICpcbiAqIFRpdGxlOmpzUGx1bWIgMi4zLjBcbiAqXG4gKiBQcm92aWRlcyBhIHdheSB0byB2aXN1YWxseSBjb25uZWN0IGVsZW1lbnRzIG9uIGFuIEhUTUwgcGFnZSwgdXNpbmcgU1ZHLlxuICpcbiAqIFRoaXMgZmlsZSBjb250YWlucyB1dGlsaXR5IGZ1bmN0aW9ucyB0aGF0IHJ1biBpbiBib3RoIGJyb3dzZXJzIGFuZCBoZWFkbGVzcy5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTAgLSAyMDE3IGpzUGx1bWIgKGhlbGxvQGpzcGx1bWJ0b29sa2l0LmNvbSlcbiAqXG4gKiBodHRwOi8vanNwbHVtYnRvb2xraXQuY29tXG4gKiBodHRwOi8vZ2l0aHViLmNvbS9zcG9ycml0dC9qc3BsdW1iXG4gKlxuICogRHVhbCBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGFuZCBHUEwyIGxpY2Vuc2VzLlxuICovXG5cbjtcbihmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgX2lzYSA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGEpID09PSBcIltvYmplY3QgQXJyYXldXCI7XG4gICAgICAgIH0sXG4gICAgICAgIF9pc251bSA9IGZ1bmN0aW9uIChuKSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG4pID09PSBcIltvYmplY3QgTnVtYmVyXVwiO1xuICAgICAgICB9LFxuICAgICAgICBfaXNzID0gZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgcyA9PT0gXCJzdHJpbmdcIjtcbiAgICAgICAgfSxcbiAgICAgICAgX2lzYiA9IGZ1bmN0aW9uIChzKSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIHMgPT09IFwiYm9vbGVhblwiO1xuICAgICAgICB9LFxuICAgICAgICBfaXNudWxsID0gZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgICAgIHJldHVybiBzID09IG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIF9pc28gPSBmdW5jdGlvbiAobykge1xuICAgICAgICAgICAgcmV0dXJuIG8gPT0gbnVsbCA/IGZhbHNlIDogT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pID09PSBcIltvYmplY3QgT2JqZWN0XVwiO1xuICAgICAgICB9LFxuICAgICAgICBfaXNkID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykgPT09IFwiW29iamVjdCBEYXRlXVwiO1xuICAgICAgICB9LFxuICAgICAgICBfaXNmID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykgPT09IFwiW29iamVjdCBGdW5jdGlvbl1cIjtcbiAgICAgICAgfSxcbiAgICAgICAgX2lzTmFtZWRGdW5jdGlvbiA9IGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgICAgIHJldHVybiBfaXNmKG8pICYmIG8ubmFtZSAhPSBudWxsICYmIG8ubmFtZS5sZW5ndGggPiAwO1xuICAgICAgICB9LFxuICAgICAgICBfaXNlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgaW4gbykge1xuICAgICAgICAgICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTtcblxuICAgIHZhciByb290ID0gdGhpcztcbiAgICByb290LmpzUGx1bWJVdGlsID0ge1xuICAgICAgICBpc0FycmF5OiBfaXNhLFxuICAgICAgICBpc1N0cmluZzogX2lzcyxcbiAgICAgICAgaXNCb29sZWFuOiBfaXNiLFxuICAgICAgICBpc051bGw6IF9pc251bGwsXG4gICAgICAgIGlzT2JqZWN0OiBfaXNvLFxuICAgICAgICBpc0RhdGU6IF9pc2QsXG4gICAgICAgIGlzRnVuY3Rpb246IF9pc2YsXG4gICAgICAgIGlzRW1wdHk6IF9pc2UsXG4gICAgICAgIGlzTnVtYmVyOiBfaXNudW0sXG4gICAgICAgIGNsb25lOiBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgaWYgKF9pc3MoYSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJcIiArIGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChfaXNiKGEpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICEhYTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKF9pc2QoYSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IERhdGUoYS5nZXRUaW1lKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoX2lzZihhKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoX2lzYShhKSkge1xuICAgICAgICAgICAgICAgIHZhciBiID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGIucHVzaCh0aGlzLmNsb25lKGFbaV0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChfaXNvKGEpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGMgPSB7fTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqIGluIGEpIHtcbiAgICAgICAgICAgICAgICAgICAgY1tqXSA9IHRoaXMuY2xvbmUoYVtqXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG1lcmdlOiBmdW5jdGlvbiAoYSwgYiwgY29sbGF0aW9ucykge1xuICAgICAgICAgICAgLy8gZmlyc3QgY2hhbmdlIHRoZSBjb2xsYXRpb25zIGFycmF5IC0gaWYgcHJlc2VudCAtIGludG8gYSBsb29rdXAgdGFibGUsIGJlY2F1c2UgaXRzIGZhc3Rlci5cbiAgICAgICAgICAgIHZhciBjTWFwID0ge30sIGFyLCBpO1xuICAgICAgICAgICAgY29sbGF0aW9ucyA9IGNvbGxhdGlvbnMgfHwgW107XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY29sbGF0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNNYXBbY29sbGF0aW9uc1tpXV0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgYyA9IHRoaXMuY2xvbmUoYSk7XG4gICAgICAgICAgICBmb3IgKGkgaW4gYikge1xuICAgICAgICAgICAgICAgIGlmIChjW2ldID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY1tpXSA9IGJbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKF9pc3MoYltpXSkgfHwgX2lzYihiW2ldKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNNYXBbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNbaV0gPSBiW2ldOyAvLyBpZiB3ZSBkb250IHdhbnQgdG8gY29sbGF0ZSwganVzdCBjb3B5IGl0IGluLlxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXIgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIGMncyBvYmplY3QgaXMgYWxzbyBhbiBhcnJheSB3ZSBjYW4ga2VlcCBpdHMgdmFsdWVzLlxuICAgICAgICAgICAgICAgICAgICAgICAgYXIucHVzaC5hcHBseShhciwgX2lzYShjW2ldKSA/IGNbaV0gOiBbIGNbaV0gXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhci5wdXNoLmFwcGx5KGFyLCBfaXNhKGJbaV0pID8gYltpXSA6IFsgYltpXSBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNbaV0gPSBhcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9pc2EoYltpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBjJ3Mgb2JqZWN0IGlzIGFsc28gYW4gYXJyYXkgd2UgY2FuIGtlZXAgaXRzIHZhbHVlcy5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaXNhKGNbaV0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXIucHVzaC5hcHBseShhciwgY1tpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBhci5wdXNoLmFwcGx5KGFyLCBiW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNbaV0gPSBhcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChfaXNvKGJbaV0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvdmVyd2l0ZSBjJ3MgdmFsdWUgd2l0aCBhbiBvYmplY3QgaWYgaXQgaXMgbm90IGFscmVhZHkgb25lLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFfaXNvKGNbaV0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY1tpXSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiBpbiBiW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY1tpXVtqXSA9IGJbaV1bal07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjO1xuICAgICAgICB9LFxuICAgICAgICByZXBsYWNlOiBmdW5jdGlvbiAoaW5PYmosIHBhdGgsIHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoaW5PYmogPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBxID0gaW5PYmosIHQgPSBxO1xuICAgICAgICAgICAgcGF0aC5yZXBsYWNlKC8oW15cXC5dKSsvZywgZnVuY3Rpb24gKHRlcm0sIGxjLCBwb3MsIHN0cikge1xuICAgICAgICAgICAgICAgIHZhciBhcnJheSA9IHRlcm0ubWF0Y2goLyhbXlxcWzAtOV0rKXsxfShcXFspKFswLTkrXSkvKSxcbiAgICAgICAgICAgICAgICAgICAgbGFzdCA9IHBvcyArIHRlcm0ubGVuZ3RoID49IHN0ci5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgIF9nZXRBcnJheSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0W2FycmF5WzFdXSB8fCAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRbYXJyYXlbMV1dID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRbYXJyYXlbMV1dO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGlmIChsYXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHNldCB0ZXJtID0gdmFsdWUgb24gY3VycmVudCB0LCBjcmVhdGluZyB0ZXJtIGFzIGFycmF5IGlmIG5lY2Vzc2FyeS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGFycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfZ2V0QXJyYXkoKVthcnJheVszXV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRbdGVybV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc2V0IHRvIGN1cnJlbnQgdFt0ZXJtXSwgY3JlYXRpbmcgdFt0ZXJtXSBpZiBuZWNlc3NhcnkuXG4gICAgICAgICAgICAgICAgICAgIGlmIChhcnJheSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSBfZ2V0QXJyYXkoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHQgPSBhW2FycmF5WzNdXSB8fCAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFbYXJyYXlbM11dID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFbYXJyYXlbM11dO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHQgPSB0W3Rlcm1dIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdFt0ZXJtXSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0W3Rlcm1dO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gaW5PYmo7XG4gICAgICAgIH0sXG4gICAgICAgIC8vXG4gICAgICAgIC8vIGNoYWluIGEgbGlzdCBvZiBmdW5jdGlvbnMsIHN1cHBsaWVkIGJ5IFsgb2JqZWN0LCBtZXRob2QgbmFtZSwgYXJncyBdLCBhbmQgcmV0dXJuIG9uIHRoZSBmaXJzdFxuICAgICAgICAvLyBvbmUgdGhhdCByZXR1cm5zIHRoZSBmYWlsVmFsdWUuIGlmIG5vbmUgcmV0dXJuIHRoZSBmYWlsVmFsdWUsIHJldHVybiB0aGUgc3VjY2Vzc1ZhbHVlLlxuICAgICAgICAvL1xuICAgICAgICBmdW5jdGlvbkNoYWluOiBmdW5jdGlvbiAoc3VjY2Vzc1ZhbHVlLCBmYWlsVmFsdWUsIGZucykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgbyA9IGZuc1tpXVswXVtmbnNbaV1bMV1dLmFwcGx5KGZuc1tpXVswXSwgZm5zW2ldWzJdKTtcbiAgICAgICAgICAgICAgICBpZiAobyA9PT0gZmFpbFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdWNjZXNzVmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIHRha2UgdGhlIGdpdmVuIG1vZGVsIGFuZCBleHBhbmQgb3V0IGFueSBwYXJhbWV0ZXJzLlxuICAgICAgICAvLyAnZnVuY3Rpb25QcmVmaXgnIGlzIG9wdGlvbmFsLCBhbmQgaWYgcHJlc2VudCwgaGVscHMganNwbHVtYiBmaWd1cmUgb3V0IHdoYXQgdG8gZG8gaWYgYSB2YWx1ZSBpcyBhIEZ1bmN0aW9uLlxuICAgICAgICAvLyBpZiB5b3UgZG8gbm90IHByb3ZpZGUgaXQsIGpzcGx1bWIgd2lsbCBydW4gdGhlIGdpdmVuIHZhbHVlcyB0aHJvdWdoIGFueSBmdW5jdGlvbnMgaXQgZmluZHMsIGFuZCB1c2UgdGhlIGZ1bmN0aW9uJ3NcbiAgICAgICAgLy8gb3V0cHV0IGFzIHRoZSB2YWx1ZSBpbiB0aGUgcmVzdWx0LiBpZiB5b3UgZG8gcHJvdmlkZSB0aGUgcHJlZml4LCBvbmx5IGZ1bmN0aW9ucyB0aGF0IGFyZSBuYW1lZCBhbmQgaGF2ZSB0aGlzIHByZWZpeFxuICAgICAgICAvLyB3aWxsIGJlIGV4ZWN1dGVkOyBvdGhlciBmdW5jdGlvbnMgd2lsbCBiZSBwYXNzZWQgYXMgdmFsdWVzIHRvIHRoZSBvdXRwdXQuXG4gICAgICAgIHBvcHVsYXRlOiBmdW5jdGlvbiAobW9kZWwsIHZhbHVlcywgZnVuY3Rpb25QcmVmaXgpIHtcbiAgICAgICAgICAgIC8vIGZvciBhIHN0cmluZywgc2VlIGlmIGl0IGhhcyBwYXJhbWV0ZXIgbWF0Y2hlcywgYW5kIGlmIHNvLCB0cnkgdG8gbWFrZSB0aGUgc3Vic3RpdHV0aW9ucy5cbiAgICAgICAgICAgIHZhciBnZXRWYWx1ZSA9IGZ1bmN0aW9uIChmcm9tU3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXRjaGVzID0gZnJvbVN0cmluZy5tYXRjaCgvKFxcJHsuKj99KS9nKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoZXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXRjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbCA9IHZhbHVlc1ttYXRjaGVzW2ldLnN1YnN0cmluZygyLCBtYXRjaGVzW2ldLmxlbmd0aCAtIDEpXSB8fCBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWwgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tU3RyaW5nID0gZnJvbVN0cmluZy5yZXBsYWNlKG1hdGNoZXNbaV0sIHZhbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmcm9tU3RyaW5nO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBwcm9jZXNzIG9uZSBlbnRyeS5cbiAgICAgICAgICAgICAgICBfb25lID0gZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9pc3MoZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0VmFsdWUoZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChfaXNmKGQpICYmIChmdW5jdGlvblByZWZpeCA9PSBudWxsIHx8IChkLm5hbWUgfHwgXCJcIikuaW5kZXhPZihmdW5jdGlvblByZWZpeCkgPT09IDApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGQodmFsdWVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKF9pc2EoZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgciA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByLnB1c2goX29uZShkW2ldKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoX2lzbyhkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiBpbiBkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNbal0gPSBfb25lKGRbal0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmV0dXJuIF9vbmUobW9kZWwpO1xuICAgICAgICB9LFxuICAgICAgICBmaW5kV2l0aEZ1bmN0aW9uOiBmdW5jdGlvbiAoYSwgZikge1xuICAgICAgICAgICAgaWYgKGEpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGYoYVtpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9LFxuICAgICAgICByZW1vdmVXaXRoRnVuY3Rpb246IGZ1bmN0aW9uIChhLCBmKSB7XG4gICAgICAgICAgICB2YXIgaWR4ID0gcm9vdC5qc1BsdW1iVXRpbC5maW5kV2l0aEZ1bmN0aW9uKGEsIGYpO1xuICAgICAgICAgICAgaWYgKGlkeCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgYS5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpZHggIT09IC0xO1xuICAgICAgICB9LFxuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIChsLCB2KSB7XG4gICAgICAgICAgICB2YXIgaWR4ID0gbC5pbmRleE9mKHYpO1xuICAgICAgICAgICAgaWYgKGlkeCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgbC5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpZHggIT09IC0xO1xuICAgICAgICB9LFxuICAgICAgICAvLyBUT0RPIHN1cHBvcnQgaW5zZXJ0IGluZGV4XG4gICAgICAgIGFkZFdpdGhGdW5jdGlvbjogZnVuY3Rpb24gKGxpc3QsIGl0ZW0sIGhhc2hGdW5jdGlvbikge1xuICAgICAgICAgICAgaWYgKHJvb3QuanNQbHVtYlV0aWwuZmluZFdpdGhGdW5jdGlvbihsaXN0LCBoYXNoRnVuY3Rpb24pID09PSAtMSkge1xuICAgICAgICAgICAgICAgIGxpc3QucHVzaChpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgYWRkVG9MaXN0OiBmdW5jdGlvbiAobWFwLCBrZXksIHZhbHVlLCBpbnNlcnRBdFN0YXJ0KSB7XG4gICAgICAgICAgICB2YXIgbCA9IG1hcFtrZXldO1xuICAgICAgICAgICAgaWYgKGwgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGwgPSBbXTtcbiAgICAgICAgICAgICAgICBtYXBba2V5XSA9IGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsW2luc2VydEF0U3RhcnQgPyBcInVuc2hpZnRcIiA6IFwicHVzaFwiXSh2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gbDtcbiAgICAgICAgfSxcbiAgICAgICAgc3VnZ2VzdCA6IGZ1bmN0aW9uKGxpc3QsIGl0ZW0sIGluc2VydEF0SGVhZCkge1xuICAgICAgICAgICAgaWYgKGxpc3QuaW5kZXhPZihpdGVtKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5zZXJ0QXRIZWFkKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3QudW5zaGlmdChpdGVtKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsaXN0LnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9LFxuICAgICAgICAvL1xuICAgICAgICAvLyBleHRlbmRzIHRoZSBnaXZlbiBvYmogKHdoaWNoIGNhbiBiZSBhbiBhcnJheSkgd2l0aCB0aGUgZ2l2ZW4gY29uc3RydWN0b3IgZnVuY3Rpb24sIHByb3RvdHlwZSBmdW5jdGlvbnMsIGFuZFxuICAgICAgICAvLyBjbGFzcyBtZW1iZXJzLCBhbnkgb2Ygd2hpY2ggbWF5IGJlIG51bGwuXG4gICAgICAgIC8vXG4gICAgICAgIGV4dGVuZDogZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQsIF9wcm90b0ZuKSB7XG4gICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgIHBhcmVudCA9IF9pc2EocGFyZW50KSA/IHBhcmVudCA6IFsgcGFyZW50IF07XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBwYXJlbnQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqIGluIHBhcmVudFtpXS5wcm90b3R5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudFtpXS5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkoaikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkLnByb3RvdHlwZVtqXSA9IHBhcmVudFtpXS5wcm90b3R5cGVbal07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBfbWFrZUZuID0gZnVuY3Rpb24gKG5hbWUsIHByb3RvRm4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcGFyZW50Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50W2ldLnByb3RvdHlwZVtuYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudFtpXS5wcm90b3R5cGVbbmFtZV0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvdG9Gbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgX29uZVNldCA9IGZ1bmN0aW9uIChmbnMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrIGluIGZucykge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZC5wcm90b3R5cGVba10gPSBfbWFrZUZuKGssIGZuc1trXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMjsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBfb25lU2V0KGFyZ3VtZW50c1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgICAgIH0sXG4gICAgICAgIHV1aWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAoJ3h4eHh4eHh4LXh4eHgtNHh4eC15eHh4LXh4eHh4eHh4eHh4eCcucmVwbGFjZSgvW3h5XS9nLCBmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgICAgIHZhciByID0gTWF0aC5yYW5kb20oKSAqIDE2IHwgMCwgdiA9IGMgPT09ICd4JyA/IHIgOiAociAmIDB4MyB8IDB4OCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHYudG9TdHJpbmcoMTYpO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9LFxuICAgICAgICBsb2dFbmFibGVkOiB0cnVlLFxuICAgICAgICBsb2c6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChyb290LmpzUGx1bWJVdGlsLmxvZ0VuYWJsZWQgJiYgdHlwZW9mIGNvbnNvbGUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbXNnID0gYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2cobXNnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdyYXBzIG9uZSBmdW5jdGlvbiB3aXRoIGFub3RoZXIsIGNyZWF0aW5nIGEgcGxhY2Vob2xkZXIgZm9yIHRoZVxuICAgICAgICAgKiB3cmFwcGVkIGZ1bmN0aW9uIGlmIGl0IHdhcyBudWxsLiB0aGlzIGlzIHVzZWQgdG8gd3JhcCB0aGUgdmFyaW91c1xuICAgICAgICAgKiBkcmFnL2Ryb3AgZXZlbnQgZnVuY3Rpb25zIC0gdG8gYWxsb3cganNQbHVtYiB0byBiZSBub3RpZmllZCBvZlxuICAgICAgICAgKiBpbXBvcnRhbnQgbGlmZWN5Y2xlIGV2ZW50cyB3aXRob3V0IGltcG9zaW5nIGl0c2VsZiBvbiB0aGUgdXNlcidzXG4gICAgICAgICAqIGRyYWcvZHJvcCBmdW5jdGlvbmFsaXR5LlxuICAgICAgICAgKiBAbWV0aG9kIGpzUGx1bWJVdGlsLndyYXBcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gd3JhcHBlZEZ1bmN0aW9uIG9yaWdpbmFsIGZ1bmN0aW9uIHRvIHdyYXA7IG1heSBiZSBudWxsLlxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBuZXdGdW5jdGlvbiBmdW5jdGlvbiB0byB3cmFwIHRoZSBvcmlnaW5hbCB3aXRoLlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gW3JldHVybk9uVGhpc1ZhbHVlXSBPcHRpb25hbC4gSW5kaWNhdGVzIHRoYXQgdGhlIHdyYXBwZWRGdW5jdGlvbiBzaG91bGRcbiAgICAgICAgICogbm90IGJlIGV4ZWN1dGVkIGlmIHRoZSBuZXdGdW5jdGlvbiByZXR1cm5zIGEgdmFsdWUgbWF0Y2hpbmcgJ3JldHVybk9uVGhpc1ZhbHVlJy5cbiAgICAgICAgICogbm90ZSB0aGF0IHRoaXMgaXMgYSBzaW1wbGUgY29tcGFyaXNvbiBhbmQgb25seSB3b3JrcyBmb3IgcHJpbWl0aXZlcyByaWdodCBub3cuXG4gICAgICAgICAqL1xuICAgICAgICB3cmFwOiBmdW5jdGlvbiAod3JhcHBlZEZ1bmN0aW9uLCBuZXdGdW5jdGlvbiwgcmV0dXJuT25UaGlzVmFsdWUpIHtcbiAgICAgICAgICAgIHdyYXBwZWRGdW5jdGlvbiA9IHdyYXBwZWRGdW5jdGlvbiB8fCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbmV3RnVuY3Rpb24gPSBuZXdGdW5jdGlvbiB8fCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgciA9IG51bGw7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgciA9IG5ld0Z1bmN0aW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICByb290LmpzUGx1bWJVdGlsLmxvZyhcImpzUGx1bWIgZnVuY3Rpb24gZmFpbGVkIDogXCIgKyBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJldHVybk9uVGhpc1ZhbHVlID09IG51bGwgfHwgKHIgIT09IHJldHVybk9uVGhpc1ZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgciA9IHdyYXBwZWRGdW5jdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByb290LmpzUGx1bWJVdGlsLmxvZyhcIndyYXBwZWQgZnVuY3Rpb24gZmFpbGVkIDogXCIgKyBlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcm9vdC5qc1BsdW1iVXRpbC5FdmVudEdlbmVyYXRvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9saXN0ZW5lcnMgPSB7fSxcbiAgICAgICAgICAgIGV2ZW50c1N1c3BlbmRlZCA9IGZhbHNlLFxuICAgICAgICAgICAgdGljayA9IGZhbHNlLFxuICAgICAgICAvLyB0aGlzIGlzIGEgbGlzdCBvZiBldmVudHMgdGhhdCBzaG91bGQgcmUtdGhyb3cgYW55IGVycm9ycyB0aGF0IG9jY3VyIGR1cmluZyB0aGVpciBkaXNwYXRjaC4gaXQgaXMgY3VycmVudCBwcml2YXRlLlxuICAgICAgICAgICAgZXZlbnRzVG9EaWVPbiA9IHsgXCJyZWFkeVwiOiB0cnVlIH0sXG4gICAgICAgICAgICBxdWV1ZSA9IFtdO1xuXG4gICAgICAgIHRoaXMuYmluZCA9IGZ1bmN0aW9uIChldmVudCwgbGlzdGVuZXIsIGluc2VydEF0U3RhcnQpIHtcbiAgICAgICAgICAgIHZhciBfb25lID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgICAgICAgICAgcm9vdC5qc1BsdW1iVXRpbC5hZGRUb0xpc3QoX2xpc3RlbmVycywgZXZ0LCBsaXN0ZW5lciwgaW5zZXJ0QXRTdGFydCk7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXIuX19qc1BsdW1iID0gbGlzdGVuZXIuX19qc1BsdW1iIHx8IHt9O1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyLl9fanNQbHVtYltyb290LmpzUGx1bWJVdGlsLnV1aWQoKV0gPSBldnQ7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGV2ZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgX29uZShldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChldmVudC5sZW5ndGggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXZlbnQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgX29uZShldmVudFtpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmZpcmUgPSBmdW5jdGlvbiAoZXZlbnQsIHZhbHVlLCBvcmlnaW5hbEV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoIXRpY2spIHtcbiAgICAgICAgICAgICAgICB0aWNrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoIWV2ZW50c1N1c3BlbmRlZCAmJiBfbGlzdGVuZXJzW2V2ZW50XSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbCA9IF9saXN0ZW5lcnNbZXZlbnRdLmxlbmd0aCwgaSA9IDAsIF9nb25lID0gZmFsc2UsIHJldCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5zaG91bGRGaXJlRXZlbnQgfHwgdGhpcy5zaG91bGRGaXJlRXZlbnQoZXZlbnQsIHZhbHVlLCBvcmlnaW5hbEV2ZW50KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCFfZ29uZSAmJiBpIDwgbCAmJiByZXQgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZG9pbmcgaXQgdGhpcyB3YXkgcmF0aGVyIHRoYW4gY2F0Y2hpbmcgYW5kIHRoZW4gcG9zc2libHkgcmUtdGhyb3dpbmcgbWVhbnMgdGhhdCBhbiBlcnJvciBwcm9wYWdhdGVkIGJ5IHRoaXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBtZXRob2Qgd2lsbCBoYXZlIHRoZSB3aG9sZSBjYWxsIHN0YWNrIGF2YWlsYWJsZSBpbiB0aGUgZGVidWdnZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50c1RvRGllT25bZXZlbnRdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9saXN0ZW5lcnNbZXZlbnRdW2ldLmFwcGx5KHRoaXMsIFt2YWx1ZSwgb3JpZ2luYWxFdmVudF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldCA9IF9saXN0ZW5lcnNbZXZlbnRdW2ldLmFwcGx5KHRoaXMsIFt2YWx1ZSwgb3JpZ2luYWxFdmVudF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByb290LmpzUGx1bWJVdGlsLmxvZyhcImpzUGx1bWI6IGZpcmUgZmFpbGVkIGZvciBldmVudCBcIiArIGV2ZW50ICsgXCIgOiBcIiArIGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2xpc3RlbmVycyA9PSBudWxsIHx8IF9saXN0ZW5lcnNbZXZlbnRdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2dvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aWNrID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgX2RyYWluKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHF1ZXVlLnVuc2hpZnQoYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBfZHJhaW4gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBuID0gcXVldWUucG9wKCk7XG4gICAgICAgICAgICBpZiAobikge1xuICAgICAgICAgICAgICAgIHRoaXMuZmlyZS5hcHBseSh0aGlzLCBuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfS5iaW5kKHRoaXMpO1xuXG4gICAgICAgIHRoaXMudW5iaW5kID0gZnVuY3Rpb24gKGV2ZW50T3JMaXN0ZW5lciwgbGlzdGVuZXIpIHtcblxuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBfbGlzdGVuZXJzID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBldmVudE9yTGlzdGVuZXIgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIF9saXN0ZW5lcnNbZXZlbnRPckxpc3RlbmVyXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnRPckxpc3RlbmVyLl9fanNQbHVtYikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXZ0O1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpIGluIGV2ZW50T3JMaXN0ZW5lci5fX2pzUGx1bWIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2dCA9IGV2ZW50T3JMaXN0ZW5lci5fX2pzUGx1bWJbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICByb290LmpzUGx1bWJVdGlsLnJlbW92ZShfbGlzdGVuZXJzW2V2dF0gfHwgW10sIGV2ZW50T3JMaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgICAgcm9vdC5qc1BsdW1iVXRpbC5yZW1vdmUoX2xpc3RlbmVyc1tldmVudE9yTGlzdGVuZXJdIHx8IFtdLCBsaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuZ2V0TGlzdGVuZXIgPSBmdW5jdGlvbiAoZm9yRXZlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBfbGlzdGVuZXJzW2ZvckV2ZW50XTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zZXRTdXNwZW5kRXZlbnRzID0gZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgZXZlbnRzU3VzcGVuZGVkID0gdmFsO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmlzU3VzcGVuZEV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBldmVudHNTdXNwZW5kZWQ7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc2lsZW50bHkgPSBmdW5jdGlvbihmbikge1xuICAgICAgICAgICAgdGhpcy5zZXRTdXNwZW5kRXZlbnRzKHRydWUpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByb290LmpzUGx1bWJVdGlsLmxvZyhcIkNhbm5vdCBleGVjdXRlIHNpbGVudCBmdW5jdGlvbiBcIiArIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zZXRTdXNwZW5kRXZlbnRzKGZhbHNlKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jbGVhbnVwTGlzdGVuZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSBpbiBfbGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgICAgX2xpc3RlbmVyc1tpXSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIHJvb3QuanNQbHVtYlV0aWwuRXZlbnRHZW5lcmF0b3IucHJvdG90eXBlID0ge1xuICAgICAgICBjbGVhbnVwOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmNsZWFudXBMaXN0ZW5lcnMoKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAodHlwZW9mIGV4cG9ydHMgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgZXhwb3J0cy5qc1BsdW1iVXRpbCA9IHJvb3QuanNQbHVtYlV0aWw7XG4gICAgfVxuXG59KS5jYWxsKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdGhpcyk7XG5cbi8qXG4gKiBqc1BsdW1iIENvbW11bml0eSBFZGl0aW9uXG4gKlxuICogUHJvdmlkZXMgYSB3YXkgdG8gdmlzdWFsbHkgY29ubmVjdCBlbGVtZW50cyBvbiBhbiBIVE1MIHBhZ2UsIHVzaW5nIFNWRy5cbiAqXG4gKiBUaGlzIGZpbGUgY29udGFpbnMgdXRpbGl0eSBmdW5jdGlvbnMgdGhhdCBydW4gaW4gYnJvd3NlcnMgb25seS5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTAgLSAyMDE3IGpzUGx1bWIgKGhlbGxvQGpzcGx1bWJ0b29sa2l0LmNvbSlcbiAqXG4gKiBodHRwczovL2pzcGx1bWJ0b29sa2l0LmNvbVxuICogaHR0cHM6Ly9naXRodWIuY29tL2pzcGx1bWIvanNwbHVtYlxuICpcbiAqIER1YWwgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBhbmQgR1BMMiBsaWNlbnNlcy5cbiAqL1xuIDsoZnVuY3Rpb24oKSB7XG5cbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgIHZhciByb290ID0gdGhpcztcblxuICAgIHJvb3QuanNQbHVtYlV0aWwubWF0Y2hlc1NlbGVjdG9yID0gZnVuY3Rpb24oZWwsIHNlbGVjdG9yLCBjdHgpIHtcbiAgICAgICBjdHggPSBjdHggfHwgZWwucGFyZW50Tm9kZTtcbiAgICAgICB2YXIgcG9zc2libGVzID0gY3R4LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xuICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9zc2libGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgIGlmIChwb3NzaWJsZXNbaV0gPT09IGVsKSB7XG4gICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgfVxuICAgICAgIH1cbiAgICAgICByZXR1cm4gZmFsc2U7XG4gICB9O1xuXG4gICAgcm9vdC5qc1BsdW1iVXRpbC5jb25zdW1lID0gZnVuY3Rpb24oZSwgZG9Ob3RQcmV2ZW50RGVmYXVsdCkge1xuICAgICAgIGlmIChlLnN0b3BQcm9wYWdhdGlvbikge1xuICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgIH1cbiAgICAgICBlbHNlIHtcbiAgICAgICAgICAgZS5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xuICAgICAgIH1cblxuICAgICAgIGlmICghZG9Ob3RQcmV2ZW50RGVmYXVsdCAmJiBlLnByZXZlbnREZWZhdWx0KXtcbiAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgIH1cbiAgIH07XG5cbiAgIC8qXG4gICAgKiBGdW5jdGlvbjogc2l6ZUVsZW1lbnRcbiAgICAqIEhlbHBlciB0byBzaXplIGFuZCBwb3NpdGlvbiBhbiBlbGVtZW50LiBZb3Ugd291bGQgdHlwaWNhbGx5IHVzZVxuICAgICogdGhpcyB3aGVuIHdyaXRpbmcgeW91ciBvd24gQ29ubmVjdG9yIG9yIEVuZHBvaW50IGltcGxlbWVudGF0aW9uLlxuICAgICpcbiAgICAqIFBhcmFtZXRlcnM6XG4gICAgKiAgeCAtIFtpbnRdIHggcG9zaXRpb24gZm9yIHRoZSBlbGVtZW50IG9yaWdpblxuICAgICogIHkgLSBbaW50XSB5IHBvc2l0aW9uIGZvciB0aGUgZWxlbWVudCBvcmlnaW5cbiAgICAqICB3IC0gW2ludF0gd2lkdGggb2YgdGhlIGVsZW1lbnRcbiAgICAqICBoIC0gW2ludF0gaGVpZ2h0IG9mIHRoZSBlbGVtZW50XG4gICAgKlxuICAgICovXG4gICAgcm9vdC5qc1BsdW1iVXRpbC5zaXplRWxlbWVudCA9IGZ1bmN0aW9uKGVsLCB4LCB5LCB3LCBoKSB7XG4gICAgICAgaWYgKGVsKSB7XG4gICAgICAgICAgIGVsLnN0eWxlLmhlaWdodCA9IGggKyBcInB4XCI7XG4gICAgICAgICAgIGVsLmhlaWdodCA9IGg7XG4gICAgICAgICAgIGVsLnN0eWxlLndpZHRoID0gdyArIFwicHhcIjtcbiAgICAgICAgICAgZWwud2lkdGggPSB3O1xuICAgICAgICAgICBlbC5zdHlsZS5sZWZ0ID0geCArIFwicHhcIjtcbiAgICAgICAgICAgZWwuc3R5bGUudG9wID0geSArIFwicHhcIjtcbiAgICAgICB9XG4gICB9O1xuXG4gfSkuY2FsbCh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHRoaXMpO1xuXG4vKlxuICoganNQbHVtYlxuICogXG4gKiBUaXRsZTpqc1BsdW1iIDIuMy4wXG4gKiBcbiAqIFByb3ZpZGVzIGEgd2F5IHRvIHZpc3VhbGx5IGNvbm5lY3QgZWxlbWVudHMgb24gYW4gSFRNTCBwYWdlLCB1c2luZyBTVkcuXG4gKiBcbiAqIFRoaXMgZmlsZSBjb250YWlucyB0aGUgY29yZSBjb2RlLlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMCAtIDIwMTcganNQbHVtYiAoaGVsbG9AanNwbHVtYnRvb2xraXQuY29tKVxuICogXG4gKiBodHRwOi8vanNwbHVtYnRvb2xraXQuY29tXG4gKiBodHRwOi8vZ2l0aHViLmNvbS9zcG9ycml0dC9qc3BsdW1iXG4gKiBcbiAqIER1YWwgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBhbmQgR1BMMiBsaWNlbnNlcy5cbiAqL1xuKGZ1bmN0aW9uICgpIHtcblxuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgdmFyIHJvb3QgPSB0aGlzO1xuICAgIHZhciBjb25uZWN0b3JUeXBlcyA9IFtdLCByZW5kZXJlclR5cGVzO1xuXG4gICAgdmFyIF9qdSA9IHJvb3QuanNQbHVtYlV0aWwsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGNyZWF0ZXMgYSB0aW1lc3RhbXAsIHVzaW5nIG1pbGxpc2Vjb25kcyBzaW5jZSAxOTcwLCBidXQgYXMgYSBzdHJpbmcuXG4gICAgICAgICAqL1xuICAgICAgICBfdGltZXN0YW1wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiXCIgKyAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuICAgICAgICB9LFxuXG4gICAgLy8gaGVscGVyIG1ldGhvZCB0byB1cGRhdGUgdGhlIGhvdmVyIHN0eWxlIHdoZW5ldmVyIGl0LCBvciBwYWludFN0eWxlLCBjaGFuZ2VzLlxuICAgIC8vIHdlIHVzZSBwYWludFN0eWxlIGFzIHRoZSBmb3VuZGF0aW9uIGFuZCBtZXJnZSBob3ZlclBhaW50U3R5bGUgb3ZlciB0aGVcbiAgICAvLyB0b3AuXG4gICAgICAgIF91cGRhdGVIb3ZlclN0eWxlID0gZnVuY3Rpb24gKGNvbXBvbmVudCkge1xuICAgICAgICAgICAgaWYgKGNvbXBvbmVudC5fanNQbHVtYi5wYWludFN0eWxlICYmIGNvbXBvbmVudC5fanNQbHVtYi5ob3ZlclBhaW50U3R5bGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWVyZ2VkSG92ZXJTdHlsZSA9IHt9O1xuICAgICAgICAgICAgICAgIGpzUGx1bWIuZXh0ZW5kKG1lcmdlZEhvdmVyU3R5bGUsIGNvbXBvbmVudC5fanNQbHVtYi5wYWludFN0eWxlKTtcbiAgICAgICAgICAgICAgICBqc1BsdW1iLmV4dGVuZChtZXJnZWRIb3ZlclN0eWxlLCBjb21wb25lbnQuX2pzUGx1bWIuaG92ZXJQYWludFN0eWxlKTtcbiAgICAgICAgICAgICAgICBkZWxldGUgY29tcG9uZW50Ll9qc1BsdW1iLmhvdmVyUGFpbnRTdHlsZTtcbiAgICAgICAgICAgICAgICAvLyB3ZSB3YW50IHRoZSBmaWxsIG9mIHBhaW50U3R5bGUgdG8gb3ZlcnJpZGUgYSBncmFkaWVudCwgaWYgcG9zc2libGUuXG4gICAgICAgICAgICAgICAgaWYgKG1lcmdlZEhvdmVyU3R5bGUuZ3JhZGllbnQgJiYgY29tcG9uZW50Ll9qc1BsdW1iLnBhaW50U3R5bGUuZmlsbCkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgbWVyZ2VkSG92ZXJTdHlsZS5ncmFkaWVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29tcG9uZW50Ll9qc1BsdW1iLmhvdmVyUGFpbnRTdHlsZSA9IG1lcmdlZEhvdmVyU3R5bGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGV2ZW50cyA9IFtcInRhcFwiLCBcImRibHRhcFwiLCBcImNsaWNrXCIsIFwiZGJsY2xpY2tcIiwgXCJtb3VzZW92ZXJcIiwgXCJtb3VzZW91dFwiLCBcIm1vdXNlbW92ZVwiLCBcIm1vdXNlZG93blwiLCBcIm1vdXNldXBcIiwgXCJjb250ZXh0bWVudVwiIF0sXG4gICAgICAgIGV2ZW50RmlsdGVycyA9IHsgXCJtb3VzZW91dFwiOiBcIm1vdXNlbGVhdmVcIiwgXCJtb3VzZWV4aXRcIjogXCJtb3VzZWxlYXZlXCIgfSxcbiAgICAgICAgX3VwZGF0ZUF0dGFjaGVkRWxlbWVudHMgPSBmdW5jdGlvbiAoY29tcG9uZW50LCBzdGF0ZSwgdGltZXN0YW1wLCBzb3VyY2VFbGVtZW50KSB7XG4gICAgICAgICAgICB2YXIgYWZmZWN0ZWRFbGVtZW50cyA9IGNvbXBvbmVudC5nZXRBdHRhY2hlZEVsZW1lbnRzKCk7XG4gICAgICAgICAgICBpZiAoYWZmZWN0ZWRFbGVtZW50cykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBqID0gYWZmZWN0ZWRFbGVtZW50cy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzb3VyY2VFbGVtZW50IHx8IHNvdXJjZUVsZW1lbnQgIT09IGFmZmVjdGVkRWxlbWVudHNbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFmZmVjdGVkRWxlbWVudHNbaV0uc2V0SG92ZXIoc3RhdGUsIHRydWUsIHRpbWVzdGFtcCk7XHRcdFx0Ly8gdGVsbCB0aGUgYXR0YWNoZWQgZWxlbWVudHMgbm90IHRvIGluZm9ybSB0aGVpciBvd24gYXR0YWNoZWQgZWxlbWVudHMuXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIF9zcGxpdFR5cGUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgcmV0dXJuIHQgPT0gbnVsbCA/IG51bGwgOiB0LnNwbGl0KFwiIFwiKTtcbiAgICAgICAgfSxcbiAgICAgICAgX21hcFR5cGUgPSBmdW5jdGlvbihtYXAsIG9iaiwgdHlwZUlkKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpIGluIG9iaikge1xuICAgICAgICAgICAgICAgIG1hcFtpXSA9IHR5cGVJZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgX2VhY2ggPSBmdW5jdGlvbihmbiwgb2JqKSB7XG4gICAgICAgICAgICBvYmogPSBfanUuaXNBcnJheShvYmopIHx8IChvYmoubGVuZ3RoICE9IG51bGwgJiYgIV9qdS5pc1N0cmluZyhvYmopKSA/IG9iaiA6IFsgb2JqIF07XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iai5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGZuLmFwcGx5KG9ialtpXSwgWyBvYmpbaV0gXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIF9qdS5sb2coXCIuZWFjaCBpdGVyYXRpb24gZmFpbGVkIDogXCIgKyBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIF9hcHBseVR5cGVzID0gZnVuY3Rpb24gKGNvbXBvbmVudCwgcGFyYW1zLCBkb05vdFJlcGFpbnQpIHtcbiAgICAgICAgICAgIGlmIChjb21wb25lbnQuZ2V0RGVmYXVsdFR5cGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGQgPSBjb21wb25lbnQuZ2V0VHlwZURlc2NyaXB0b3IoKSwgbWFwID0ge307XG4gICAgICAgICAgICAgICAgdmFyIGRlZlR5cGUgPSBjb21wb25lbnQuZ2V0RGVmYXVsdFR5cGUoKTtcbiAgICAgICAgICAgICAgICB2YXIgbyA9IF9qdS5tZXJnZSh7fSwgZGVmVHlwZSk7XG4gICAgICAgICAgICAgICAgX21hcFR5cGUobWFwLCBkZWZUeXBlLCBcIl9fZGVmYXVsdFwiKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaiA9IGNvbXBvbmVudC5fanNQbHVtYi50eXBlcy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRpZCA9IGNvbXBvbmVudC5fanNQbHVtYi50eXBlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRpZCAhPT0gXCJfX2RlZmF1bHRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF90ID0gY29tcG9uZW50Ll9qc1BsdW1iLmluc3RhbmNlLmdldFR5cGUodGlkLCB0ZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3QgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG8gPSBfanUubWVyZ2UobywgX3QsIFsgXCJjc3NDbGFzc1wiIF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9tYXBUeXBlKG1hcCwgX3QsIHRpZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAocGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgICAgIG8gPSBfanUucG9wdWxhdGUobywgcGFyYW1zLCBcIl9cIik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29tcG9uZW50LmFwcGx5VHlwZShvLCBkb05vdFJlcGFpbnQsIG1hcCk7XG4gICAgICAgICAgICAgICAgaWYgKCFkb05vdFJlcGFpbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50LnJlcGFpbnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBCRUdJTiBqc1BsdW1iVUlDb21wb25lbnQgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICBqc1BsdW1iVUlDb21wb25lbnQgPSByb290LmpzUGx1bWJVSUNvbXBvbmVudCA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcblxuICAgICAgICAgICAgX2p1LkV2ZW50R2VuZXJhdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgICAgICAgICBhID0gYXJndW1lbnRzLFxuICAgICAgICAgICAgICAgIGlkUHJlZml4ID0gc2VsZi5pZFByZWZpeCxcbiAgICAgICAgICAgICAgICBpZCA9IGlkUHJlZml4ICsgKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcblxuICAgICAgICAgICAgdGhpcy5fanNQbHVtYiA9IHtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZTogcGFyYW1zLl9qc1BsdW1iLFxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnM6IHBhcmFtcy5wYXJhbWV0ZXJzIHx8IHt9LFxuICAgICAgICAgICAgICAgIHBhaW50U3R5bGU6IG51bGwsXG4gICAgICAgICAgICAgICAgaG92ZXJQYWludFN0eWxlOiBudWxsLFxuICAgICAgICAgICAgICAgIHBhaW50U3R5bGVJblVzZTogbnVsbCxcbiAgICAgICAgICAgICAgICBob3ZlcjogZmFsc2UsXG4gICAgICAgICAgICAgICAgYmVmb3JlRGV0YWNoOiBwYXJhbXMuYmVmb3JlRGV0YWNoLFxuICAgICAgICAgICAgICAgIGJlZm9yZURyb3A6IHBhcmFtcy5iZWZvcmVEcm9wLFxuICAgICAgICAgICAgICAgIG92ZXJsYXlQbGFjZW1lbnRzOiBbXSxcbiAgICAgICAgICAgICAgICBob3ZlckNsYXNzOiBwYXJhbXMuaG92ZXJDbGFzcyB8fCBwYXJhbXMuX2pzUGx1bWIuRGVmYXVsdHMuSG92ZXJDbGFzcyxcbiAgICAgICAgICAgICAgICB0eXBlczogW10sXG4gICAgICAgICAgICAgICAgdHlwZUNhY2hlOnt9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB0aGlzLmNhY2hlVHlwZUl0ZW0gPSBmdW5jdGlvbihrZXksIGl0ZW0sIHR5cGVJZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2pzUGx1bWIudHlwZUNhY2hlW3R5cGVJZF0gPSB0aGlzLl9qc1BsdW1iLnR5cGVDYWNoZVt0eXBlSWRdIHx8IHt9O1xuICAgICAgICAgICAgICAgIHRoaXMuX2pzUGx1bWIudHlwZUNhY2hlW3R5cGVJZF1ba2V5XSA9IGl0ZW07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5nZXRDYWNoZWRUeXBlSXRlbSA9IGZ1bmN0aW9uKGtleSwgdHlwZUlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2pzUGx1bWIudHlwZUNhY2hlW3R5cGVJZF0gPyB0aGlzLl9qc1BsdW1iLnR5cGVDYWNoZVt0eXBlSWRdW2tleV0gOiBudWxsO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdGhpcy5nZXRJZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWQ7XG4gICAgICAgICAgICB9O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBkZWZhdWx0IHR5cGUgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXG4gICAgICAgICAgICB2YXIgbyA9IHBhcmFtcy5vdmVybGF5cyB8fCBbXSwgb28gPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmRlZmF1bHRPdmVybGF5S2V5cykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5kZWZhdWx0T3ZlcmxheUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkobywgdGhpcy5fanNQbHVtYi5pbnN0YW5jZS5EZWZhdWx0c1t0aGlzLmRlZmF1bHRPdmVybGF5S2V5c1tpXV0gfHwgW10pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBvLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIGEgc3RyaW5nLCBjb252ZXJ0IHRvIG9iamVjdCByZXByZXNlbnRhdGlvbiBzbyB0aGF0IHdlIGNhbiBzdG9yZSB0aGUgdHlwZWlkIG9uIGl0LlxuICAgICAgICAgICAgICAgICAgICAvLyBhbHNvIGFzc2lnbiBhbiBpZC5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGZvID0ganNQbHVtYi5jb252ZXJ0VG9GdWxsT3ZlcmxheVNwZWMob1tpXSk7XG4gICAgICAgICAgICAgICAgICAgIG9vW2ZvWzFdLmlkXSA9IGZvO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIF9kZWZhdWx0VHlwZSA9IHtcbiAgICAgICAgICAgICAgICBvdmVybGF5czpvbyxcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzOiBwYXJhbXMucGFyYW1ldGVycyB8fCB7fSxcbiAgICAgICAgICAgICAgICBzY29wZTogcGFyYW1zLnNjb3BlIHx8IHRoaXMuX2pzUGx1bWIuaW5zdGFuY2UuZ2V0RGVmYXVsdFNjb3BlKClcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLmdldERlZmF1bHRUeXBlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9kZWZhdWx0VHlwZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLmFwcGVuZFRvRGVmYXVsdFR5cGUgPSBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpIGluIG9iaikge1xuICAgICAgICAgICAgICAgICAgICBfZGVmYXVsdFR5cGVbaV0gPSBvYmpbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gZW5kIGRlZmF1bHQgdHlwZSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgICAgICAvLyBhbGwgY29tcG9uZW50cyBjYW4gZ2VuZXJhdGUgZXZlbnRzXG5cbiAgICAgICAgICAgIGlmIChwYXJhbXMuZXZlbnRzKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgZXZ0TmFtZSBpbiBwYXJhbXMuZXZlbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuYmluZChldnROYW1lLCBwYXJhbXMuZXZlbnRzW2V2dE5hbWVdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGFsbCBjb21wb25lbnRzIGdldCB0aGlzIGNsb25lIGZ1bmN0aW9uLlxuICAgICAgICAgICAgLy8gVE9ETyBpc3N1ZSAxMTYgc2hvd2VkIGEgcHJvYmxlbSB3aXRoIHRoaXMgLSBpdCBzZWVtcyAnYScgdGhhdCBpcyBpblxuICAgICAgICAgICAgLy8gdGhlIGNsb25lIGZ1bmN0aW9uJ3Mgc2NvcGUgaXMgc2hhcmVkIGJ5IGFsbCBpbnZvY2F0aW9ucyBvZiBpdCwgdGhlIGNsYXNzaWNcbiAgICAgICAgICAgIC8vIEpTIGNsb3N1cmUgcHJvYmxlbS4gIGZvciBub3csIGpzUGx1bWIgZG9lcyBhIHZlcnNpb24gb2YgdGhpcyBpbmxpbmUgd2hlcmVcbiAgICAgICAgICAgIC8vIGl0IHVzZWQgdG8gY2FsbCBjbG9uZS4gIGJ1dCBpdCB3b3VsZCBiZSBuaWNlIHRvIGZpbmQgc29tZSB0aW1lIHRvIGxvb2tcbiAgICAgICAgICAgIC8vIGZ1cnRoZXIgYXQgdGhpcy5cbiAgICAgICAgICAgIHRoaXMuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIG8gPSBPYmplY3QuY3JlYXRlKHRoaXMuY29uc3RydWN0b3IucHJvdG90eXBlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnN0cnVjdG9yLmFwcGx5KG8sIGEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBvO1xuICAgICAgICAgICAgfS5iaW5kKHRoaXMpO1xuXG4gICAgICAgICAgICAvLyB1c2VyIGNhbiBzdXBwbHkgYSBiZWZvcmVEZXRhY2ggY2FsbGJhY2ssIHdoaWNoIHdpbGwgYmUgZXhlY3V0ZWQgYmVmb3JlIGEgZGV0YWNoXG4gICAgICAgICAgICAvLyBpcyBwZXJmb3JtZWQ7IHJldHVybmluZyBmYWxzZSBwcmV2ZW50cyB0aGUgZGV0YWNoLlxuICAgICAgICAgICAgdGhpcy5pc0RldGFjaEFsbG93ZWQgPSBmdW5jdGlvbiAoY29ubmVjdGlvbikge1xuICAgICAgICAgICAgICAgIHZhciByID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fanNQbHVtYi5iZWZvcmVEZXRhY2gpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHIgPSB0aGlzLl9qc1BsdW1iLmJlZm9yZURldGFjaChjb25uZWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2p1LmxvZyhcImpzUGx1bWI6IGJlZm9yZURldGFjaCBjYWxsYmFjayBmYWlsZWRcIiwgZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyB1c2VyIGNhbiBzdXBwbHkgYSBiZWZvcmVEcm9wIGNhbGxiYWNrLCB3aGljaCB3aWxsIGJlIGV4ZWN1dGVkIGJlZm9yZSBhIGRyb3BwZWRcbiAgICAgICAgICAgIC8vIGNvbm5lY3Rpb24gaXMgY29uZmlybWVkLiB1c2VyIGNhbiByZXR1cm4gZmFsc2UgdG8gcmVqZWN0IGNvbm5lY3Rpb24uXG4gICAgICAgICAgICB0aGlzLmlzRHJvcEFsbG93ZWQgPSBmdW5jdGlvbiAoc291cmNlSWQsIHRhcmdldElkLCBzY29wZSwgY29ubmVjdGlvbiwgZHJvcEVuZHBvaW50LCBzb3VyY2UsIHRhcmdldCkge1xuICAgICAgICAgICAgICAgIHZhciByID0gdGhpcy5fanNQbHVtYi5pbnN0YW5jZS5jaGVja0NvbmRpdGlvbihcImJlZm9yZURyb3BcIiwge1xuICAgICAgICAgICAgICAgICAgICBzb3VyY2VJZDogc291cmNlSWQsXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldElkOiB0YXJnZXRJZCxcbiAgICAgICAgICAgICAgICAgICAgc2NvcGU6IHNjb3BlLFxuICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uOiBjb25uZWN0aW9uLFxuICAgICAgICAgICAgICAgICAgICBkcm9wRW5kcG9pbnQ6IGRyb3BFbmRwb2ludCxcbiAgICAgICAgICAgICAgICAgICAgc291cmNlOiBzb3VyY2UsIHRhcmdldDogdGFyZ2V0XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2pzUGx1bWIuYmVmb3JlRHJvcCkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgciA9IHRoaXMuX2pzUGx1bWIuYmVmb3JlRHJvcCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlSWQ6IHNvdXJjZUlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldElkOiB0YXJnZXRJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY29wZTogc2NvcGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbjogY29ubmVjdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkcm9wRW5kcG9pbnQ6IGRyb3BFbmRwb2ludCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IHNvdXJjZSwgdGFyZ2V0OiB0YXJnZXRcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfanUubG9nKFwianNQbHVtYjogYmVmb3JlRHJvcCBjYWxsYmFjayBmYWlsZWRcIiwgZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgZG9tTGlzdGVuZXJzID0gW107XG5cbiAgICAgICAgICAgIC8vIHNldHMgdGhlIGNvbXBvbmVudCBhc3NvY2lhdGVkIHdpdGggbGlzdGVuZXIgZXZlbnRzLiBmb3IgaW5zdGFuY2UsIGFuIG92ZXJsYXkgZGVsZWdhdGVzXG4gICAgICAgICAgICAvLyBpdHMgZXZlbnRzIGJhY2sgdG8gYSBjb25uZWN0b3IuIGJ1dCBpZiB0aGUgY29ubmVjdG9yIGlzIHN3YXBwZWQgb24gdGhlIHVuZGVybHlpbmcgY29ubmVjdGlvbixcbiAgICAgICAgICAgIC8vIHRoZW4gdGhpcyBjb21wb25lbnQgbXVzdCBiZSBjaGFuZ2VkLiBUaGlzIGlzIGNhbGxlZCBieSBzZXRDb25uZWN0b3IgaW4gdGhlIENvbm5lY3Rpb24gY2xhc3MuXG4gICAgICAgICAgICB0aGlzLnNldExpc3RlbmVyQ29tcG9uZW50ID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRvbUxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBkb21MaXN0ZW5lcnNbaV1bM10gPSBjO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cblxuICAgICAgICB9O1xuXG4gICAgdmFyIF9yZW1vdmVUeXBlQ3NzSGVscGVyID0gZnVuY3Rpb24gKGNvbXBvbmVudCwgdHlwZUluZGV4KSB7XG4gICAgICAgIHZhciB0eXBlSWQgPSBjb21wb25lbnQuX2pzUGx1bWIudHlwZXNbdHlwZUluZGV4XSxcbiAgICAgICAgICAgIHR5cGUgPSBjb21wb25lbnQuX2pzUGx1bWIuaW5zdGFuY2UuZ2V0VHlwZSh0eXBlSWQsIGNvbXBvbmVudC5nZXRUeXBlRGVzY3JpcHRvcigpKTtcblxuICAgICAgICBpZiAodHlwZSAhPSBudWxsICYmIHR5cGUuY3NzQ2xhc3MgJiYgY29tcG9uZW50LmNhbnZhcykge1xuICAgICAgICAgICAgY29tcG9uZW50Ll9qc1BsdW1iLmluc3RhbmNlLnJlbW92ZUNsYXNzKGNvbXBvbmVudC5jYW52YXMsIHR5cGUuY3NzQ2xhc3MpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIF9qdS5leHRlbmQocm9vdC5qc1BsdW1iVUlDb21wb25lbnQsIF9qdS5FdmVudEdlbmVyYXRvciwge1xuXG4gICAgICAgIGdldFBhcmFtZXRlcjogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9qc1BsdW1iLnBhcmFtZXRlcnNbbmFtZV07XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0UGFyYW1ldGVyOiBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2pzUGx1bWIucGFyYW1ldGVyc1tuYW1lXSA9IHZhbHVlO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldFBhcmFtZXRlcnM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9qc1BsdW1iLnBhcmFtZXRlcnM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0UGFyYW1ldGVyczogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgICAgIHRoaXMuX2pzUGx1bWIucGFyYW1ldGVycyA9IHA7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0Q2xhc3M6ZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4ganNQbHVtYi5nZXRDbGFzcyh0aGlzLmNhbnZhcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFzQ2xhc3M6ZnVuY3Rpb24oY2xhenopIHtcbiAgICAgICAgICAgIHJldHVybiBqc1BsdW1iLmhhc0NsYXNzKHRoaXMuY2FudmFzLCBjbGF6eik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYWRkQ2xhc3M6IGZ1bmN0aW9uIChjbGF6eikge1xuICAgICAgICAgICAganNQbHVtYi5hZGRDbGFzcyh0aGlzLmNhbnZhcywgY2xhenopO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlbW92ZUNsYXNzOiBmdW5jdGlvbiAoY2xhenopIHtcbiAgICAgICAgICAgIGpzUGx1bWIucmVtb3ZlQ2xhc3ModGhpcy5jYW52YXMsIGNsYXp6KTtcbiAgICAgICAgfSxcblxuICAgICAgICB1cGRhdGVDbGFzc2VzOiBmdW5jdGlvbiAoY2xhc3Nlc1RvQWRkLCBjbGFzc2VzVG9SZW1vdmUpIHtcbiAgICAgICAgICAgIGpzUGx1bWIudXBkYXRlQ2xhc3Nlcyh0aGlzLmNhbnZhcywgY2xhc3Nlc1RvQWRkLCBjbGFzc2VzVG9SZW1vdmUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldFR5cGU6IGZ1bmN0aW9uICh0eXBlSWQsIHBhcmFtcywgZG9Ob3RSZXBhaW50KSB7XG4gICAgICAgICAgICB0aGlzLmNsZWFyVHlwZXMoKTtcbiAgICAgICAgICAgIHRoaXMuX2pzUGx1bWIudHlwZXMgPSBfc3BsaXRUeXBlKHR5cGVJZCkgfHwgW107XG4gICAgICAgICAgICBfYXBwbHlUeXBlcyh0aGlzLCBwYXJhbXMsIGRvTm90UmVwYWludCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0VHlwZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2pzUGx1bWIudHlwZXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVhcHBseVR5cGVzOiBmdW5jdGlvbiAocGFyYW1zLCBkb05vdFJlcGFpbnQpIHtcbiAgICAgICAgICAgIF9hcHBseVR5cGVzKHRoaXMsIHBhcmFtcywgZG9Ob3RSZXBhaW50KTtcbiAgICAgICAgfSxcblxuICAgICAgICBoYXNUeXBlOiBmdW5jdGlvbiAodHlwZUlkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fanNQbHVtYi50eXBlcy5pbmRleE9mKHR5cGVJZCkgIT09IC0xO1xuICAgICAgICB9LFxuXG4gICAgICAgIGFkZFR5cGU6IGZ1bmN0aW9uICh0eXBlSWQsIHBhcmFtcywgZG9Ob3RSZXBhaW50KSB7XG4gICAgICAgICAgICB2YXIgdCA9IF9zcGxpdFR5cGUodHlwZUlkKSwgX2NvbnQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICh0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaiA9IHQubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5oYXNUeXBlKHRbaV0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9qc1BsdW1iLnR5cGVzLnB1c2godFtpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfY29udCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKF9jb250KSB7XG4gICAgICAgICAgICAgICAgICAgIF9hcHBseVR5cGVzKHRoaXMsIHBhcmFtcywgZG9Ob3RSZXBhaW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVtb3ZlVHlwZTogZnVuY3Rpb24gKHR5cGVJZCwgcGFyYW1zLCBkb05vdFJlcGFpbnQpIHtcbiAgICAgICAgICAgIHZhciB0ID0gX3NwbGl0VHlwZSh0eXBlSWQpLCBfY29udCA9IGZhbHNlLCBfb25lID0gZnVuY3Rpb24gKHR0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGlkeCA9IHRoaXMuX2pzUGx1bWIudHlwZXMuaW5kZXhPZih0dCk7XG4gICAgICAgICAgICAgICAgaWYgKGlkeCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIGNzcyBjbGFzcyBpZiBuZWNlc3NhcnlcbiAgICAgICAgICAgICAgICAgICAgX3JlbW92ZVR5cGVDc3NIZWxwZXIodGhpcywgaWR4KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fanNQbHVtYi50eXBlcy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKTtcblxuICAgICAgICAgICAgaWYgKHQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBqID0gdC5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgX2NvbnQgPSBfb25lKHRbaV0pIHx8IF9jb250O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoX2NvbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgX2FwcGx5VHlwZXModGhpcywgcGFyYW1zLCBkb05vdFJlcGFpbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY2xlYXJUeXBlczogZnVuY3Rpb24gKHBhcmFtcywgZG9Ob3RSZXBhaW50KSB7XG4gICAgICAgICAgICB2YXIgaSA9IHRoaXMuX2pzUGx1bWIudHlwZXMubGVuZ3RoO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBpOyBqKyspIHtcbiAgICAgICAgICAgICAgICBfcmVtb3ZlVHlwZUNzc0hlbHBlcih0aGlzLCAwKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9qc1BsdW1iLnR5cGVzLnNwbGljZSgwLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9hcHBseVR5cGVzKHRoaXMsIHBhcmFtcywgZG9Ob3RSZXBhaW50KTtcbiAgICAgICAgfSxcblxuICAgICAgICB0b2dnbGVUeXBlOiBmdW5jdGlvbiAodHlwZUlkLCBwYXJhbXMsIGRvTm90UmVwYWludCkge1xuICAgICAgICAgICAgdmFyIHQgPSBfc3BsaXRUeXBlKHR5cGVJZCk7XG4gICAgICAgICAgICBpZiAodCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGogPSB0Lmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaWR4ID0gdGhpcy5fanNQbHVtYi50eXBlcy5pbmRleE9mKHRbaV0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaWR4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3JlbW92ZVR5cGVDc3NIZWxwZXIodGhpcywgaWR4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2pzUGx1bWIudHlwZXMuc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9qc1BsdW1iLnR5cGVzLnB1c2godFtpXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBfYXBwbHlUeXBlcyh0aGlzLCBwYXJhbXMsIGRvTm90UmVwYWludCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGFwcGx5VHlwZTogZnVuY3Rpb24gKHQsIGRvTm90UmVwYWludCkge1xuICAgICAgICAgICAgdGhpcy5zZXRQYWludFN0eWxlKHQucGFpbnRTdHlsZSwgZG9Ob3RSZXBhaW50KTtcbiAgICAgICAgICAgIHRoaXMuc2V0SG92ZXJQYWludFN0eWxlKHQuaG92ZXJQYWludFN0eWxlLCBkb05vdFJlcGFpbnQpO1xuICAgICAgICAgICAgaWYgKHQucGFyYW1ldGVycykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgaW4gdC5wYXJhbWV0ZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0UGFyYW1ldGVyKGksIHQucGFyYW1ldGVyc1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fanNQbHVtYi5wYWludFN0eWxlSW5Vc2UgPSB0aGlzLmdldFBhaW50U3R5bGUoKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0UGFpbnRTdHlsZTogZnVuY3Rpb24gKHN0eWxlLCBkb05vdFJlcGFpbnQpIHtcbiAgICAgICAgICAgIC8vIHRoaXMuX2pzUGx1bWIucGFpbnRTdHlsZSA9IGpzUGx1bWIuZXh0ZW5kKHt9LCBzdHlsZSk7XG4gICAgICAgICAgICAvLyBUT0RPIGZpZ3VyZSBvdXQgaWYgd2Ugd2FudCBjb21wb25lbnRzIHRvIGNsb25lIHBhaW50U3R5bGUgc28gYXMgbm90IHRvIHNoYXJlIGl0LlxuICAgICAgICAgICAgdGhpcy5fanNQbHVtYi5wYWludFN0eWxlID0gc3R5bGU7XG4gICAgICAgICAgICB0aGlzLl9qc1BsdW1iLnBhaW50U3R5bGVJblVzZSA9IHRoaXMuX2pzUGx1bWIucGFpbnRTdHlsZTtcbiAgICAgICAgICAgIF91cGRhdGVIb3ZlclN0eWxlKHRoaXMpO1xuICAgICAgICAgICAgaWYgKCFkb05vdFJlcGFpbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlcGFpbnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZ2V0UGFpbnRTdHlsZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2pzUGx1bWIucGFpbnRTdHlsZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0SG92ZXJQYWludFN0eWxlOiBmdW5jdGlvbiAoc3R5bGUsIGRvTm90UmVwYWludCkge1xuICAgICAgICAgICAgLy90aGlzLl9qc1BsdW1iLmhvdmVyUGFpbnRTdHlsZSA9IGpzUGx1bWIuZXh0ZW5kKHt9LCBzdHlsZSk7XG4gICAgICAgICAgICAvLyBUT0RPIGZpZ3VyZSBvdXQgaWYgd2Ugd2FudCBjb21wb25lbnRzIHRvIGNsb25lIHBhaW50U3R5bGUgc28gYXMgbm90IHRvIHNoYXJlIGl0LlxuICAgICAgICAgICAgdGhpcy5fanNQbHVtYi5ob3ZlclBhaW50U3R5bGUgPSBzdHlsZTtcbiAgICAgICAgICAgIF91cGRhdGVIb3ZlclN0eWxlKHRoaXMpO1xuICAgICAgICAgICAgaWYgKCFkb05vdFJlcGFpbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlcGFpbnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZ2V0SG92ZXJQYWludFN0eWxlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fanNQbHVtYi5ob3ZlclBhaW50U3R5bGU7XG4gICAgICAgIH0sXG4gICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIChmb3JjZSkge1xuICAgICAgICAgICAgaWYgKGZvcmNlIHx8IHRoaXMudHlwZUlkID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsZWFudXBMaXN0ZW5lcnMoKTsgLy8gdGhpcyBpcyBvbiBFdmVudEdlbmVyYXRvclxuICAgICAgICAgICAgICAgIHRoaXMuY2xvbmUgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuX2pzUGx1bWIgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGlzSG92ZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9qc1BsdW1iLmhvdmVyO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldEhvdmVyOiBmdW5jdGlvbiAoaG92ZXIsIGlnbm9yZUF0dGFjaGVkRWxlbWVudHMsIHRpbWVzdGFtcCkge1xuICAgICAgICAgICAgLy8gd2hpbGUgZHJhZ2dpbmcsIHdlIGlnbm9yZSB0aGVzZSBldmVudHMuICB0aGlzIGtlZXBzIHRoZSBVSSBmcm9tIGZsYXNoaW5nIGFuZFxuICAgICAgICAgICAgLy8gc3dpc2hpbmcgYW5kIHdoYXRldmVyaW5nLlxuICAgICAgICAgICAgaWYgKHRoaXMuX2pzUGx1bWIgJiYgIXRoaXMuX2pzUGx1bWIuaW5zdGFuY2UuY3VycmVudGx5RHJhZ2dpbmcgJiYgIXRoaXMuX2pzUGx1bWIuaW5zdGFuY2UuaXNIb3ZlclN1c3BlbmRlZCgpKSB7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9qc1BsdW1iLmhvdmVyID0gaG92ZXI7XG4gICAgICAgICAgICAgICAgdmFyIG1ldGhvZCA9IGhvdmVyID8gXCJhZGRDbGFzc1wiIDogXCJyZW1vdmVDbGFzc1wiO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2FudmFzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2pzUGx1bWIuaW5zdGFuY2UuaG92ZXJDbGFzcyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9qc1BsdW1iLmluc3RhbmNlW21ldGhvZF0odGhpcy5jYW52YXMsIHRoaXMuX2pzUGx1bWIuaW5zdGFuY2UuaG92ZXJDbGFzcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2pzUGx1bWIuaG92ZXJDbGFzcyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9qc1BsdW1iLmluc3RhbmNlW21ldGhvZF0odGhpcy5jYW52YXMsIHRoaXMuX2pzUGx1bWIuaG92ZXJDbGFzcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2pzUGx1bWIuaG92ZXJQYWludFN0eWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fanNQbHVtYi5wYWludFN0eWxlSW5Vc2UgPSBob3ZlciA/IHRoaXMuX2pzUGx1bWIuaG92ZXJQYWludFN0eWxlIDogdGhpcy5fanNQbHVtYi5wYWludFN0eWxlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2pzUGx1bWIuaW5zdGFuY2UuaXNTdXNwZW5kRHJhd2luZygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXAgPSB0aW1lc3RhbXAgfHwgX3RpbWVzdGFtcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBhaW50KHt0aW1lc3RhbXA6IHRpbWVzdGFtcCwgcmVjYWxjOiBmYWxzZX0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGdldCB0aGUgbGlzdCBvZiBvdGhlciBhZmZlY3RlZCBlbGVtZW50cywgaWYgc3VwcG9ydGVkIGJ5IHRoaXMgY29tcG9uZW50LlxuICAgICAgICAgICAgICAgIC8vIGZvciBhIGNvbm5lY3Rpb24sIGl0cyB0aGUgZW5kcG9pbnRzLiAgZm9yIGFuIGVuZHBvaW50LCBpdHMgdGhlIGNvbm5lY3Rpb25zISBzdXJwcmlzZS5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5nZXRBdHRhY2hlZEVsZW1lbnRzICYmICFpZ25vcmVBdHRhY2hlZEVsZW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIF91cGRhdGVBdHRhY2hlZEVsZW1lbnRzKHRoaXMsIGhvdmVyLCBfdGltZXN0YW1wKCksIHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gRU5EIGpzUGx1bWJVSUNvbXBvbmVudCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgdmFyIF9qc1BsdW1iSW5zdGFuY2VJbmRleCA9IDAsXG4gICAgICAgIGdldEluc3RhbmNlSW5kZXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgaSA9IF9qc1BsdW1iSW5zdGFuY2VJbmRleCArIDE7XG4gICAgICAgICAgICBfanNQbHVtYkluc3RhbmNlSW5kZXgrKztcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9O1xuXG4gICAgdmFyIGpzUGx1bWJJbnN0YW5jZSA9IHJvb3QuanNQbHVtYkluc3RhbmNlID0gZnVuY3Rpb24gKF9kZWZhdWx0cykge1xuXG4gICAgICAgIHRoaXMudmVyc2lvbiA9IFwiMi41LjFcIjtcblxuICAgICAgICBpZiAoX2RlZmF1bHRzKSB7XG4gICAgICAgICAgICBqc1BsdW1iLmV4dGVuZCh0aGlzLkRlZmF1bHRzLCBfZGVmYXVsdHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5sb2dFbmFibGVkID0gdGhpcy5EZWZhdWx0cy5Mb2dFbmFibGVkO1xuICAgICAgICB0aGlzLl9jb25uZWN0aW9uVHlwZXMgPSB7fTtcbiAgICAgICAgdGhpcy5fZW5kcG9pbnRUeXBlcyA9IHt9O1xuXG4gICAgICAgIF9qdS5FdmVudEdlbmVyYXRvci5hcHBseSh0aGlzKTtcblxuICAgICAgICB2YXIgX2N1cnJlbnRJbnN0YW5jZSA9IHRoaXMsXG4gICAgICAgICAgICBfaW5zdGFuY2VJbmRleCA9IGdldEluc3RhbmNlSW5kZXgoKSxcbiAgICAgICAgICAgIF9iYiA9IF9jdXJyZW50SW5zdGFuY2UuYmluZCxcbiAgICAgICAgICAgIF9pbml0aWFsRGVmYXVsdHMgPSB7fSxcbiAgICAgICAgICAgIF96b29tID0gMSxcbiAgICAgICAgICAgIF9pbmZvID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVsID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGVsLm5vZGVUeXBlID09PSAzIHx8IGVsLm5vZGVUeXBlID09PSA4KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGVsOmVsLCB0ZXh0OnRydWUgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfZWwgPSBfY3VycmVudEluc3RhbmNlLmdldEVsZW1lbnQoZWwpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBlbDogX2VsLCBpZDogKF9qdS5pc1N0cmluZyhlbCkgJiYgX2VsID09IG51bGwpID8gZWwgOiBfZ2V0SWQoX2VsKSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5nZXRJbnN0YW5jZUluZGV4ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9pbnN0YW5jZUluZGV4O1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuc2V0Wm9vbSA9IGZ1bmN0aW9uICh6LCByZXBhaW50RXZlcnl0aGluZykge1xuICAgICAgICAgICAgX3pvb20gPSB6O1xuICAgICAgICAgICAgX2N1cnJlbnRJbnN0YW5jZS5maXJlKFwiem9vbVwiLCBfem9vbSk7XG4gICAgICAgICAgICBpZiAocmVwYWludEV2ZXJ5dGhpbmcpIHtcbiAgICAgICAgICAgICAgICBfY3VycmVudEluc3RhbmNlLnJlcGFpbnRFdmVyeXRoaW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5nZXRab29tID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF96b29tO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5EZWZhdWx0cykge1xuICAgICAgICAgICAgX2luaXRpYWxEZWZhdWx0c1tpXSA9IHRoaXMuRGVmYXVsdHNbaV07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgX2NvbnRhaW5lciwgX2NvbnRhaW5lckRlbGVnYXRpb25zID0gW107XG4gICAgICAgIHRoaXMudW5iaW5kQ29udGFpbmVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoX2NvbnRhaW5lciAhPSBudWxsICYmIF9jb250YWluZXJEZWxlZ2F0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfY29udGFpbmVyRGVsZWdhdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgX2N1cnJlbnRJbnN0YW5jZS5vZmYoX2NvbnRhaW5lciwgX2NvbnRhaW5lckRlbGVnYXRpb25zW2ldWzBdLCBfY29udGFpbmVyRGVsZWdhdGlvbnNbaV1bMV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zZXRDb250YWluZXIgPSBmdW5jdGlvbiAoYykge1xuXG4gICAgICAgICAgICB0aGlzLnVuYmluZENvbnRhaW5lcigpO1xuXG4gICAgICAgICAgICAvLyBnZXQgY29udGFpbmVyIGFzIGRvbSBlbGVtZW50LlxuICAgICAgICAgICAgYyA9IHRoaXMuZ2V0RWxlbWVudChjKTtcbiAgICAgICAgICAgIC8vIG1vdmUgZXhpc3RpbmcgY29ubmVjdGlvbnMgYW5kIGVuZHBvaW50cywgaWYgYW55LlxuICAgICAgICAgICAgdGhpcy5zZWxlY3QoKS5lYWNoKGZ1bmN0aW9uIChjb25uKSB7XG4gICAgICAgICAgICAgICAgY29ubi5tb3ZlUGFyZW50KGMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdEVuZHBvaW50cygpLmVhY2goZnVuY3Rpb24gKGVwKSB7XG4gICAgICAgICAgICAgICAgZXAubW92ZVBhcmVudChjKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBzZXQgY29udGFpbmVyLlxuICAgICAgICAgICAgdmFyIHByZXZpb3VzQ29udGFpbmVyID0gX2NvbnRhaW5lcjtcbiAgICAgICAgICAgIF9jb250YWluZXIgPSBjO1xuICAgICAgICAgICAgX2NvbnRhaW5lckRlbGVnYXRpb25zLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICB2YXIgZXZlbnRBbGlhc2VzID0ge1xuICAgICAgICAgICAgICAgIFwiZW5kcG9pbnRjbGlja1wiOlwiZW5kcG9pbnRDbGlja1wiLFxuICAgICAgICAgICAgICAgIFwiZW5kcG9pbnRkYmxjbGlja1wiOlwiZW5kcG9pbnREYmxDbGlja1wiXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgX29uZURlbGVnYXRlSGFuZGxlciA9IGZ1bmN0aW9uIChpZCwgZSwgY29tcG9uZW50VHlwZSkge1xuICAgICAgICAgICAgICAgIHZhciB0ID0gZS5zcmNFbGVtZW50IHx8IGUudGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICBqcCA9ICh0ICYmIHQucGFyZW50Tm9kZSA/IHQucGFyZW50Tm9kZS5fanNQbHVtYiA6IG51bGwpIHx8ICh0ID8gdC5fanNQbHVtYiA6IG51bGwpIHx8ICh0ICYmIHQucGFyZW50Tm9kZSAmJiB0LnBhcmVudE5vZGUucGFyZW50Tm9kZSA/IHQucGFyZW50Tm9kZS5wYXJlbnROb2RlLl9qc1BsdW1iIDogbnVsbCk7XG4gICAgICAgICAgICAgICAgaWYgKGpwKSB7XG4gICAgICAgICAgICAgICAgICAgIGpwLmZpcmUoaWQsIGpwLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFsaWFzID0gY29tcG9uZW50VHlwZSA/IGV2ZW50QWxpYXNlc1tjb21wb25lbnRUeXBlICsgaWRdIHx8IGlkIDogaWQ7XG4gICAgICAgICAgICAgICAgICAgIC8vIGpzcGx1bWIgYWxzbyBmaXJlcyBldmVyeSBldmVudCBjb21pbmcgZnJvbSBjb21wb25lbnRzL292ZXJsYXlzLiBUaGF0J3Mgd2hhdCB0aGUgdGVzdCBmb3IgYGpwLmNvbXBvbmVudGAgaXMgZm9yLlxuICAgICAgICAgICAgICAgICAgICBfY3VycmVudEluc3RhbmNlLmZpcmUoYWxpYXMsIGpwLmNvbXBvbmVudCB8fCBqcCwgZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIF9hZGRPbmVEZWxlZ2F0ZSA9IGZ1bmN0aW9uKGV2ZW50SWQsIHNlbGVjdG9yLCBmbikge1xuICAgICAgICAgICAgICAgIF9jb250YWluZXJEZWxlZ2F0aW9ucy5wdXNoKFtldmVudElkLCBmbl0pO1xuICAgICAgICAgICAgICAgIF9jdXJyZW50SW5zdGFuY2Uub24oX2NvbnRhaW5lciwgZXZlbnRJZCwgc2VsZWN0b3IsIGZuKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIGRlbGVnYXRlIG9uZSBldmVudCBvbiB0aGUgY29udGFpbmVyIHRvIGpzcGx1bWIgZWxlbWVudHMuIGl0IG1pZ2h0IGJlIHBvc3NpYmxlIHRvXG4gICAgICAgICAgICAvLyBhYnN0cmFjdCB0aGlzIG91dDogZWFjaCBvZiBlbmRwb2ludCwgY29ubmVjdGlvbiBhbmQgb3ZlcmxheSBjb3VsZCByZWdpc3RlciB0aGVtc2VsdmVzIHdpdGhcbiAgICAgICAgICAgIC8vIGpzcGx1bWIgYXMgXCJjb21wb25lbnQgdHlwZXNcIiBvciB3aGF0ZXZlciwgYW5kIHByb3ZpZGUgYSBzdWl0YWJsZSBzZWxlY3Rvci4gdGhpcyB3b3VsZCBiZVxuICAgICAgICAgICAgLy8gZG9uZSBieSB0aGUgcmVuZGVyZXIgKGFsdGhvdWdoIGFkbWl0dGVkbHkgZnJvbSAyLjAgb253YXJkcyB3ZSdyZSBub3Qgc3VwcG9ydGluZyB2bWwgYW55bW9yZSlcbiAgICAgICAgICAgIHZhciBfb25lRGVsZWdhdGUgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgICAgICAgICAvLyBjb25uZWN0aW9ucy5cbiAgICAgICAgICAgICAgICBfYWRkT25lRGVsZWdhdGUoaWQsIFwiLmp0ay1jb25uZWN0b3JcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgX29uZURlbGVnYXRlSGFuZGxlcihpZCwgZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gZW5kcG9pbnRzLiBub3RlIHRoZXkgY2FuIGhhdmUgYW4gZW5jbG9zaW5nIGRpdiwgb3Igbm90LlxuICAgICAgICAgICAgICAgIF9hZGRPbmVEZWxlZ2F0ZShpZCwgXCIuanRrLWVuZHBvaW50XCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIF9vbmVEZWxlZ2F0ZUhhbmRsZXIoaWQsIGUsIFwiZW5kcG9pbnRcIik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gb3ZlcmxheXNcbiAgICAgICAgICAgICAgICBfYWRkT25lRGVsZWdhdGUoaWQsIFwiLmp0ay1vdmVybGF5XCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIF9vbmVEZWxlZ2F0ZUhhbmRsZXIoaWQsIGUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBldmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBfb25lRGVsZWdhdGUoZXZlbnRzW2ldKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gbWFuYWdlZCBlbGVtZW50c1xuICAgICAgICAgICAgZm9yICh2YXIgZWxJZCBpbiBtYW5hZ2VkRWxlbWVudHMpIHtcbiAgICAgICAgICAgICAgICB2YXIgZWwgPSBtYW5hZ2VkRWxlbWVudHNbZWxJZF0uZWw7XG4gICAgICAgICAgICAgICAgaWYgKGVsLnBhcmVudE5vZGUgPT09IHByZXZpb3VzQ29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXZpb3VzQ29udGFpbmVyLnJlbW92ZUNoaWxkKGVsKTtcbiAgICAgICAgICAgICAgICAgICAgX2NvbnRhaW5lci5hcHBlbmRDaGlsZChlbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ2V0Q29udGFpbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9jb250YWluZXI7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5iaW5kID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgICAgICAgICAgaWYgKFwicmVhZHlcIiA9PT0gZXZlbnQgJiYgaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgICAgICBmbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgX2JiLmFwcGx5KF9jdXJyZW50SW5zdGFuY2UsIFtldmVudCwgZm5dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBfY3VycmVudEluc3RhbmNlLmltcG9ydERlZmF1bHRzID0gZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgaW4gZCkge1xuICAgICAgICAgICAgICAgIF9jdXJyZW50SW5zdGFuY2UuRGVmYXVsdHNbaV0gPSBkW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGQuQ29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgX2N1cnJlbnRJbnN0YW5jZS5zZXRDb250YWluZXIoZC5Db250YWluZXIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gX2N1cnJlbnRJbnN0YW5jZTtcbiAgICAgICAgfTtcblxuICAgICAgICBfY3VycmVudEluc3RhbmNlLnJlc3RvcmVEZWZhdWx0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF9jdXJyZW50SW5zdGFuY2UuRGVmYXVsdHMgPSBqc1BsdW1iLmV4dGVuZCh7fSwgX2luaXRpYWxEZWZhdWx0cyk7XG4gICAgICAgICAgICByZXR1cm4gX2N1cnJlbnRJbnN0YW5jZTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgbG9nID0gbnVsbCxcbiAgICAgICAgICAgIGluaXRpYWxpemVkID0gZmFsc2UsXG4gICAgICAgIC8vIFRPRE8gcmVtb3ZlIGZyb20gd2luZG93IHNjb3BlXG4gICAgICAgICAgICBjb25uZWN0aW9ucyA9IFtdLFxuICAgICAgICAvLyBtYXAgb2YgZWxlbWVudCBpZCAtPiBlbmRwb2ludCBsaXN0cy4gYW4gZWxlbWVudCBjYW4gaGF2ZSBhbiBhcmJpdHJhcnlcbiAgICAgICAgLy8gbnVtYmVyIG9mIGVuZHBvaW50cyBvbiBpdCwgYW5kIG5vdCBhbGwgb2YgdGhlbSBoYXZlIHRvIGJlIGNvbm5lY3RlZFxuICAgICAgICAvLyB0byBhbnl0aGluZy5cbiAgICAgICAgICAgIGVuZHBvaW50c0J5RWxlbWVudCA9IHt9LFxuICAgICAgICAgICAgZW5kcG9pbnRzQnlVVUlEID0ge30sXG4gICAgICAgICAgICBtYW5hZ2VkRWxlbWVudHMgPSB7fSxcbiAgICAgICAgICAgIG9mZnNldHMgPSB7fSxcbiAgICAgICAgICAgIG9mZnNldFRpbWVzdGFtcHMgPSB7fSxcbiAgICAgICAgICAgIGRyYWdnYWJsZVN0YXRlcyA9IHt9LFxuICAgICAgICAgICAgY29ubmVjdGlvbkJlaW5nRHJhZ2dlZCA9IGZhbHNlLFxuICAgICAgICAgICAgc2l6ZXMgPSBbXSxcbiAgICAgICAgICAgIF9zdXNwZW5kRHJhd2luZyA9IGZhbHNlLFxuICAgICAgICAgICAgX3N1c3BlbmRlZEF0ID0gbnVsbCxcbiAgICAgICAgICAgIERFRkFVTFRfU0NPUEUgPSB0aGlzLkRlZmF1bHRzLlNjb3BlLFxuICAgICAgICAgICAgX2N1cklkU3RhbXAgPSAxLFxuICAgICAgICAgICAgX2lkc3RhbXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiXCIgKyBfY3VySWRTdGFtcCsrO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAvL1xuICAgICAgICAvLyBhcHBlbmRzIGFuIGVsZW1lbnQgdG8gc29tZSBvdGhlciBlbGVtZW50LCB3aGljaCBpcyBjYWxjdWxhdGVkIGFzIGZvbGxvd3M6XG4gICAgICAgIC8vXG4gICAgICAgIC8vIDEuIGlmIENvbnRhaW5lciBleGlzdHMsIHVzZSB0aGF0IGVsZW1lbnQuXG4gICAgICAgIC8vIDIuIGlmIHRoZSAncGFyZW50JyBwYXJhbWV0ZXIgZXhpc3RzLCB1c2UgdGhhdC5cbiAgICAgICAgLy8gMy4gb3RoZXJ3aXNlIGp1c3QgdXNlIHRoZSByb290IGVsZW1lbnQuXG4gICAgICAgIC8vXG4gICAgICAgIC8vXG4gICAgICAgICAgICBfYXBwZW5kRWxlbWVudCA9IGZ1bmN0aW9uIChlbCwgcGFyZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKF9jb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgX2NvbnRhaW5lci5hcHBlbmRDaGlsZChlbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHBlbmRUb1Jvb3QoZWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRFbGVtZW50KHBhcmVudCkuYXBwZW5kQ2hpbGQoZWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSxcblxuICAgICAgICAvL1xuICAgICAgICAvLyBEcmF3cyBhbiBlbmRwb2ludCBhbmQgaXRzIGNvbm5lY3Rpb25zLiB0aGlzIGlzIHRoZSBtYWluIGVudHJ5IHBvaW50IGludG8gZHJhd2luZyBjb25uZWN0aW9ucyBhcyB3ZWxsXG4gICAgICAgIC8vIGFzIGVuZHBvaW50cywgc2luY2UganNQbHVtYiBpcyBlbmRwb2ludC1jZW50cmljIHVuZGVyIHRoZSBob29kLlxuICAgICAgICAvL1xuICAgICAgICAvLyBAcGFyYW0gZWxlbWVudCBlbGVtZW50IHRvIGRyYXcgKG9mIHR5cGUgbGlicmFyeSBzcGVjaWZpYyBlbGVtZW50IG9iamVjdClcbiAgICAgICAgLy8gQHBhcmFtIHVpIFVJIG9iamVjdCBmcm9tIGN1cnJlbnQgbGlicmFyeSdzIGV2ZW50IHN5c3RlbS4gb3B0aW9uYWwuXG4gICAgICAgIC8vIEBwYXJhbSB0aW1lc3RhbXAgdGltZXN0YW1wIGZvciB0aGlzIHBhaW50IGN5Y2xlLiB1c2VkIHRvIHNwZWVkIHRoaW5ncyB1cCBhIGxpdHRsZSBieSBjdXR0aW5nIGRvd24gdGhlIGFtb3VudCBvZiBvZmZzZXQgY2FsY3VsYXRpb25zIHdlIGRvLlxuICAgICAgICAvLyBAcGFyYW0gY2xlYXJFZGl0cyBkZWZhdWx0cyB0byBmYWxzZTsgaW5kaWNhdGVzIHRoYXQgbW91c2UgZWRpdHMgZm9yIGNvbm5lY3RvcnMgc2hvdWxkIGJlIGNsZWFyZWRcbiAgICAgICAgLy8vXG4gICAgICAgICAgICBfZHJhdyA9IGZ1bmN0aW9uIChlbGVtZW50LCB1aSwgdGltZXN0YW1wLCBjbGVhckVkaXRzKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoIV9zdXNwZW5kRHJhd2luZykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaWQgPSBfZ2V0SWQoZWxlbWVudCksXG4gICAgICAgICAgICAgICAgICAgICAgICByZXBhaW50RWxzLFxuICAgICAgICAgICAgICAgICAgICAgICAgZG0gPSBfY3VycmVudEluc3RhbmNlLmdldERyYWdNYW5hZ2VyKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGRtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXBhaW50RWxzID0gZG0uZ2V0RWxlbWVudHNGb3JEcmFnZ2FibGUoaWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRpbWVzdGFtcCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXAgPSBfdGltZXN0YW1wKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyB1cGRhdGUgdGhlIG9mZnNldCBvZiBldmVyeXRoaW5nIF9iZWZvcmVfIHdlIHRyeSB0byBkcmF3IGFueXRoaW5nLlxuICAgICAgICAgICAgICAgICAgICB2YXIgbyA9IF91cGRhdGVPZmZzZXQoeyBlbElkOiBpZCwgb2Zmc2V0OiB1aSwgcmVjYWxjOiBmYWxzZSwgdGltZXN0YW1wOiB0aW1lc3RhbXAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcGFpbnRFbHMgJiYgbyAmJiBvLm8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgaW4gcmVwYWludEVscykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF91cGRhdGVPZmZzZXQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbElkOiByZXBhaW50RWxzW2ldLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IG8uby5sZWZ0ICsgcmVwYWludEVsc1tpXS5vZmZzZXQubGVmdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogby5vLnRvcCArIHJlcGFpbnRFbHNbaV0ub2Zmc2V0LnRvcFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWNhbGM6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IHRpbWVzdGFtcFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgX2N1cnJlbnRJbnN0YW5jZS5hbmNob3JNYW5hZ2VyLnJlZHJhdyhpZCwgdWksIHRpbWVzdGFtcCwgbnVsbCwgY2xlYXJFZGl0cyk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcGFpbnRFbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogaW4gcmVwYWludEVscykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jdXJyZW50SW5zdGFuY2UuYW5jaG9yTWFuYWdlci5yZWRyYXcocmVwYWludEVsc1tqXS5pZCwgdWksIHRpbWVzdGFtcCwgcmVwYWludEVsc1tqXS5vZmZzZXQsIGNsZWFyRWRpdHMsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAvL1xuICAgICAgICAvLyBnZXRzIGFuIEVuZHBvaW50IGJ5IHV1aWQuXG4gICAgICAgIC8vXG4gICAgICAgICAgICBfZ2V0RW5kcG9pbnQgPSBmdW5jdGlvbiAodXVpZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbmRwb2ludHNCeVVVSURbdXVpZF07XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIGluaXRzIGEgZHJhZ2dhYmxlIGlmIGl0J3Mgbm90IGFscmVhZHkgaW5pdGlhbGlzZWQuXG4gICAgICAgICAgICAgKiBUT0RPOiBzb21laG93IGFic3RyYWN0IHRoaXMgdG8gdGhlIGFkYXB0ZXIsIGJlY2F1c2UgdGhlIGNvbmNlcHQgb2YgXCJkcmFnZ2FibGVcIiBoYXMgbm9cbiAgICAgICAgICAgICAqIHBsYWNlIG9uIHRoZSBzZXJ2ZXIuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIF9pbml0RHJhZ2dhYmxlSWZOZWNlc3NhcnkgPSBmdW5jdGlvbiAoZWxlbWVudCwgaXNEcmFnZ2FibGUsIGRyYWdPcHRpb25zLCBpZCwgZmlyZUV2ZW50KSB7XG4gICAgICAgICAgICAgICAgLy8gbW92ZSB0byBEcmFnTWFuYWdlcj9cbiAgICAgICAgICAgICAgICBpZiAoIWpzUGx1bWIuaGVhZGxlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9kcmFnZ2FibGUgPSBpc0RyYWdnYWJsZSA9PSBudWxsID8gZmFsc2UgOiBpc0RyYWdnYWJsZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9kcmFnZ2FibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChqc1BsdW1iLmlzRHJhZ1N1cHBvcnRlZChlbGVtZW50LCBfY3VycmVudEluc3RhbmNlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvcHRpb25zID0gZHJhZ09wdGlvbnMgfHwgX2N1cnJlbnRJbnN0YW5jZS5EZWZhdWx0cy5EcmFnT3B0aW9ucztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zID0ganNQbHVtYi5leHRlbmQoe30sIG9wdGlvbnMpOyAvLyBtYWtlIGEgY29weS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWpzUGx1bWIuaXNBbHJlYWR5RHJhZ2dhYmxlKGVsZW1lbnQsIF9jdXJyZW50SW5zdGFuY2UpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkcmFnRXZlbnQgPSBqc1BsdW1iLmRyYWdFdmVudHMuZHJhZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0b3BFdmVudCA9IGpzUGx1bWIuZHJhZ0V2ZW50cy5zdG9wLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRFdmVudCA9IGpzUGx1bWIuZHJhZ0V2ZW50cy5zdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9zdGFydGVkID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX21hbmFnZShpZCwgZWxlbWVudCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uc1tzdGFydEV2ZW50XSA9IF9qdS53cmFwKG9wdGlvbnNbc3RhcnRFdmVudF0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jdXJyZW50SW5zdGFuY2Uuc2V0SG92ZXJTdXNwZW5kZWQodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY3VycmVudEluc3RhbmNlLnNlbGVjdCh7c291cmNlOiBlbGVtZW50fSkuYWRkQ2xhc3MoX2N1cnJlbnRJbnN0YW5jZS5lbGVtZW50RHJhZ2dpbmdDbGFzcyArIFwiIFwiICsgX2N1cnJlbnRJbnN0YW5jZS5zb3VyY2VFbGVtZW50RHJhZ2dpbmdDbGFzcywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY3VycmVudEluc3RhbmNlLnNlbGVjdCh7dGFyZ2V0OiBlbGVtZW50fSkuYWRkQ2xhc3MoX2N1cnJlbnRJbnN0YW5jZS5lbGVtZW50RHJhZ2dpbmdDbGFzcyArIFwiIFwiICsgX2N1cnJlbnRJbnN0YW5jZS50YXJnZXRFbGVtZW50RHJhZ2dpbmdDbGFzcywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY3VycmVudEluc3RhbmNlLnNldENvbm5lY3Rpb25CZWluZ0RyYWdnZWQodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5jYW5EcmFnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRyYWdPcHRpb25zLmNhbkRyYWcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgZmFsc2UpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnNbZHJhZ0V2ZW50XSA9IF9qdS53cmFwKG9wdGlvbnNbZHJhZ0V2ZW50XSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogaGVyZSB3ZSBjb3VsZCBhY3R1YWxseSB1c2UgZ2V0RHJhZ09iamVjdCwgYW5kIHRoZW4gY29tcHV0ZSBpdCBvdXJzZWx2ZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzaW5jZSBldmVyeSBhZGFwdGVyIGRvZXMgdGhlIHNhbWUgdGhpbmcuIGJ1dCBpJ20gbm90IHN1cmUgd2h5IFlVSSdzIGdldERyYWdPYmplY3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRpZmZlcnMgZnJvbSBnZXRVSVBvc2l0aW9uIHNvIG11Y2hcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1aSA9IF9jdXJyZW50SW5zdGFuY2UuZ2V0VUlQb3NpdGlvbihhcmd1bWVudHMsIF9jdXJyZW50SW5zdGFuY2UuZ2V0Wm9vbSgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1aSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2RyYXcoZWxlbWVudCwgdWksIG51bGwsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfc3RhcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY3VycmVudEluc3RhbmNlLmFkZENsYXNzKGVsZW1lbnQsIFwianRrLWRyYWdnZWRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9zdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnNbc3RvcEV2ZW50XSA9IF9qdS53cmFwKG9wdGlvbnNbc3RvcEV2ZW50XSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVsZW1lbnRzID0gYXJndW1lbnRzWzBdLnNlbGVjdGlvbiwgdWlwO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX29uZSA9IGZ1bmN0aW9uIChfZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfZVsxXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJ1biB0aGUgcmVwb3J0ZWQgb2Zmc2V0IHRocm91Z2ggdGhlIGNvZGUgdGhhdCB0YWtlcyBwYXJlbnQgY29udGFpbmVyc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbnRvIGFjY291bnQsIHRvIGFkanVzdCBpZiBuZWNlc3NhcnkgKGlzc3VlIDU1NClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdWlwID0gX2N1cnJlbnRJbnN0YW5jZS5nZXRVSVBvc2l0aW9uKFt7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbDpfZVsyXS5lbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvczpbX2VbMV0ubGVmdCwgX2VbMV0udG9wXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9kcmF3KF9lWzJdLmVsLCB1aXApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY3VycmVudEluc3RhbmNlLnJlbW92ZUNsYXNzKF9lWzBdLCBcImp0ay1kcmFnZ2VkXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jdXJyZW50SW5zdGFuY2Uuc2VsZWN0KHtzb3VyY2U6IF9lWzJdLmVsfSkucmVtb3ZlQ2xhc3MoX2N1cnJlbnRJbnN0YW5jZS5lbGVtZW50RHJhZ2dpbmdDbGFzcyArIFwiIFwiICsgX2N1cnJlbnRJbnN0YW5jZS5zb3VyY2VFbGVtZW50RHJhZ2dpbmdDbGFzcywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2N1cnJlbnRJbnN0YW5jZS5zZWxlY3Qoe3RhcmdldDogX2VbMl0uZWx9KS5yZW1vdmVDbGFzcyhfY3VycmVudEluc3RhbmNlLmVsZW1lbnREcmFnZ2luZ0NsYXNzICsgXCIgXCIgKyBfY3VycmVudEluc3RhbmNlLnRhcmdldEVsZW1lbnREcmFnZ2luZ0NsYXNzLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY3VycmVudEluc3RhbmNlLmdldERyYWdNYW5hZ2VyKCkuZHJhZ0VuZGVkKF9lWzJdLmVsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfb25lKGVsZW1lbnRzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3N0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jdXJyZW50SW5zdGFuY2Uuc2V0SG92ZXJTdXNwZW5kZWQoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2N1cnJlbnRJbnN0YW5jZS5zZXRDb25uZWN0aW9uQmVpbmdEcmFnZ2VkKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbElkID0gX2dldElkKGVsZW1lbnQpOyAvLyBuZWVkIElEXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRyYWdnYWJsZVN0YXRlc1tlbElkXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkcmFnZ2FibGUgPSBkcmFnZ2FibGVTdGF0ZXNbZWxJZF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGlzYWJsZWQgPSBkcmFnZ2FibGUgPT0gbnVsbCA/IGZhbHNlIDogIWRyYWdnYWJsZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2N1cnJlbnRJbnN0YW5jZS5pbml0RHJhZ2dhYmxlKGVsZW1lbnQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY3VycmVudEluc3RhbmNlLmdldERyYWdNYW5hZ2VyKCkucmVnaXN0ZXIoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaXJlRXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jdXJyZW50SW5zdGFuY2UuZmlyZShcImVsZW1lbnREcmFnZ2FibGVcIiwge2VsOmVsZW1lbnQsIG9wdGlvbnM6b3B0aW9uc30pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhbHJlYWR5IGRyYWdnYWJsZS4gYXR0YWNoIGFueSBzdGFydCwgZHJhZyBvciBzdG9wIGxpc3RlbmVycyB0byB0aGUgY3VycmVudCBEcmFnLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZHJhZ09wdGlvbnMuZm9yY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jdXJyZW50SW5zdGFuY2UuaW5pdERyYWdnYWJsZShlbGVtZW50LCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIF9zY29wZU1hdGNoID0gZnVuY3Rpb24gKGUxLCBlMikge1xuICAgICAgICAgICAgICAgIHZhciBzMSA9IGUxLnNjb3BlLnNwbGl0KC9cXHMvKSwgczIgPSBlMi5zY29wZS5zcGxpdCgvXFxzLyk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzMS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHMyLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoczJbal0gPT09IHMxW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBfbWVyZ2VPdmVycmlkZXMgPSBmdW5jdGlvbiAoZGVmLCB2YWx1ZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgbSA9IGpzUGx1bWIuZXh0ZW5kKHt9LCBkZWYpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgaW4gdmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZXNbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1baV0gPSB2YWx1ZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG07XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgIC8qXG4gICAgICAgICAqIHByZXBhcmVzIGEgZmluYWwgcGFyYW1zIG9iamVjdCB0aGF0IGNhbiBiZSBwYXNzZWQgdG8gX25ld0Nvbm5lY3Rpb24sIHRha2luZyBpbnRvIGFjY291bnQgZGVmYXVsdHMsIGV2ZW50cywgZXRjLlxuICAgICAgICAgKi9cbiAgICAgICAgICAgIF9wcmVwYXJlQ29ubmVjdGlvblBhcmFtcyA9IGZ1bmN0aW9uIChwYXJhbXMsIHJlZmVyZW5jZVBhcmFtcykge1xuICAgICAgICAgICAgICAgIHZhciBfcCA9IGpzUGx1bWIuZXh0ZW5kKHsgfSwgcGFyYW1zKTtcbiAgICAgICAgICAgICAgICBpZiAocmVmZXJlbmNlUGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgICAgIGpzUGx1bWIuZXh0ZW5kKF9wLCByZWZlcmVuY2VQYXJhbXMpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGhvdHdpcmUgZW5kcG9pbnRzIHBhc3NlZCBhcyBzb3VyY2Ugb3IgdGFyZ2V0IHRvIHNvdXJjZUVuZHBvaW50L3RhcmdldEVuZHBvaW50LCByZXNwZWN0aXZlbHkuXG4gICAgICAgICAgICAgICAgaWYgKF9wLnNvdXJjZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX3Auc291cmNlLmVuZHBvaW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfcC5zb3VyY2VFbmRwb2ludCA9IF9wLnNvdXJjZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9wLnNvdXJjZSA9IF9jdXJyZW50SW5zdGFuY2UuZ2V0RWxlbWVudChfcC5zb3VyY2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChfcC50YXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9wLnRhcmdldC5lbmRwb2ludCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3AudGFyZ2V0RW5kcG9pbnQgPSBfcC50YXJnZXQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfcC50YXJnZXQgPSBfY3VycmVudEluc3RhbmNlLmdldEVsZW1lbnQoX3AudGFyZ2V0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHRlc3QgZm9yIGVuZHBvaW50IHV1aWRzIHRvIGNvbm5lY3RcbiAgICAgICAgICAgICAgICBpZiAocGFyYW1zLnV1aWRzKSB7XG4gICAgICAgICAgICAgICAgICAgIF9wLnNvdXJjZUVuZHBvaW50ID0gX2dldEVuZHBvaW50KHBhcmFtcy51dWlkc1swXSk7XG4gICAgICAgICAgICAgICAgICAgIF9wLnRhcmdldEVuZHBvaW50ID0gX2dldEVuZHBvaW50KHBhcmFtcy51dWlkc1sxXSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gbm93IGVuc3VyZSB0aGF0IGlmIHdlIGRvIGhhdmUgRW5kcG9pbnRzIGFscmVhZHksIHRoZXkncmUgbm90IGZ1bGwuXG4gICAgICAgICAgICAgICAgLy8gc291cmNlOlxuICAgICAgICAgICAgICAgIGlmIChfcC5zb3VyY2VFbmRwb2ludCAmJiBfcC5zb3VyY2VFbmRwb2ludC5pc0Z1bGwoKSkge1xuICAgICAgICAgICAgICAgICAgICBfanUubG9nKF9jdXJyZW50SW5zdGFuY2UsIFwiY291bGQgbm90IGFkZCBjb25uZWN0aW9uOyBzb3VyY2UgZW5kcG9pbnQgaXMgZnVsbFwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHRhcmdldDpcbiAgICAgICAgICAgICAgICBpZiAoX3AudGFyZ2V0RW5kcG9pbnQgJiYgX3AudGFyZ2V0RW5kcG9pbnQuaXNGdWxsKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgX2p1LmxvZyhfY3VycmVudEluc3RhbmNlLCBcImNvdWxkIG5vdCBhZGQgY29ubmVjdGlvbjsgdGFyZ2V0IGVuZHBvaW50IGlzIGZ1bGxcIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBpZiBzb3VyY2UgZW5kcG9pbnQgbWFuZGF0ZXMgY29ubmVjdGlvbiB0eXBlIGFuZCBub3RoaW5nIHNwZWNpZmllZCBpbiBvdXIgcGFyYW1zLCB1c2UgaXQuXG4gICAgICAgICAgICAgICAgaWYgKCFfcC50eXBlICYmIF9wLnNvdXJjZUVuZHBvaW50KSB7XG4gICAgICAgICAgICAgICAgICAgIF9wLnR5cGUgPSBfcC5zb3VyY2VFbmRwb2ludC5jb25uZWN0aW9uVHlwZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBjb3B5IGluIGFueSBjb25uZWN0b3JPdmVybGF5cyB0aGF0IHdlcmUgc3BlY2lmaWVkIG9uIHRoZSBzb3VyY2UgZW5kcG9pbnQuXG4gICAgICAgICAgICAgICAgLy8gaXQgZG9lc250IGNvcHkgdGFyZ2V0IGVuZHBvaW50IG92ZXJsYXlzLiAgaSdtIG5vdCBzdXJlIGlmIHdlIHdhbnQgaXQgdG8gb3Igbm90LlxuICAgICAgICAgICAgICAgIGlmIChfcC5zb3VyY2VFbmRwb2ludCAmJiBfcC5zb3VyY2VFbmRwb2ludC5jb25uZWN0b3JPdmVybGF5cykge1xuICAgICAgICAgICAgICAgICAgICBfcC5vdmVybGF5cyA9IF9wLm92ZXJsYXlzIHx8IFtdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaiA9IF9wLnNvdXJjZUVuZHBvaW50LmNvbm5lY3Rvck92ZXJsYXlzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3Aub3ZlcmxheXMucHVzaChfcC5zb3VyY2VFbmRwb2ludC5jb25uZWN0b3JPdmVybGF5c1tpXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBzY29wZVxuICAgICAgICAgICAgICAgIGlmIChfcC5zb3VyY2VFbmRwb2ludCAmJiBfcC5zb3VyY2VFbmRwb2ludC5zY29wZSkge1xuICAgICAgICAgICAgICAgICAgICBfcC5zY29wZSA9IF9wLnNvdXJjZUVuZHBvaW50LnNjb3BlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHBvaW50ZXIgZXZlbnRzXG4gICAgICAgICAgICAgICAgaWYgKCFfcFtcInBvaW50ZXItZXZlbnRzXCJdICYmIF9wLnNvdXJjZUVuZHBvaW50ICYmIF9wLnNvdXJjZUVuZHBvaW50LmNvbm5lY3RvclBvaW50ZXJFdmVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgX3BbXCJwb2ludGVyLWV2ZW50c1wiXSA9IF9wLnNvdXJjZUVuZHBvaW50LmNvbm5lY3RvclBvaW50ZXJFdmVudHM7XG4gICAgICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgICAgICB2YXIgX2FkZEVuZHBvaW50ID0gZnVuY3Rpb24gKGVsLCBkZWYsIGlkeCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2N1cnJlbnRJbnN0YW5jZS5hZGRFbmRwb2ludChlbCwgX21lcmdlT3ZlcnJpZGVzKGRlZiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgYW5jaG9yOiBfcC5hbmNob3JzID8gX3AuYW5jaG9yc1tpZHhdIDogX3AuYW5jaG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kcG9pbnQ6IF9wLmVuZHBvaW50cyA/IF9wLmVuZHBvaW50c1tpZHhdIDogX3AuZW5kcG9pbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYWludFN0eWxlOiBfcC5lbmRwb2ludFN0eWxlcyA/IF9wLmVuZHBvaW50U3R5bGVzW2lkeF0gOiBfcC5lbmRwb2ludFN0eWxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaG92ZXJQYWludFN0eWxlOiBfcC5lbmRwb2ludEhvdmVyU3R5bGVzID8gX3AuZW5kcG9pbnRIb3ZlclN0eWxlc1tpZHhdIDogX3AuZW5kcG9pbnRIb3ZlclN0eWxlXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgZm9yIG1ha2VTb3VyY2UvbWFrZVRhcmdldCBzcGVjcy5cblxuICAgICAgICAgICAgICAgIHZhciBfb25lRWxlbWVudERlZiA9IGZ1bmN0aW9uICh0eXBlLCBpZHgsIGRlZnMsIG1hdGNoVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX3BbdHlwZV0gJiYgIV9wW3R5cGVdLmVuZHBvaW50ICYmICFfcFt0eXBlICsgXCJFbmRwb2ludFwiXSAmJiAhX3AubmV3Q29ubmVjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRpZCA9IF9nZXRJZChfcFt0eXBlXSksIHRlcCA9IGRlZnNbdGlkXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdGVwID0gdGVwID8gdGVwW21hdGNoVHlwZV0gOiBudWxsO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGVwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgbm90IGVuYWJsZWQsIHJldHVybi5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRlcC5lbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5ld0VuZHBvaW50ID0gdGVwLmVuZHBvaW50ICE9IG51bGwgJiYgdGVwLmVuZHBvaW50Ll9qc1BsdW1iID8gdGVwLmVuZHBvaW50IDogX2FkZEVuZHBvaW50KF9wW3R5cGVdLCB0ZXAuZGVmLCBpZHgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXdFbmRwb2ludC5pc0Z1bGwoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9wW3R5cGUgKyBcIkVuZHBvaW50XCJdID0gbmV3RW5kcG9pbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFfcC5zY29wZSAmJiB0ZXAuZGVmLnNjb3BlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9wLnNjb3BlID0gdGVwLmRlZi5zY29wZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IC8vIHByb3ZpZGUgc2NvcGUgaWYgbm90IGFscmVhZHkgcHJvdmlkZWQgYW5kIGVuZHBvaW50IGRlZiBoYXMgb25lLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0ZXAudW5pcXVlRW5kcG9pbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0ZXAuZW5kcG9pbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlcC5lbmRwb2ludCA9IG5ld0VuZHBvaW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3RW5kcG9pbnQuc2V0RGVsZXRlT25FbXB0eShmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdFbmRwb2ludC5maW5hbEVuZHBvaW50ID0gdGVwLmVuZHBvaW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3RW5kcG9pbnQuc2V0RGVsZXRlT25FbXB0eSh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgaWYgKF9vbmVFbGVtZW50RGVmKFwic291cmNlXCIsIDAsIHRoaXMuc291cmNlRW5kcG9pbnREZWZpbml0aW9ucywgX3AudHlwZSB8fCBcImRlZmF1bHRcIikgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKF9vbmVFbGVtZW50RGVmKFwidGFyZ2V0XCIsIDEsIHRoaXMudGFyZ2V0RW5kcG9pbnREZWZpbml0aW9ucywgX3AudHlwZSB8fCBcImRlZmF1bHRcIikgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBsYXN0LCBlbnN1cmUgc2NvcGVzIG1hdGNoXG4gICAgICAgICAgICAgICAgaWYgKF9wLnNvdXJjZUVuZHBvaW50ICYmIF9wLnRhcmdldEVuZHBvaW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghX3Njb3BlTWF0Y2goX3Auc291cmNlRW5kcG9pbnQsIF9wLnRhcmdldEVuZHBvaW50KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3AgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9wO1xuICAgICAgICAgICAgfS5iaW5kKF9jdXJyZW50SW5zdGFuY2UpLFxuXG4gICAgICAgICAgICBfbmV3Q29ubmVjdGlvbiA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29ubmVjdGlvbkZ1bmMgPSBfY3VycmVudEluc3RhbmNlLkRlZmF1bHRzLkNvbm5lY3Rpb25UeXBlIHx8IF9jdXJyZW50SW5zdGFuY2UuZ2V0RGVmYXVsdENvbm5lY3Rpb25UeXBlKCk7XG5cbiAgICAgICAgICAgICAgICBwYXJhbXMuX2pzUGx1bWIgPSBfY3VycmVudEluc3RhbmNlO1xuICAgICAgICAgICAgICAgIHBhcmFtcy5uZXdDb25uZWN0aW9uID0gX25ld0Nvbm5lY3Rpb247XG4gICAgICAgICAgICAgICAgcGFyYW1zLm5ld0VuZHBvaW50ID0gX25ld0VuZHBvaW50O1xuICAgICAgICAgICAgICAgIHBhcmFtcy5lbmRwb2ludHNCeVVVSUQgPSBlbmRwb2ludHNCeVVVSUQ7XG4gICAgICAgICAgICAgICAgcGFyYW1zLmVuZHBvaW50c0J5RWxlbWVudCA9IGVuZHBvaW50c0J5RWxlbWVudDtcbiAgICAgICAgICAgICAgICBwYXJhbXMuZmluYWxpc2VDb25uZWN0aW9uID0gX2ZpbmFsaXNlQ29ubmVjdGlvbjtcbiAgICAgICAgICAgICAgICBwYXJhbXMuaWQgPSBcImNvbl9cIiArIF9pZHN0YW1wKCk7XG4gICAgICAgICAgICAgICAgdmFyIGNvbiA9IG5ldyBjb25uZWN0aW9uRnVuYyhwYXJhbXMpO1xuXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIGNvbm5lY3Rpb24gaXMgZHJhZ2dhYmxlLCB0aGVuIG1heWJlIHdlIG5lZWQgdG8gdGVsbCB0aGUgdGFyZ2V0IGVuZHBvaW50IHRvIGluaXQgdGhlXG4gICAgICAgICAgICAgICAgLy8gZHJhZ2dpbmcgY29kZS4gaXQgd29uJ3QgcnVuIGFnYWluIGlmIGl0IGFscmVhZHkgY29uZmlndXJlZCB0byBiZSBkcmFnZ2FibGUuXG4gICAgICAgICAgICAgICAgaWYgKGNvbi5pc0RldGFjaGFibGUoKSkge1xuICAgICAgICAgICAgICAgICAgICBjb24uZW5kcG9pbnRzWzBdLmluaXREcmFnZ2FibGUoXCJfanNQbHVtYlNvdXJjZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgY29uLmVuZHBvaW50c1sxXS5pbml0RHJhZ2dhYmxlKFwiX2pzUGx1bWJUYXJnZXRcIik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbjtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gYWRkcyB0aGUgY29ubmVjdGlvbiB0byB0aGUgYmFja2luZyBtb2RlbCwgZmlyZXMgYW4gZXZlbnQgaWYgbmVjZXNzYXJ5IGFuZCB0aGVuIHJlZHJhd3NcbiAgICAgICAgLy9cbiAgICAgICAgICAgIF9maW5hbGlzZUNvbm5lY3Rpb24gPSBfY3VycmVudEluc3RhbmNlLmZpbmFsaXNlQ29ubmVjdGlvbiA9IGZ1bmN0aW9uIChqcGMsIHBhcmFtcywgb3JpZ2luYWxFdmVudCwgZG9JbmZvcm1BbmNob3JNYW5hZ2VyKSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICAgICAgICAgICAgICAgIC8vIGFkZCB0byBsaXN0IG9mIGNvbm5lY3Rpb25zIChieSBzY29wZSkuXG4gICAgICAgICAgICAgICAgaWYgKCFqcGMuc3VzcGVuZGVkRW5kcG9pbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbnMucHVzaChqcGMpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGpwYy5wZW5kaW5nID0gbnVsbDtcblxuICAgICAgICAgICAgICAgIC8vIHR1cm4gb2ZmIGlzVGVtcG9yYXJ5U291cmNlIG9uIHRoZSBzb3VyY2UgZW5kcG9pbnQgKG9ubHkgdmlhYmxlIG9uIGZpcnN0IGRyYXcpXG4gICAgICAgICAgICAgICAganBjLmVuZHBvaW50c1swXS5pc1RlbXBvcmFyeVNvdXJjZSA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgLy8gYWx3YXlzIGluZm9ybSB0aGUgYW5jaG9yIG1hbmFnZXJcbiAgICAgICAgICAgICAgICAvLyBleGNlcHQgdGhhdCBpZiBqcGMgaGFzIGEgc3VzcGVuZGVkIGVuZHBvaW50IGl0J3Mgbm90IHRydWUgdG8gc2F5IHRoZVxuICAgICAgICAgICAgICAgIC8vIGNvbm5lY3Rpb24gaXMgbmV3OyBpdCBoYXMganVzdCAocG9zc2libHkpIG1vdmVkLiB0aGUgcXVlc3Rpb24gaXMgd2hldGhlclxuICAgICAgICAgICAgICAgIC8vIHRvIG1ha2UgdGhhdCBjYWxsIGhlcmUgb3IgaW4gdGhlIGFuY2hvciBtYW5hZ2VyLiAgaSB0aGluayBwZXJoYXBzIGhlcmUuXG4gICAgICAgICAgICAgICAgaWYgKGRvSW5mb3JtQW5jaG9yTWFuYWdlciAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgX2N1cnJlbnRJbnN0YW5jZS5hbmNob3JNYW5hZ2VyLm5ld0Nvbm5lY3Rpb24oanBjKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBmb3JjZSBhIHBhaW50XG4gICAgICAgICAgICAgICAgX2RyYXcoanBjLnNvdXJjZSk7XG5cbiAgICAgICAgICAgICAgICAvLyBmaXJlIGFuIGV2ZW50XG4gICAgICAgICAgICAgICAgaWYgKCFwYXJhbXMuZG9Ob3RGaXJlQ29ubmVjdGlvbkV2ZW50ICYmIHBhcmFtcy5maXJlRXZlbnQgIT09IGZhbHNlKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGV2ZW50QXJncyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb246IGpwYyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZToganBjLnNvdXJjZSwgdGFyZ2V0OiBqcGMudGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlSWQ6IGpwYy5zb3VyY2VJZCwgdGFyZ2V0SWQ6IGpwYy50YXJnZXRJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZUVuZHBvaW50OiBqcGMuZW5kcG9pbnRzWzBdLCB0YXJnZXRFbmRwb2ludDoganBjLmVuZHBvaW50c1sxXVxuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIF9jdXJyZW50SW5zdGFuY2UuZmlyZShcImNvbm5lY3Rpb25cIiwgZXZlbnRBcmdzLCBvcmlnaW5hbEV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgIC8qXG4gICAgICAgICBmYWN0b3J5IG1ldGhvZCB0byBwcmVwYXJlIGEgbmV3IGVuZHBvaW50LiAgdGhpcyBzaG91bGQgYWx3YXlzIGJlIHVzZWQgaW5zdGVhZCBvZiBjcmVhdGluZyBFbmRwb2ludHNcbiAgICAgICAgIG1hbnVhbGx5LCBzaW5jZSB0aGlzIG1ldGhvZCBhdHRhY2hlcyBldmVudCBsaXN0ZW5lcnMgYW5kIGFuIGlkLlxuICAgICAgICAgKi9cbiAgICAgICAgICAgIF9uZXdFbmRwb2ludCA9IGZ1bmN0aW9uIChwYXJhbXMsIGlkKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVuZHBvaW50RnVuYyA9IF9jdXJyZW50SW5zdGFuY2UuRGVmYXVsdHMuRW5kcG9pbnRUeXBlIHx8IGpzUGx1bWIuRW5kcG9pbnQ7XG4gICAgICAgICAgICAgICAgdmFyIF9wID0ganNQbHVtYi5leHRlbmQoe30sIHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgX3AuX2pzUGx1bWIgPSBfY3VycmVudEluc3RhbmNlO1xuICAgICAgICAgICAgICAgIF9wLm5ld0Nvbm5lY3Rpb24gPSBfbmV3Q29ubmVjdGlvbjtcbiAgICAgICAgICAgICAgICBfcC5uZXdFbmRwb2ludCA9IF9uZXdFbmRwb2ludDtcbiAgICAgICAgICAgICAgICBfcC5lbmRwb2ludHNCeVVVSUQgPSBlbmRwb2ludHNCeVVVSUQ7XG4gICAgICAgICAgICAgICAgX3AuZW5kcG9pbnRzQnlFbGVtZW50ID0gZW5kcG9pbnRzQnlFbGVtZW50O1xuICAgICAgICAgICAgICAgIF9wLmZpcmVEZXRhY2hFdmVudCA9IGZpcmVEZXRhY2hFdmVudDtcbiAgICAgICAgICAgICAgICBfcC5lbGVtZW50SWQgPSBpZCB8fCBfZ2V0SWQoX3Auc291cmNlKTtcbiAgICAgICAgICAgICAgICB2YXIgZXAgPSBuZXcgZW5kcG9pbnRGdW5jKF9wKTtcbiAgICAgICAgICAgICAgICBlcC5pZCA9IFwiZXBfXCIgKyBfaWRzdGFtcCgpO1xuICAgICAgICAgICAgICAgIF9tYW5hZ2UoX3AuZWxlbWVudElkLCBfcC5zb3VyY2UpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFqc1BsdW1iLmhlYWRsZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIF9jdXJyZW50SW5zdGFuY2UuZ2V0RHJhZ01hbmFnZXIoKS5lbmRwb2ludEFkZGVkKF9wLnNvdXJjZSwgaWQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBlcDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgLypcbiAgICAgICAgICogcGVyZm9ybXMgdGhlIGdpdmVuIGZ1bmN0aW9uIG9wZXJhdGlvbiBvbiBhbGwgdGhlIGNvbm5lY3Rpb25zIGZvdW5kXG4gICAgICAgICAqIGZvciB0aGUgZ2l2ZW4gZWxlbWVudCBpZDsgdGhpcyBtZWFucyB3ZSBmaW5kIGFsbCB0aGUgZW5kcG9pbnRzIGZvclxuICAgICAgICAgKiB0aGUgZ2l2ZW4gZWxlbWVudCwgYW5kIHRoZW4gZm9yIGVhY2ggZW5kcG9pbnQgZmluZCB0aGUgY29ubmVjdG9yc1xuICAgICAgICAgKiBjb25uZWN0ZWQgdG8gaXQuIHRoZW4gd2UgcGFzcyBlYWNoIGNvbm5lY3Rpb24gaW4gdG8gdGhlIGdpdmVuXG4gICAgICAgICAqIGZ1bmN0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgICAgIF9vcGVyYXRpb24gPSBmdW5jdGlvbiAoZWxJZCwgZnVuYywgZW5kcG9pbnRGdW5jKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVuZHBvaW50cyA9IGVuZHBvaW50c0J5RWxlbWVudFtlbElkXTtcbiAgICAgICAgICAgICAgICBpZiAoZW5kcG9pbnRzICYmIGVuZHBvaW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gZW5kcG9pbnRzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwLCBqaiA9IGVuZHBvaW50c1tpXS5jb25uZWN0aW9ucy5sZW5ndGg7IGogPCBqajsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJldFZhbCA9IGZ1bmMoZW5kcG9pbnRzW2ldLmNvbm5lY3Rpb25zW2pdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgZnVuY3Rpb24gcGFzc2VkIGluIHJldHVybnMgdHJ1ZSwgd2UgZXhpdC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBtb3N0IGZ1bmN0aW9ucyByZXR1cm4gZmFsc2UuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJldFZhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVuZHBvaW50RnVuYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZHBvaW50RnVuYyhlbmRwb2ludHNbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgX3NldERyYWdnYWJsZSA9IGZ1bmN0aW9uIChlbGVtZW50LCBkcmFnZ2FibGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ganNQbHVtYi5lYWNoKGVsZW1lbnQsIGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX2N1cnJlbnRJbnN0YW5jZS5pc0RyYWdTdXBwb3J0ZWQoZWwpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkcmFnZ2FibGVTdGF0ZXNbX2N1cnJlbnRJbnN0YW5jZS5nZXRBdHRyaWJ1dGUoZWwsIFwiaWRcIildID0gZHJhZ2dhYmxlO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2N1cnJlbnRJbnN0YW5jZS5zZXRFbGVtZW50RHJhZ2dhYmxlKGVsLCBkcmFnZ2FibGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAvKlxuICAgICAgICAgKiBwcml2YXRlIG1ldGhvZCB0byBkbyB0aGUgYnVzaW5lc3Mgb2YgaGlkaW5nL3Nob3dpbmcuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBlbFxuICAgICAgICAgKiAgICAgICAgICAgIGVpdGhlciBJZCBvZiB0aGUgZWxlbWVudCBpbiBxdWVzdGlvbiBvciBhIGxpYnJhcnkgc3BlY2lmaWNcbiAgICAgICAgICogICAgICAgICAgICBvYmplY3QgZm9yIHRoZSBlbGVtZW50LlxuICAgICAgICAgKiBAcGFyYW0gc3RhdGVcbiAgICAgICAgICogICAgICAgICAgICBTdHJpbmcgc3BlY2lmeWluZyBhIHZhbHVlIGZvciB0aGUgY3NzICdkaXNwbGF5JyBwcm9wZXJ0eVxuICAgICAgICAgKiAgICAgICAgICAgICgnYmxvY2snIG9yICdub25lJykuXG4gICAgICAgICAqL1xuICAgICAgICAgICAgX3NldFZpc2libGUgPSBmdW5jdGlvbiAoZWwsIHN0YXRlLCBhbHNvQ2hhbmdlRW5kcG9pbnRzKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUgPSBzdGF0ZSA9PT0gXCJibG9ja1wiO1xuICAgICAgICAgICAgICAgIHZhciBlbmRwb2ludEZ1bmMgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChhbHNvQ2hhbmdlRW5kcG9pbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGVuZHBvaW50RnVuYyA9IGZ1bmN0aW9uIChlcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXAuc2V0VmlzaWJsZShzdGF0ZSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBpbmZvID0gX2luZm8oZWwpO1xuICAgICAgICAgICAgICAgIF9vcGVyYXRpb24oaW5mby5pZCwgZnVuY3Rpb24gKGpwYykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGUgJiYgYWxzb0NoYW5nZUVuZHBvaW50cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyB0ZXN0IGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHRoaXMgZnVuY3Rpb25hbGl0eSBpcyBuZXcsIGFuZCBpIHdhbnRlZCB0byBtYWludGFpbiBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgYmxvY2sgd2lsbCBvbmx5IHNldCBhIGNvbm5lY3Rpb24gdG8gYmUgdmlzaWJsZSBpZiB0aGUgb3RoZXIgZW5kcG9pbnQgaW4gdGhlIGNvbm5lY3Rpb24gaXMgYWxzbyB2aXNpYmxlLlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9pZHggPSBqcGMuc291cmNlSWQgPT09IGluZm8uaWQgPyAxIDogMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChqcGMuZW5kcG9pbnRzW29pZHhdLmlzVmlzaWJsZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAganBjLnNldFZpc2libGUodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7IC8vIHRoZSBkZWZhdWx0IGJlaGF2aW91ciBmb3Igc2hvdywgYW5kIHdoYXQgYWx3YXlzIGhhcHBlbnMgZm9yIGhpZGUsIGlzIHRvIGp1c3Qgc2V0IHRoZSB2aXNpYmlsaXR5IHdpdGhvdXQgZ2V0dGluZyBjbGV2ZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICBqcGMuc2V0VmlzaWJsZShzdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBlbmRwb2ludEZ1bmMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgLypcbiAgICAgICAgICogdG9nZ2xlcyB0aGUgZHJhZ2dhYmxlIHN0YXRlIG9mIHRoZSBnaXZlbiBlbGVtZW50KHMpLlxuICAgICAgICAgKiBlbCBpcyBlaXRoZXIgYW4gaWQsIG9yIGFuIGVsZW1lbnQgb2JqZWN0LCBvciBhIGxpc3Qgb2YgaWRzL2VsZW1lbnQgb2JqZWN0cy5cbiAgICAgICAgICovXG4gICAgICAgICAgICBfdG9nZ2xlRHJhZ2dhYmxlID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXRlO1xuICAgICAgICAgICAgICAgIGpzUGx1bWIuZWFjaChlbCwgZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlbElkID0gX2N1cnJlbnRJbnN0YW5jZS5nZXRBdHRyaWJ1dGUoZWwsIFwiaWRcIik7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlID0gZHJhZ2dhYmxlU3RhdGVzW2VsSWRdID09IG51bGwgPyBmYWxzZSA6IGRyYWdnYWJsZVN0YXRlc1tlbElkXTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSAhc3RhdGU7XG4gICAgICAgICAgICAgICAgICAgIGRyYWdnYWJsZVN0YXRlc1tlbElkXSA9IHN0YXRlO1xuICAgICAgICAgICAgICAgICAgICBfY3VycmVudEluc3RhbmNlLnNldERyYWdnYWJsZShlbCwgc3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBwcml2YXRlIG1ldGhvZCB0byBkbyB0aGUgYnVzaW5lc3Mgb2YgdG9nZ2xpbmcgaGlkaW5nL3Nob3dpbmcuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIF90b2dnbGVWaXNpYmxlID0gZnVuY3Rpb24gKGVsSWQsIGNoYW5nZUVuZHBvaW50cykge1xuICAgICAgICAgICAgICAgIHZhciBlbmRwb2ludEZ1bmMgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChjaGFuZ2VFbmRwb2ludHMpIHtcbiAgICAgICAgICAgICAgICAgICAgZW5kcG9pbnRGdW5jID0gZnVuY3Rpb24gKGVwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RhdGUgPSBlcC5pc1Zpc2libGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVwLnNldFZpc2libGUoIXN0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX29wZXJhdGlvbihlbElkLCBmdW5jdGlvbiAoanBjKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdGF0ZSA9IGpwYy5pc1Zpc2libGUoKTtcbiAgICAgICAgICAgICAgICAgICAganBjLnNldFZpc2libGUoIXN0YXRlKTtcbiAgICAgICAgICAgICAgICB9LCBlbmRwb2ludEZ1bmMpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAvLyBUT0RPIGNvbXBhcmlzb24gcGVyZm9ybWFuY2VcbiAgICAgICAgICAgIF9nZXRDYWNoZWREYXRhID0gZnVuY3Rpb24gKGVsSWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgbyA9IG9mZnNldHNbZWxJZF07XG4gICAgICAgICAgICAgICAgaWYgKCFvKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdXBkYXRlT2Zmc2V0KHtlbElkOiBlbElkfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge286IG8sIHM6IHNpemVzW2VsSWRdfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIGdldHMgYW4gaWQgZm9yIHRoZSBnaXZlbiBlbGVtZW50LCBjcmVhdGluZyBhbmQgc2V0dGluZyBvbmUgaWZcbiAgICAgICAgICAgICAqIG5lY2Vzc2FyeS4gIHRoZSBpZCBpcyBvZiB0aGUgZm9ybVxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICAgIGpzUGx1bWJfPGluc3RhbmNlIGluZGV4Pl88aW5kZXggaW4gaW5zdGFuY2U+XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogd2hlcmUgXCJpbmRleCBpbiBpbnN0YW5jZVwiIGlzIGEgbW9ub3RvbmljYWxseSBpbmNyZWFzaW5nIGludGVnZXIgdGhhdCBzdGFydHMgYXQgMCxcbiAgICAgICAgICAgICAqIGZvciBlYWNoIGluc3RhbmNlLiAgdGhpcyBtZXRob2QgaXMgdXNlZCBub3Qgb25seSB0byBhc3NpZ24gaWRzIHRvIGVsZW1lbnRzIHRoYXQgZG8gbm90XG4gICAgICAgICAgICAgKiBoYXZlIHRoZW0gYnV0IGFsc28gdG8gY29ubmVjdGlvbnMgYW5kIGVuZHBvaW50cy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgX2dldElkID0gZnVuY3Rpb24gKGVsZW1lbnQsIHV1aWQsIGRvTm90Q3JlYXRlSWZOb3RGb3VuZCkge1xuICAgICAgICAgICAgICAgIGlmIChfanUuaXNTdHJpbmcoZWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBpZCA9IF9jdXJyZW50SW5zdGFuY2UuZ2V0QXR0cmlidXRlKGVsZW1lbnQsIFwiaWRcIik7XG4gICAgICAgICAgICAgICAgaWYgKCFpZCB8fCBpZCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiBmaXhlZCB1dWlkIHBhcmFtZXRlciBpcyBnaXZlblxuICAgICAgICAgICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMiAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQgPSB1dWlkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgfHwgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMgJiYgIWFyZ3VtZW50c1syXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkID0gXCJqc1BsdW1iX1wiICsgX2luc3RhbmNlSW5kZXggKyBcIl9cIiArIF9pZHN0YW1wKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoIWRvTm90Q3JlYXRlSWZOb3RGb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2N1cnJlbnRJbnN0YW5jZS5zZXRBdHRyaWJ1dGUoZWxlbWVudCwgXCJpZFwiLCBpZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICB0aGlzLnNldENvbm5lY3Rpb25CZWluZ0RyYWdnZWQgPSBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgY29ubmVjdGlvbkJlaW5nRHJhZ2dlZCA9IHY7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaXNDb25uZWN0aW9uQmVpbmdEcmFnZ2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb25CZWluZ0RyYWdnZWQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgYSBtYXAgb2YgYWxsIHRoZSBlbGVtZW50cyB0aGlzIGpzUGx1bWJJbnN0YW5jZSBpcyBjdXJyZW50bHkgbWFuYWdpbmcuXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3R9IE1hcCBvZiBbaWQtPiB7ZWwsIGVuZHBvaW50W10sIGNvbm5lY3Rpb24sIHBvc2l0aW9ufV0gaW5mb3JtYXRpb24uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdldE1hbmFnZWRFbGVtZW50cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIG1hbmFnZWRFbGVtZW50cztcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmNvbm5lY3RvckNsYXNzID0gXCJqdGstY29ubmVjdG9yXCI7XG4gICAgICAgIHRoaXMuY29ubmVjdG9yT3V0bGluZUNsYXNzID0gXCJqdGstY29ubmVjdG9yLW91dGxpbmVcIjtcbiAgICAgICAgdGhpcy5lZGl0YWJsZUNvbm5lY3RvckNsYXNzID0gXCJqdGstY29ubmVjdG9yLWVkaXRhYmxlXCI7XG4gICAgICAgIHRoaXMuY29ubmVjdGVkQ2xhc3MgPSBcImp0ay1jb25uZWN0ZWRcIjtcbiAgICAgICAgdGhpcy5ob3ZlckNsYXNzID0gXCJqdGstaG92ZXJcIjtcbiAgICAgICAgdGhpcy5lbmRwb2ludENsYXNzID0gXCJqdGstZW5kcG9pbnRcIjtcbiAgICAgICAgdGhpcy5lbmRwb2ludENvbm5lY3RlZENsYXNzID0gXCJqdGstZW5kcG9pbnQtY29ubmVjdGVkXCI7XG4gICAgICAgIHRoaXMuZW5kcG9pbnRGdWxsQ2xhc3MgPSBcImp0ay1lbmRwb2ludC1mdWxsXCI7XG4gICAgICAgIHRoaXMuZW5kcG9pbnREcm9wQWxsb3dlZENsYXNzID0gXCJqdGstZW5kcG9pbnQtZHJvcC1hbGxvd2VkXCI7XG4gICAgICAgIHRoaXMuZW5kcG9pbnREcm9wRm9yYmlkZGVuQ2xhc3MgPSBcImp0ay1lbmRwb2ludC1kcm9wLWZvcmJpZGRlblwiO1xuICAgICAgICB0aGlzLm92ZXJsYXlDbGFzcyA9IFwianRrLW92ZXJsYXlcIjtcbiAgICAgICAgdGhpcy5kcmFnZ2luZ0NsYXNzID0gXCJqdGstZHJhZ2dpbmdcIjtcbiAgICAgICAgdGhpcy5lbGVtZW50RHJhZ2dpbmdDbGFzcyA9IFwianRrLWVsZW1lbnQtZHJhZ2dpbmdcIjtcbiAgICAgICAgdGhpcy5zb3VyY2VFbGVtZW50RHJhZ2dpbmdDbGFzcyA9IFwianRrLXNvdXJjZS1lbGVtZW50LWRyYWdnaW5nXCI7XG4gICAgICAgIHRoaXMudGFyZ2V0RWxlbWVudERyYWdnaW5nQ2xhc3MgPSBcImp0ay10YXJnZXQtZWxlbWVudC1kcmFnZ2luZ1wiO1xuICAgICAgICB0aGlzLmVuZHBvaW50QW5jaG9yQ2xhc3NQcmVmaXggPSBcImp0ay1lbmRwb2ludC1hbmNob3JcIjtcbiAgICAgICAgdGhpcy5ob3ZlclNvdXJjZUNsYXNzID0gXCJqdGstc291cmNlLWhvdmVyXCI7XG4gICAgICAgIHRoaXMuaG92ZXJUYXJnZXRDbGFzcyA9IFwianRrLXRhcmdldC1ob3ZlclwiO1xuICAgICAgICB0aGlzLmRyYWdTZWxlY3RDbGFzcyA9IFwianRrLWRyYWctc2VsZWN0XCI7XG5cbiAgICAgICAgdGhpcy5BbmNob3JzID0ge307XG4gICAgICAgIHRoaXMuQ29ubmVjdG9ycyA9IHsgIFwic3ZnXCI6IHt9IH07XG4gICAgICAgIHRoaXMuRW5kcG9pbnRzID0geyBcInN2Z1wiOiB7fSB9O1xuICAgICAgICB0aGlzLk92ZXJsYXlzID0geyBcInN2Z1wiOiB7fSB9IDtcbiAgICAgICAgdGhpcy5Db25uZWN0b3JSZW5kZXJlcnMgPSB7fTtcbiAgICAgICAgdGhpcy5TVkcgPSBcInN2Z1wiO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0ganNQbHVtYkluc3RhbmNlIHB1YmxpYyBBUEkgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblxuICAgICAgICB0aGlzLmFkZEVuZHBvaW50ID0gZnVuY3Rpb24gKGVsLCBwYXJhbXMsIHJlZmVyZW5jZVBhcmFtcykge1xuICAgICAgICAgICAgcmVmZXJlbmNlUGFyYW1zID0gcmVmZXJlbmNlUGFyYW1zIHx8IHt9O1xuICAgICAgICAgICAgdmFyIHAgPSBqc1BsdW1iLmV4dGVuZCh7fSwgcmVmZXJlbmNlUGFyYW1zKTtcbiAgICAgICAgICAgIGpzUGx1bWIuZXh0ZW5kKHAsIHBhcmFtcyk7XG4gICAgICAgICAgICBwLmVuZHBvaW50ID0gcC5lbmRwb2ludCB8fCBfY3VycmVudEluc3RhbmNlLkRlZmF1bHRzLkVuZHBvaW50O1xuICAgICAgICAgICAgcC5wYWludFN0eWxlID0gcC5wYWludFN0eWxlIHx8IF9jdXJyZW50SW5zdGFuY2UuRGVmYXVsdHMuRW5kcG9pbnRTdHlsZTtcblxuICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSBbXSxcbiAgICAgICAgICAgICAgICBpbnB1dHMgPSAoX2p1LmlzQXJyYXkoZWwpIHx8IChlbC5sZW5ndGggIT0gbnVsbCAmJiAhX2p1LmlzU3RyaW5nKGVsKSkpID8gZWwgOiBbIGVsIF07XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBqID0gaW5wdXRzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgICAgICAgICAgICAgIHAuc291cmNlID0gX2N1cnJlbnRJbnN0YW5jZS5nZXRFbGVtZW50KGlucHV0c1tpXSk7XG4gICAgICAgICAgICAgICAgX2Vuc3VyZUNvbnRhaW5lcihwLnNvdXJjZSk7XG5cbiAgICAgICAgICAgICAgICB2YXIgaWQgPSBfZ2V0SWQocC5zb3VyY2UpLCBlID0gX25ld0VuZHBvaW50KHAsIGlkKTtcblxuICAgICAgICAgICAgICAgIC8vIGVuc3VyZSBlbGVtZW50IGlzIG1hbmFnZWQuXG4gICAgICAgICAgICAgICAgdmFyIG15T2Zmc2V0ID0gX21hbmFnZShpZCwgcC5zb3VyY2UpLmluZm8ubztcbiAgICAgICAgICAgICAgICBfanUuYWRkVG9MaXN0KGVuZHBvaW50c0J5RWxlbWVudCwgaWQsIGUpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFfc3VzcGVuZERyYXdpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5wYWludCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbmNob3JMb2M6IGUuYW5jaG9yLmNvbXB1dGUoeyB4eTogWyBteU9mZnNldC5sZWZ0LCBteU9mZnNldC50b3AgXSwgd2g6IHNpemVzW2lkXSwgZWxlbWVudDogZSwgdGltZXN0YW1wOiBfc3VzcGVuZGVkQXQgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IF9zdXNwZW5kZWRBdFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzLmxlbmd0aCA9PT0gMSA/IHJlc3VsdHNbMF0gOiByZXN1bHRzO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuYWRkRW5kcG9pbnRzID0gZnVuY3Rpb24gKGVsLCBlbmRwb2ludHMsIHJlZmVyZW5jZVBhcmFtcykge1xuICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBqID0gZW5kcG9pbnRzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBlID0gX2N1cnJlbnRJbnN0YW5jZS5hZGRFbmRwb2ludChlbCwgZW5kcG9pbnRzW2ldLCByZWZlcmVuY2VQYXJhbXMpO1xuICAgICAgICAgICAgICAgIGlmIChfanUuaXNBcnJheShlKSkge1xuICAgICAgICAgICAgICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShyZXN1bHRzLCBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmFuaW1hdGUgPSBmdW5jdGlvbiAoZWwsIHByb3BlcnRpZXMsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5hbmltYXRpb25TdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICAgICAgdmFyIGRlbCA9IF9jdXJyZW50SW5zdGFuY2UuZ2V0RWxlbWVudChlbCksXG4gICAgICAgICAgICAgICAgaWQgPSBfZ2V0SWQoZGVsKSxcbiAgICAgICAgICAgICAgICBzdGVwRnVuY3Rpb24gPSBqc1BsdW1iLmFuaW1FdmVudHMuc3RlcCxcbiAgICAgICAgICAgICAgICBjb21wbGV0ZUZ1bmN0aW9uID0ganNQbHVtYi5hbmltRXZlbnRzLmNvbXBsZXRlO1xuXG4gICAgICAgICAgICBvcHRpb25zW3N0ZXBGdW5jdGlvbl0gPSBfanUud3JhcChvcHRpb25zW3N0ZXBGdW5jdGlvbl0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfY3VycmVudEluc3RhbmNlLnJldmFsaWRhdGUoaWQpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIG9uQ29tcGxldGUgcmVwYWludHMsIGp1c3QgdG8gbWFrZSBzdXJlIGV2ZXJ5dGhpbmcgbG9va3MgZ29vZCBhdCB0aGUgZW5kIG9mIHRoZSBhbmltYXRpb24uXG4gICAgICAgICAgICBvcHRpb25zW2NvbXBsZXRlRnVuY3Rpb25dID0gX2p1LndyYXAob3B0aW9uc1tjb21wbGV0ZUZ1bmN0aW9uXSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF9jdXJyZW50SW5zdGFuY2UucmV2YWxpZGF0ZShpZCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgX2N1cnJlbnRJbnN0YW5jZS5kb0FuaW1hdGUoZGVsLCBwcm9wZXJ0aWVzLCBvcHRpb25zKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogY2hlY2tzIGZvciBhIGxpc3RlbmVyIGZvciB0aGUgZ2l2ZW4gY29uZGl0aW9uLCBleGVjdXRpbmcgaXQgaWYgZm91bmQsIHBhc3NpbmcgaW4gdGhlIGdpdmVuIHZhbHVlLlxuICAgICAgICAgKiBjb25kaXRpb24gbGlzdGVuZXJzIHdvdWxkIGhhdmUgYmVlbiBhdHRhY2hlZCB1c2luZyBcImJpbmRcIiAod2hpY2ggaXMsIHlvdSBjb3VsZCBhcmd1ZSwgbm93IG92ZXJsb2FkZWQsIHNpbmNlXG4gICAgICAgICAqIGZpcmluZyBjbGljayBldmVudHMgZXRjIGlzIGEgYml0IGRpZmZlcmVudCB0byB3aGF0IHRoaXMgZG9lcykuICBpIHRob3VnaHQgYWJvdXQgYWRkaW5nIGEgXCJiaW5kQ29uZGl0aW9uXCJcbiAgICAgICAgICogb3Igc29tZXRoaW5nLCBidXQgZGVjaWRlZCBhZ2FpbnN0IGl0LCBmb3IgdGhlIHNha2Ugb2Ygc2ltcGxpY2l0eS4ganNQbHVtYiB3aWxsIG5ldmVyIGZpcmUgb25lIG9mIHRoZXNlXG4gICAgICAgICAqIGNvbmRpdGlvbiBldmVudHMgYW55d2F5LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jaGVja0NvbmRpdGlvbiA9IGZ1bmN0aW9uIChjb25kaXRpb25OYW1lLCBhcmdzKSB7XG4gICAgICAgICAgICB2YXIgbCA9IF9jdXJyZW50SW5zdGFuY2UuZ2V0TGlzdGVuZXIoY29uZGl0aW9uTmFtZSksXG4gICAgICAgICAgICAgICAgciA9IHRydWU7XG5cbiAgICAgICAgICAgIGlmIChsICYmIGwubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBqID0gbC5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHIgPSByICYmIGxbaV0uYXBwbHkobFtpXSwgdmFsdWVzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBfanUubG9nKF9jdXJyZW50SW5zdGFuY2UsIFwiY2Fubm90IGNoZWNrIGNvbmRpdGlvbiBbXCIgKyBjb25kaXRpb25OYW1lICsgXCJdXCIgKyBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmNvbm5lY3QgPSBmdW5jdGlvbiAocGFyYW1zLCByZWZlcmVuY2VQYXJhbXMpIHtcbiAgICAgICAgICAgIC8vIHByZXBhcmUgYSBmaW5hbCBzZXQgb2YgcGFyYW1ldGVycyB0byBjcmVhdGUgY29ubmVjdGlvbiB3aXRoXG4gICAgICAgICAgICB2YXIgX3AgPSBfcHJlcGFyZUNvbm5lY3Rpb25QYXJhbXMocGFyYW1zLCByZWZlcmVuY2VQYXJhbXMpLCBqcGM7XG4gICAgICAgICAgICAvLyBUT0RPIHByb2JhYmx5IGEgbmljZXIgcmV0dXJuIHZhbHVlIGlmIHRoZSBjb25uZWN0aW9uIHdhcyBub3QgbWFkZS4gIF9wcmVwYXJlQ29ubmVjdGlvblBhcmFtc1xuICAgICAgICAgICAgLy8gd2lsbCByZXR1cm4gbnVsbCAoYW5kIGxvZyBzb21ldGhpbmcpIGlmIGVpdGhlciBlbmRwb2ludCB3YXMgZnVsbC4gIHdoYXQgd291bGQgYmUgbmljZXIgaXMgdG9cbiAgICAgICAgICAgIC8vIGNyZWF0ZSBhIGRlZGljYXRlZCAnZXJyb3InIG9iamVjdC5cbiAgICAgICAgICAgIGlmIChfcCkge1xuICAgICAgICAgICAgICAgIGlmIChfcC5zb3VyY2UgPT0gbnVsbCAmJiBfcC5zb3VyY2VFbmRwb2ludCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIF9qdS5sb2coXCJDYW5ub3QgZXN0YWJsaXNoIGNvbm5lY3Rpb24gLSBzb3VyY2UgZG9lcyBub3QgZXhpc3RcIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKF9wLnRhcmdldCA9PSBudWxsICYmIF9wLnRhcmdldEVuZHBvaW50ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgX2p1LmxvZyhcIkNhbm5vdCBlc3RhYmxpc2ggY29ubmVjdGlvbiAtIHRhcmdldCBkb2VzIG5vdCBleGlzdFwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfZW5zdXJlQ29udGFpbmVyKF9wLnNvdXJjZSk7XG4gICAgICAgICAgICAgICAgLy8gY3JlYXRlIHRoZSBjb25uZWN0aW9uLiAgaXQgaXMgbm90IHlldCByZWdpc3RlcmVkXG4gICAgICAgICAgICAgICAganBjID0gX25ld0Nvbm5lY3Rpb24oX3ApO1xuICAgICAgICAgICAgICAgIC8vIG5vdyBhZGQgaXQgdGhlIG1vZGVsLCBmaXJlIGFuIGV2ZW50LCBhbmQgcmVkcmF3XG4gICAgICAgICAgICAgICAgX2ZpbmFsaXNlQ29ubmVjdGlvbihqcGMsIF9wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBqcGM7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHN0VHlwZXMgPSBbXG4gICAgICAgICAgICB7IGVsOiBcInNvdXJjZVwiLCBlbElkOiBcInNvdXJjZUlkXCIsIGVwRGVmczogXCJzb3VyY2VFbmRwb2ludERlZmluaXRpb25zXCIgfSxcbiAgICAgICAgICAgIHsgZWw6IFwidGFyZ2V0XCIsIGVsSWQ6IFwidGFyZ2V0SWRcIiwgZXBEZWZzOiBcInRhcmdldEVuZHBvaW50RGVmaW5pdGlvbnNcIiB9XG4gICAgICAgIF07XG5cbiAgICAgICAgdmFyIF9zZXQgPSBmdW5jdGlvbiAoYywgZWwsIGlkeCwgZG9Ob3RSZXBhaW50KSB7XG4gICAgICAgICAgICB2YXIgZXAsIF9zdCA9IHN0VHlwZXNbaWR4XSwgY0lkID0gY1tfc3QuZWxJZF0sIGNFbCA9IGNbX3N0LmVsXSwgc2lkLCBzZXAsXG4gICAgICAgICAgICAgICAgb2xkRW5kcG9pbnQgPSBjLmVuZHBvaW50c1tpZHhdO1xuXG4gICAgICAgICAgICB2YXIgZXZ0UGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIGluZGV4OiBpZHgsXG4gICAgICAgICAgICAgICAgb3JpZ2luYWxTb3VyY2VJZDogaWR4ID09PSAwID8gY0lkIDogYy5zb3VyY2VJZCxcbiAgICAgICAgICAgICAgICBuZXdTb3VyY2VJZDogYy5zb3VyY2VJZCxcbiAgICAgICAgICAgICAgICBvcmlnaW5hbFRhcmdldElkOiBpZHggPT09IDEgPyBjSWQgOiBjLnRhcmdldElkLFxuICAgICAgICAgICAgICAgIG5ld1RhcmdldElkOiBjLnRhcmdldElkLFxuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb246IGNcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmIChlbC5jb25zdHJ1Y3RvciA9PT0ganNQbHVtYi5FbmRwb2ludCkge1xuICAgICAgICAgICAgICAgIGVwID0gZWw7XG4gICAgICAgICAgICAgICAgZXAuYWRkQ29ubmVjdGlvbihjKTtcbiAgICAgICAgICAgICAgICBlbCA9IGVwLmVsZW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzaWQgPSBfZ2V0SWQoZWwpO1xuICAgICAgICAgICAgICAgIHNlcCA9IHRoaXNbX3N0LmVwRGVmc11bc2lkXTtcblxuICAgICAgICAgICAgICAgIGlmIChzaWQgPT09IGNbX3N0LmVsSWRdKSB7XG4gICAgICAgICAgICAgICAgICAgIGVwID0gbnVsbDsgLy8gZG9udCBjaGFuZ2Ugc291cmNlL3RhcmdldCBpZiB0aGUgZWxlbWVudCBpcyBhbHJlYWR5IHRoZSBvbmUgZ2l2ZW4uXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNlcCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB0IGluIHNlcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzZXBbdF0uZW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVwID0gc2VwW3RdLmVuZHBvaW50ICE9IG51bGwgJiYgc2VwW3RdLmVuZHBvaW50Ll9qc1BsdW1iID8gc2VwW3RdLmVuZHBvaW50IDogdGhpcy5hZGRFbmRwb2ludChlbCwgc2VwW3RdLmRlZik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VwW3RdLnVuaXF1ZUVuZHBvaW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VwW3RdLmVuZHBvaW50ID0gZXA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlcC5hZGRDb25uZWN0aW9uKGMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlcCA9IGMubWFrZUVuZHBvaW50KGlkeCA9PT0gMCwgZWwsIHNpZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG9sZEVuZHBvaW50LmRldGFjaEZyb21Db25uZWN0aW9uKGMpO1xuICAgICAgICAgICAgICAgIGMuZW5kcG9pbnRzW2lkeF0gPSBlcDtcbiAgICAgICAgICAgICAgICBjW19zdC5lbF0gPSBlcC5lbGVtZW50O1xuICAgICAgICAgICAgICAgIGNbX3N0LmVsSWRdID0gZXAuZWxlbWVudElkO1xuICAgICAgICAgICAgICAgIGV2dFBhcmFtc1tpZHggPT09IDAgPyBcIm5ld1NvdXJjZUlkXCIgOiBcIm5ld1RhcmdldElkXCJdID0gZXAuZWxlbWVudElkO1xuXG4gICAgICAgICAgICAgICAgZmlyZU1vdmVFdmVudChldnRQYXJhbXMpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFkb05vdFJlcGFpbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgYy5yZXBhaW50KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBldnRQYXJhbXMuZWxlbWVudCA9IGVsO1xuICAgICAgICAgICAgcmV0dXJuIGV2dFBhcmFtcztcblxuICAgICAgICB9LmJpbmQodGhpcyk7XG5cbiAgICAgICAgdGhpcy5zZXRTb3VyY2UgPSBmdW5jdGlvbiAoY29ubmVjdGlvbiwgZWwsIGRvTm90UmVwYWludCkge1xuICAgICAgICAgICAgdmFyIHAgPSBfc2V0KGNvbm5lY3Rpb24sIGVsLCAwLCBkb05vdFJlcGFpbnQpO1xuICAgICAgICAgICAgdGhpcy5hbmNob3JNYW5hZ2VyLnNvdXJjZUNoYW5nZWQocC5vcmlnaW5hbFNvdXJjZUlkLCBwLm5ld1NvdXJjZUlkLCBjb25uZWN0aW9uLCBwLmVsKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zZXRUYXJnZXQgPSBmdW5jdGlvbiAoY29ubmVjdGlvbiwgZWwsIGRvTm90UmVwYWludCkge1xuICAgICAgICAgICAgdmFyIHAgPSBfc2V0KGNvbm5lY3Rpb24sIGVsLCAxLCBkb05vdFJlcGFpbnQpO1xuICAgICAgICAgICAgdGhpcy5hbmNob3JNYW5hZ2VyLnVwZGF0ZU90aGVyRW5kcG9pbnQocC5vcmlnaW5hbFNvdXJjZUlkLCBwLm9yaWdpbmFsVGFyZ2V0SWQsIHAubmV3VGFyZ2V0SWQsIGNvbm5lY3Rpb24pO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuZGVsZXRlRW5kcG9pbnQgPSBmdW5jdGlvbiAob2JqZWN0LCBkb250VXBkYXRlSG92ZXIsIGRlbGV0ZUF0dGFjaGVkT2JqZWN0cykge1xuICAgICAgICAgICAgdmFyIGVuZHBvaW50ID0gKHR5cGVvZiBvYmplY3QgPT09IFwic3RyaW5nXCIpID8gZW5kcG9pbnRzQnlVVUlEW29iamVjdF0gOiBvYmplY3Q7XG4gICAgICAgICAgICBpZiAoZW5kcG9pbnQpIHtcbiAgICAgICAgICAgICAgICBfY3VycmVudEluc3RhbmNlLmRlbGV0ZU9iamVjdCh7IGVuZHBvaW50OiBlbmRwb2ludCwgZG9udFVwZGF0ZUhvdmVyOiBkb250VXBkYXRlSG92ZXIsIGRlbGV0ZUF0dGFjaGVkT2JqZWN0czpkZWxldGVBdHRhY2hlZE9iamVjdHMgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX2N1cnJlbnRJbnN0YW5jZTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmRlbGV0ZUV2ZXJ5RW5kcG9pbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2lzID0gX2N1cnJlbnRJbnN0YW5jZS5zZXRTdXNwZW5kRHJhd2luZyh0cnVlKTtcbiAgICAgICAgICAgIGZvciAodmFyIGlkIGluIGVuZHBvaW50c0J5RWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHZhciBlbmRwb2ludHMgPSBlbmRwb2ludHNCeUVsZW1lbnRbaWRdO1xuICAgICAgICAgICAgICAgIGlmIChlbmRwb2ludHMgJiYgZW5kcG9pbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaiA9IGVuZHBvaW50cy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jdXJyZW50SW5zdGFuY2UuZGVsZXRlRW5kcG9pbnQoZW5kcG9pbnRzW2ldLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVuZHBvaW50c0J5RWxlbWVudCA9IHt9O1xuICAgICAgICAgICAgbWFuYWdlZEVsZW1lbnRzID0ge307XG4gICAgICAgICAgICBlbmRwb2ludHNCeVVVSUQgPSB7fTtcbiAgICAgICAgICAgIG9mZnNldHMgPSB7fTtcbiAgICAgICAgICAgIG9mZnNldFRpbWVzdGFtcHMgPSB7fTtcbiAgICAgICAgICAgIF9jdXJyZW50SW5zdGFuY2UuYW5jaG9yTWFuYWdlci5yZXNldCgpO1xuICAgICAgICAgICAgdmFyIGRtID0gX2N1cnJlbnRJbnN0YW5jZS5nZXREcmFnTWFuYWdlcigpO1xuICAgICAgICAgICAgaWYgKGRtKSB7XG4gICAgICAgICAgICAgICAgZG0ucmVzZXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghX2lzKSB7XG4gICAgICAgICAgICAgICAgX2N1cnJlbnRJbnN0YW5jZS5zZXRTdXNwZW5kRHJhd2luZyhmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX2N1cnJlbnRJbnN0YW5jZTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgZmlyZURldGFjaEV2ZW50ID0gZnVuY3Rpb24gKGpwYywgZG9GaXJlRXZlbnQsIG9yaWdpbmFsRXZlbnQpIHtcbiAgICAgICAgICAgIC8vIG1heSBoYXZlIGJlZW4gZ2l2ZW4gYSBjb25uZWN0aW9uLCBvciBpbiBzcGVjaWFsIGNhc2VzLCBhbiBvYmplY3RcbiAgICAgICAgICAgIHZhciBjb25uVHlwZSA9IF9jdXJyZW50SW5zdGFuY2UuRGVmYXVsdHMuQ29ubmVjdGlvblR5cGUgfHwgX2N1cnJlbnRJbnN0YW5jZS5nZXREZWZhdWx0Q29ubmVjdGlvblR5cGUoKSxcbiAgICAgICAgICAgICAgICBhcmdJc0Nvbm5lY3Rpb24gPSBqcGMuY29uc3RydWN0b3IgPT09IGNvbm5UeXBlLFxuICAgICAgICAgICAgICAgIHBhcmFtcyA9IGFyZ0lzQ29ubmVjdGlvbiA/IHtcbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbjoganBjLFxuICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IGpwYy5zb3VyY2UsIHRhcmdldDoganBjLnRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgc291cmNlSWQ6IGpwYy5zb3VyY2VJZCwgdGFyZ2V0SWQ6IGpwYy50YXJnZXRJZCxcbiAgICAgICAgICAgICAgICAgICAgc291cmNlRW5kcG9pbnQ6IGpwYy5lbmRwb2ludHNbMF0sIHRhcmdldEVuZHBvaW50OiBqcGMuZW5kcG9pbnRzWzFdXG4gICAgICAgICAgICAgICAgfSA6IGpwYztcblxuICAgICAgICAgICAgaWYgKGRvRmlyZUV2ZW50KSB7XG4gICAgICAgICAgICAgICAgX2N1cnJlbnRJbnN0YW5jZS5maXJlKFwiY29ubmVjdGlvbkRldGFjaGVkXCIsIHBhcmFtcywgb3JpZ2luYWxFdmVudCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGFsd2F5cyBmaXJlIHRoaXMuIHVzZWQgYnkgaW50ZXJuYWwganNwbHVtYiBzdHVmZi5cbiAgICAgICAgICAgIF9jdXJyZW50SW5zdGFuY2UuZmlyZShcImludGVybmFsLmNvbm5lY3Rpb25EZXRhY2hlZFwiLCBwYXJhbXMsIG9yaWdpbmFsRXZlbnQpO1xuXG4gICAgICAgICAgICBfY3VycmVudEluc3RhbmNlLmFuY2hvck1hbmFnZXIuY29ubmVjdGlvbkRldGFjaGVkKHBhcmFtcyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGZpcmVNb3ZlRXZlbnQgPSBfY3VycmVudEluc3RhbmNlLmZpcmVNb3ZlRXZlbnQgPSBmdW5jdGlvbiAocGFyYW1zLCBldnQpIHtcbiAgICAgICAgICAgIF9jdXJyZW50SW5zdGFuY2UuZmlyZShcImNvbm5lY3Rpb25Nb3ZlZFwiLCBwYXJhbXMsIGV2dCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy51bnJlZ2lzdGVyRW5kcG9pbnQgPSBmdW5jdGlvbiAoZW5kcG9pbnQpIHtcbiAgICAgICAgICAgIGlmIChlbmRwb2ludC5fanNQbHVtYi51dWlkKSB7XG4gICAgICAgICAgICAgICAgZW5kcG9pbnRzQnlVVUlEW2VuZHBvaW50Ll9qc1BsdW1iLnV1aWRdID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9jdXJyZW50SW5zdGFuY2UuYW5jaG9yTWFuYWdlci5kZWxldGVFbmRwb2ludChlbmRwb2ludCk7XG4gICAgICAgICAgICAvLyBUT0RPIGF0IGxlYXN0IHJlcGxhY2UgdGhpcyB3aXRoIGEgcmVtb3ZlV2l0aEZ1bmN0aW9uIGNhbGwuXG4gICAgICAgICAgICBmb3IgKHZhciBlIGluIGVuZHBvaW50c0J5RWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHZhciBlbmRwb2ludHMgPSBlbmRwb2ludHNCeUVsZW1lbnRbZV07XG4gICAgICAgICAgICAgICAgaWYgKGVuZHBvaW50cykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3RW5kcG9pbnRzID0gW107XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBqID0gZW5kcG9pbnRzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVuZHBvaW50c1tpXSAhPT0gZW5kcG9pbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdFbmRwb2ludHMucHVzaChlbmRwb2ludHNbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZW5kcG9pbnRzQnlFbGVtZW50W2VdID0gbmV3RW5kcG9pbnRzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZW5kcG9pbnRzQnlFbGVtZW50W2VdLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGVuZHBvaW50c0J5RWxlbWVudFtlXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIElTX0RFVEFDSF9BTExPV0VEID0gXCJpc0RldGFjaEFsbG93ZWRcIjtcbiAgICAgICAgdmFyIEJFRk9SRV9ERVRBQ0ggPSBcImJlZm9yZURldGFjaFwiO1xuICAgICAgICB2YXIgQ0hFQ0tfQ09ORElUSU9OID0gXCJjaGVja0NvbmRpdGlvblwiO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWxldGVzIGEgQ29ubmVjdGlvbi5cbiAgICAgICAgICogQG1ldGhvZCBkZWxldGVDb25uZWN0aW9uXG4gICAgICAgICAqIEBwYXJhbSBjb25uZWN0aW9uIENvbm5lY3Rpb24gdG8gZGVsZXRlXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyYW1zXSBPcHRpb25hbCBkZWxldGUgcGFyYW1ldGVyc1xuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtwYXJhbXMuZG9Ob3RGaXJlRXZlbnQ9ZmFsc2VdIElmIHRydWUsIGEgY29ubmVjdGlvbiBkZXRhY2hlZCBldmVudCB3aWxsIG5vdCBiZSBmaXJlZC4gT3RoZXJ3aXNlIG9uZSB3aWxsLlxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtwYXJhbXMuZm9yY2U9ZmFsc2VdIElmIHRydWUsIHRoZSBjb25uZWN0aW9uIHdpbGwgYmUgZGVsZXRlZCBldmVuIGlmIGEgYmVmb3JlRGV0YWNoIGludGVyY2VwdG9yIHRyaWVzIHRvIHN0b3AgdGhlIGRlbGV0aW9uLlxuICAgICAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgY29ubmVjdGlvbiB3YXMgZGVsZXRlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kZWxldGVDb25uZWN0aW9uID0gZnVuY3Rpb24oY29ubmVjdGlvbiwgcGFyYW1zKSB7XG5cbiAgICAgICAgICAgIGlmIChjb25uZWN0aW9uICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG5cbiAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmZvcmNlIHx8IF9qdS5mdW5jdGlvbkNoYWluKHRydWUsIGZhbHNlLCBbXG4gICAgICAgICAgICAgICAgICAgIFsgY29ubmVjdGlvbi5lbmRwb2ludHNbMF0sIElTX0RFVEFDSF9BTExPV0VELCBbIGNvbm5lY3Rpb24gXSBdLFxuICAgICAgICAgICAgICAgICAgICBbIGNvbm5lY3Rpb24uZW5kcG9pbnRzWzFdLCBJU19ERVRBQ0hfQUxMT1dFRCwgWyBjb25uZWN0aW9uIF0gXSxcbiAgICAgICAgICAgICAgICAgICAgWyBjb25uZWN0aW9uLCBJU19ERVRBQ0hfQUxMT1dFRCwgWyBjb25uZWN0aW9uIF0gXSxcbiAgICAgICAgICAgICAgICAgICAgWyBfY3VycmVudEluc3RhbmNlLCBDSEVDS19DT05ESVRJT04sIFsgQkVGT1JFX0RFVEFDSCwgY29ubmVjdGlvbiBdIF1cbiAgICAgICAgICAgICAgICBdKSkge1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb24uc2V0SG92ZXIoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBmaXJlRGV0YWNoRXZlbnQoY29ubmVjdGlvbiwgIWNvbm5lY3Rpb24ucGVuZGluZyAmJiBwYXJhbXMuZmlyZUV2ZW50ICE9PSBmYWxzZSwgcGFyYW1zLm9yaWdpbmFsRXZlbnQpO1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb24uZW5kcG9pbnRzWzBdLmRldGFjaEZyb21Db25uZWN0aW9uKGNvbm5lY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uLmVuZHBvaW50c1sxXS5kZXRhY2hGcm9tQ29ubmVjdGlvbihjb25uZWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgX2p1LnJlbW92ZVdpdGhGdW5jdGlvbihjb25uZWN0aW9ucywgZnVuY3Rpb24gKF9jKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29ubmVjdGlvbi5pZCA9PT0gX2MuaWQ7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb24uY2xlYW51cCgpO1xuICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdmUgYWxsIENvbm5lY3Rpb25zIGZyb20gYWxsIGVsZW1lbnRzLCBidXQgbGVhdmVzIEVuZHBvaW50cyBpbiBwbGFjZSAoKHVubGVzcyBhIGNvbm5lY3Rpb24gaXMgc2V0IHRvIGF1dG8gZGVsZXRlIGl0cyBFbmRwb2ludHMpLlxuICAgICAgICAgKiBAbWV0aG9kIGRlbGV0ZUV2ZXJ5Q29ubmVjdGlvblxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtc10gb3B0aW9uYWwgcGFyYW1zIG9iamVjdCBmb3IgdGhlIGNhbGxcbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBbcGFyYW1zLmZpcmVFdmVudD10cnVlXSBXaGV0aGVyIG9yIG5vdCB0byBmaXJlIGRldGFjaCBldmVudHNcbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBbcGFyYW1zLmZvcmNlRGV0YWNoPWZhbHNlXSBJZiB0cnVlLCB0aGlzIGNhbGwgd2lsbCBpZ25vcmUgYW55IGBiZWZvcmVEZXRhY2hgIGludGVyY2VwdG9ycy5cbiAgICAgICAgICogQHJldHVybnMge051bWJlcn0gVGhlIG51bWJlciBvZiBjb25uZWN0aW9ucyB0aGF0IHdlcmUgZGVsZXRlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGVsZXRlRXZlcnlDb25uZWN0aW9uID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICAgICAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICAgICAgICAgICAgdmFyIGNvdW50ID0gY29ubmVjdGlvbnMubGVuZ3RoLCBkZWxldGVkQ291bnQgPSAwO1xuICAgICAgICAgICAgX2N1cnJlbnRJbnN0YW5jZS5iYXRjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZWRDb3VudCArPSBfY3VycmVudEluc3RhbmNlLmRlbGV0ZUNvbm5lY3Rpb24oY29ubmVjdGlvbnNbMF0sIHBhcmFtcykgPyAxIDogMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBkZWxldGVkQ291bnQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW92ZXMgYWxsIGFuIGVsZW1lbnQncyBDb25uZWN0aW9ucy5cbiAgICAgICAgICogQG1ldGhvZCBkZWxldGVDb25uZWN0aW9uc0ZvckVsZW1lbnRcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGVsIEVpdGhlciB0aGUgaWQgb2YgdGhlIGVsZW1lbnQsIG9yIGEgc2VsZWN0b3IgZm9yIHRoZSBlbGVtZW50LlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtc10gT3B0aW9uYWwgcGFyYW1ldGVycy5cbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBbcGFyYW1zLmZpcmVFdmVudD10cnVlXSBXaGV0aGVyIG9yIG5vdCB0byBmaXJlIHRoZSBkZXRhY2ggZXZlbnQuXG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3BhcmFtcy5mb3JjZURldGFjaD1mYWxzZV0gSWYgdHJ1ZSwgdGhpcyBjYWxsIHdpbGwgaWdub3JlIGFueSBgYmVmb3JlRGV0YWNoYCBpbnRlcmNlcHRvcnMuXG4gICAgICAgICAqIEByZXR1cm4ge2pzUGx1bWJJbnN0YW5jZX0gVGhlIGN1cnJlbnQganNQbHVtYiBpbnN0YW5jZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGVsZXRlQ29ubmVjdGlvbnNGb3JFbGVtZW50ID0gZnVuY3Rpb24gKGVsLCBwYXJhbXMpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgICAgICAgICAgIGVsID0gX2N1cnJlbnRJbnN0YW5jZS5nZXRFbGVtZW50KGVsKTtcbiAgICAgICAgICAgIHZhciBpZCA9IF9nZXRJZChlbCksIGVuZHBvaW50cyA9IGVuZHBvaW50c0J5RWxlbWVudFtpZF07XG4gICAgICAgICAgICBpZiAoZW5kcG9pbnRzICYmIGVuZHBvaW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaiA9IGVuZHBvaW50cy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZW5kcG9pbnRzW2ldLmRlbGV0ZUV2ZXJ5Q29ubmVjdGlvbihwYXJhbXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfY3VycmVudEluc3RhbmNlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vLyBub3QgcHVibGljLiAgYnV0IG9mIGNvdXJzZSBpdHMgZXhwb3NlZC4gaG93IHRvIGNoYW5nZSB0aGlzLlxuICAgICAgICB0aGlzLmRlbGV0ZU9iamVjdCA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgICAgICAgICAgICAgIGVuZHBvaW50czoge30sXG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25zOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgZW5kcG9pbnRDb3VudDogMCxcbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbkNvdW50OiAwXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBkZWxldGVBdHRhY2hlZE9iamVjdHMgPSBwYXJhbXMuZGVsZXRlQXR0YWNoZWRPYmplY3RzICE9PSBmYWxzZTtcblxuICAgICAgICAgICAgdmFyIHVucmF2ZWxDb25uZWN0aW9uID0gZnVuY3Rpb24gKGNvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBpZiAoY29ubmVjdGlvbiAhPSBudWxsICYmIHJlc3VsdC5jb25uZWN0aW9uc1tjb25uZWN0aW9uLmlkXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcGFyYW1zLmRvbnRVcGRhdGVIb3ZlciAmJiBjb25uZWN0aW9uLl9qc1BsdW1iICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb24uc2V0SG92ZXIoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5jb25uZWN0aW9uc1tjb25uZWN0aW9uLmlkXSA9IGNvbm5lY3Rpb247XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5jb25uZWN0aW9uQ291bnQrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIHVucmF2ZWxFbmRwb2ludCA9IGZ1bmN0aW9uIChlbmRwb2ludCkge1xuICAgICAgICAgICAgICAgIGlmIChlbmRwb2ludCAhPSBudWxsICYmIHJlc3VsdC5lbmRwb2ludHNbZW5kcG9pbnQuaWRdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXJhbXMuZG9udFVwZGF0ZUhvdmVyICYmIGVuZHBvaW50Ll9qc1BsdW1iICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZHBvaW50LnNldEhvdmVyKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXN1bHQuZW5kcG9pbnRzW2VuZHBvaW50LmlkXSA9IGVuZHBvaW50O1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuZW5kcG9pbnRDb3VudCsrO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChkZWxldGVBdHRhY2hlZE9iamVjdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZW5kcG9pbnQuY29ubmVjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYyA9IGVuZHBvaW50LmNvbm5lY3Rpb25zW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVucmF2ZWxDb25uZWN0aW9uKGMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKHBhcmFtcy5jb25uZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgdW5yYXZlbENvbm5lY3Rpb24ocGFyYW1zLmNvbm5lY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdW5yYXZlbEVuZHBvaW50KHBhcmFtcy5lbmRwb2ludCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGxvb3AgdGhyb3VnaCBjb25uZWN0aW9uc1xuICAgICAgICAgICAgZm9yICh2YXIgaSBpbiByZXN1bHQuY29ubmVjdGlvbnMpIHtcbiAgICAgICAgICAgICAgICB2YXIgYyA9IHJlc3VsdC5jb25uZWN0aW9uc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoYy5fanNQbHVtYikge1xuICAgICAgICAgICAgICAgICAgICBfanUucmVtb3ZlV2l0aEZ1bmN0aW9uKGNvbm5lY3Rpb25zLCBmdW5jdGlvbiAoX2MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjLmlkID09PSBfYy5pZDtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgZmlyZURldGFjaEV2ZW50KGMsIHBhcmFtcy5maXJlRXZlbnQgPT09IGZhbHNlID8gZmFsc2UgOiAhYy5wZW5kaW5nLCBwYXJhbXMub3JpZ2luYWxFdmVudCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkb05vdENsZWFudXAgPSBwYXJhbXMuZGVsZXRlQXR0YWNoZWRPYmplY3RzID09IG51bGwgPyBudWxsIDogIXBhcmFtcy5kZWxldGVBdHRhY2hlZE9iamVjdHM7XG5cbiAgICAgICAgICAgICAgICAgICAgYy5lbmRwb2ludHNbMF0uZGV0YWNoRnJvbUNvbm5lY3Rpb24oYywgbnVsbCwgZG9Ob3RDbGVhbnVwKTtcbiAgICAgICAgICAgICAgICAgICAgYy5lbmRwb2ludHNbMV0uZGV0YWNoRnJvbUNvbm5lY3Rpb24oYywgbnVsbCwgZG9Ob3RDbGVhbnVwKTtcblxuICAgICAgICAgICAgICAgICAgICBjLmNsZWFudXAodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGMuZGVzdHJveSh0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGxvb3AgdGhyb3VnaCBlbmRwb2ludHNcbiAgICAgICAgICAgIGZvciAodmFyIGogaW4gcmVzdWx0LmVuZHBvaW50cykge1xuICAgICAgICAgICAgICAgIHZhciBlID0gcmVzdWx0LmVuZHBvaW50c1tqXTtcbiAgICAgICAgICAgICAgICBpZiAoZS5fanNQbHVtYikge1xuICAgICAgICAgICAgICAgICAgICBfY3VycmVudEluc3RhbmNlLnVucmVnaXN0ZXJFbmRwb2ludChlKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gRklSRSBzb21lIGVuZHBvaW50IGRlbGV0ZWQgZXZlbnQ/XG4gICAgICAgICAgICAgICAgICAgIGUuY2xlYW51cCh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgZS5kZXN0cm95KHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmRyYWdnYWJsZSA9IGZ1bmN0aW9uIChlbCwgb3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIGluZm87XG4gICAgICAgICAgICBfZWFjaChmdW5jdGlvbihfZWwpIHtcbiAgICAgICAgICAgICAgICAgaW5mbyA9IF9pbmZvKF9lbCk7XG4gICAgICAgICAgICAgICAgaWYgKGluZm8uZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgX2luaXREcmFnZ2FibGVJZk5lY2Vzc2FyeShpbmZvLmVsLCB0cnVlLCBvcHRpb25zLCBpbmZvLmlkLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBlbCk7XG4gICAgICAgICAgICByZXR1cm4gX2N1cnJlbnRJbnN0YW5jZTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmRyb3BwYWJsZSA9IGZ1bmN0aW9uKGVsLCBvcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgaW5mbztcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICAgICAgb3B0aW9ucy5hbGxvd0xvb3BiYWNrID0gZmFsc2U7XG4gICAgICAgICAgICBfZWFjaChmdW5jdGlvbihfZWwpIHtcbiAgICAgICAgICAgICAgICBpbmZvID0gX2luZm8oX2VsKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5mby5lbCkge1xuICAgICAgICAgICAgICAgICAgICBfY3VycmVudEluc3RhbmNlLmluaXREcm9wcGFibGUoaW5mby5lbCwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgZWwpO1xuICAgICAgICAgICAgcmV0dXJuIF9jdXJyZW50SW5zdGFuY2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gaGVscGVycyBmb3Igc2VsZWN0L3NlbGVjdEVuZHBvaW50c1xuICAgICAgICB2YXIgX3NldE9wZXJhdGlvbiA9IGZ1bmN0aW9uIChsaXN0LCBmdW5jLCBhcmdzLCBzZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBqID0gbGlzdC5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdFtpXVtmdW5jXS5hcHBseShsaXN0W2ldLCBhcmdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGVjdG9yKGxpc3QpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9nZXRPcGVyYXRpb24gPSBmdW5jdGlvbiAobGlzdCwgZnVuYywgYXJncykge1xuICAgICAgICAgICAgICAgIHZhciBvdXQgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaiA9IGxpc3QubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dC5wdXNoKFsgbGlzdFtpXVtmdW5jXS5hcHBseShsaXN0W2ldLCBhcmdzKSwgbGlzdFtpXSBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXR0ZXIgPSBmdW5jdGlvbiAobGlzdCwgZnVuYywgc2VsZWN0b3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3NldE9wZXJhdGlvbihsaXN0LCBmdW5jLCBhcmd1bWVudHMsIHNlbGVjdG9yKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldHRlciA9IGZ1bmN0aW9uIChsaXN0LCBmdW5jKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9nZXRPcGVyYXRpb24obGlzdCwgZnVuYywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHByZXBhcmVMaXN0ID0gZnVuY3Rpb24gKGlucHV0LCBkb05vdEdldElkcykge1xuICAgICAgICAgICAgICAgIHZhciByID0gW107XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQgPT09IFwiKlwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgci5wdXNoKGlucHV0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb05vdEdldElkcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIgPSBpbnB1dDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGogPSBpbnB1dC5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIucHVzaChfaW5mbyhpbnB1dFtpXSkuaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByLnB1c2goX2luZm8oaW5wdXQpLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZmlsdGVyTGlzdCA9IGZ1bmN0aW9uIChsaXN0LCB2YWx1ZSwgbWlzc2luZ0lzRmFsc2UpIHtcbiAgICAgICAgICAgICAgICBpZiAobGlzdCA9PT0gXCIqXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBsaXN0Lmxlbmd0aCA+IDAgPyBsaXN0LmluZGV4T2YodmFsdWUpICE9PSAtMSA6ICFtaXNzaW5nSXNGYWxzZTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgLy8gZ2V0IHNvbWUgY29ubmVjdGlvbnMsIHNwZWNpZnlpbmcgc291cmNlL3RhcmdldC9zY29wZVxuICAgICAgICB0aGlzLmdldENvbm5lY3Rpb25zID0gZnVuY3Rpb24gKG9wdGlvbnMsIGZsYXQpIHtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucykge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5jb25zdHJ1Y3RvciA9PT0gU3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IHsgXCJzY29wZVwiOiBvcHRpb25zIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc2NvcGUgPSBvcHRpb25zLnNjb3BlIHx8IF9jdXJyZW50SW5zdGFuY2UuZ2V0RGVmYXVsdFNjb3BlKCksXG4gICAgICAgICAgICAgICAgc2NvcGVzID0gcHJlcGFyZUxpc3Qoc2NvcGUsIHRydWUpLFxuICAgICAgICAgICAgICAgIHNvdXJjZXMgPSBwcmVwYXJlTGlzdChvcHRpb25zLnNvdXJjZSksXG4gICAgICAgICAgICAgICAgdGFyZ2V0cyA9IHByZXBhcmVMaXN0KG9wdGlvbnMudGFyZ2V0KSxcbiAgICAgICAgICAgICAgICByZXN1bHRzID0gKCFmbGF0ICYmIHNjb3Blcy5sZW5ndGggPiAxKSA/IHt9IDogW10sXG4gICAgICAgICAgICAgICAgX2FkZE9uZSA9IGZ1bmN0aW9uIChzY29wZSwgb2JqKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZmxhdCAmJiBzY29wZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNzID0gcmVzdWx0c1tzY29wZV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3MgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNzID0gcmVzdWx0c1tzY29wZV0gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHNzLnB1c2gob2JqKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChvYmopO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGpqID0gY29ubmVjdGlvbnMubGVuZ3RoOyBqIDwgamo7IGorKykge1xuICAgICAgICAgICAgICAgIHZhciBjID0gY29ubmVjdGlvbnNbal0sXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZUlkID0gYy5wcm94aWVzICYmIGMucHJveGllc1swXSA/IGMucHJveGllc1swXS5vcmlnaW5hbEVwLmVsZW1lbnRJZCA6IGMuc291cmNlSWQsXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldElkID0gYy5wcm94aWVzICYmIGMucHJveGllc1sxXSA/IGMucHJveGllc1sxXS5vcmlnaW5hbEVwLmVsZW1lbnRJZCA6IGMudGFyZ2V0SWQ7XG5cbiAgICAgICAgICAgICAgICBpZiAoZmlsdGVyTGlzdChzY29wZXMsIGMuc2NvcGUpICYmIGZpbHRlckxpc3Qoc291cmNlcywgc291cmNlSWQpICYmIGZpbHRlckxpc3QodGFyZ2V0cywgdGFyZ2V0SWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIF9hZGRPbmUoYy5zY29wZSwgYyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgX2N1cnJ5RWFjaCA9IGZ1bmN0aW9uIChsaXN0LCBleGVjdXRvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZikge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBsaXN0Lmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGYobGlzdFtpXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV4ZWN1dG9yKGxpc3QpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2N1cnJ5R2V0ID0gZnVuY3Rpb24gKGxpc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGlkeCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGlzdFtpZHhdO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIHZhciBfbWFrZUNvbW1vblNlbGVjdEhhbmRsZXIgPSBmdW5jdGlvbiAobGlzdCwgZXhlY3V0b3IpIHtcbiAgICAgICAgICAgIHZhciBvdXQgPSB7XG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aDogbGlzdC5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgIGVhY2g6IF9jdXJyeUVhY2gobGlzdCwgZXhlY3V0b3IpLFxuICAgICAgICAgICAgICAgICAgICBnZXQ6IF9jdXJyeUdldChsaXN0KVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0dGVycyA9IFtcInNldEhvdmVyXCIsIFwicmVtb3ZlQWxsT3ZlcmxheXNcIiwgXCJzZXRMYWJlbFwiLCBcImFkZENsYXNzXCIsIFwiYWRkT3ZlcmxheVwiLCBcInJlbW92ZU92ZXJsYXlcIixcbiAgICAgICAgICAgICAgICAgICAgXCJyZW1vdmVPdmVybGF5c1wiLCBcInNob3dPdmVybGF5XCIsIFwiaGlkZU92ZXJsYXlcIiwgXCJzaG93T3ZlcmxheXNcIiwgXCJoaWRlT3ZlcmxheXNcIiwgXCJzZXRQYWludFN0eWxlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwic2V0SG92ZXJQYWludFN0eWxlXCIsIFwic2V0U3VzcGVuZEV2ZW50c1wiLCBcInNldFBhcmFtZXRlclwiLCBcInNldFBhcmFtZXRlcnNcIiwgXCJzZXRWaXNpYmxlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwicmVwYWludFwiLCBcImFkZFR5cGVcIiwgXCJ0b2dnbGVUeXBlXCIsIFwicmVtb3ZlVHlwZVwiLCBcInJlbW92ZUNsYXNzXCIsIFwic2V0VHlwZVwiLCBcImJpbmRcIiwgXCJ1bmJpbmRcIiBdLFxuXG4gICAgICAgICAgICAgICAgZ2V0dGVycyA9IFtcImdldExhYmVsXCIsIFwiZ2V0T3ZlcmxheVwiLCBcImlzSG92ZXJcIiwgXCJnZXRQYXJhbWV0ZXJcIiwgXCJnZXRQYXJhbWV0ZXJzXCIsIFwiZ2V0UGFpbnRTdHlsZVwiLFxuICAgICAgICAgICAgICAgICAgICBcImdldEhvdmVyUGFpbnRTdHlsZVwiLCBcImlzVmlzaWJsZVwiLCBcImhhc1R5cGVcIiwgXCJnZXRUeXBlXCIsIFwiaXNTdXNwZW5kRXZlbnRzXCIgXSxcbiAgICAgICAgICAgICAgICBpLCBpaTtcblxuICAgICAgICAgICAgZm9yIChpID0gMCwgaWkgPSBzZXR0ZXJzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgICAgICBvdXRbc2V0dGVyc1tpXV0gPSBzZXR0ZXIobGlzdCwgc2V0dGVyc1tpXSwgZXhlY3V0b3IpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBpaSA9IGdldHRlcnMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgICAgIG91dFtnZXR0ZXJzW2ldXSA9IGdldHRlcihsaXN0LCBnZXR0ZXJzW2ldKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgX21ha2VDb25uZWN0aW9uU2VsZWN0SGFuZGxlciA9IGZ1bmN0aW9uIChsaXN0KSB7XG4gICAgICAgICAgICB2YXIgY29tbW9uID0gX21ha2VDb21tb25TZWxlY3RIYW5kbGVyKGxpc3QsIF9tYWtlQ29ubmVjdGlvblNlbGVjdEhhbmRsZXIpO1xuICAgICAgICAgICAgcmV0dXJuIGpzUGx1bWIuZXh0ZW5kKGNvbW1vbiwge1xuICAgICAgICAgICAgICAgIC8vIHNldHRlcnNcbiAgICAgICAgICAgICAgICBzZXREZXRhY2hhYmxlOiBzZXR0ZXIobGlzdCwgXCJzZXREZXRhY2hhYmxlXCIsIF9tYWtlQ29ubmVjdGlvblNlbGVjdEhhbmRsZXIpLFxuICAgICAgICAgICAgICAgIHNldFJlYXR0YWNoOiBzZXR0ZXIobGlzdCwgXCJzZXRSZWF0dGFjaFwiLCBfbWFrZUNvbm5lY3Rpb25TZWxlY3RIYW5kbGVyKSxcbiAgICAgICAgICAgICAgICBzZXRDb25uZWN0b3I6IHNldHRlcihsaXN0LCBcInNldENvbm5lY3RvclwiLCBfbWFrZUNvbm5lY3Rpb25TZWxlY3RIYW5kbGVyKSxcbiAgICAgICAgICAgICAgICBkZWxldGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gbGlzdC5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfY3VycmVudEluc3RhbmNlLmRlbGV0ZUNvbm5lY3Rpb24obGlzdFtpXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC8vIGdldHRlcnNcbiAgICAgICAgICAgICAgICBpc0RldGFjaGFibGU6IGdldHRlcihsaXN0LCBcImlzRGV0YWNoYWJsZVwiKSxcbiAgICAgICAgICAgICAgICBpc1JlYXR0YWNoOiBnZXR0ZXIobGlzdCwgXCJpc1JlYXR0YWNoXCIpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgX21ha2VFbmRwb2ludFNlbGVjdEhhbmRsZXIgPSBmdW5jdGlvbiAobGlzdCkge1xuICAgICAgICAgICAgdmFyIGNvbW1vbiA9IF9tYWtlQ29tbW9uU2VsZWN0SGFuZGxlcihsaXN0LCBfbWFrZUVuZHBvaW50U2VsZWN0SGFuZGxlcik7XG4gICAgICAgICAgICByZXR1cm4ganNQbHVtYi5leHRlbmQoY29tbW9uLCB7XG4gICAgICAgICAgICAgICAgc2V0RW5hYmxlZDogc2V0dGVyKGxpc3QsIFwic2V0RW5hYmxlZFwiLCBfbWFrZUVuZHBvaW50U2VsZWN0SGFuZGxlciksXG4gICAgICAgICAgICAgICAgc2V0QW5jaG9yOiBzZXR0ZXIobGlzdCwgXCJzZXRBbmNob3JcIiwgX21ha2VFbmRwb2ludFNlbGVjdEhhbmRsZXIpLFxuICAgICAgICAgICAgICAgIGlzRW5hYmxlZDogZ2V0dGVyKGxpc3QsIFwiaXNFbmFibGVkXCIpLFxuICAgICAgICAgICAgICAgIGRlbGV0ZUV2ZXJ5Q29ubmVjdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBsaXN0Lmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RbaV0uZGVsZXRlRXZlcnlDb25uZWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwiZGVsZXRlXCI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gbGlzdC5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfY3VycmVudEluc3RhbmNlLmRlbGV0ZUVuZHBvaW50KGxpc3RbaV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5zZWxlY3QgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG4gICAgICAgICAgICBwYXJhbXMuc2NvcGUgPSBwYXJhbXMuc2NvcGUgfHwgXCIqXCI7XG4gICAgICAgICAgICByZXR1cm4gX21ha2VDb25uZWN0aW9uU2VsZWN0SGFuZGxlcihwYXJhbXMuY29ubmVjdGlvbnMgfHwgX2N1cnJlbnRJbnN0YW5jZS5nZXRDb25uZWN0aW9ucyhwYXJhbXMsIHRydWUpKTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLnNlbGVjdEVuZHBvaW50cyA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgICAgICAgICAgIHBhcmFtcy5zY29wZSA9IHBhcmFtcy5zY29wZSB8fCBcIipcIjtcbiAgICAgICAgICAgIHZhciBub0VsZW1lbnRGaWx0ZXJzID0gIXBhcmFtcy5lbGVtZW50ICYmICFwYXJhbXMuc291cmNlICYmICFwYXJhbXMudGFyZ2V0LFxuICAgICAgICAgICAgICAgIGVsZW1lbnRzID0gbm9FbGVtZW50RmlsdGVycyA/IFwiKlwiIDogcHJlcGFyZUxpc3QocGFyYW1zLmVsZW1lbnQpLFxuICAgICAgICAgICAgICAgIHNvdXJjZXMgPSBub0VsZW1lbnRGaWx0ZXJzID8gXCIqXCIgOiBwcmVwYXJlTGlzdChwYXJhbXMuc291cmNlKSxcbiAgICAgICAgICAgICAgICB0YXJnZXRzID0gbm9FbGVtZW50RmlsdGVycyA/IFwiKlwiIDogcHJlcGFyZUxpc3QocGFyYW1zLnRhcmdldCksXG4gICAgICAgICAgICAgICAgc2NvcGVzID0gcHJlcGFyZUxpc3QocGFyYW1zLnNjb3BlLCB0cnVlKTtcblxuICAgICAgICAgICAgdmFyIGVwID0gW107XG5cbiAgICAgICAgICAgIGZvciAodmFyIGVsIGluIGVuZHBvaW50c0J5RWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHZhciBlaXRoZXIgPSBmaWx0ZXJMaXN0KGVsZW1lbnRzLCBlbCwgdHJ1ZSksXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZSA9IGZpbHRlckxpc3Qoc291cmNlcywgZWwsIHRydWUpLFxuICAgICAgICAgICAgICAgICAgICBzb3VyY2VNYXRjaEV4YWN0ID0gc291cmNlcyAhPT0gXCIqXCIsXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldCA9IGZpbHRlckxpc3QodGFyZ2V0cywgZWwsIHRydWUpLFxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRNYXRjaEV4YWN0ID0gdGFyZ2V0cyAhPT0gXCIqXCI7XG5cbiAgICAgICAgICAgICAgICAvLyBpZiB0aGV5IHJlcXVlc3RlZCAnZWl0aGVyJyB0aGVuIGp1c3QgbWF0Y2ggc2NvcGUuIG90aGVyd2lzZSBpZiB0aGV5IHJlcXVlc3RlZCAnc291cmNlJyAobm90IGFzIGEgd2lsZGNhcmQpIHRoZW4gd2UgaGF2ZSB0byBtYXRjaCBvbmx5IGVuZHBvaW50cyB0aGF0IGhhdmUgaXNTb3VyY2Ugc2V0IHRvIHRvIHRydWUsIGFuZCB0aGUgc2FtZSB0aGluZyB3aXRoIGlzVGFyZ2V0LlxuICAgICAgICAgICAgICAgIGlmIChlaXRoZXIgfHwgc291cmNlIHx8IHRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICBpbm5lcjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGVuZHBvaW50c0J5RWxlbWVudFtlbF0ubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfZXAgPSBlbmRwb2ludHNCeUVsZW1lbnRbZWxdW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaWx0ZXJMaXN0KHNjb3BlcywgX2VwLnNjb3BlLCB0cnVlKSkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBub01hdGNoU291cmNlID0gKHNvdXJjZU1hdGNoRXhhY3QgJiYgc291cmNlcy5sZW5ndGggPiAwICYmICFfZXAuaXNTb3VyY2UpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9NYXRjaFRhcmdldCA9ICh0YXJnZXRNYXRjaEV4YWN0ICYmIHRhcmdldHMubGVuZ3RoID4gMCAmJiAhX2VwLmlzVGFyZ2V0KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9NYXRjaFNvdXJjZSB8fCBub01hdGNoVGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZSBpbm5lcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVwLnB1c2goX2VwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gX21ha2VFbmRwb2ludFNlbGVjdEhhbmRsZXIoZXApO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGdldCBhbGwgY29ubmVjdGlvbnMgbWFuYWdlZCBieSB0aGUgaW5zdGFuY2Ugb2YganNwbHVtYi5cbiAgICAgICAgdGhpcy5nZXRBbGxDb25uZWN0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBjb25uZWN0aW9ucztcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5nZXREZWZhdWx0U2NvcGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gREVGQVVMVF9TQ09QRTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gZ2V0IGFuIGVuZHBvaW50IGJ5IHV1aWQuXG4gICAgICAgIHRoaXMuZ2V0RW5kcG9pbnQgPSBfZ2V0RW5kcG9pbnQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHRoZSBsaXN0IG9mIEVuZHBvaW50cyBmb3IgYSBnaXZlbiBlbGVtZW50LlxuICAgICAgICAgKiBAbWV0aG9kIGdldEVuZHBvaW50c1xuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ3xFbGVtZW50fFNlbGVjdG9yfSBlbCBUaGUgZWxlbWVudCB0byBnZXQgZW5kcG9pbnRzIGZvci5cbiAgICAgICAgICogQHJldHVybiB7RW5kcG9pbnRbXX0gQW4gYXJyYXkgb2YgRW5kcG9pbnRzIGZvciB0aGUgc3BlY2lmaWVkIGVsZW1lbnQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdldEVuZHBvaW50cyA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgcmV0dXJuIGVuZHBvaW50c0J5RWxlbWVudFtfaW5mbyhlbCkuaWRdIHx8IFtdO1xuICAgICAgICB9O1xuICAgICAgICAvLyBnZXRzIHRoZSBkZWZhdWx0IGVuZHBvaW50IHR5cGUuIHVzZWQgd2hlbiBzdWJjbGFzc2luZy4gc2VlIHdpa2kuXG4gICAgICAgIHRoaXMuZ2V0RGVmYXVsdEVuZHBvaW50VHlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBqc1BsdW1iLkVuZHBvaW50O1xuICAgICAgICB9O1xuICAgICAgICAvLyBnZXRzIHRoZSBkZWZhdWx0IGNvbm5lY3Rpb24gdHlwZS4gdXNlZCB3aGVuIHN1YmNsYXNzaW5nLiAgc2VlIHdpa2kuXG4gICAgICAgIHRoaXMuZ2V0RGVmYXVsdENvbm5lY3Rpb25UeXBlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGpzUGx1bWIuQ29ubmVjdGlvbjtcbiAgICAgICAgfTtcbiAgICAgICAgLypcbiAgICAgICAgICogR2V0cyBhbiBlbGVtZW50J3MgaWQsIGNyZWF0aW5nIG9uZSBpZiBuZWNlc3NhcnkuIHJlYWxseSBvbmx5IGV4cG9zZWRcbiAgICAgICAgICogZm9yIHRoZSBsaWItc3BlY2lmaWMgZnVuY3Rpb25hbGl0eSB0byBhY2Nlc3M7IHdvdWxkIGJlIGJldHRlciB0byBwYXNzXG4gICAgICAgICAqIHRoZSBjdXJyZW50IGluc3RhbmNlIGludG8gdGhlIGxpYi1zcGVjaWZpYyBjb2RlIChldmVuIHRob3VnaCB0aGlzIGlzXG4gICAgICAgICAqIGEgc3RhdGljIGNhbGwuIGkganVzdCBkb24ndCB3YW50IHRvIGV4cG9zZSBpdCB0byB0aGUgcHVibGljIEFQSSkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdldElkID0gX2dldElkO1xuXG4gICAgICAgIHRoaXMuYXBwZW5kRWxlbWVudCA9IF9hcHBlbmRFbGVtZW50O1xuXG4gICAgICAgIHZhciBfaG92ZXJTdXNwZW5kZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc0hvdmVyU3VzcGVuZGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9ob3ZlclN1c3BlbmRlZDtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zZXRIb3ZlclN1c3BlbmRlZCA9IGZ1bmN0aW9uIChzKSB7XG4gICAgICAgICAgICBfaG92ZXJTdXNwZW5kZWQgPSBzO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIHNldCBhbiBlbGVtZW50J3MgY29ubmVjdGlvbnMgdG8gYmUgaGlkZGVuXG4gICAgICAgIHRoaXMuaGlkZSA9IGZ1bmN0aW9uIChlbCwgY2hhbmdlRW5kcG9pbnRzKSB7XG4gICAgICAgICAgICBfc2V0VmlzaWJsZShlbCwgXCJub25lXCIsIGNoYW5nZUVuZHBvaW50cyk7XG4gICAgICAgICAgICByZXR1cm4gX2N1cnJlbnRJbnN0YW5jZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBleHBvc2VkIGZvciBvdGhlciBvYmplY3RzIHRvIHVzZSB0byBnZXQgYSB1bmlxdWUgaWQuXG4gICAgICAgIHRoaXMuaWRzdGFtcCA9IF9pZHN0YW1wO1xuXG4gICAgICAgIHRoaXMuY29ubmVjdG9yc0luaXRpYWxpemVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJDb25uZWN0b3JUeXBlID0gZnVuY3Rpb24gKGNvbm5lY3RvciwgbmFtZSkge1xuICAgICAgICAgICAgY29ubmVjdG9yVHlwZXMucHVzaChbY29ubmVjdG9yLCBuYW1lXSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gZW5zdXJlIHRoYXQsIGlmIHRoZSBjdXJyZW50IGNvbnRhaW5lciBleGlzdHMsIGl0IGlzIGEgRE9NIGVsZW1lbnQgYW5kIG5vdCBhIHNlbGVjdG9yLlxuICAgICAgICAvLyBpZiBpdCBkb2VzIG5vdCBleGlzdCBhbmQgYGNhbmRpZGF0ZWAgaXMgc3VwcGxpZWQsIHRoZSBvZmZzZXQgcGFyZW50IG9mIHRoYXQgZWxlbWVudCB3aWxsIGJlIHNldCBhcyB0aGUgQ29udGFpbmVyLlxuICAgICAgICAvLyB0aGlzIGlzIHVzZWQgdG8gZG8gYSBiZXR0ZXIgZGVmYXVsdCBiZWhhdmlvdXIgZm9yIHRoZSBjYXNlIHRoYXQgdGhlIHVzZXIgaGFzIG5vdCBzZXQgYSBjb250YWluZXI6XG4gICAgICAgIC8vIGFkZEVuZHBvaW50LCBtYWtlU291cmNlLCBtYWtlVGFyZ2V0IGFuZCBjb25uZWN0IGFsbCBjYWxsIHRoaXMgbWV0aG9kIHdpdGggdGhlIG9mZnNldFBhcmVudCBvZiB0aGVcbiAgICAgICAgLy8gZWxlbWVudCBpbiBxdWVzdGlvbiAoZm9yIGNvbm5lY3QgaXQgaXMgdGhlIHNvdXJjZSBlbGVtZW50KS4gU28gaWYgbm8gY29udGFpbmVyIGlzIHNldCwgaXQgaXMgaW5mZXJyZWRcbiAgICAgICAgLy8gdG8gYmUgdGhlIG9mZnNldFBhcmVudCBvZiB0aGUgZmlyc3QgZWxlbWVudCB0aGUgdXNlciB0cmllcyB0byBjb25uZWN0LlxuICAgICAgICB2YXIgX2Vuc3VyZUNvbnRhaW5lciA9IGZ1bmN0aW9uIChjYW5kaWRhdGUpIHtcbiAgICAgICAgICAgIGlmICghX2NvbnRhaW5lciAmJiBjYW5kaWRhdGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2FuID0gX2N1cnJlbnRJbnN0YW5jZS5nZXRFbGVtZW50KGNhbmRpZGF0ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGNhbi5vZmZzZXRQYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgX2N1cnJlbnRJbnN0YW5jZS5zZXRDb250YWluZXIoY2FuLm9mZnNldFBhcmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBfZ2V0Q29udGFpbmVyRnJvbURlZmF1bHRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKF9jdXJyZW50SW5zdGFuY2UuRGVmYXVsdHMuQ29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgX2N1cnJlbnRJbnN0YW5jZS5zZXRDb250YWluZXIoX2N1cnJlbnRJbnN0YW5jZS5EZWZhdWx0cy5Db250YWluZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGNoZWNrIGlmIGEgZ2l2ZW4gZWxlbWVudCBpcyBtYW5hZ2VkIG9yIG5vdC4gaWYgbm90LCBhZGQgdG8gb3VyIG1hcC4gaWYgZHJhd2luZyBpcyBub3Qgc3VzcGVuZGVkIHRoZW5cbiAgICAgICAgLy8gd2UnbGwgYWxzbyBzdGFzaCBpdHMgZGltZW5zaW9uczsgb3RoZXJ3aXNlIHdlJ2xsIGRvIHRoaXMgaW4gYSBsYXp5IHdheSB0aHJvdWdoIHVwZGF0ZU9mZnNldC5cbiAgICAgICAgdmFyIF9tYW5hZ2UgPSBfY3VycmVudEluc3RhbmNlLm1hbmFnZSA9IGZ1bmN0aW9uIChpZCwgZWxlbWVudCwgX3RyYW5zaWVudCkge1xuICAgICAgICAgICAgaWYgKCFtYW5hZ2VkRWxlbWVudHNbaWRdKSB7XG4gICAgICAgICAgICAgICAgbWFuYWdlZEVsZW1lbnRzW2lkXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgZWw6IGVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgIGVuZHBvaW50czogW10sXG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25zOiBbXVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBtYW5hZ2VkRWxlbWVudHNbaWRdLmluZm8gPSBfdXBkYXRlT2Zmc2V0KHsgZWxJZDogaWQsIHRpbWVzdGFtcDogX3N1c3BlbmRlZEF0IH0pO1xuICAgICAgICAgICAgICAgIGlmICghX3RyYW5zaWVudCkge1xuICAgICAgICAgICAgICAgICAgICBfY3VycmVudEluc3RhbmNlLmZpcmUoXCJtYW5hZ2VFbGVtZW50XCIsIHsgaWQ6aWQsIGluZm86bWFuYWdlZEVsZW1lbnRzW2lkXS5pbmZvLCBlbDplbGVtZW50IH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG1hbmFnZWRFbGVtZW50c1tpZF07XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIF91bm1hbmFnZSA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICBpZiAobWFuYWdlZEVsZW1lbnRzW2lkXSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBtYW5hZ2VkRWxlbWVudHNbaWRdO1xuICAgICAgICAgICAgICAgIF9jdXJyZW50SW5zdGFuY2UuZmlyZShcInVubWFuYWdlRWxlbWVudFwiLCBpZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHVwZGF0ZXMgdGhlIG9mZnNldCBhbmQgc2l6ZSBmb3IgYSBnaXZlbiBlbGVtZW50LCBhbmQgc3RvcmVzIHRoZVxuICAgICAgICAgKiB2YWx1ZXMuIGlmICdvZmZzZXQnIGlzIG5vdCBudWxsIHdlIHVzZSB0aGF0IChpdCB3b3VsZCBoYXZlIGJlZW5cbiAgICAgICAgICogcGFzc2VkIGluIGZyb20gYSBkcmFnIGNhbGwpIGJlY2F1c2UgaXQncyBmYXN0ZXI7IGJ1dCBpZiBpdCBpcyBudWxsLFxuICAgICAgICAgKiBvciBpZiAncmVjYWxjJyBpcyB0cnVlIGluIG9yZGVyIHRvIGZvcmNlIGEgcmVjYWxjdWxhdGlvbiwgd2UgZ2V0IHRoZSBjdXJyZW50IHZhbHVlcy5cbiAgICAgICAgICovXG4gICAgICAgIHZhciBfdXBkYXRlT2Zmc2V0ID0gdGhpcy51cGRhdGVPZmZzZXQgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG5cbiAgICAgICAgICAgIHZhciB0aW1lc3RhbXAgPSBwYXJhbXMudGltZXN0YW1wLCByZWNhbGMgPSBwYXJhbXMucmVjYWxjLCBvZmZzZXQgPSBwYXJhbXMub2Zmc2V0LCBlbElkID0gcGFyYW1zLmVsSWQsIHM7XG4gICAgICAgICAgICBpZiAoX3N1c3BlbmREcmF3aW5nICYmICF0aW1lc3RhbXApIHtcbiAgICAgICAgICAgICAgICB0aW1lc3RhbXAgPSBfc3VzcGVuZGVkQXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXJlY2FsYykge1xuICAgICAgICAgICAgICAgIGlmICh0aW1lc3RhbXAgJiYgdGltZXN0YW1wID09PSBvZmZzZXRUaW1lc3RhbXBzW2VsSWRdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7bzogcGFyYW1zLm9mZnNldCB8fCBvZmZzZXRzW2VsSWRdLCBzOiBzaXplc1tlbElkXX07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlY2FsYyB8fCAoIW9mZnNldCAmJiBvZmZzZXRzW2VsSWRdID09IG51bGwpKSB7IC8vIGlmIGZvcmNlZCByZXBhaW50IG9yIG5vIG9mZnNldCBhdmFpbGFibGUsIHdlIHJlY2FsY3VsYXRlLlxuXG4gICAgICAgICAgICAgICAgLy8gZ2V0IHRoZSBjdXJyZW50IHNpemUgYW5kIG9mZnNldCwgYW5kIHN0b3JlIHRoZW1cbiAgICAgICAgICAgICAgICBzID0gbWFuYWdlZEVsZW1lbnRzW2VsSWRdID8gbWFuYWdlZEVsZW1lbnRzW2VsSWRdLmVsIDogbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAocyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHNpemVzW2VsSWRdID0gX2N1cnJlbnRJbnN0YW5jZS5nZXRTaXplKHMpO1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXRzW2VsSWRdID0gX2N1cnJlbnRJbnN0YW5jZS5nZXRPZmZzZXQocyk7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldFRpbWVzdGFtcHNbZWxJZF0gPSB0aW1lc3RhbXA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvZmZzZXRzW2VsSWRdID0gb2Zmc2V0IHx8IG9mZnNldHNbZWxJZF07XG4gICAgICAgICAgICAgICAgaWYgKHNpemVzW2VsSWRdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcyA9IG1hbmFnZWRFbGVtZW50c1tlbElkXS5lbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZXNbZWxJZF0gPSBfY3VycmVudEluc3RhbmNlLmdldFNpemUocyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb2Zmc2V0VGltZXN0YW1wc1tlbElkXSA9IHRpbWVzdGFtcDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG9mZnNldHNbZWxJZF0gJiYgIW9mZnNldHNbZWxJZF0ucmlnaHQpIHtcbiAgICAgICAgICAgICAgICBvZmZzZXRzW2VsSWRdLnJpZ2h0ID0gb2Zmc2V0c1tlbElkXS5sZWZ0ICsgc2l6ZXNbZWxJZF1bMF07XG4gICAgICAgICAgICAgICAgb2Zmc2V0c1tlbElkXS5ib3R0b20gPSBvZmZzZXRzW2VsSWRdLnRvcCArIHNpemVzW2VsSWRdWzFdO1xuICAgICAgICAgICAgICAgIG9mZnNldHNbZWxJZF0ud2lkdGggPSBzaXplc1tlbElkXVswXTtcbiAgICAgICAgICAgICAgICBvZmZzZXRzW2VsSWRdLmhlaWdodCA9IHNpemVzW2VsSWRdWzFdO1xuICAgICAgICAgICAgICAgIG9mZnNldHNbZWxJZF0uY2VudGVyeCA9IG9mZnNldHNbZWxJZF0ubGVmdCArIChvZmZzZXRzW2VsSWRdLndpZHRoIC8gMik7XG4gICAgICAgICAgICAgICAgb2Zmc2V0c1tlbElkXS5jZW50ZXJ5ID0gb2Zmc2V0c1tlbElkXS50b3AgKyAob2Zmc2V0c1tlbElkXS5oZWlnaHQgLyAyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHtvOiBvZmZzZXRzW2VsSWRdLCBzOiBzaXplc1tlbElkXX07XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGNhbGxiYWNrIGZyb20gdGhlIGN1cnJlbnQgbGlicmFyeSB0byB0ZWxsIHVzIHRvIHByZXBhcmUgb3Vyc2VsdmVzIChhdHRhY2hcbiAgICAgICAgICogbW91c2UgbGlzdGVuZXJzIGV0YzsgY2FuJ3QgZG8gdGhhdCB1bnRpbCB0aGUgbGlicmFyeSBoYXMgcHJvdmlkZWQgYSBiaW5kIG1ldGhvZClcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJlbmRlcmVyVHlwZXMgPSByb290LmpzUGx1bWIuZ2V0UmVuZGVyTW9kZXMoKTtcblxuICAgICAgICAgICAgdmFyIF9vbmVUeXBlID0gZnVuY3Rpb24gKHJlbmRlcmVyLCBuYW1lLCBmbikge1xuICAgICAgICAgICAgICAgIHJvb3QuanNQbHVtYi5Db25uZWN0b3JzW3JlbmRlcmVyXVtuYW1lXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgcm9vdC5qc1BsdW1iLkNvbm5lY3RvclJlbmRlcmVyc1tyZW5kZXJlcl0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIF9qdS5leHRlbmQocm9vdC5qc1BsdW1iLkNvbm5lY3RvcnNbcmVuZGVyZXJdW25hbWVdLCBbIGZuLCByb290LmpzUGx1bWIuQ29ubmVjdG9yUmVuZGVyZXJzW3JlbmRlcmVyXV0pO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKCFyb290LmpzUGx1bWIuY29ubmVjdG9yc0luaXRpYWxpemVkKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb25uZWN0b3JUeXBlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJlbmRlcmVyVHlwZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9vbmVUeXBlKHJlbmRlcmVyVHlwZXNbal0sIGNvbm5lY3RvclR5cGVzW2ldWzFdLCBjb25uZWN0b3JUeXBlc1tpXVswXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByb290LmpzUGx1bWIuY29ubmVjdG9yc0luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFpbml0aWFsaXplZCkge1xuICAgICAgICAgICAgICAgIF9nZXRDb250YWluZXJGcm9tRGVmYXVsdHMoKTtcbiAgICAgICAgICAgICAgICBfY3VycmVudEluc3RhbmNlLmFuY2hvck1hbmFnZXIgPSBuZXcgcm9vdC5qc1BsdW1iLkFuY2hvck1hbmFnZXIoe2pzUGx1bWJJbnN0YW5jZTogX2N1cnJlbnRJbnN0YW5jZX0pO1xuICAgICAgICAgICAgICAgIGluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBfY3VycmVudEluc3RhbmNlLmZpcmUoXCJyZWFkeVwiLCBfY3VycmVudEluc3RhbmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfS5iaW5kKHRoaXMpO1xuXG4gICAgICAgIHRoaXMubG9nID0gbG9nO1xuICAgICAgICB0aGlzLmpzUGx1bWJVSUNvbXBvbmVudCA9IGpzUGx1bWJVSUNvbXBvbmVudDtcblxuICAgICAgICAvKlxuICAgICAgICAgKiBDcmVhdGVzIGFuIGFuY2hvciB3aXRoIHRoZSBnaXZlbiBwYXJhbXMuXG4gICAgICAgICAqXG4gICAgICAgICAqXG4gICAgICAgICAqIFJldHVybnM6IFRoZSBuZXdseSBjcmVhdGVkIEFuY2hvci5cbiAgICAgICAgICogVGhyb3dzOiBhbiBlcnJvciBpZiBhIG5hbWVkIGFuY2hvciB3YXMgbm90IGZvdW5kLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tYWtlQW5jaG9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHBwLCBfYSA9IGZ1bmN0aW9uICh0LCBwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJvb3QuanNQbHVtYi5BbmNob3JzW3RdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgcm9vdC5qc1BsdW1iLkFuY2hvcnNbdF0ocCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghX2N1cnJlbnRJbnN0YW5jZS5EZWZhdWx0cy5Eb05vdFRocm93RXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IHsgbXNnOiBcImpzUGx1bWI6IHVua25vd24gYW5jaG9yIHR5cGUgJ1wiICsgdCArIFwiJ1wiIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc3BlY2ltZW4gPSBhcmd1bWVudHNbMF0sIGVsZW1lbnRJZCA9IGFyZ3VtZW50c1sxXSwganNQbHVtYkluc3RhbmNlID0gYXJndW1lbnRzWzJdLCBuZXdBbmNob3IgPSBudWxsO1xuICAgICAgICAgICAgLy8gaWYgaXQgYXBwZWFycyB0byBiZSBhbiBhbmNob3IgYWxyZWFkeS4uLlxuICAgICAgICAgICAgaWYgKHNwZWNpbWVuLmNvbXB1dGUgJiYgc3BlY2ltZW4uZ2V0T3JpZW50YXRpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3BlY2ltZW47XG4gICAgICAgICAgICB9ICAvL1RPRE8gaGF6eSBoZXJlIGFib3V0IHdoZXRoZXIgaXQgc2hvdWxkIGJlIGFkZGVkIG9yIGlzIGFscmVhZHkgYWRkZWQgc29tZWhvdy5cbiAgICAgICAgICAgIC8vIGlzIGl0IHRoZSBuYW1lIG9mIGFuIGFuY2hvciB0eXBlP1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHNwZWNpbWVuID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgbmV3QW5jaG9yID0gX2EoYXJndW1lbnRzWzBdLCB7ZWxlbWVudElkOiBlbGVtZW50SWQsIGpzUGx1bWJJbnN0YW5jZTogX2N1cnJlbnRJbnN0YW5jZX0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaXMgaXQgYW4gYXJyYXk/IGl0IHdpbGwgYmUgb25lIG9mOlxuICAgICAgICAgICAgLy8gYW4gYXJyYXkgb2YgW3NwZWMsIHBhcmFtc10gLSB0aGlzIGRlZmluZXMgYSBzaW5nbGUgYW5jaG9yLCB3aGljaCBtYXkgYmUgZHluYW1pYywgYnV0IGhhcyBwYXJhbWV0ZXJzLlxuICAgICAgICAgICAgLy8gYW4gYXJyYXkgb2YgYXJyYXlzIC0gdGhpcyBkZWZpbmVzIHNvbWUgZHluYW1pYyBhbmNob3JzXG4gICAgICAgICAgICAvLyBhbiBhcnJheSBvZiBudW1iZXJzIC0gdGhpcyBkZWZpbmVzIGEgc2luZ2xlIGFuY2hvci5cbiAgICAgICAgICAgIGVsc2UgaWYgKF9qdS5pc0FycmF5KHNwZWNpbWVuKSkge1xuICAgICAgICAgICAgICAgIGlmIChfanUuaXNBcnJheShzcGVjaW1lblswXSkgfHwgX2p1LmlzU3RyaW5nKHNwZWNpbWVuWzBdKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiBbc3BlYywgcGFyYW1zXSBmb3JtYXRcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNwZWNpbWVuLmxlbmd0aCA9PT0gMiAmJiBfanUuaXNPYmplY3Qoc3BlY2ltZW5bMV0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBmaXJzdCBhcmcgaXMgYSBzdHJpbmcsIGl0cyBhIG5hbWVkIGFuY2hvciB3aXRoIHBhcmFtc1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9qdS5pc1N0cmluZyhzcGVjaW1lblswXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcCA9IHJvb3QuanNQbHVtYi5leHRlbmQoe2VsZW1lbnRJZDogZWxlbWVudElkLCBqc1BsdW1iSW5zdGFuY2U6IF9jdXJyZW50SW5zdGFuY2V9LCBzcGVjaW1lblsxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3QW5jaG9yID0gX2Eoc3BlY2ltZW5bMF0sIHBwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG90aGVyd2lzZSBmaXJzdCBhcmcgaXMgYXJyYXksIHNlY29uZCBpcyBwYXJhbXMuIHdlIHRyZWF0IGFzIGEgZHluYW1pYyBhbmNob3IsIHdoaWNoIGlzIGZpbmVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGV2ZW4gaWYgdGhlIGZpcnN0IGFyZyBoYXMgb25seSBvbmUgZW50cnkuIHlvdSBjb3VsZCBhcmd1ZSBhbGwgYW5jaG9ycyBzaG91bGQgYmUgaW1wbGljaXRseSBkeW5hbWljIGluIGZhY3QuXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcCA9IHJvb3QuanNQbHVtYi5leHRlbmQoe2VsZW1lbnRJZDogZWxlbWVudElkLCBqc1BsdW1iSW5zdGFuY2U6IF9jdXJyZW50SW5zdGFuY2UsIGFuY2hvcnM6IHNwZWNpbWVuWzBdfSwgc3BlY2ltZW5bMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0FuY2hvciA9IG5ldyByb290LmpzUGx1bWIuRHluYW1pY0FuY2hvcihwcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdBbmNob3IgPSBuZXcganNQbHVtYi5EeW5hbWljQW5jaG9yKHthbmNob3JzOiBzcGVjaW1lbiwgc2VsZWN0b3I6IG51bGwsIGVsZW1lbnRJZDogZWxlbWVudElkLCBqc1BsdW1iSW5zdGFuY2U6IF9jdXJyZW50SW5zdGFuY2V9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYW5jaG9yUGFyYW1zID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgeDogc3BlY2ltZW5bMF0sIHk6IHNwZWNpbWVuWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3JpZW50YXRpb246IChzcGVjaW1lbi5sZW5ndGggPj0gNCkgPyBbIHNwZWNpbWVuWzJdLCBzcGVjaW1lblszXSBdIDogWzAsIDBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0czogKHNwZWNpbWVuLmxlbmd0aCA+PSA2KSA/IFsgc3BlY2ltZW5bNF0sIHNwZWNpbWVuWzVdIF0gOiBbIDAsIDAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRJZDogZWxlbWVudElkLFxuICAgICAgICAgICAgICAgICAgICAgICAganNQbHVtYkluc3RhbmNlOiBfY3VycmVudEluc3RhbmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY3NzQ2xhc3M6IHNwZWNpbWVuLmxlbmd0aCA9PT0gNyA/IHNwZWNpbWVuWzZdIDogbnVsbFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBuZXdBbmNob3IgPSBuZXcgcm9vdC5qc1BsdW1iLkFuY2hvcihhbmNob3JQYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICBuZXdBbmNob3IuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHJvb3QuanNQbHVtYi5BbmNob3IoYW5jaG9yUGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghbmV3QW5jaG9yLmlkKSB7XG4gICAgICAgICAgICAgICAgbmV3QW5jaG9yLmlkID0gXCJhbmNob3JfXCIgKyBfaWRzdGFtcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ld0FuY2hvcjtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogbWFrZXMgYSBsaXN0IG9mIGFuY2hvcnMgZnJvbSB0aGUgZ2l2ZW4gbGlzdCBvZiB0eXBlcyBvciBjb29yZHMsIGVnXG4gICAgICAgICAqIFtcIlRvcENlbnRlclwiLCBcIlJpZ2h0TWlkZGxlXCIsIFwiQm90dG9tQ2VudGVyXCIsIFswLCAxLCAtMSwgLTFdIF1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubWFrZUFuY2hvcnMgPSBmdW5jdGlvbiAodHlwZXMsIGVsZW1lbnRJZCwganNQbHVtYkluc3RhbmNlKSB7XG4gICAgICAgICAgICB2YXIgciA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gdHlwZXMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdHlwZXNbaV0gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgci5wdXNoKHJvb3QuanNQbHVtYi5BbmNob3JzW3R5cGVzW2ldXSh7ZWxlbWVudElkOiBlbGVtZW50SWQsIGpzUGx1bWJJbnN0YW5jZToganNQbHVtYkluc3RhbmNlfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChfanUuaXNBcnJheSh0eXBlc1tpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgci5wdXNoKF9jdXJyZW50SW5zdGFuY2UubWFrZUFuY2hvcih0eXBlc1tpXSwgZWxlbWVudElkLCBqc1BsdW1iSW5zdGFuY2UpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogTWFrZXMgYSBkeW5hbWljIGFuY2hvciBmcm9tIHRoZSBnaXZlbiBsaXN0IG9mIGFuY2hvcnMgKHdoaWNoIG1heSBiZSBpbiBzaG9ydGhhbmQgbm90YXRpb24gYXMgc3RyaW5ncyBvciBkaW1lbnNpb24gYXJyYXlzLCBvciBBbmNob3JcbiAgICAgICAgICogb2JqZWN0cyB0aGVtc2VsdmVzKSBhbmQgdGhlIGdpdmVuLCBvcHRpb25hbCwgYW5jaG9yU2VsZWN0b3IgZnVuY3Rpb24gKGpzUGx1bWIgdXNlcyBhIGRlZmF1bHQgaWYgdGhpcyBpcyBub3QgcHJvdmlkZWQ7IG1vc3QgcGVvcGxlIHdpbGxcbiAgICAgICAgICogbm90IG5lZWQgdG8gcHJvdmlkZSB0aGlzIC0gaSB0aGluaykuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm1ha2VEeW5hbWljQW5jaG9yID0gZnVuY3Rpb24gKGFuY2hvcnMsIGFuY2hvclNlbGVjdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IHJvb3QuanNQbHVtYi5EeW5hbWljQW5jaG9yKHthbmNob3JzOiBhbmNob3JzLCBzZWxlY3RvcjogYW5jaG9yU2VsZWN0b3IsIGVsZW1lbnRJZDogbnVsbCwganNQbHVtYkluc3RhbmNlOiBfY3VycmVudEluc3RhbmNlfSk7XG4gICAgICAgIH07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLSBtYWtlU291cmNlL21ha2VUYXJnZXQgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBcblxuICAgICAgICB0aGlzLnRhcmdldEVuZHBvaW50RGVmaW5pdGlvbnMgPSB7fTtcbiAgICAgICAgdGhpcy5zb3VyY2VFbmRwb2ludERlZmluaXRpb25zID0ge307XG5cbiAgICAgICAgdmFyIHNlbGVjdG9yRmlsdGVyID0gZnVuY3Rpb24gKGV2dCwgX2VsLCBzZWxlY3RvciwgX2luc3RhbmNlLCBuZWdhdGUpIHtcbiAgICAgICAgICAgIHZhciB0ID0gZXZ0LnRhcmdldCB8fCBldnQuc3JjRWxlbWVudCwgb2sgPSBmYWxzZSxcbiAgICAgICAgICAgICAgICBzZWwgPSBfaW5zdGFuY2UuZ2V0U2VsZWN0b3IoX2VsLCBzZWxlY3Rvcik7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNlbC5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIGlmIChzZWxbal0gPT09IHQpIHtcbiAgICAgICAgICAgICAgICAgICAgb2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmVnYXRlID8gIW9rIDogb2s7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIF9tYWtlRWxlbWVudERyb3BIYW5kbGVyID0gZnVuY3Rpb24gKGVsSW5mbywgcCwgZHJvcE9wdGlvbnMsIGlzU291cmNlLCBpc1RhcmdldCkge1xuICAgICAgICAgICAgdmFyIHByb3h5Q29tcG9uZW50ID0gbmV3IGpzUGx1bWJVSUNvbXBvbmVudChwKTtcbiAgICAgICAgICAgIHZhciBfZHJvcCA9IHAuX2pzUGx1bWIuRW5kcG9pbnREcm9wSGFuZGxlcih7XG4gICAgICAgICAgICAgICAganNQbHVtYjogX2N1cnJlbnRJbnN0YW5jZSxcbiAgICAgICAgICAgICAgICBlbmFibGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbEluZm8uZGVmLmVuYWJsZWQ7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpc0Z1bGw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhcmdldENvdW50ID0gX2N1cnJlbnRJbnN0YW5jZS5zZWxlY3Qoe3RhcmdldDogZWxJbmZvLmlkfSkubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxJbmZvLmRlZi5tYXhDb25uZWN0aW9ucyA+IDAgJiYgdGFyZ2V0Q291bnQgPj0gZWxJbmZvLmRlZi5tYXhDb25uZWN0aW9ucztcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGVsSW5mby5lbCxcbiAgICAgICAgICAgICAgICBlbGVtZW50SWQ6IGVsSW5mby5pZCxcbiAgICAgICAgICAgICAgICBpc1NvdXJjZTogaXNTb3VyY2UsXG4gICAgICAgICAgICAgICAgaXNUYXJnZXQ6IGlzVGFyZ2V0LFxuICAgICAgICAgICAgICAgIGFkZENsYXNzOiBmdW5jdGlvbiAoY2xhenopIHtcbiAgICAgICAgICAgICAgICAgICAgX2N1cnJlbnRJbnN0YW5jZS5hZGRDbGFzcyhlbEluZm8uZWwsIGNsYXp6KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHJlbW92ZUNsYXNzOiBmdW5jdGlvbiAoY2xhenopIHtcbiAgICAgICAgICAgICAgICAgICAgX2N1cnJlbnRJbnN0YW5jZS5yZW1vdmVDbGFzcyhlbEluZm8uZWwsIGNsYXp6KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9uRHJvcDogZnVuY3Rpb24gKGpwYykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc291cmNlID0ganBjLmVuZHBvaW50c1swXTtcbiAgICAgICAgICAgICAgICAgICAgc291cmNlLmFuY2hvci5sb2NrZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGlzRHJvcEFsbG93ZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb3h5Q29tcG9uZW50LmlzRHJvcEFsbG93ZWQuYXBwbHkocHJveHlDb21wb25lbnQsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpc1JlZHJvcDpmdW5jdGlvbihqcGMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChqcGMuc3VzcGVuZGVkRWxlbWVudCAhPSBudWxsICYmIGpwYy5zdXNwZW5kZWRFbmRwb2ludCAhPSBudWxsICYmIGpwYy5zdXNwZW5kZWRFbmRwb2ludC5lbGVtZW50ID09PSBlbEluZm8uZWwpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZ2V0RW5kcG9pbnQ6IGZ1bmN0aW9uIChqcGMpIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBtYWtlIGEgbmV3IEVuZHBvaW50IGZvciB0aGUgdGFyZ2V0LCBvciBnZXQgaXQgZnJvbSB0aGUgY2FjaGUgaWYgdW5pcXVlRW5kcG9pbnRcbiAgICAgICAgICAgICAgICAgICAgLy8gaXMgc2V0LiBpZiBpdHMgYSByZWRyb3AgdGhlIG5ldyBlbmRwb2ludCB3aWxsIGJlIGltbWVkaWF0ZWx5IGNsZWFuZWQgdXAuXG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld0VuZHBvaW50ID0gZWxJbmZvLmRlZi5lbmRwb2ludDtcblxuICAgICAgICAgICAgICAgICAgICAvLyBpZiBubyBjYWNoZWQgZW5kcG9pbnQsIG9yIHRoZXJlIHdhcyBvbmUgYnV0IGl0IGhhcyBiZWVuIGNsZWFuZWQgdXBcbiAgICAgICAgICAgICAgICAgICAgLy8gKGllLiBkZXRhY2hlZCksIGNyZWF0ZSBhIG5ldyBvbmVcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5ld0VuZHBvaW50ID09IG51bGwgfHwgbmV3RW5kcG9pbnQuX2pzUGx1bWIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVwcyA9IF9jdXJyZW50SW5zdGFuY2UuZGVyaXZlRW5kcG9pbnRBbmRBbmNob3JTcGVjKGpwYy5nZXRUeXBlKCkuam9pbihcIiBcIiksIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBwID0gZXBzLmVuZHBvaW50cyA/IHJvb3QuanNQbHVtYi5leHRlbmQocCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZHBvaW50OmVsSW5mby5kZWYuZGVmLmVuZHBvaW50IHx8IGVwcy5lbmRwb2ludHNbMV1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pIDpwO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVwcy5hbmNob3JzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHAgPSByb290LmpzUGx1bWIuZXh0ZW5kKHBwLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuY2hvcjplbEluZm8uZGVmLmRlZi5hbmNob3IgfHwgZXBzLmFuY2hvcnNbMV1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0VuZHBvaW50ID0gX2N1cnJlbnRJbnN0YW5jZS5hZGRFbmRwb2ludChlbEluZm8uZWwsIHBwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0VuZHBvaW50Ll9tdE5ldyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAocC51bmlxdWVFbmRwb2ludCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxJbmZvLmRlZi5lbmRwb2ludCA9IG5ld0VuZHBvaW50O1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgbmV3RW5kcG9pbnQuc2V0RGVsZXRlT25FbXB0eSh0cnVlKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBpZiBjb25uZWN0aW9uIGlzIGRldGFjaGFibGUsIGluaXQgdGhlIG5ldyBlbmRwb2ludCB0byBiZSBkcmFnZ2FibGUsIHRvIHN1cHBvcnQgdGhhdCBoYXBwZW5pbmcuXG4gICAgICAgICAgICAgICAgICAgIGlmIChqcGMuaXNEZXRhY2hhYmxlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0VuZHBvaW50LmluaXREcmFnZ2FibGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBhbmNob3IgaGFzIGEgJ3Bvc2l0aW9uRmluZGVyJyBzZXQsIHRoZW4gZGVsZWdhdGUgdG8gdGhhdCBmdW5jdGlvbiB0byBmaW5kXG4gICAgICAgICAgICAgICAgICAgIC8vIG91dCB3aGVyZSB0byBsb2NhdGUgdGhlIGFuY2hvci5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG5ld0VuZHBvaW50LmFuY2hvci5wb3NpdGlvbkZpbmRlciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZHJvcFBvc2l0aW9uID0gX2N1cnJlbnRJbnN0YW5jZS5nZXRVSVBvc2l0aW9uKGFyZ3VtZW50cywgX2N1cnJlbnRJbnN0YW5jZS5nZXRab29tKCkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsUG9zaXRpb24gPSBfY3VycmVudEluc3RhbmNlLmdldE9mZnNldChlbEluZm8uZWwpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsU2l6ZSA9IF9jdXJyZW50SW5zdGFuY2UuZ2V0U2l6ZShlbEluZm8uZWwpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwID0gZHJvcFBvc2l0aW9uID09IG51bGwgPyBbMCwwXSA6IG5ld0VuZHBvaW50LmFuY2hvci5wb3NpdGlvbkZpbmRlcihkcm9wUG9zaXRpb24sIGVsUG9zaXRpb24sIGVsU2l6ZSwgbmV3RW5kcG9pbnQuYW5jaG9yLmNvbnN0cnVjdG9yUGFyYW1zKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3RW5kcG9pbnQuYW5jaG9yLnggPSBhcFswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0VuZHBvaW50LmFuY2hvci55ID0gYXBbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBub3cgZmlndXJlIGFuIG9yaWVudGF0aW9uIGZvciBpdC4ua2luZCBvZiBoYXJkIHRvIGtub3cgd2hhdCB0byBkbyBhY3R1YWxseS4gcHJvYmFibHkgdGhlIGJlc3QgdGhpbmcgaSBjYW4gZG8gaXMgdG9cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN1cHBvcnQgc3BlY2lmeWluZyBhbiBvcmllbnRhdGlvbiBpbiB0aGUgYW5jaG9yJ3Mgc3BlYy4gaWYgb25lIGlzIG5vdCBzdXBwbGllZCB0aGVuIGkgd2lsbCBtYWtlIHRoZSBvcmllbnRhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYmUgd2hhdCB3aWxsIGNhdXNlIHRoZSBtb3N0IG5hdHVyYWwgbGluayB0byB0aGUgc291cmNlOiBpdCB3aWxsIGJlIHBvaW50aW5nIGF0IHRoZSBzb3VyY2UsIGJ1dCBpdCBuZWVkcyB0byBiZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3BlY2lmaWVkIGluIG9uZSBheGlzIG9ubHksIGFuZCBzbyBob3cgdG8gbWFrZSB0aGF0IGNob2ljZT8gaSB0aGluayBpIHdpbGwgdXNlIHdoaWNoZXZlciBheGlzIGlzIHRoZSBvbmUgaW4gd2hpY2hcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSB0YXJnZXQgaXMgZnVydGhlc3QgYXdheSBmcm9tIHRoZSBzb3VyY2UuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3RW5kcG9pbnQ7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBtYXliZUNsZWFudXA6IGZ1bmN0aW9uIChlcCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXAuX210TmV3ICYmIGVwLmNvbm5lY3Rpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2N1cnJlbnRJbnN0YW5jZS5kZWxldGVPYmplY3Qoe2VuZHBvaW50OiBlcH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGVwLl9tdE5ldztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyB3cmFwIGRyb3AgZXZlbnRzIGFzIG5lZWRlZCBhbmQgaW5pdGlhbGlzZSBkcm9wcGFibGVcbiAgICAgICAgICAgIHZhciBkcm9wRXZlbnQgPSByb290LmpzUGx1bWIuZHJhZ0V2ZW50cy5kcm9wO1xuICAgICAgICAgICAgZHJvcE9wdGlvbnMuc2NvcGUgPSBkcm9wT3B0aW9ucy5zY29wZSB8fCAocC5zY29wZSB8fCBfY3VycmVudEluc3RhbmNlLkRlZmF1bHRzLlNjb3BlKTtcbiAgICAgICAgICAgIGRyb3BPcHRpb25zW2Ryb3BFdmVudF0gPSBfanUud3JhcChkcm9wT3B0aW9uc1tkcm9wRXZlbnRdLCBfZHJvcCwgdHJ1ZSk7XG5cbiAgICAgICAgICAgIC8vIGlmIHRhcmdldCwgcmV0dXJuIHRydWUgZnJvbSB0aGUgb3ZlciBldmVudC4gdGhpcyB3aWxsIGNhdXNlIGthdGF2b3JpbyB0byBzdG9wIHNldHRpbmcgZHJvcHMgdG8gaG92ZXJcbiAgICAgICAgICAgIC8vIGlmIG11bHRpcGxlRHJvcCBpcyBzZXQgdG8gZmFsc2UuXG4gICAgICAgICAgICBpZiAoaXNUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICBkcm9wT3B0aW9uc1tyb290LmpzUGx1bWIuZHJhZ0V2ZW50cy5vdmVyXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRydWU7IH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHZhbmlsbGEganNwbHVtYiBvbmx5XG4gICAgICAgICAgICBpZiAocC5hbGxvd0xvb3BiYWNrID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGRyb3BPcHRpb25zLmNhbkRyb3AgPSBmdW5jdGlvbiAoX2RyYWcpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlID0gX2RyYWcuZ2V0RHJhZ0VsZW1lbnQoKS5fanNQbHVtYlJlbGF0ZWRFbGVtZW50O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGUgIT09IGVsSW5mby5lbDtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX2N1cnJlbnRJbnN0YW5jZS5pbml0RHJvcHBhYmxlKGVsSW5mby5lbCwgZHJvcE9wdGlvbnMsIFwiaW50ZXJuYWxcIik7XG5cbiAgICAgICAgICAgIHJldHVybiBfZHJvcDtcblxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIHNlZSBBUEkgZG9jc1xuICAgICAgICB0aGlzLm1ha2VUYXJnZXQgPSBmdW5jdGlvbiAoZWwsIHBhcmFtcywgcmVmZXJlbmNlUGFyYW1zKSB7XG5cbiAgICAgICAgICAgIC8vIHB1dCBqc3BsdW1iIHJlZiBpbnRvIHBhcmFtcyB3aXRob3V0IGFsdGVyaW5nIHRoZSBwYXJhbXMgcGFzc2VkIGluXG4gICAgICAgICAgICB2YXIgcCA9IHJvb3QuanNQbHVtYi5leHRlbmQoe19qc1BsdW1iOiB0aGlzfSwgcmVmZXJlbmNlUGFyYW1zKTtcbiAgICAgICAgICAgIHJvb3QuanNQbHVtYi5leHRlbmQocCwgcGFyYW1zKTtcblxuICAgICAgICAgICAgdmFyIG1heENvbm5lY3Rpb25zID0gcC5tYXhDb25uZWN0aW9ucyB8fCAtMSxcblxuICAgICAgICAgICAgICAgIF9kb09uZSA9IGZ1bmN0aW9uIChlbCkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGdldCB0aGUgZWxlbWVudCdzIGlkIGFuZCBzdG9yZSB0aGUgZW5kcG9pbnQgZGVmaW5pdGlvbiBmb3IgaXQuICBqc1BsdW1iLmNvbm5lY3QgY2FsbHMgd2lsbCBsb29rIGZvciBvbmUgb2YgdGhlc2UsXG4gICAgICAgICAgICAgICAgICAgIC8vIGFuZCB1c2UgdGhlIGVuZHBvaW50IGRlZmluaXRpb24gaWYgZm91bmQuXG4gICAgICAgICAgICAgICAgICAgIC8vIGRlY29kZSB0aGUgaW5mbyBmb3IgdGhpcyBlbGVtZW50IChpZCBhbmQgZWxlbWVudClcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsSW5mbyA9IF9pbmZvKGVsKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsaWQgPSBlbEluZm8uaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBkcm9wT3B0aW9ucyA9IHJvb3QuanNQbHVtYi5leHRlbmQoe30sIHAuZHJvcE9wdGlvbnMgfHwge30pLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSA9IHAuY29ubmVjdGlvblR5cGUgfHwgXCJkZWZhdWx0XCI7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy50YXJnZXRFbmRwb2ludERlZmluaXRpb25zW2VsaWRdID0gdGhpcy50YXJnZXRFbmRwb2ludERlZmluaXRpb25zW2VsaWRdIHx8IHt9O1xuXG4gICAgICAgICAgICAgICAgICAgIF9lbnN1cmVDb250YWluZXIoZWxpZCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhpcyBpcyBhIGdyb3VwIGFuZCB0aGUgdXNlciBoYXMgbm90IG1hbmRhdGVkIGEgcmFuaywgc2V0IHRvIC0xIHNvIHRoYXQgTm9kZXMgdGFrZXNcbiAgICAgICAgICAgICAgICAgICAgLy8gcHJlY2VkZW5jZS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsSW5mby5lbC5faXNKc1BsdW1iR3JvdXAgJiYgZHJvcE9wdGlvbnMucmFuayA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkcm9wT3B0aW9ucy5yYW5rID0gLTE7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBzdG9yZSB0aGUgZGVmaW5pdGlvblxuICAgICAgICAgICAgICAgICAgICB2YXIgX2RlZiA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZjogcm9vdC5qc1BsdW1iLmV4dGVuZCh7fSwgcCksXG4gICAgICAgICAgICAgICAgICAgICAgICB1bmlxdWVFbmRwb2ludDogcC51bmlxdWVFbmRwb2ludCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heENvbm5lY3Rpb25zOiBtYXhDb25uZWN0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuYWJsZWQ6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAocC5jcmVhdGVFbmRwb2ludCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2RlZi51bmlxdWVFbmRwb2ludCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBfZGVmLmVuZHBvaW50ID0gX2N1cnJlbnRJbnN0YW5jZS5hZGRFbmRwb2ludChlbCwgX2RlZi5kZWYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2RlZi5lbmRwb2ludC5zZXREZWxldGVPbkVtcHR5KGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGVsSW5mby5kZWYgPSBfZGVmO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRhcmdldEVuZHBvaW50RGVmaW5pdGlvbnNbZWxpZF1bdHlwZV0gPSBfZGVmO1xuICAgICAgICAgICAgICAgICAgICBfbWFrZUVsZW1lbnREcm9wSGFuZGxlcihlbEluZm8sIHAsIGRyb3BPcHRpb25zLCBwLmlzU291cmNlID09PSB0cnVlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gc3Rhc2ggdGhlIGRlZmluaXRpb24gb24gdGhlIGRyb3BcbiAgICAgICAgICAgICAgICAgICAgZWxJbmZvLmVsLl9rYXRhdm9yaW9Ecm9wW2VsSW5mby5lbC5fa2F0YXZvcmlvRHJvcC5sZW5ndGggLSAxXS50YXJnZXREZWYgPSBfZGVmO1xuXG4gICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpO1xuXG4gICAgICAgICAgICAvLyBtYWtlIGFuIGFycmF5IGlmIG9ubHkgZ2l2ZW4gb25lIGVsZW1lbnRcbiAgICAgICAgICAgIHZhciBpbnB1dHMgPSBlbC5sZW5ndGggJiYgZWwuY29uc3RydWN0b3IgIT09IFN0cmluZyA/IGVsIDogWyBlbCBdO1xuXG4gICAgICAgICAgICAvLyByZWdpc3RlciBlYWNoIG9uZSBpbiB0aGUgbGlzdC5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGlucHV0cy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgX2RvT25lKGlucHV0c1tpXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIHNlZSBhcGkgZG9jc1xuICAgICAgICB0aGlzLnVubWFrZVRhcmdldCA9IGZ1bmN0aW9uIChlbCwgZG9Ob3RDbGVhckFycmF5cykge1xuICAgICAgICAgICAgdmFyIGluZm8gPSBfaW5mbyhlbCk7XG4gICAgICAgICAgICBfY3VycmVudEluc3RhbmNlLmRlc3Ryb3lEcm9wcGFibGUoaW5mby5lbCwgXCJpbnRlcm5hbFwiKTtcbiAgICAgICAgICAgIGlmICghZG9Ob3RDbGVhckFycmF5cykge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnRhcmdldEVuZHBvaW50RGVmaW5pdGlvbnNbaW5mby5pZF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIHNlZSBhcGkgZG9jc1xuICAgICAgICB0aGlzLm1ha2VTb3VyY2UgPSBmdW5jdGlvbiAoZWwsIHBhcmFtcywgcmVmZXJlbmNlUGFyYW1zKSB7XG4gICAgICAgICAgICB2YXIgcCA9IHJvb3QuanNQbHVtYi5leHRlbmQoe19qc1BsdW1iOiB0aGlzfSwgcmVmZXJlbmNlUGFyYW1zKTtcbiAgICAgICAgICAgIHJvb3QuanNQbHVtYi5leHRlbmQocCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHZhciB0eXBlID0gcC5jb25uZWN0aW9uVHlwZSB8fCBcImRlZmF1bHRcIjtcbiAgICAgICAgICAgIHZhciBhYWUgPSBfY3VycmVudEluc3RhbmNlLmRlcml2ZUVuZHBvaW50QW5kQW5jaG9yU3BlYyh0eXBlKTtcbiAgICAgICAgICAgIHAuZW5kcG9pbnQgPSBwLmVuZHBvaW50IHx8IGFhZS5lbmRwb2ludHNbMF07XG4gICAgICAgICAgICBwLmFuY2hvciA9IHAuYW5jaG9yIHx8IGFhZS5hbmNob3JzWzBdO1xuICAgICAgICAgICAgdmFyIG1heENvbm5lY3Rpb25zID0gcC5tYXhDb25uZWN0aW9ucyB8fCAtMSxcbiAgICAgICAgICAgICAgICBvbk1heENvbm5lY3Rpb25zID0gcC5vbk1heENvbm5lY3Rpb25zLFxuICAgICAgICAgICAgICAgIF9kb09uZSA9IGZ1bmN0aW9uIChlbEluZm8pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZ2V0IHRoZSBlbGVtZW50J3MgaWQgYW5kIHN0b3JlIHRoZSBlbmRwb2ludCBkZWZpbml0aW9uIGZvciBpdC4gIGpzUGx1bWIuY29ubmVjdCBjYWxscyB3aWxsIGxvb2sgZm9yIG9uZSBvZiB0aGVzZSxcbiAgICAgICAgICAgICAgICAgICAgLy8gYW5kIHVzZSB0aGUgZW5kcG9pbnQgZGVmaW5pdGlvbiBpZiBmb3VuZC5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsaWQgPSBlbEluZm8uaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBfZGVsID0gdGhpcy5nZXRFbGVtZW50KGVsSW5mby5lbCk7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zb3VyY2VFbmRwb2ludERlZmluaXRpb25zW2VsaWRdID0gdGhpcy5zb3VyY2VFbmRwb2ludERlZmluaXRpb25zW2VsaWRdIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICBfZW5zdXJlQ29udGFpbmVyKGVsaWQpO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBfZGVmID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmOnJvb3QuanNQbHVtYi5leHRlbmQoe30sIHApLFxuICAgICAgICAgICAgICAgICAgICAgICAgdW5pcXVlRW5kcG9pbnQ6IHAudW5pcXVlRW5kcG9pbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhDb25uZWN0aW9uczogbWF4Q29ubmVjdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHAuY3JlYXRlRW5kcG9pbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9kZWYudW5pcXVlRW5kcG9pbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2RlZi5lbmRwb2ludCA9IF9jdXJyZW50SW5zdGFuY2UuYWRkRW5kcG9pbnQoZWwsIF9kZWYuZGVmKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9kZWYuZW5kcG9pbnQuc2V0RGVsZXRlT25FbXB0eShmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNvdXJjZUVuZHBvaW50RGVmaW5pdGlvbnNbZWxpZF1bdHlwZV0gPSBfZGVmO1xuICAgICAgICAgICAgICAgICAgICBlbEluZm8uZGVmID0gX2RlZjtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgc3RvcEV2ZW50ID0gcm9vdC5qc1BsdW1iLmRyYWdFdmVudHMuc3RvcCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyYWdFdmVudCA9IHJvb3QuanNQbHVtYi5kcmFnRXZlbnRzLmRyYWcsXG4gICAgICAgICAgICAgICAgICAgICAgICBkcmFnT3B0aW9ucyA9IHJvb3QuanNQbHVtYi5leHRlbmQoeyB9LCBwLmRyYWdPcHRpb25zIHx8IHt9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nRHJhZyA9IGRyYWdPcHRpb25zLmRyYWcsXG4gICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZ1N0b3AgPSBkcmFnT3B0aW9ucy5zdG9wLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXAgPSBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kcG9pbnRBZGRlZEJ1dE5vRHJhZ1lldCA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIHNldCBzY29wZSBpZiBpdHMgbm90IHNldCBpbiBkcmFnT3B0aW9ucyBidXQgd2FzIHBhc3NlZCBpbiBpbiBwYXJhbXNcbiAgICAgICAgICAgICAgICAgICAgZHJhZ09wdGlvbnMuc2NvcGUgPSBkcmFnT3B0aW9ucy5zY29wZSB8fCBwLnNjb3BlO1xuXG4gICAgICAgICAgICAgICAgICAgIGRyYWdPcHRpb25zW2RyYWdFdmVudF0gPSBfanUud3JhcChkcmFnT3B0aW9uc1tkcmFnRXZlbnRdLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXhpc3RpbmdEcmFnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmdEcmFnLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmRwb2ludEFkZGVkQnV0Tm9EcmFnWWV0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGRyYWdPcHRpb25zW3N0b3BFdmVudF0gPSBfanUud3JhcChkcmFnT3B0aW9uc1tzdG9wRXZlbnRdLCBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleGlzdGluZ1N0b3ApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZ1N0b3AuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudGx5RHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcC5fanNQbHVtYiAhPSBudWxsKSB7IC8vIGlmIG5vdCBjbGVhbmVkIHVwLi4uXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZXNldCB0aGUgYW5jaG9yIHRvIHRoZSBhbmNob3IgdGhhdCB3YXMgaW5pdGlhbGx5IHByb3ZpZGVkLiB0aGUgb25lIHdlIHdlcmUgdXNpbmcgdG8gZHJhZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBjb25uZWN0aW9uIHdhcyBqdXN0IGEgcGxhY2Vob2xkZXIgdGhhdCB3YXMgbG9jYXRlZCBhdCB0aGUgcGxhY2UgdGhlIHVzZXIgcHJlc3NlZCB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBtb3VzZSBidXR0b24gdG8gaW5pdGlhdGUgdGhlIGRyYWcuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFuY2hvckRlZiA9IHAuYW5jaG9yIHx8IHRoaXMuRGVmYXVsdHMuQW5jaG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbGRBbmNob3IgPSBlcC5hbmNob3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9sZENvbm5lY3Rpb24gPSBlcC5jb25uZWN0aW9uc1swXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciAgICBuZXdBbmNob3IgPSB0aGlzLm1ha2VBbmNob3IoYW5jaG9yRGVmLCBlbGlkLCB0aGlzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2VsID0gZXAuZWxlbWVudDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBhbmNob3IgaGFzIGEgJ3Bvc2l0aW9uRmluZGVyJyBzZXQsIHRoZW4gZGVsZWdhdGUgdG8gdGhhdCBmdW5jdGlvbiB0byBmaW5kXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3V0IHdoZXJlIHRvIGxvY2F0ZSB0aGUgYW5jaG9yLiBpc3N1ZSAxMTcuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5ld0FuY2hvci5wb3NpdGlvbkZpbmRlciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbFBvc2l0aW9uID0gX2N1cnJlbnRJbnN0YW5jZS5nZXRPZmZzZXQoX2VsKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsU2l6ZSA9IHRoaXMuZ2V0U2l6ZShfZWwpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHJvcFBvc2l0aW9uID0geyBsZWZ0OiBlbFBvc2l0aW9uLmxlZnQgKyAob2xkQW5jaG9yLnggKiBlbFNpemVbMF0pLCB0b3A6IGVsUG9zaXRpb24udG9wICsgKG9sZEFuY2hvci55ICogZWxTaXplWzFdKSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXAgPSBuZXdBbmNob3IucG9zaXRpb25GaW5kZXIoZHJvcFBvc2l0aW9uLCBlbFBvc2l0aW9uLCBlbFNpemUsIG5ld0FuY2hvci5jb25zdHJ1Y3RvclBhcmFtcyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3QW5jaG9yLnggPSBhcFswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3QW5jaG9yLnkgPSBhcFsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcC5zZXRBbmNob3IobmV3QW5jaG9yLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcC5yZXBhaW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBhaW50KGVwLmVsZW1lbnRJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9sZENvbm5lY3Rpb24gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcGFpbnQob2xkQ29ubmVjdGlvbi50YXJnZXRJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIHdoZW4gdGhlIHVzZXIgcHJlc3NlcyB0aGUgbW91c2UsIGFkZCBhbiBFbmRwb2ludCwgaWYgd2UgYXJlIGVuYWJsZWQuXG4gICAgICAgICAgICAgICAgICAgIHZhciBtb3VzZURvd25MaXN0ZW5lciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvbiByaWdodCBtb3VzZSBidXR0b24sIGFib3J0LlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUud2hpY2ggPT09IDMgfHwgZS5idXR0b24gPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gc3RvcmUgZGVmIG9uIGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVmID0gdGhpcy5zb3VyY2VFbmRwb2ludERlZmluaXRpb25zW2VsaWRdW3R5cGVdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBkaXNhYmxlZCwgcmV0dXJuLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFkZWYuZW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgZWxpZCA9IHRoaXMuZ2V0SWQodGhpcy5nZXRFbGVtZW50KGVsSW5mby5lbCkpOyAvLyBlbGlkIG1pZ2h0IGhhdmUgY2hhbmdlZCBzaW5jZSB0aGlzIG1ldGhvZCB3YXMgY2FsbGVkIHRvIGNvbmZpZ3VyZSB0aGUgZWxlbWVudC5cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgYSBmaWx0ZXIgd2FzIGdpdmVuLCBydW4gaXQsIGFuZCByZXR1cm4gaWYgaXQgc2F5cyBuby5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwLmZpbHRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByID0gX2p1LmlzU3RyaW5nKHAuZmlsdGVyKSA/IHNlbGVjdG9yRmlsdGVyKGUsIGVsSW5mby5lbCwgcC5maWx0ZXIsIHRoaXMsIHAuZmlsdGVyRXhjbHVkZSkgOiBwLmZpbHRlcihlLCBlbEluZm8uZWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBtYXhDb25uZWN0aW9ucyByZWFjaGVkXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc291cmNlQ291bnQgPSB0aGlzLnNlbGVjdCh7c291cmNlOiBlbGlkfSkubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlZi5tYXhDb25uZWN0aW9ucyA+PSAwICYmIChzb3VyY2VDb3VudCA+PSBkZWYubWF4Q29ubmVjdGlvbnMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9uTWF4Q29ubmVjdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25NYXhDb25uZWN0aW9ucyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50OiBlbEluZm8uZWwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXhDb25uZWN0aW9uczogbWF4Q29ubmVjdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZmluZCB0aGUgcG9zaXRpb24gb24gdGhlIGVsZW1lbnQgYXQgd2hpY2ggdGhlIG1vdXNlIHdhcyBwcmVzc2VkOyB0aGlzIGlzIHdoZXJlIHRoZSBlbmRwb2ludFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2lsbCBiZSBsb2NhdGVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVseHkgPSByb290LmpzUGx1bWIuZ2V0UG9zaXRpb25PbkVsZW1lbnQoZSwgX2RlbCwgX3pvb20pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIG92ZXJyaWRlIHRoZSBhbmNob3IgaW4gaGVyZSwgYW5kIGZvcmNlICdpc1NvdXJjZScsIGJ1dCB3ZSBkb24ndCB3YW50IHRvIG1lc3Mgd2l0aFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHBhcmFtcyBwYXNzZWQgaW4sIGJlY2F1c2UgYWZ0ZXIgYSBjb25uZWN0aW9uIGlzIGVzdGFibGlzaGVkIHdlJ3JlIGdvaW5nIHRvIHJlc2V0IHRoZSBlbmRwb2ludFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdG8gaGF2ZSB0aGUgYW5jaG9yIHdlIHdlcmUgZ2l2ZW4uXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGVtcEVuZHBvaW50UGFyYW1zID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICByb290LmpzUGx1bWIuZXh0ZW5kKHRlbXBFbmRwb2ludFBhcmFtcywgcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wRW5kcG9pbnRQYXJhbXMuaXNUZW1wb3JhcnlTb3VyY2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcEVuZHBvaW50UGFyYW1zLmFuY2hvciA9IFsgZWx4eVswXSwgZWx4eVsxXSAsIDAsIDBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcEVuZHBvaW50UGFyYW1zLmRyYWdPcHRpb25zID0gZHJhZ09wdGlvbnM7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZWYuZGVmLnNjb3BlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcEVuZHBvaW50UGFyYW1zLnNjb3BlID0gZGVmLmRlZi5zY29wZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgZXAgPSB0aGlzLmFkZEVuZHBvaW50KGVsaWQsIHRlbXBFbmRwb2ludFBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmRwb2ludEFkZGVkQnV0Tm9EcmFnWWV0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVwLnNldERlbGV0ZU9uRW1wdHkodHJ1ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHVuaXF1ZSBlbmRwb2ludCBhbmQgaXQncyBhbHJlYWR5IGJlZW4gY3JlYXRlZCwgcHVzaCBpdCBvbnRvIHRoZSBlbmRwb2ludCB3ZSBjcmVhdGUuIGF0IHRoZSBlbmRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9mIGEgc3VjY2Vzc2Z1bCBjb25uZWN0aW9uIHdlJ2xsIHN3aXRjaCB0byB0aGF0IGVuZHBvaW50LlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyB0aGlzIGlzIHRoZSBzYW1lIGNvZGUgYXMgdGhlIHByb2dyYW1tYXRpYyBlbmRwb2ludHMgY3JlYXRlIG9uIGxpbmUgMTA1MCBpc2hcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZWYudW5pcXVlRW5kcG9pbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWRlZi5lbmRwb2ludCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWYuZW5kcG9pbnQgPSBlcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXAuc2V0RGVsZXRlT25FbXB0eShmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcC5maW5hbEVuZHBvaW50ID0gZGVmLmVuZHBvaW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9kZWxUZW1wRW5kcG9pbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBtb3VzZXVwIGV2ZW50IGlzIGZpcmVkIG9ubHkgaWYgbm8gZHJhZ2dpbmcgb2NjdXJyZWQsIGJ5IGpxdWVyeSBhbmQgeXVpLCBidXQgZm9yIG1vb3Rvb2xzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXQgaXMgZmlyZWQgZXZlbiBpZiBkcmFnZ2luZyBoYXMgb2NjdXJyZWQsIGluIHdoaWNoIGNhc2Ugd2Ugd291bGQgYmxvdyBhd2F5IGEgcGVyZmVjdGx5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbGVnaXRpbWF0ZSBlbmRwb2ludCwgd2VyZSBpdCBub3QgZm9yIHRoaXMgY2hlY2suICB0aGUgZmxhZyBpcyBzZXQgYWZ0ZXIgYWRkaW5nIGFuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZW5kcG9pbnQgYW5kIGNsZWFyZWQgaW4gYSBkcmFnIGxpc3RlbmVyIHdlIHNldCBpbiB0aGUgZHJhZ09wdGlvbnMgYWJvdmUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2N1cnJlbnRJbnN0YW5jZS5vZmYoZXAuY2FudmFzLCBcIm1vdXNldXBcIiwgX2RlbFRlbXBFbmRwb2ludCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2N1cnJlbnRJbnN0YW5jZS5vZmYoZWxJbmZvLmVsLCBcIm1vdXNldXBcIiwgX2RlbFRlbXBFbmRwb2ludCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVuZHBvaW50QWRkZWRCdXROb0RyYWdZZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kcG9pbnRBZGRlZEJ1dE5vRHJhZ1lldCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY3VycmVudEluc3RhbmNlLmRlbGV0ZUVuZHBvaW50KGVwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBfY3VycmVudEluc3RhbmNlLm9uKGVwLmNhbnZhcywgXCJtb3VzZXVwXCIsIF9kZWxUZW1wRW5kcG9pbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2N1cnJlbnRJbnN0YW5jZS5vbihlbEluZm8uZWwsIFwibW91c2V1cFwiLCBfZGVsVGVtcEVuZHBvaW50KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3B0aW9uYWxseSBjaGVjayBmb3IgYXR0cmlidXRlcyB0byBleHRyYWN0IGZyb20gdGhlIHNvdXJjZSBlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGF5bG9hZCA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlZi5kZWYuZXh0cmFjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGF0dCBpbiBkZWYuZGVmLmV4dHJhY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHYgPSAoZS5zcmNFbGVtZW50IHx8IGUudGFyZ2V0KS5nZXRBdHRyaWJ1dGUoYXR0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWRbZGVmLmRlZi5leHRyYWN0W2F0dF1dID0gdjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW5kIHRoZW4gdHJpZ2dlciBpdHMgbW91c2Vkb3duIGV2ZW50LCB3aGljaCB3aWxsIGtpY2sgb2ZmIGEgZHJhZywgd2hpY2ggd2lsbCBzdGFydCBkcmFnZ2luZ1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYSBuZXcgY29ubmVjdGlvbiBmcm9tIHRoaXMgZW5kcG9pbnQuXG4gICAgICAgICAgICAgICAgICAgICAgICBfY3VycmVudEluc3RhbmNlLnRyaWdnZXIoZXAuY2FudmFzLCBcIm1vdXNlZG93blwiLCBlLCBwYXlsb2FkKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgX2p1LmNvbnN1bWUoZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpO1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub24oZWxJbmZvLmVsLCBcIm1vdXNlZG93blwiLCBtb3VzZURvd25MaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgICAgIF9kZWYudHJpZ2dlciA9IG1vdXNlRG93bkxpc3RlbmVyO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIGEgZmlsdGVyIHdhcyBwcm92aWRlZCwgc2V0IGl0IGFzIGEgZHJhZ0ZpbHRlciBvbiB0aGUgZWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgLy8gdG8gcHJldmVudCB0aGUgZWxlbWVudCBkcmFnIGZ1bmN0aW9uIGZyb20ga2lja2luZyBpbiB3aGVuIHdlIHdhbnQgdG9cbiAgICAgICAgICAgICAgICAgICAgLy8gZHJhZyBhIG5ldyBjb25uZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgIGlmIChwLmZpbHRlciAmJiAoX2p1LmlzU3RyaW5nKHAuZmlsdGVyKSB8fCBfanUuaXNGdW5jdGlvbihwLmZpbHRlcikpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfY3VycmVudEluc3RhbmNlLnNldERyYWdGaWx0ZXIoZWxJbmZvLmVsLCBwLmZpbHRlcik7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB2YXIgZHJvcE9wdGlvbnMgPSByb290LmpzUGx1bWIuZXh0ZW5kKHt9LCBwLmRyb3BPcHRpb25zIHx8IHt9KTtcblxuICAgICAgICAgICAgICAgICAgICBfbWFrZUVsZW1lbnREcm9wSGFuZGxlcihlbEluZm8sIHAsIGRyb3BPcHRpb25zLCB0cnVlLCBwLmlzVGFyZ2V0ID09PSB0cnVlKTtcblxuICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKTtcblxuICAgICAgICAgICAgdmFyIGlucHV0cyA9IGVsLmxlbmd0aCAmJiBlbC5jb25zdHJ1Y3RvciAhPT0gU3RyaW5nID8gZWwgOiBbIGVsIF07XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBpbnB1dHMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgICAgIF9kb09uZShfaW5mbyhpbnB1dHNbaV0pKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gc2VlIGFwaSBkb2NzXG4gICAgICAgIHRoaXMudW5tYWtlU291cmNlID0gZnVuY3Rpb24gKGVsLCBjb25uZWN0aW9uVHlwZSwgZG9Ob3RDbGVhckFycmF5cykge1xuICAgICAgICAgICAgdmFyIGluZm8gPSBfaW5mbyhlbCk7XG4gICAgICAgICAgICBfY3VycmVudEluc3RhbmNlLmRlc3Ryb3lEcm9wcGFibGUoaW5mby5lbCwgXCJpbnRlcm5hbFwiKTtcbiAgICAgICAgICAgIHZhciBlbGRlZnMgPSB0aGlzLnNvdXJjZUVuZHBvaW50RGVmaW5pdGlvbnNbaW5mby5pZF07XG4gICAgICAgICAgICBpZiAoZWxkZWZzKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgZGVmIGluIGVsZGVmcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29ubmVjdGlvblR5cGUgPT0gbnVsbCB8fCBjb25uZWN0aW9uVHlwZSA9PT0gZGVmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbW91c2VEb3duTGlzdGVuZXIgPSBlbGRlZnNbZGVmXS50cmlnZ2VyO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1vdXNlRG93bkxpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2N1cnJlbnRJbnN0YW5jZS5vZmYoaW5mby5lbCwgXCJtb3VzZWRvd25cIiwgbW91c2VEb3duTGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFkb05vdENsZWFyQXJyYXlzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuc291cmNlRW5kcG9pbnREZWZpbml0aW9uc1tpbmZvLmlkXVtkZWZdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBzZWUgYXBpIGRvY3NcbiAgICAgICAgdGhpcy51bm1ha2VFdmVyeVNvdXJjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5zb3VyY2VFbmRwb2ludERlZmluaXRpb25zKSB7XG4gICAgICAgICAgICAgICAgX2N1cnJlbnRJbnN0YW5jZS51bm1ha2VTb3VyY2UoaSwgbnVsbCwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuc291cmNlRW5kcG9pbnREZWZpbml0aW9ucyA9IHt9O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIF9nZXRTY29wZSA9IGZ1bmN0aW9uIChlbCwgdHlwZXMsIGNvbm5lY3Rpb25UeXBlKSB7XG4gICAgICAgICAgICB0eXBlcyA9IF9qdS5pc0FycmF5KHR5cGVzKSA/IHR5cGVzIDogWyB0eXBlcyBdO1xuICAgICAgICAgICAgdmFyIGlkID0gX2dldElkKGVsKTtcbiAgICAgICAgICAgIGNvbm5lY3Rpb25UeXBlID0gY29ubmVjdGlvblR5cGUgfHwgXCJkZWZhdWx0XCI7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsZGVmcyA9IHRoaXNbdHlwZXNbaV1dW2lkXTtcbiAgICAgICAgICAgICAgICBpZiAoZWxkZWZzICYmIGVsZGVmc1tjb25uZWN0aW9uVHlwZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZGVmc1tjb25uZWN0aW9uVHlwZV0uZGVmLnNjb3BlIHx8IHRoaXMuRGVmYXVsdHMuU2NvcGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LmJpbmQodGhpcyk7XG5cbiAgICAgICAgdmFyIF9zZXRTY29wZSA9IGZ1bmN0aW9uIChlbCwgc2NvcGUsIHR5cGVzLCBjb25uZWN0aW9uVHlwZSkge1xuICAgICAgICAgICAgdHlwZXMgPSBfanUuaXNBcnJheSh0eXBlcykgPyB0eXBlcyA6IFsgdHlwZXMgXTtcbiAgICAgICAgICAgIHZhciBpZCA9IF9nZXRJZChlbCk7XG4gICAgICAgICAgICBjb25uZWN0aW9uVHlwZSA9IGNvbm5lY3Rpb25UeXBlIHx8IFwiZGVmYXVsdFwiO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBlbGRlZnMgPSB0aGlzW3R5cGVzW2ldXVtpZF07XG4gICAgICAgICAgICAgICAgaWYgKGVsZGVmcyAmJiBlbGRlZnNbY29ubmVjdGlvblR5cGVdKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZGVmc1tjb25uZWN0aW9uVHlwZV0uZGVmLnNjb3BlID0gc2NvcGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0uYmluZCh0aGlzKTtcblxuICAgICAgICB0aGlzLmdldFNjb3BlID0gZnVuY3Rpb24gKGVsLCBzY29wZSkge1xuICAgICAgICAgICAgcmV0dXJuIF9nZXRTY29wZShlbCwgWyBcInNvdXJjZUVuZHBvaW50RGVmaW5pdGlvbnNcIiwgXCJ0YXJnZXRFbmRwb2ludERlZmluaXRpb25zXCIgXSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ2V0U291cmNlU2NvcGUgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIHJldHVybiBfZ2V0U2NvcGUoZWwsIFwic291cmNlRW5kcG9pbnREZWZpbml0aW9uc1wiKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5nZXRUYXJnZXRTY29wZSA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgcmV0dXJuIF9nZXRTY29wZShlbCwgXCJ0YXJnZXRFbmRwb2ludERlZmluaXRpb25zXCIpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNldFNjb3BlID0gZnVuY3Rpb24gKGVsLCBzY29wZSwgY29ubmVjdGlvblR5cGUpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U291cmNlU2NvcGUoZWwsIHNjb3BlLCBjb25uZWN0aW9uVHlwZSk7XG4gICAgICAgICAgICB0aGlzLnNldFRhcmdldFNjb3BlKGVsLCBzY29wZSwgY29ubmVjdGlvblR5cGUpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNldFNvdXJjZVNjb3BlID0gZnVuY3Rpb24gKGVsLCBzY29wZSwgY29ubmVjdGlvblR5cGUpIHtcbiAgICAgICAgICAgIF9zZXRTY29wZShlbCwgc2NvcGUsIFwic291cmNlRW5kcG9pbnREZWZpbml0aW9uc1wiLCBjb25uZWN0aW9uVHlwZSk7XG4gICAgICAgICAgICAvLyB3ZSBnZXQgdGhlIHNvdXJjZSBzY29wZSBkdXJpbmcgdGhlIG1vdXNlZG93biBldmVudCwgYnV0IHdlIGFsc28gd2FudCB0byBzZXQgdGhpcy5cbiAgICAgICAgICAgIHRoaXMuc2V0RHJhZ1Njb3BlKGVsLCBzY29wZSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc2V0VGFyZ2V0U2NvcGUgPSBmdW5jdGlvbiAoZWwsIHNjb3BlLCBjb25uZWN0aW9uVHlwZSkge1xuICAgICAgICAgICAgX3NldFNjb3BlKGVsLCBzY29wZSwgXCJ0YXJnZXRFbmRwb2ludERlZmluaXRpb25zXCIsIGNvbm5lY3Rpb25UeXBlKTtcbiAgICAgICAgICAgIHRoaXMuc2V0RHJvcFNjb3BlKGVsLCBzY29wZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gc2VlIGFwaSBkb2NzXG4gICAgICAgIHRoaXMudW5tYWtlRXZlcnlUYXJnZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpIGluIHRoaXMudGFyZ2V0RW5kcG9pbnREZWZpbml0aW9ucykge1xuICAgICAgICAgICAgICAgIF9jdXJyZW50SW5zdGFuY2UudW5tYWtlVGFyZ2V0KGksIHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnRhcmdldEVuZHBvaW50RGVmaW5pdGlvbnMgPSB7fTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGRvZXMgdGhlIHdvcmsgb2Ygc2V0dGluZyBhIHNvdXJjZSBlbmFibGVkIG9yIGRpc2FibGVkLlxuICAgICAgICB2YXIgX3NldEVuYWJsZWQgPSBmdW5jdGlvbiAodHlwZSwgZWwsIHN0YXRlLCB0b2dnbGUsIGNvbm5lY3Rpb25UeXBlKSB7XG4gICAgICAgICAgICB2YXIgYSA9IHR5cGUgPT09IFwic291cmNlXCIgPyB0aGlzLnNvdXJjZUVuZHBvaW50RGVmaW5pdGlvbnMgOiB0aGlzLnRhcmdldEVuZHBvaW50RGVmaW5pdGlvbnMsXG4gICAgICAgICAgICAgICAgb3JpZ2luYWxTdGF0ZSwgaW5mbywgbmV3U3RhdGU7XG5cbiAgICAgICAgICAgIGNvbm5lY3Rpb25UeXBlID0gY29ubmVjdGlvblR5cGUgfHwgXCJkZWZhdWx0XCI7XG5cbiAgICAgICAgICAgIC8vIGEgc2VsZWN0b3Igb3IgYW4gYXJyYXlcbiAgICAgICAgICAgIGlmIChlbC5sZW5ndGggJiYgIV9qdS5pc1N0cmluZyhlbCkpIHtcbiAgICAgICAgICAgICAgICBvcmlnaW5hbFN0YXRlID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gZWwubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpbmZvID0gX2luZm8oZWxbaV0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYVtpbmZvLmlkXSAmJiBhW2luZm8uaWRdW2Nvbm5lY3Rpb25UeXBlXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxTdGF0ZVtpXSA9IGFbaW5mby5pZF1bY29ubmVjdGlvblR5cGVdLmVuYWJsZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdTdGF0ZSA9IHRvZ2dsZSA/ICFvcmlnaW5hbFN0YXRlW2ldIDogc3RhdGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBhW2luZm8uaWRdW2Nvbm5lY3Rpb25UeXBlXS5lbmFibGVkID0gbmV3U3RhdGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBfY3VycmVudEluc3RhbmNlW25ld1N0YXRlID8gXCJyZW1vdmVDbGFzc1wiIDogXCJhZGRDbGFzc1wiXShpbmZvLmVsLCBcImp0ay1cIiArIHR5cGUgKyBcIi1kaXNhYmxlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG90aGVyd2lzZSBhIERPTSBlbGVtZW50IG9yIGEgU3RyaW5nIElELlxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5mbyA9IF9pbmZvKGVsKTtcbiAgICAgICAgICAgICAgICB2YXIgaWQgPSBpbmZvLmlkO1xuICAgICAgICAgICAgICAgIGlmIChhW2lkXSAmJiBhW2lkXVtjb25uZWN0aW9uVHlwZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxTdGF0ZSA9IGFbaWRdW2Nvbm5lY3Rpb25UeXBlXS5lbmFibGVkO1xuICAgICAgICAgICAgICAgICAgICBuZXdTdGF0ZSA9IHRvZ2dsZSA/ICFvcmlnaW5hbFN0YXRlIDogc3RhdGU7XG4gICAgICAgICAgICAgICAgICAgIGFbaWRdW2Nvbm5lY3Rpb25UeXBlXS5lbmFibGVkID0gbmV3U3RhdGU7XG4gICAgICAgICAgICAgICAgICAgIF9jdXJyZW50SW5zdGFuY2VbbmV3U3RhdGUgPyBcInJlbW92ZUNsYXNzXCIgOiBcImFkZENsYXNzXCJdKGluZm8uZWwsIFwianRrLVwiICsgdHlwZSArIFwiLWRpc2FibGVkXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbFN0YXRlO1xuICAgICAgICB9LmJpbmQodGhpcyk7XG5cbiAgICAgICAgdmFyIF9maXJzdCA9IGZ1bmN0aW9uIChlbCwgZm4pIHtcbiAgICAgICAgICAgIGlmIChfanUuaXNTdHJpbmcoZWwpIHx8ICFlbC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgWyBlbCBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGVsLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBbIGVsWzBdIF0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0uYmluZCh0aGlzKTtcblxuICAgICAgICB0aGlzLnRvZ2dsZVNvdXJjZUVuYWJsZWQgPSBmdW5jdGlvbiAoZWwsIGNvbm5lY3Rpb25UeXBlKSB7XG4gICAgICAgICAgICBfc2V0RW5hYmxlZChcInNvdXJjZVwiLCBlbCwgbnVsbCwgdHJ1ZSwgY29ubmVjdGlvblR5cGUpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXNTb3VyY2VFbmFibGVkKGVsLCBjb25uZWN0aW9uVHlwZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5zZXRTb3VyY2VFbmFibGVkID0gZnVuY3Rpb24gKGVsLCBzdGF0ZSwgY29ubmVjdGlvblR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiBfc2V0RW5hYmxlZChcInNvdXJjZVwiLCBlbCwgc3RhdGUsIG51bGwsIGNvbm5lY3Rpb25UeXBlKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5pc1NvdXJjZSA9IGZ1bmN0aW9uIChlbCwgY29ubmVjdGlvblR5cGUpIHtcbiAgICAgICAgICAgIGNvbm5lY3Rpb25UeXBlID0gY29ubmVjdGlvblR5cGUgfHwgXCJkZWZhdWx0XCI7XG4gICAgICAgICAgICByZXR1cm4gX2ZpcnN0KGVsLCBmdW5jdGlvbiAoX2VsKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsZGVmcyA9IHRoaXMuc291cmNlRW5kcG9pbnREZWZpbml0aW9uc1tfaW5mbyhfZWwpLmlkXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWxkZWZzICE9IG51bGwgJiYgZWxkZWZzW2Nvbm5lY3Rpb25UeXBlXSAhPSBudWxsO1xuICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5pc1NvdXJjZUVuYWJsZWQgPSBmdW5jdGlvbiAoZWwsIGNvbm5lY3Rpb25UeXBlKSB7XG4gICAgICAgICAgICBjb25uZWN0aW9uVHlwZSA9IGNvbm5lY3Rpb25UeXBlIHx8IFwiZGVmYXVsdFwiO1xuICAgICAgICAgICAgcmV0dXJuIF9maXJzdChlbCwgZnVuY3Rpb24gKF9lbCkge1xuICAgICAgICAgICAgICAgIHZhciBzZXAgPSB0aGlzLnNvdXJjZUVuZHBvaW50RGVmaW5pdGlvbnNbX2luZm8oX2VsKS5pZF07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlcCAmJiBzZXBbY29ubmVjdGlvblR5cGVdICYmIHNlcFtjb25uZWN0aW9uVHlwZV0uZW5hYmxlZCA9PT0gdHJ1ZTtcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy50b2dnbGVUYXJnZXRFbmFibGVkID0gZnVuY3Rpb24gKGVsLCBjb25uZWN0aW9uVHlwZSkge1xuICAgICAgICAgICAgX3NldEVuYWJsZWQoXCJ0YXJnZXRcIiwgZWwsIG51bGwsIHRydWUsIGNvbm5lY3Rpb25UeXBlKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlzVGFyZ2V0RW5hYmxlZChlbCwgY29ubmVjdGlvblR5cGUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuaXNUYXJnZXQgPSBmdW5jdGlvbiAoZWwsIGNvbm5lY3Rpb25UeXBlKSB7XG4gICAgICAgICAgICBjb25uZWN0aW9uVHlwZSA9IGNvbm5lY3Rpb25UeXBlIHx8IFwiZGVmYXVsdFwiO1xuICAgICAgICAgICAgcmV0dXJuIF9maXJzdChlbCwgZnVuY3Rpb24gKF9lbCkge1xuICAgICAgICAgICAgICAgIHZhciBlbGRlZnMgPSB0aGlzLnRhcmdldEVuZHBvaW50RGVmaW5pdGlvbnNbX2luZm8oX2VsKS5pZF07XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsZGVmcyAhPSBudWxsICYmIGVsZGVmc1tjb25uZWN0aW9uVHlwZV0gIT0gbnVsbDtcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaXNUYXJnZXRFbmFibGVkID0gZnVuY3Rpb24gKGVsLCBjb25uZWN0aW9uVHlwZSkge1xuICAgICAgICAgICAgY29ubmVjdGlvblR5cGUgPSBjb25uZWN0aW9uVHlwZSB8fCBcImRlZmF1bHRcIjtcbiAgICAgICAgICAgIHJldHVybiBfZmlyc3QoZWwsIGZ1bmN0aW9uIChfZWwpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGVwID0gdGhpcy50YXJnZXRFbmRwb2ludERlZmluaXRpb25zW19pbmZvKF9lbCkuaWRdO1xuICAgICAgICAgICAgICAgIHJldHVybiB0ZXAgJiYgdGVwW2Nvbm5lY3Rpb25UeXBlXSAmJiB0ZXBbY29ubmVjdGlvblR5cGVdLmVuYWJsZWQgPT09IHRydWU7XG4gICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNldFRhcmdldEVuYWJsZWQgPSBmdW5jdGlvbiAoZWwsIHN0YXRlLCBjb25uZWN0aW9uVHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIF9zZXRFbmFibGVkKFwidGFyZ2V0XCIsIGVsLCBzdGF0ZSwgbnVsbCwgY29ubmVjdGlvblR5cGUpO1xuICAgICAgICB9O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0gZW5kIG1ha2VTb3VyY2UvbWFrZVRhcmdldCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgdGhpcy5yZWFkeSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgX2N1cnJlbnRJbnN0YW5jZS5iaW5kKFwicmVhZHlcIiwgZm4pO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBfZWxFYWNoID0gZnVuY3Rpb24oZWwsIGZuKSB7XG4gICAgICAgICAgICAvLyBzdXBwb3J0IGJvdGggbGlzdHMuLi5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgZWwgPT09ICdvYmplY3QnICYmIGVsLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGVsLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZm4oZWxbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Ugey8vIC4uLmFuZCBzaW5nbGUgc3RyaW5ncyBvciBlbGVtZW50cy5cbiAgICAgICAgICAgICAgICBmbihlbCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBfY3VycmVudEluc3RhbmNlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIHJlcGFpbnQgc29tZSBlbGVtZW50J3MgZW5kcG9pbnRzIGFuZCBjb25uZWN0aW9uc1xuICAgICAgICB0aGlzLnJlcGFpbnQgPSBmdW5jdGlvbiAoZWwsIHVpLCB0aW1lc3RhbXApIHtcbiAgICAgICAgICAgIHJldHVybiBfZWxFYWNoKGVsLCBmdW5jdGlvbihfZWwpIHtcbiAgICAgICAgICAgICAgICBfZHJhdyhfZWwsIHVpLCB0aW1lc3RhbXApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5yZXZhbGlkYXRlID0gZnVuY3Rpb24gKGVsLCB0aW1lc3RhbXAsIGlzSWRBbHJlYWR5KSB7XG4gICAgICAgICAgICByZXR1cm4gX2VsRWFjaChlbCwgZnVuY3Rpb24oX2VsKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsSWQgPSBpc0lkQWxyZWFkeSA/IF9lbCA6IF9jdXJyZW50SW5zdGFuY2UuZ2V0SWQoX2VsKTtcbiAgICAgICAgICAgICAgICBfY3VycmVudEluc3RhbmNlLnVwZGF0ZU9mZnNldCh7IGVsSWQ6IGVsSWQsIHJlY2FsYzogdHJ1ZSwgdGltZXN0YW1wOnRpbWVzdGFtcCB9KTtcbiAgICAgICAgICAgICAgICB2YXIgZG0gPSBfY3VycmVudEluc3RhbmNlLmdldERyYWdNYW5hZ2VyKCk7XG4gICAgICAgICAgICAgICAgaWYgKGRtKSB7XG4gICAgICAgICAgICAgICAgICAgIGRtLnVwZGF0ZU9mZnNldHMoZWxJZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF9jdXJyZW50SW5zdGFuY2UucmVwYWludChfZWwpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gcmVwYWludCBldmVyeSBlbmRwb2ludCBhbmQgY29ubmVjdGlvbi5cbiAgICAgICAgdGhpcy5yZXBhaW50RXZlcnl0aGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIFRPRE8gdGhpcyB0aW1lc3RhbXAgY2F1c2VzIGNvbnRpbnVvdXMgYW5jaG9ycyB0byBub3QgcmVwYWludCBwcm9wZXJseS5cbiAgICAgICAgICAgIC8vIGZpeCB0aGlzLiBkbyBub3QganVzdCB0YWtlIG91dCB0aGUgdGltZXN0YW1wLiBpdCBydW5zIGEgbG90IGZhc3RlciB3aXRoXG4gICAgICAgICAgICAvLyB0aGUgdGltZXN0YW1wIGluY2x1ZGVkLlxuICAgICAgICAgICAgdmFyIHRpbWVzdGFtcCA9IF90aW1lc3RhbXAoKSwgZWxJZDtcblxuICAgICAgICAgICAgZm9yIChlbElkIGluIGVuZHBvaW50c0J5RWxlbWVudCkge1xuICAgICAgICAgICAgICAgIF9jdXJyZW50SW5zdGFuY2UudXBkYXRlT2Zmc2V0KHsgZWxJZDogZWxJZCwgcmVjYWxjOiB0cnVlLCB0aW1lc3RhbXA6IHRpbWVzdGFtcCB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChlbElkIGluIGVuZHBvaW50c0J5RWxlbWVudCkge1xuICAgICAgICAgICAgICAgIF9kcmF3KGVsSWQsIG51bGwsIHRpbWVzdGFtcCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMucmVtb3ZlQWxsRW5kcG9pbnRzID0gZnVuY3Rpb24gKGVsLCByZWN1cnNlLCBhZmZlY3RlZEVsZW1lbnRzKSB7XG4gICAgICAgICAgICBhZmZlY3RlZEVsZW1lbnRzID0gYWZmZWN0ZWRFbGVtZW50cyB8fCBbXTtcbiAgICAgICAgICAgIHZhciBfb25lID0gZnVuY3Rpb24gKF9lbCkge1xuICAgICAgICAgICAgICAgIHZhciBpbmZvID0gX2luZm8oX2VsKSxcbiAgICAgICAgICAgICAgICAgICAgZWJlID0gZW5kcG9pbnRzQnlFbGVtZW50W2luZm8uaWRdLFxuICAgICAgICAgICAgICAgICAgICBpLCBpaTtcblxuICAgICAgICAgICAgICAgIGlmIChlYmUpIHtcbiAgICAgICAgICAgICAgICAgICAgYWZmZWN0ZWRFbGVtZW50cy5wdXNoKGluZm8pO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBpaSA9IGViZS5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfY3VycmVudEluc3RhbmNlLmRlbGV0ZUVuZHBvaW50KGViZVtpXSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlbGV0ZSBlbmRwb2ludHNCeUVsZW1lbnRbaW5mby5pZF07XG5cbiAgICAgICAgICAgICAgICBpZiAocmVjdXJzZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5mby5lbCAmJiBpbmZvLmVsLm5vZGVUeXBlICE9PSAzICYmIGluZm8uZWwubm9kZVR5cGUgIT09IDgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGlpID0gaW5mby5lbC5jaGlsZE5vZGVzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfb25lKGluZm8uZWwuY2hpbGROb2Rlc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBfb25lKGVsKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBfZG9SZW1vdmUgPSBmdW5jdGlvbihpbmZvLCBhZmZlY3RlZEVsZW1lbnRzKSB7XG4gICAgICAgICAgICBfY3VycmVudEluc3RhbmNlLnJlbW92ZUFsbEVuZHBvaW50cyhpbmZvLmlkLCB0cnVlLCBhZmZlY3RlZEVsZW1lbnRzKTtcbiAgICAgICAgICAgIHZhciBkbSA9IF9jdXJyZW50SW5zdGFuY2UuZ2V0RHJhZ01hbmFnZXIoKTtcbiAgICAgICAgICAgIHZhciBfb25lID0gZnVuY3Rpb24oX2luZm8pIHtcblxuICAgICAgICAgICAgICAgIGlmIChkbSkge1xuICAgICAgICAgICAgICAgICAgICBkbS5lbGVtZW50UmVtb3ZlZChfaW5mby5pZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF9jdXJyZW50SW5zdGFuY2UuYW5jaG9yTWFuYWdlci5jbGVhckZvcihfaW5mby5pZCk7XG4gICAgICAgICAgICAgICAgX2N1cnJlbnRJbnN0YW5jZS5hbmNob3JNYW5hZ2VyLnJlbW92ZUZsb2F0aW5nQ29ubmVjdGlvbihfaW5mby5pZCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoX2N1cnJlbnRJbnN0YW5jZS5pc1NvdXJjZShfaW5mby5lbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgX2N1cnJlbnRJbnN0YW5jZS51bm1ha2VTb3VyY2UoX2luZm8uZWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoX2N1cnJlbnRJbnN0YW5jZS5pc1RhcmdldChfaW5mby5lbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgX2N1cnJlbnRJbnN0YW5jZS51bm1ha2VUYXJnZXQoX2luZm8uZWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfY3VycmVudEluc3RhbmNlLmRlc3Ryb3lEcmFnZ2FibGUoX2luZm8uZWwpO1xuICAgICAgICAgICAgICAgIF9jdXJyZW50SW5zdGFuY2UuZGVzdHJveURyb3BwYWJsZShfaW5mby5lbCk7XG5cblxuICAgICAgICAgICAgICAgIGRlbGV0ZSBfY3VycmVudEluc3RhbmNlLmZsb2F0aW5nQ29ubmVjdGlvbnNbX2luZm8uaWRdO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBtYW5hZ2VkRWxlbWVudHNbX2luZm8uaWRdO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBvZmZzZXRzW19pbmZvLmlkXTtcbiAgICAgICAgICAgICAgICBpZiAoX2luZm8uZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgX2N1cnJlbnRJbnN0YW5jZS5yZW1vdmVFbGVtZW50KF9pbmZvLmVsKTtcbiAgICAgICAgICAgICAgICAgICAgX2luZm8uZWwuX2pzUGx1bWIgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIHJlbW92ZSBhbGwgYWZmZWN0ZWQgY2hpbGQgZWxlbWVudHNcbiAgICAgICAgICAgIGZvciAodmFyIGFlID0gMTsgYWUgPCBhZmZlY3RlZEVsZW1lbnRzLmxlbmd0aDsgYWUrKykge1xuICAgICAgICAgICAgICAgIF9vbmUoYWZmZWN0ZWRFbGVtZW50c1thZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYW5kIGFsd2F5cyByZW1vdmUgdGhlIHJlcXVlc3RlZCBvbmUgZnJvbSB0aGUgZG9tLlxuICAgICAgICAgICAgX29uZShpbmZvKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVtb3ZlIHRoZSBnaXZlbiBlbGVtZW50LCBpbmNsdWRpbmcgY2xlYW5pbmcgdXAgYWxsIGVuZHBvaW50cyByZWdpc3RlcmVkIGZvciBpdC5cbiAgICAgICAgICogVGhpcyBpcyBleHBvc2VkIGluIHRoZSBwdWJsaWMgQVBJIGJ1dCBhbHNvIHVzZWQgaW50ZXJuYWxseSBieSBqc1BsdW1iIHdoZW4gcmVtb3ZpbmcgdGhlXG4gICAgICAgICAqIGVsZW1lbnQgYXNzb2NpYXRlZCB3aXRoIGEgY29ubmVjdGlvbiBkcmFnLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZW1vdmUgPSBmdW5jdGlvbiAoZWwsIGRvTm90UmVwYWludCkge1xuICAgICAgICAgICAgdmFyIGluZm8gPSBfaW5mbyhlbCksIGFmZmVjdGVkRWxlbWVudHMgPSBbXTtcbiAgICAgICAgICAgIGlmIChpbmZvLnRleHQpIHtcbiAgICAgICAgICAgICAgICBpbmZvLmVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoaW5mby5lbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpbmZvLmlkKSB7XG4gICAgICAgICAgICAgICAgX2N1cnJlbnRJbnN0YW5jZS5iYXRjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIF9kb1JlbW92ZShpbmZvLCBhZmZlY3RlZEVsZW1lbnRzKTtcbiAgICAgICAgICAgICAgICB9LCBkb05vdFJlcGFpbnQgPT09IGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfY3VycmVudEluc3RhbmNlO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuZW1wdHkgPSBmdW5jdGlvbiAoZWwsIGRvTm90UmVwYWludCkge1xuICAgICAgICAgICAgdmFyIGFmZmVjdGVkRWxlbWVudHMgPSBbXTtcbiAgICAgICAgICAgIHZhciBfb25lID0gZnVuY3Rpb24oZWwsIGRvbnRSZW1vdmVGb2N1cykge1xuICAgICAgICAgICAgICAgIHZhciBpbmZvID0gX2luZm8oZWwpO1xuICAgICAgICAgICAgICAgIGlmIChpbmZvLnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5mby5lbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGluZm8uZWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpbmZvLmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlKGluZm8uZWwuY2hpbGROb2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfb25lKGluZm8uZWwuY2hpbGROb2Rlc1swXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkb250UmVtb3ZlRm9jdXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9kb1JlbW92ZShpbmZvLCBhZmZlY3RlZEVsZW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIF9jdXJyZW50SW5zdGFuY2UuYmF0Y2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgX29uZShlbCwgdHJ1ZSk7XG4gICAgICAgICAgICB9LCBkb05vdFJlcGFpbnQgPT09IGZhbHNlKTtcblxuICAgICAgICAgICAgcmV0dXJuIF9jdXJyZW50SW5zdGFuY2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF9jdXJyZW50SW5zdGFuY2Uuc2lsZW50bHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgX2hvdmVyU3VzcGVuZGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgX2N1cnJlbnRJbnN0YW5jZS5yZW1vdmVBbGxHcm91cHMoKTtcbiAgICAgICAgICAgICAgICBfY3VycmVudEluc3RhbmNlLnJlbW92ZUdyb3VwTWFuYWdlcigpO1xuICAgICAgICAgICAgICAgIF9jdXJyZW50SW5zdGFuY2UuZGVsZXRlRXZlcnlFbmRwb2ludCgpO1xuICAgICAgICAgICAgICAgIF9jdXJyZW50SW5zdGFuY2UudW5iaW5kKCk7XG4gICAgICAgICAgICAgICAgdGhpcy50YXJnZXRFbmRwb2ludERlZmluaXRpb25zID0ge307XG4gICAgICAgICAgICAgICAgdGhpcy5zb3VyY2VFbmRwb2ludERlZmluaXRpb25zID0ge307XG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbnMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kb1Jlc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9SZXNldCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIF9jbGVhck9iamVjdCA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgIGlmIChvYmouY2FudmFzICYmIG9iai5jYW52YXMucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgIG9iai5jYW52YXMucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChvYmouY2FudmFzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9iai5jbGVhbnVwKCk7XG4gICAgICAgICAgICBvYmouZGVzdHJveSgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfY3VycmVudEluc3RhbmNlLnNlbGVjdCgpLmVhY2goX2NsZWFyT2JqZWN0KTtcbiAgICAgICAgICAgIF9jdXJyZW50SW5zdGFuY2Uuc2VsZWN0RW5kcG9pbnRzKCkuZWFjaChfY2xlYXJPYmplY3QpO1xuXG4gICAgICAgICAgICBlbmRwb2ludHNCeUVsZW1lbnQgPSB7fTtcbiAgICAgICAgICAgIGVuZHBvaW50c0J5VVVJRCA9IHt9O1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuc2V0RGVmYXVsdFNjb3BlID0gZnVuY3Rpb24gKHNjb3BlKSB7XG4gICAgICAgICAgICBERUZBVUxUX1NDT1BFID0gc2NvcGU7XG4gICAgICAgICAgICByZXR1cm4gX2N1cnJlbnRJbnN0YW5jZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBzZXRzIHdoZXRoZXIgb3Igbm90IHNvbWUgZWxlbWVudCBzaG91bGQgYmUgY3VycmVudGx5IGRyYWdnYWJsZS5cbiAgICAgICAgdGhpcy5zZXREcmFnZ2FibGUgPSBfc2V0RHJhZ2dhYmxlO1xuXG4gICAgICAgIHRoaXMuZGVyaXZlRW5kcG9pbnRBbmRBbmNob3JTcGVjID0gZnVuY3Rpb24odHlwZSwgZG9udFByZXBlbmREZWZhdWx0KSB7XG4gICAgICAgICAgICB2YXIgYml0cyA9ICgoZG9udFByZXBlbmREZWZhdWx0ID8gXCJcIiA6IFwiZGVmYXVsdCBcIikgKyB0eXBlKS5zcGxpdCgvW1xcc10vKSwgZXBzID0gbnVsbCwgZXAgPSBudWxsLCBhID0gbnVsbCwgYXMgPSBudWxsO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiaXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90ID0gX2N1cnJlbnRJbnN0YW5jZS5nZXRUeXBlKGJpdHNbaV0sIFwiY29ubmVjdGlvblwiKTtcbiAgICAgICAgICAgICAgICBpZiAoX3QpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90LmVuZHBvaW50cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXBzID0gX3QuZW5kcG9pbnRzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChfdC5lbmRwb2ludCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXAgPSBfdC5lbmRwb2ludDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoX3QuYW5jaG9ycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXMgPSBfdC5hbmNob3JzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChfdC5hbmNob3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGEgPSBfdC5hbmNob3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBlbmRwb2ludHM6IGVwcyA/IGVwcyA6IFsgZXAsIGVwIF0sIGFuY2hvcnM6IGFzID8gYXMgOiBbYSwgYSBdfTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBzZXRzIHRoZSBpZCBvZiBzb21lIGVsZW1lbnQsIGNoYW5naW5nIHdoYXRldmVyIHdlIG5lZWQgdG8gdG8ga2VlcCB0cmFjay5cbiAgICAgICAgdGhpcy5zZXRJZCA9IGZ1bmN0aW9uIChlbCwgbmV3SWQsIGRvTm90U2V0QXR0cmlidXRlKSB7XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgdmFyIGlkO1xuXG4gICAgICAgICAgICBpZiAoX2p1LmlzU3RyaW5nKGVsKSkge1xuICAgICAgICAgICAgICAgIGlkID0gZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbCA9IHRoaXMuZ2V0RWxlbWVudChlbCk7XG4gICAgICAgICAgICAgICAgaWQgPSB0aGlzLmdldElkKGVsKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHNDb25ucyA9IHRoaXMuZ2V0Q29ubmVjdGlvbnMoe3NvdXJjZTogaWQsIHNjb3BlOiAnKid9LCB0cnVlKSxcbiAgICAgICAgICAgICAgICB0Q29ubnMgPSB0aGlzLmdldENvbm5lY3Rpb25zKHt0YXJnZXQ6IGlkLCBzY29wZTogJyonfSwgdHJ1ZSk7XG5cbiAgICAgICAgICAgIG5ld0lkID0gXCJcIiArIG5ld0lkO1xuXG4gICAgICAgICAgICBpZiAoIWRvTm90U2V0QXR0cmlidXRlKSB7XG4gICAgICAgICAgICAgICAgZWwgPSB0aGlzLmdldEVsZW1lbnQoaWQpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKGVsLCBcImlkXCIsIG5ld0lkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGVsID0gdGhpcy5nZXRFbGVtZW50KG5ld0lkKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZW5kcG9pbnRzQnlFbGVtZW50W25ld0lkXSA9IGVuZHBvaW50c0J5RWxlbWVudFtpZF0gfHwgW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBlbmRwb2ludHNCeUVsZW1lbnRbbmV3SWRdLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgICAgICBlbmRwb2ludHNCeUVsZW1lbnRbbmV3SWRdW2ldLnNldEVsZW1lbnRJZChuZXdJZCk7XG4gICAgICAgICAgICAgICAgZW5kcG9pbnRzQnlFbGVtZW50W25ld0lkXVtpXS5zZXRSZWZlcmVuY2VFbGVtZW50KGVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlbGV0ZSBlbmRwb2ludHNCeUVsZW1lbnRbaWRdO1xuXG4gICAgICAgICAgICB0aGlzLnNvdXJjZUVuZHBvaW50RGVmaW5pdGlvbnNbbmV3SWRdID0gdGhpcy5zb3VyY2VFbmRwb2ludERlZmluaXRpb25zW2lkXTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnNvdXJjZUVuZHBvaW50RGVmaW5pdGlvbnNbaWRdO1xuICAgICAgICAgICAgdGhpcy50YXJnZXRFbmRwb2ludERlZmluaXRpb25zW25ld0lkXSA9IHRoaXMudGFyZ2V0RW5kcG9pbnREZWZpbml0aW9uc1tpZF07XG4gICAgICAgICAgICBkZWxldGUgdGhpcy50YXJnZXRFbmRwb2ludERlZmluaXRpb25zW2lkXTtcblxuICAgICAgICAgICAgdGhpcy5hbmNob3JNYW5hZ2VyLmNoYW5nZUlkKGlkLCBuZXdJZCk7XG4gICAgICAgICAgICB2YXIgZG0gPSB0aGlzLmdldERyYWdNYW5hZ2VyKCk7XG4gICAgICAgICAgICBpZiAoZG0pIHtcbiAgICAgICAgICAgICAgICBkbS5jaGFuZ2VJZChpZCwgbmV3SWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWFuYWdlZEVsZW1lbnRzW25ld0lkXSA9IG1hbmFnZWRFbGVtZW50c1tpZF07XG4gICAgICAgICAgICBkZWxldGUgbWFuYWdlZEVsZW1lbnRzW2lkXTtcblxuICAgICAgICAgICAgdmFyIF9jb25ucyA9IGZ1bmN0aW9uIChsaXN0LCBlcElkeCwgdHlwZSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGxpc3QubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBsaXN0W2ldLmVuZHBvaW50c1tlcElkeF0uc2V0RWxlbWVudElkKG5ld0lkKTtcbiAgICAgICAgICAgICAgICAgICAgbGlzdFtpXS5lbmRwb2ludHNbZXBJZHhdLnNldFJlZmVyZW5jZUVsZW1lbnQoZWwpO1xuICAgICAgICAgICAgICAgICAgICBsaXN0W2ldW3R5cGUgKyBcIklkXCJdID0gbmV3SWQ7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RbaV1bdHlwZV0gPSBlbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgX2Nvbm5zKHNDb25ucywgMCwgXCJzb3VyY2VcIik7XG4gICAgICAgICAgICBfY29ubnModENvbm5zLCAxLCBcInRhcmdldFwiKTtcblxuICAgICAgICAgICAgdGhpcy5yZXBhaW50KG5ld0lkKTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLnNldERlYnVnTG9nID0gZnVuY3Rpb24gKGRlYnVnTG9nKSB7XG4gICAgICAgICAgICBsb2cgPSBkZWJ1Z0xvZztcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLnNldFN1c3BlbmREcmF3aW5nID0gZnVuY3Rpb24gKHZhbCwgcmVwYWludEFmdGVyd2FyZHMpIHtcbiAgICAgICAgICAgIHZhciBjdXJWYWwgPSBfc3VzcGVuZERyYXdpbmc7XG4gICAgICAgICAgICBfc3VzcGVuZERyYXdpbmcgPSB2YWw7XG4gICAgICAgICAgICBpZiAodmFsKSB7XG4gICAgICAgICAgICAgICAgX3N1c3BlbmRlZEF0ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIF9zdXNwZW5kZWRBdCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVwYWludEFmdGVyd2FyZHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlcGFpbnRFdmVyeXRoaW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY3VyVmFsO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIHJldHVybnMgd2hldGhlciBvciBub3QgZHJhd2luZyBpcyBjdXJyZW50bHkgc3VzcGVuZGVkLlxuICAgICAgICB0aGlzLmlzU3VzcGVuZERyYXdpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3N1c3BlbmREcmF3aW5nO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIHJldHVybiB0aW1lc3RhbXAgZm9yIHdoZW4gZHJhd2luZyB3YXMgc3VzcGVuZGVkLlxuICAgICAgICB0aGlzLmdldFN1c3BlbmRlZEF0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9zdXNwZW5kZWRBdDtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmJhdGNoID0gZnVuY3Rpb24gKGZuLCBkb05vdFJlcGFpbnRBZnRlcndhcmRzKSB7XG4gICAgICAgICAgICB2YXIgX3dhc1N1c3BlbmRlZCA9IHRoaXMuaXNTdXNwZW5kRHJhd2luZygpO1xuICAgICAgICAgICAgaWYgKCFfd2FzU3VzcGVuZGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTdXNwZW5kRHJhd2luZyh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgX2p1LmxvZyhcIkZ1bmN0aW9uIHJ1biB3aGlsZSBzdXNwZW5kZWQgZmFpbGVkXCIsIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFfd2FzU3VzcGVuZGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTdXNwZW5kRHJhd2luZyhmYWxzZSwgIWRvTm90UmVwYWludEFmdGVyd2FyZHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuZG9XaGlsZVN1c3BlbmRlZCA9IHRoaXMuYmF0Y2g7XG5cbiAgICAgICAgdGhpcy5nZXRDYWNoZWREYXRhID0gX2dldENhY2hlZERhdGE7XG4gICAgICAgIHRoaXMudGltZXN0YW1wID0gX3RpbWVzdGFtcDtcbiAgICAgICAgdGhpcy5zaG93ID0gZnVuY3Rpb24gKGVsLCBjaGFuZ2VFbmRwb2ludHMpIHtcbiAgICAgICAgICAgIF9zZXRWaXNpYmxlKGVsLCBcImJsb2NrXCIsIGNoYW5nZUVuZHBvaW50cyk7XG4gICAgICAgICAgICByZXR1cm4gX2N1cnJlbnRJbnN0YW5jZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBUT0RPOiB1cGRhdGUgdGhpcyBtZXRob2QgdG8gcmV0dXJuIHRoZSBjdXJyZW50IHN0YXRlLlxuICAgICAgICB0aGlzLnRvZ2dsZVZpc2libGUgPSBfdG9nZ2xlVmlzaWJsZTtcbiAgICAgICAgdGhpcy50b2dnbGVEcmFnZ2FibGUgPSBfdG9nZ2xlRHJhZ2dhYmxlO1xuICAgICAgICB0aGlzLmFkZExpc3RlbmVyID0gdGhpcy5iaW5kO1xuICAgIH07XG5cbiAgICBfanUuZXh0ZW5kKHJvb3QuanNQbHVtYkluc3RhbmNlLCBfanUuRXZlbnRHZW5lcmF0b3IsIHtcbiAgICAgICAgc2V0QXR0cmlidXRlOiBmdW5jdGlvbiAoZWwsIGEsIHYpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKGVsLCBhLCB2KTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0QXR0cmlidXRlOiBmdW5jdGlvbiAoZWwsIGEpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZShyb290LmpzUGx1bWIuZ2V0RWxlbWVudChlbCksIGEpO1xuICAgICAgICB9LFxuICAgICAgICBjb252ZXJ0VG9GdWxsT3ZlcmxheVNwZWM6IGZ1bmN0aW9uKHNwZWMpIHtcbiAgICAgICAgICAgIGlmIChfanUuaXNTdHJpbmcoc3BlYykpIHtcbiAgICAgICAgICAgICAgICBzcGVjID0gWyBzcGVjLCB7IH0gXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNwZWNbMV0uaWQgPSBzcGVjWzFdLmlkIHx8IF9qdS51dWlkKCk7XG4gICAgICAgICAgICByZXR1cm4gc3BlYztcbiAgICAgICAgfSxcbiAgICAgICAgcmVnaXN0ZXJDb25uZWN0aW9uVHlwZTogZnVuY3Rpb24gKGlkLCB0eXBlKSB7XG4gICAgICAgICAgICB0aGlzLl9jb25uZWN0aW9uVHlwZXNbaWRdID0gcm9vdC5qc1BsdW1iLmV4dGVuZCh7fSwgdHlwZSk7XG4gICAgICAgICAgICBpZiAodHlwZS5vdmVybGF5cykge1xuICAgICAgICAgICAgICAgIHZhciB0byA9IHt9O1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHlwZS5vdmVybGF5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiBhIHN0cmluZywgY29udmVydCB0byBvYmplY3QgcmVwcmVzZW50YXRpb24gc28gdGhhdCB3ZSBjYW4gc3RvcmUgdGhlIHR5cGVpZCBvbiBpdC5cbiAgICAgICAgICAgICAgICAgICAgLy8gYWxzbyBhc3NpZ24gYW4gaWQuXG4gICAgICAgICAgICAgICAgICAgIHZhciBmbyA9IHRoaXMuY29udmVydFRvRnVsbE92ZXJsYXlTcGVjKHR5cGUub3ZlcmxheXNbaV0pO1xuICAgICAgICAgICAgICAgICAgICB0b1tmb1sxXS5pZF0gPSBmbztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fY29ubmVjdGlvblR5cGVzW2lkXS5vdmVybGF5cyA9IHRvO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICByZWdpc3RlckNvbm5lY3Rpb25UeXBlczogZnVuY3Rpb24gKHR5cGVzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpIGluIHR5cGVzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWdpc3RlckNvbm5lY3Rpb25UeXBlKGksIHR5cGVzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcmVnaXN0ZXJFbmRwb2ludFR5cGU6IGZ1bmN0aW9uIChpZCwgdHlwZSkge1xuICAgICAgICAgICAgdGhpcy5fZW5kcG9pbnRUeXBlc1tpZF0gPSByb290LmpzUGx1bWIuZXh0ZW5kKHt9LCB0eXBlKTtcbiAgICAgICAgICAgIGlmICh0eXBlLm92ZXJsYXlzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRvID0ge307XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlLm92ZXJsYXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIGEgc3RyaW5nLCBjb252ZXJ0IHRvIG9iamVjdCByZXByZXNlbnRhdGlvbiBzbyB0aGF0IHdlIGNhbiBzdG9yZSB0aGUgdHlwZWlkIG9uIGl0LlxuICAgICAgICAgICAgICAgICAgICAvLyBhbHNvIGFzc2lnbiBhbiBpZC5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGZvID0gdGhpcy5jb252ZXJ0VG9GdWxsT3ZlcmxheVNwZWModHlwZS5vdmVybGF5c1tpXSk7XG4gICAgICAgICAgICAgICAgICAgIHRvW2ZvWzFdLmlkXSA9IGZvO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9lbmRwb2ludFR5cGVzW2lkXS5vdmVybGF5cyA9IHRvO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICByZWdpc3RlckVuZHBvaW50VHlwZXM6IGZ1bmN0aW9uICh0eXBlcykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSBpbiB0eXBlcykge1xuICAgICAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJFbmRwb2ludFR5cGUoaSwgdHlwZXNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBnZXRUeXBlOiBmdW5jdGlvbiAoaWQsIHR5cGVEZXNjcmlwdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZURlc2NyaXB0b3IgPT09IFwiY29ubmVjdGlvblwiID8gdGhpcy5fY29ubmVjdGlvblR5cGVzW2lkXSA6IHRoaXMuX2VuZHBvaW50VHlwZXNbaWRdO1xuICAgICAgICB9LFxuICAgICAgICBzZXRJZENoYW5nZWQ6IGZ1bmN0aW9uIChvbGRJZCwgbmV3SWQpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0SWQob2xkSWQsIG5ld0lkLCB0cnVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gc2V0IHBhcmVudDogY2hhbmdlIHRoZSBwYXJlbnQgZm9yIHNvbWUgbm9kZSBhbmQgdXBkYXRlIGFsbCB0aGUgcmVnaXN0cmF0aW9ucyB3ZSBuZWVkIHRvLlxuICAgICAgICBzZXRQYXJlbnQ6IGZ1bmN0aW9uIChlbCwgbmV3UGFyZW50KSB7XG4gICAgICAgICAgICB2YXIgX2RvbSA9IHRoaXMuZ2V0RWxlbWVudChlbCksXG4gICAgICAgICAgICAgICAgX2lkID0gdGhpcy5nZXRJZChfZG9tKSxcbiAgICAgICAgICAgICAgICBfcGRvbSA9IHRoaXMuZ2V0RWxlbWVudChuZXdQYXJlbnQpLFxuICAgICAgICAgICAgICAgIF9waWQgPSB0aGlzLmdldElkKF9wZG9tKSxcbiAgICAgICAgICAgICAgICBkbSA9IHRoaXMuZ2V0RHJhZ01hbmFnZXIoKTtcblxuICAgICAgICAgICAgX2RvbS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKF9kb20pO1xuICAgICAgICAgICAgX3Bkb20uYXBwZW5kQ2hpbGQoX2RvbSk7XG4gICAgICAgICAgICBpZiAoZG0pIHtcbiAgICAgICAgICAgICAgICBkbS5zZXRQYXJlbnQoX2RvbSwgX2lkLCBfcGRvbSwgX3BpZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGV4dGVuZDogZnVuY3Rpb24gKG8xLCBvMiwgbmFtZXMpIHtcbiAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgaWYgKG5hbWVzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIG8xW25hbWVzW2ldXSA9IG8yW25hbWVzW2ldXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgaW4gbzIpIHtcbiAgICAgICAgICAgICAgICAgICAgbzFbaV0gPSBvMltpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBvMTtcbiAgICAgICAgfSxcbiAgICAgICAgZmxvYXRpbmdDb25uZWN0aW9uczoge30sXG4gICAgICAgIGdldEZsb2F0aW5nQW5jaG9ySW5kZXg6IGZ1bmN0aW9uIChqcGMpIHtcbiAgICAgICAgICAgIHJldHVybiBqcGMuZW5kcG9pbnRzWzBdLmlzRmxvYXRpbmcoKSA/IDAgOiBqcGMuZW5kcG9pbnRzWzFdLmlzRmxvYXRpbmcoKSA/IDEgOiAtMTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAganNQbHVtYkluc3RhbmNlLnByb3RvdHlwZS5EZWZhdWx0cyA9IHtcbiAgICAgICAgQW5jaG9yOiBcIkJvdHRvbVwiLFxuICAgICAgICBBbmNob3JzOiBbIG51bGwsIG51bGwgXSxcbiAgICAgICAgQ29ubmVjdGlvbnNEZXRhY2hhYmxlOiB0cnVlLFxuICAgICAgICBDb25uZWN0aW9uT3ZlcmxheXM6IFsgXSxcbiAgICAgICAgQ29ubmVjdG9yOiBcIkJlemllclwiLFxuICAgICAgICBDb250YWluZXI6IG51bGwsXG4gICAgICAgIERvTm90VGhyb3dFcnJvcnM6IGZhbHNlLFxuICAgICAgICBEcmFnT3B0aW9uczogeyB9LFxuICAgICAgICBEcm9wT3B0aW9uczogeyB9LFxuICAgICAgICBFbmRwb2ludDogXCJEb3RcIixcbiAgICAgICAgRW5kcG9pbnRPdmVybGF5czogWyBdLFxuICAgICAgICBFbmRwb2ludHM6IFsgbnVsbCwgbnVsbCBdLFxuICAgICAgICBFbmRwb2ludFN0eWxlOiB7IGZpbGw6IFwiIzQ1NlwiIH0sXG4gICAgICAgIEVuZHBvaW50U3R5bGVzOiBbIG51bGwsIG51bGwgXSxcbiAgICAgICAgRW5kcG9pbnRIb3ZlclN0eWxlOiBudWxsLFxuICAgICAgICBFbmRwb2ludEhvdmVyU3R5bGVzOiBbIG51bGwsIG51bGwgXSxcbiAgICAgICAgSG92ZXJQYWludFN0eWxlOiBudWxsLFxuICAgICAgICBMYWJlbFN0eWxlOiB7IGNvbG9yOiBcImJsYWNrXCIgfSxcbiAgICAgICAgTG9nRW5hYmxlZDogZmFsc2UsXG4gICAgICAgIE92ZXJsYXlzOiBbIF0sXG4gICAgICAgIE1heENvbm5lY3Rpb25zOiAxLFxuICAgICAgICBQYWludFN0eWxlOiB7IFwic3Ryb2tlLXdpZHRoXCI6IDQsIHN0cm9rZTogXCIjNDU2XCIgfSxcbiAgICAgICAgUmVhdHRhY2hDb25uZWN0aW9uczogZmFsc2UsXG4gICAgICAgIFJlbmRlck1vZGU6IFwic3ZnXCIsXG4gICAgICAgIFNjb3BlOiBcImpzUGx1bWJfRGVmYXVsdFNjb3BlXCJcbiAgICB9O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0gc3RhdGljIGluc3RhbmNlICsgbW9kdWxlIHJlZ2lzdHJhdGlvbiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8vIGNyZWF0ZSBzdGF0aWMgaW5zdGFuY2UgYW5kIGFzc2lnbiB0byB3aW5kb3cgaWYgd2luZG93IGV4aXN0cy5cdFxuICAgIHZhciBqc1BsdW1iID0gbmV3IGpzUGx1bWJJbnN0YW5jZSgpO1xuICAgIC8vIHJlZ2lzdGVyIG9uICdyb290JyAobGV0cyB1cyBydW4gb24gc2VydmVyIG9yIGJyb3dzZXIpXG4gICAgcm9vdC5qc1BsdW1iID0ganNQbHVtYjtcbiAgICAvLyBhZGQgJ2dldEluc3RhbmNlJyBtZXRob2QgdG8gc3RhdGljIGluc3RhbmNlXG4gICAganNQbHVtYi5nZXRJbnN0YW5jZSA9IGZ1bmN0aW9uIChfZGVmYXVsdHMsIG92ZXJyaWRlRm5zKSB7XG4gICAgICAgIHZhciBqID0gbmV3IGpzUGx1bWJJbnN0YW5jZShfZGVmYXVsdHMpO1xuICAgICAgICBpZiAob3ZlcnJpZGVGbnMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIG92ZiBpbiBvdmVycmlkZUZucykge1xuICAgICAgICAgICAgICAgIGpbb3ZmXSA9IG92ZXJyaWRlRm5zW292Zl07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgai5pbml0KCk7XG4gICAgICAgIHJldHVybiBqO1xuICAgIH07XG4gICAganNQbHVtYi5lYWNoID0gZnVuY3Rpb24gKHNwZWMsIGZuKSB7XG4gICAgICAgIGlmIChzcGVjID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHNwZWMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGZuKGpzUGx1bWIuZ2V0RWxlbWVudChzcGVjKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3BlYy5sZW5ndGggIT0gbnVsbCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzcGVjLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZm4oanNQbHVtYi5nZXRFbGVtZW50KHNwZWNbaV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZuKHNwZWMpO1xuICAgICAgICB9IC8vIGFzc3VtZSBpdCdzIGFuIGVsZW1lbnQuXG4gICAgfTtcblxuICAgIC8vIENvbW1vbkpTXG4gICAgaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBleHBvcnRzLmpzUGx1bWIgPSBqc1BsdW1iO1xuICAgIH1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tIGVuZCBzdGF0aWMgaW5zdGFuY2UgKyBBTUQgcmVnaXN0cmF0aW9uIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cdFx0XG5cbn0pLmNhbGwodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB0aGlzKTtcblxuLypcbiAqIGpzUGx1bWIgQ29tbXVuaXR5IEVkaXRpb25cbiAqXG4gKiBQcm92aWRlcyBhIHdheSB0byB2aXN1YWxseSBjb25uZWN0IGVsZW1lbnRzIG9uIGFuIEhUTUwgcGFnZSwgdXNpbmcgU1ZHLlxuICpcbiAqIFRoaXMgZmlsZSBjb250YWlucyB0aGUgYmFzZSBmdW5jdGlvbmFsaXR5IGZvciBET00gdHlwZSBhZGFwdGVycy5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTAgLSAyMDE3IGpzUGx1bWIgKGhlbGxvQGpzcGx1bWJ0b29sa2l0LmNvbSlcbiAqXG4gKiBodHRwczovL2pzcGx1bWJ0b29sa2l0LmNvbVxuICogaHR0cHM6Ly9naXRodWIuY29tL2pzcGx1bWIvanNwbHVtYlxuICpcbiAqIER1YWwgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBhbmQgR1BMMiBsaWNlbnNlcy5cbiAqL1xuO1xuKGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciByb290ID0gdGhpcywgX2p1ID0gcm9vdC5qc1BsdW1iVXRpbDtcblxuICAgIHZhciBfZ2VuTG9jID0gZnVuY3Rpb24gKHByZWZpeCwgZSkge1xuICAgICAgICAgICAgaWYgKGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbIDAsIDAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB0cyA9IF90b3VjaGVzKGUpLCB0ID0gX2dldFRvdWNoKHRzLCAwKTtcbiAgICAgICAgICAgIHJldHVybiBbdFtwcmVmaXggKyBcIlhcIl0sIHRbcHJlZml4ICsgXCJZXCJdXTtcbiAgICAgICAgfSxcbiAgICAgICAgX3BhZ2VMb2NhdGlvbiA9IF9nZW5Mb2MuYmluZCh0aGlzLCBcInBhZ2VcIiksXG4gICAgICAgIF9zY3JlZW5Mb2NhdGlvbiA9IF9nZW5Mb2MuYmluZCh0aGlzLCBcInNjcmVlblwiKSxcbiAgICAgICAgX2NsaWVudExvY2F0aW9uID0gX2dlbkxvYy5iaW5kKHRoaXMsIFwiY2xpZW50XCIpLFxuICAgICAgICBfZ2V0VG91Y2ggPSBmdW5jdGlvbiAodG91Y2hlcywgaWR4KSB7XG4gICAgICAgICAgICByZXR1cm4gdG91Y2hlcy5pdGVtID8gdG91Y2hlcy5pdGVtKGlkeCkgOiB0b3VjaGVzW2lkeF07XG4gICAgICAgIH0sXG4gICAgICAgIF90b3VjaGVzID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBlLnRvdWNoZXMgJiYgZS50b3VjaGVzLmxlbmd0aCA+IDAgPyBlLnRvdWNoZXMgOlxuICAgICAgICAgICAgICAgICAgICBlLmNoYW5nZWRUb3VjaGVzICYmIGUuY2hhbmdlZFRvdWNoZXMubGVuZ3RoID4gMCA/IGUuY2hhbmdlZFRvdWNoZXMgOlxuICAgICAgICAgICAgICAgICAgICBlLnRhcmdldFRvdWNoZXMgJiYgZS50YXJnZXRUb3VjaGVzLmxlbmd0aCA+IDAgPyBlLnRhcmdldFRvdWNoZXMgOlxuICAgICAgICAgICAgICAgIFsgZSBdO1xuICAgICAgICB9O1xuXG4gICAgLyoqXG4gICAgIE1hbmFnZXMgZHJhZ2dpbmcgZm9yIHNvbWUgaW5zdGFuY2Ugb2YganNQbHVtYi5cblxuICAgICBUT0RPIGluc3RlYWQgb2YgdGhpcyBiZWluZyBhY2Nlc3NlZCBkaXJlY3RseSwgaXQgc2hvdWxkIHN1YnNjcmliZSB0byBldmVudHMgb24gdGhlIGpzUGx1bWIgaW5zdGFuY2U6IGV2ZXJ5IG1ldGhvZFxuICAgICBpbiBoZXJlIGlzIGNhbGxlZCBkaXJlY3RseSBieSBqc1BsdW1iLiBCdXQgd2hhdCBzaG91bGQgaGFwcGVuIGlzIHRoYXQgd2UgaGF2ZSB1bnB1Ymxpc2hlZCBldmVudHMgdGhhdCB0aGlzIGxpc3RlbnNcbiAgICAgdG8uICBUaGUgb25seSB0cmljayBpcyBnZXR0aW5nIG9uZSBvZiB0aGVzZSBpbnN0YW50aWF0ZWQgd2l0aCBldmVyeSBqc1BsdW1iIGluc3RhbmNlOiBpdCBuZWVkcyB0byBoYXZlIGEgaG9vayBzb21laG93LlxuICAgICBCYXNpY2FsbHkgdGhlIGdlbmVyYWwgaWRlYSBpcyB0byBwdWxsIEFMTCB0aGUgZHJhZyBjb2RlIG91dCAocHJvdG90eXBlIG1ldGhvZCByZWdpc3RyYXRpb25zIHBsdXMgdGhpcykgaW50byBhXG4gICAgIGRlZGljYXRlZCBkcmFnIHNjcmlwdCksIHRoYXQgZG9lcyBub3QgbmVjZXNzYXJpbHkgbmVlZCB0byBiZSBpbmNsdWRlZC5cblxuXG4gICAgICovXG4gICAgdmFyIERyYWdNYW5hZ2VyID0gZnVuY3Rpb24gKF9jdXJyZW50SW5zdGFuY2UpIHtcbiAgICAgICAgdmFyIF9kcmFnZ2FibGVzID0ge30sIF9kbGlzdCA9IFtdLCBfZGVsZW1lbnRzID0ge30sIF9lbGVtZW50c1dpdGhFbmRwb2ludHMgPSB7fSxcbiAgICAgICAgLy8gZWxlbWVudGlkcyBtYXBwZWQgdG8gdGhlIGRyYWdnYWJsZSB0byB3aGljaCB0aGV5IGJlbG9uZy5cbiAgICAgICAgICAgIF9kcmFnZ2FibGVzRm9yRWxlbWVudHMgPSB7fTtcblxuICAgICAgICAvKipcbiAgICAgICAgIHJlZ2lzdGVyIHNvbWUgZWxlbWVudCBhcyBkcmFnZ2FibGUuICByaWdodCBub3cgdGhlIGRyYWcgaW5pdCBzdHVmZiBpcyBkb25lIGVsc2V3aGVyZSwgYW5kIGl0IGlzXG4gICAgICAgICBwb3NzaWJsZSB0aGF0IHdpbGwgY29udGludWUgdG8gYmUgdGhlIGNhc2UuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlZ2lzdGVyID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICB2YXIgaWQgPSBfY3VycmVudEluc3RhbmNlLmdldElkKGVsKSxcbiAgICAgICAgICAgICAgICBwYXJlbnRPZmZzZXQgPSBfY3VycmVudEluc3RhbmNlLmdldE9mZnNldChlbCk7XG5cbiAgICAgICAgICAgIGlmICghX2RyYWdnYWJsZXNbaWRdKSB7XG4gICAgICAgICAgICAgICAgX2RyYWdnYWJsZXNbaWRdID0gZWw7XG4gICAgICAgICAgICAgICAgX2RsaXN0LnB1c2goZWwpO1xuICAgICAgICAgICAgICAgIF9kZWxlbWVudHNbaWRdID0ge307XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGxvb2sgZm9yIGNoaWxkIGVsZW1lbnRzIHRoYXQgaGF2ZSBlbmRwb2ludHMgYW5kIHJlZ2lzdGVyIHRoZW0gYWdhaW5zdCB0aGlzIGRyYWdnYWJsZS5cbiAgICAgICAgICAgIHZhciBfb25lTGV2ZWwgPSBmdW5jdGlvbiAocCkge1xuICAgICAgICAgICAgICAgIGlmIChwKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcC5jaGlsZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocC5jaGlsZE5vZGVzW2ldLm5vZGVUeXBlICE9PSAzICYmIHAuY2hpbGROb2Rlc1tpXS5ub2RlVHlwZSAhPT0gOCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjRWwgPSBqc1BsdW1iLmdldEVsZW1lbnQocC5jaGlsZE5vZGVzW2ldKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2lkID0gX2N1cnJlbnRJbnN0YW5jZS5nZXRJZChwLmNoaWxkTm9kZXNbaV0sIG51bGwsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaWQgJiYgX2VsZW1lbnRzV2l0aEVuZHBvaW50c1tjaWRdICYmIF9lbGVtZW50c1dpdGhFbmRwb2ludHNbY2lkXSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNPZmYgPSBfY3VycmVudEluc3RhbmNlLmdldE9mZnNldChjRWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZGVsZW1lbnRzW2lkXVtjaWRdID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGNpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IGNPZmYubGVmdCAtIHBhcmVudE9mZnNldC5sZWZ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogY09mZi50b3AgLSBwYXJlbnRPZmZzZXQudG9wXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9kcmFnZ2FibGVzRm9yRWxlbWVudHNbY2lkXSA9IGlkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfb25lTGV2ZWwocC5jaGlsZE5vZGVzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIF9vbmVMZXZlbChlbCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gcmVmcmVzaCB0aGUgb2Zmc2V0cyBmb3IgY2hpbGQgZWxlbWVudHMgb2YgdGhpcyBlbGVtZW50LlxuICAgICAgICB0aGlzLnVwZGF0ZU9mZnNldHMgPSBmdW5jdGlvbiAoZWxJZCwgY2hpbGRPZmZzZXRPdmVycmlkZXMpIHtcbiAgICAgICAgICAgIGlmIChlbElkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjaGlsZE9mZnNldE92ZXJyaWRlcyA9IGNoaWxkT2Zmc2V0T3ZlcnJpZGVzIHx8IHt9O1xuICAgICAgICAgICAgICAgIHZhciBkb21FbCA9IGpzUGx1bWIuZ2V0RWxlbWVudChlbElkKSxcbiAgICAgICAgICAgICAgICAgICAgaWQgPSBfY3VycmVudEluc3RhbmNlLmdldElkKGRvbUVsKSxcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4gPSBfZGVsZW1lbnRzW2lkXSxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50T2Zmc2V0ID0gX2N1cnJlbnRJbnN0YW5jZS5nZXRPZmZzZXQoZG9tRWwpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgaW4gY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZHJlbi5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjZWwgPSBqc1BsdW1iLmdldEVsZW1lbnQoaSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNPZmYgPSBjaGlsZE9mZnNldE92ZXJyaWRlc1tpXSB8fCBfY3VycmVudEluc3RhbmNlLmdldE9mZnNldChjZWwpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZG8gbm90IHVwZGF0ZSBpZiB3ZSBoYXZlIGEgdmFsdWUgYWxyZWFkeSBhbmQgd2UnZCBqdXN0IGJlIHdyaXRpbmcgMCwwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNlbC5vZmZzZXRQYXJlbnQgPT0gbnVsbCAmJiBfZGVsZW1lbnRzW2lkXVtpXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9kZWxlbWVudHNbaWRdW2ldID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiBjT2ZmLmxlZnQgLSBwYXJlbnRPZmZzZXQubGVmdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogY09mZi50b3AgLSBwYXJlbnRPZmZzZXQudG9wXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9kcmFnZ2FibGVzRm9yRWxlbWVudHNbaV0gPSBpZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgIG5vdGlmaWNhdGlvbiB0aGF0IGFuIGVuZHBvaW50IHdhcyBhZGRlZCB0byB0aGUgZ2l2ZW4gZWwuICB3ZSBnbyB1cCBmcm9tIHRoYXQgZWwncyBwYXJlbnRcbiAgICAgICAgIG5vZGUsIGxvb2tpbmcgZm9yIGEgcGFyZW50IHRoYXQgaGFzIGJlZW4gcmVnaXN0ZXJlZCBhcyBhIGRyYWdnYWJsZS4gaWYgd2UgZmluZCBvbmUsIHdlIGFkZCB0aGlzXG4gICAgICAgICBlbCB0byB0aGF0IHBhcmVudCdzIGxpc3Qgb2YgZWxlbWVudHMgdG8gdXBkYXRlIG9uIGRyYWcgKGlmIGl0IGlzIG5vdCB0aGVyZSBhbHJlYWR5KVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5lbmRwb2ludEFkZGVkID0gZnVuY3Rpb24gKGVsLCBpZCkge1xuXG4gICAgICAgICAgICBpZCA9IGlkIHx8IF9jdXJyZW50SW5zdGFuY2UuZ2V0SWQoZWwpO1xuXG4gICAgICAgICAgICB2YXIgYiA9IGRvY3VtZW50LmJvZHksXG4gICAgICAgICAgICAgICAgcCA9IGVsLnBhcmVudE5vZGU7XG5cbiAgICAgICAgICAgIF9lbGVtZW50c1dpdGhFbmRwb2ludHNbaWRdID0gX2VsZW1lbnRzV2l0aEVuZHBvaW50c1tpZF0gPyBfZWxlbWVudHNXaXRoRW5kcG9pbnRzW2lkXSArIDEgOiAxO1xuXG4gICAgICAgICAgICB3aGlsZSAocCAhPSBudWxsICYmIHAgIT09IGIpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGlkID0gX2N1cnJlbnRJbnN0YW5jZS5nZXRJZChwLCBudWxsLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBpZiAocGlkICYmIF9kcmFnZ2FibGVzW3BpZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBMb2MgPSBfY3VycmVudEluc3RhbmNlLmdldE9mZnNldChwKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoX2RlbGVtZW50c1twaWRdW2lkXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY0xvYyA9IF9jdXJyZW50SW5zdGFuY2UuZ2V0T2Zmc2V0KGVsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9kZWxlbWVudHNbcGlkXVtpZF0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiBjTG9jLmxlZnQgLSBwTG9jLmxlZnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogY0xvYy50b3AgLSBwTG9jLnRvcFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBfZHJhZ2dhYmxlc0ZvckVsZW1lbnRzW2lkXSA9IHBpZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcCA9IHAucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmVuZHBvaW50RGVsZXRlZCA9IGZ1bmN0aW9uIChlbmRwb2ludCkge1xuICAgICAgICAgICAgaWYgKF9lbGVtZW50c1dpdGhFbmRwb2ludHNbZW5kcG9pbnQuZWxlbWVudElkXSkge1xuICAgICAgICAgICAgICAgIF9lbGVtZW50c1dpdGhFbmRwb2ludHNbZW5kcG9pbnQuZWxlbWVudElkXS0tO1xuICAgICAgICAgICAgICAgIGlmIChfZWxlbWVudHNXaXRoRW5kcG9pbnRzW2VuZHBvaW50LmVsZW1lbnRJZF0gPD0gMCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpIGluIF9kZWxlbWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfZGVsZW1lbnRzLmhhc093blByb3BlcnR5KGkpICYmIF9kZWxlbWVudHNbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgX2RlbGVtZW50c1tpXVtlbmRwb2ludC5lbGVtZW50SWRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBfZHJhZ2dhYmxlc0ZvckVsZW1lbnRzW2VuZHBvaW50LmVsZW1lbnRJZF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5jaGFuZ2VJZCA9IGZ1bmN0aW9uIChvbGRJZCwgbmV3SWQpIHtcbiAgICAgICAgICAgIF9kZWxlbWVudHNbbmV3SWRdID0gX2RlbGVtZW50c1tvbGRJZF07XG4gICAgICAgICAgICBfZGVsZW1lbnRzW29sZElkXSA9IHt9O1xuICAgICAgICAgICAgX2RyYWdnYWJsZXNGb3JFbGVtZW50c1tuZXdJZF0gPSBfZHJhZ2dhYmxlc0ZvckVsZW1lbnRzW29sZElkXTtcbiAgICAgICAgICAgIF9kcmFnZ2FibGVzRm9yRWxlbWVudHNbb2xkSWRdID0gbnVsbDtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmdldEVsZW1lbnRzRm9yRHJhZ2dhYmxlID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgICAgICByZXR1cm4gX2RlbGVtZW50c1tpZF07XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5lbGVtZW50UmVtb3ZlZCA9IGZ1bmN0aW9uIChlbGVtZW50SWQpIHtcbiAgICAgICAgICAgIHZhciBlbElkID0gX2RyYWdnYWJsZXNGb3JFbGVtZW50c1tlbGVtZW50SWRdO1xuICAgICAgICAgICAgaWYgKGVsSWQpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgX2RlbGVtZW50c1tlbElkXVtlbGVtZW50SWRdO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBfZHJhZ2dhYmxlc0ZvckVsZW1lbnRzW2VsZW1lbnRJZF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF9kcmFnZ2FibGVzID0ge307XG4gICAgICAgICAgICBfZGxpc3QgPSBbXTtcbiAgICAgICAgICAgIF9kZWxlbWVudHMgPSB7fTtcbiAgICAgICAgICAgIF9lbGVtZW50c1dpdGhFbmRwb2ludHMgPSB7fTtcbiAgICAgICAgfTtcblxuICAgICAgICAvL1xuICAgICAgICAvLyBub3RpZmljYXRpb24gZHJhZyBlbmRlZC4gV2UgY2hlY2sgYXV0b21hdGljYWxseSBpZiBuZWVkIHRvIHVwZGF0ZSBzb21lXG4gICAgICAgIC8vIGFuY2VzdG9yJ3Mgb2Zmc2V0cy5cbiAgICAgICAgLy9cbiAgICAgICAgdGhpcy5kcmFnRW5kZWQgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIGlmIChlbC5vZmZzZXRQYXJlbnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhciBpZCA9IF9jdXJyZW50SW5zdGFuY2UuZ2V0SWQoZWwpLFxuICAgICAgICAgICAgICAgICAgICBhbmNlc3RvciA9IF9kcmFnZ2FibGVzRm9yRWxlbWVudHNbaWRdO1xuXG4gICAgICAgICAgICAgICAgaWYgKGFuY2VzdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlT2Zmc2V0cyhhbmNlc3Rvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuc2V0UGFyZW50ID0gZnVuY3Rpb24gKGVsLCBlbElkLCBwLCBwSWQsIGN1cnJlbnRDaGlsZExvY2F0aW9uKSB7XG4gICAgICAgICAgICB2YXIgY3VycmVudCA9IF9kcmFnZ2FibGVzRm9yRWxlbWVudHNbZWxJZF07XG4gICAgICAgICAgICBpZiAoIV9kZWxlbWVudHNbcElkXSkge1xuICAgICAgICAgICAgICAgIF9kZWxlbWVudHNbcElkXSA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHBMb2MgPSBfY3VycmVudEluc3RhbmNlLmdldE9mZnNldChwKSxcbiAgICAgICAgICAgICAgICBjTG9jID0gY3VycmVudENoaWxkTG9jYXRpb24gfHwgX2N1cnJlbnRJbnN0YW5jZS5nZXRPZmZzZXQoZWwpO1xuXG4gICAgICAgICAgICBpZiAoY3VycmVudCAmJiBfZGVsZW1lbnRzW2N1cnJlbnRdKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIF9kZWxlbWVudHNbY3VycmVudF1bZWxJZF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9kZWxlbWVudHNbcElkXVtlbElkXSA9IHtcbiAgICAgICAgICAgICAgICBpZDplbElkLFxuICAgICAgICAgICAgICAgIG9mZnNldCA6IHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogY0xvYy5sZWZ0IC0gcExvYy5sZWZ0LFxuICAgICAgICAgICAgICAgICAgICB0b3A6IGNMb2MudG9wIC0gcExvYy50b3BcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgX2RyYWdnYWJsZXNGb3JFbGVtZW50c1tlbElkXSA9IHBJZDtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmNsZWFyUGFyZW50ID0gZnVuY3Rpb24oZWwsIGVsSWQpIHtcbiAgICAgICAgICAgIHZhciBjdXJyZW50ID0gX2RyYWdnYWJsZXNGb3JFbGVtZW50c1tlbElkXTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIF9kZWxlbWVudHNbY3VycmVudF1bZWxJZF07XG4gICAgICAgICAgICAgICAgZGVsZXRlIF9kcmFnZ2FibGVzRm9yRWxlbWVudHNbZWxJZF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5yZXZhbGlkYXRlUGFyZW50ID0gZnVuY3Rpb24oZWwsIGVsSWQsIGNoaWxkT2Zmc2V0KSB7XG4gICAgICAgICAgICB2YXIgY3VycmVudCA9IF9kcmFnZ2FibGVzRm9yRWxlbWVudHNbZWxJZF07XG4gICAgICAgICAgICBpZiAoY3VycmVudCkge1xuICAgICAgICAgICAgICAgIHZhciBjbyA9IHt9O1xuICAgICAgICAgICAgICAgIGNvW2VsSWRdID0gY2hpbGRPZmZzZXQ7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVPZmZzZXRzKGN1cnJlbnQsIGNvKTtcbiAgICAgICAgICAgICAgICBfY3VycmVudEluc3RhbmNlLnJldmFsaWRhdGUoY3VycmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5nZXREcmFnQW5jZXN0b3IgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIHZhciBkZSA9IGpzUGx1bWIuZ2V0RWxlbWVudChlbCksXG4gICAgICAgICAgICAgICAgaWQgPSBfY3VycmVudEluc3RhbmNlLmdldElkKGRlKSxcbiAgICAgICAgICAgICAgICBhaWQgPSBfZHJhZ2dhYmxlc0ZvckVsZW1lbnRzW2lkXTtcblxuICAgICAgICAgICAgaWYgKGFpZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBqc1BsdW1iLmdldEVsZW1lbnQoYWlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgfTtcblxuICAgIHZhciB0cmltID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICAgICAgcmV0dXJuIHN0ciA9PSBudWxsID8gbnVsbCA6IChzdHIucmVwbGFjZSgvXlxcc1xccyovLCAnJykucmVwbGFjZSgvXFxzXFxzKiQvLCAnJykpO1xuICAgICAgICB9LFxuICAgICAgICBfc2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKGVsLCBjbikge1xuICAgICAgICAgICAgY24gPSB0cmltKGNuKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZWwuY2xhc3NOYW1lLmJhc2VWYWwgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICBlbC5jbGFzc05hbWUuYmFzZVZhbCA9IGNuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZWwuY2xhc3NOYW1lID0gY247XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIF9nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIHJldHVybiAodHlwZW9mIGVsLmNsYXNzTmFtZS5iYXNlVmFsID09PSBcInVuZGVmaW5lZFwiKSA/IGVsLmNsYXNzTmFtZSA6IGVsLmNsYXNzTmFtZS5iYXNlVmFsO1xuICAgICAgICB9LFxuICAgICAgICBfY2xhc3NNYW5pcCA9IGZ1bmN0aW9uIChlbCwgY2xhc3Nlc1RvQWRkLCBjbGFzc2VzVG9SZW1vdmUpIHtcbiAgICAgICAgICAgIGNsYXNzZXNUb0FkZCA9IGNsYXNzZXNUb0FkZCA9PSBudWxsID8gW10gOiBfanUuaXNBcnJheShjbGFzc2VzVG9BZGQpID8gY2xhc3Nlc1RvQWRkIDogY2xhc3Nlc1RvQWRkLnNwbGl0KC9cXHMrLyk7XG4gICAgICAgICAgICBjbGFzc2VzVG9SZW1vdmUgPSBjbGFzc2VzVG9SZW1vdmUgPT0gbnVsbCA/IFtdIDogX2p1LmlzQXJyYXkoY2xhc3Nlc1RvUmVtb3ZlKSA/IGNsYXNzZXNUb1JlbW92ZSA6IGNsYXNzZXNUb1JlbW92ZS5zcGxpdCgvXFxzKy8pO1xuXG4gICAgICAgICAgICB2YXIgY2xhc3NOYW1lID0gX2dldENsYXNzTmFtZShlbCksXG4gICAgICAgICAgICAgICAgY3VyQ2xhc3NlcyA9IGNsYXNzTmFtZS5zcGxpdCgvXFxzKy8pO1xuXG4gICAgICAgICAgICB2YXIgX29uZVNldCA9IGZ1bmN0aW9uIChhZGQsIGNsYXNzZXMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsYXNzZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFkZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1ckNsYXNzZXMuaW5kZXhPZihjbGFzc2VzW2ldKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJDbGFzc2VzLnB1c2goY2xhc3Nlc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaWR4ID0gY3VyQ2xhc3Nlcy5pbmRleE9mKGNsYXNzZXNbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlkeCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJDbGFzc2VzLnNwbGljZShpZHgsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgX29uZVNldCh0cnVlLCBjbGFzc2VzVG9BZGQpO1xuICAgICAgICAgICAgX29uZVNldChmYWxzZSwgY2xhc3Nlc1RvUmVtb3ZlKTtcblxuICAgICAgICAgICAgX3NldENsYXNzTmFtZShlbCwgY3VyQ2xhc3Nlcy5qb2luKFwiIFwiKSk7XG4gICAgICAgIH07XG5cbiAgICByb290LmpzUGx1bWIuZXh0ZW5kKHJvb3QuanNQbHVtYkluc3RhbmNlLnByb3RvdHlwZSwge1xuXG4gICAgICAgIGhlYWRsZXNzOiBmYWxzZSxcblxuICAgICAgICBwYWdlTG9jYXRpb246IF9wYWdlTG9jYXRpb24sXG4gICAgICAgIHNjcmVlbkxvY2F0aW9uOiBfc2NyZWVuTG9jYXRpb24sXG4gICAgICAgIGNsaWVudExvY2F0aW9uOiBfY2xpZW50TG9jYXRpb24sXG5cbiAgICAgICAgZ2V0RHJhZ01hbmFnZXI6ZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kcmFnTWFuYWdlciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kcmFnTWFuYWdlciA9IG5ldyBEcmFnTWFuYWdlcih0aGlzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZHJhZ01hbmFnZXI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVjYWxjdWxhdGVPZmZzZXRzOmZ1bmN0aW9uKGVsSWQpIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0RHJhZ01hbmFnZXIoKS51cGRhdGVPZmZzZXRzKGVsSWQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNyZWF0ZUVsZW1lbnQ6ZnVuY3Rpb24odGFnLCBzdHlsZSwgY2xhenosIGF0dHMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUVsZW1lbnROUyhudWxsLCB0YWcsIHN0eWxlLCBjbGF6eiwgYXR0cyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY3JlYXRlRWxlbWVudE5TOmZ1bmN0aW9uKG5zLCB0YWcsIHN0eWxlLCBjbGF6eiwgYXR0cykge1xuICAgICAgICAgICAgdmFyIGUgPSBucyA9PSBudWxsID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpIDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5zLCB0YWcpO1xuICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICBzdHlsZSA9IHN0eWxlIHx8IHt9O1xuICAgICAgICAgICAgZm9yIChpIGluIHN0eWxlKSB7XG4gICAgICAgICAgICAgICAgZS5zdHlsZVtpXSA9IHN0eWxlW2ldO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY2xhenopIHtcbiAgICAgICAgICAgICAgICBlLmNsYXNzTmFtZSA9IGNsYXp6O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhdHRzID0gYXR0cyB8fCB7fTtcbiAgICAgICAgICAgIGZvciAoaSBpbiBhdHRzKSB7XG4gICAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoaSwgXCJcIiArIGF0dHNbaV0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRBdHRyaWJ1dGU6IGZ1bmN0aW9uIChlbCwgYXR0TmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIGVsLmdldEF0dHJpYnV0ZSAhPSBudWxsID8gZWwuZ2V0QXR0cmlidXRlKGF0dE5hbWUpIDogbnVsbDtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXRBdHRyaWJ1dGU6IGZ1bmN0aW9uIChlbCwgYSwgdikge1xuICAgICAgICAgICAgaWYgKGVsLnNldEF0dHJpYnV0ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKGEsIHYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHNldEF0dHJpYnV0ZXM6IGZ1bmN0aW9uIChlbCwgYXR0cykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSBpbiBhdHRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGF0dHMuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKGksIGF0dHNbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgYXBwZW5kVG9Sb290OiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChub2RlKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0UmVuZGVyTW9kZXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBbIFwic3ZnXCIgIF07XG4gICAgICAgIH0sXG4gICAgICAgIGdldENsYXNzOl9nZXRDbGFzc05hbWUsXG4gICAgICAgIGFkZENsYXNzOiBmdW5jdGlvbiAoZWwsIGNsYXp6KSB7XG4gICAgICAgICAgICBqc1BsdW1iLmVhY2goZWwsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgX2NsYXNzTWFuaXAoZSwgY2xhenopO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGhhc0NsYXNzOiBmdW5jdGlvbiAoZWwsIGNsYXp6KSB7XG4gICAgICAgICAgICBlbCA9IGpzUGx1bWIuZ2V0RWxlbWVudChlbCk7XG4gICAgICAgICAgICBpZiAoZWwuY2xhc3NMaXN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsLmNsYXNzTGlzdC5jb250YWlucyhjbGF6eik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2dldENsYXNzTmFtZShlbCkuaW5kZXhPZihjbGF6eikgIT09IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICByZW1vdmVDbGFzczogZnVuY3Rpb24gKGVsLCBjbGF6eikge1xuICAgICAgICAgICAganNQbHVtYi5lYWNoKGVsLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIF9jbGFzc01hbmlwKGUsIG51bGwsIGNsYXp6KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICB1cGRhdGVDbGFzc2VzOiBmdW5jdGlvbiAoZWwsIHRvQWRkLCB0b1JlbW92ZSkge1xuICAgICAgICAgICAganNQbHVtYi5lYWNoKGVsLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIF9jbGFzc01hbmlwKGUsIHRvQWRkLCB0b1JlbW92ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0Q2xhc3M6IGZ1bmN0aW9uIChlbCwgY2xhenopIHtcbiAgICAgICAgICAgIGpzUGx1bWIuZWFjaChlbCwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBfc2V0Q2xhc3NOYW1lKGUsIGNsYXp6KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBzZXRQb3NpdGlvbjogZnVuY3Rpb24gKGVsLCBwKSB7XG4gICAgICAgICAgICBlbC5zdHlsZS5sZWZ0ID0gcC5sZWZ0ICsgXCJweFwiO1xuICAgICAgICAgICAgZWwuc3R5bGUudG9wID0gcC50b3AgKyBcInB4XCI7XG4gICAgICAgIH0sXG4gICAgICAgIGdldFBvc2l0aW9uOiBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIHZhciBfb25lID0gZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICAgICAgICB2YXIgdiA9IGVsLnN0eWxlW3Byb3BdO1xuICAgICAgICAgICAgICAgIHJldHVybiB2ID8gdi5zdWJzdHJpbmcoMCwgdi5sZW5ndGggLSAyKSA6IDA7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBsZWZ0OiBfb25lKFwibGVmdFwiKSxcbiAgICAgICAgICAgICAgICB0b3A6IF9vbmUoXCJ0b3BcIilcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGdldFN0eWxlOmZ1bmN0aW9uKGVsLCBwcm9wKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXRDb21wdXRlZFN0eWxlKGVsLCBudWxsKS5nZXRQcm9wZXJ0eVZhbHVlKHByb3ApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWwuY3VycmVudFN0eWxlW3Byb3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBnZXRTZWxlY3RvcjogZnVuY3Rpb24gKGN0eCwgc3BlYykge1xuICAgICAgICAgICAgdmFyIHNlbCA9IG51bGw7XG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHNlbCA9IGN0eC5ub2RlVHlwZSAhPSBudWxsID8gY3R4IDogZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChjdHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2VsID0gY3R4LnF1ZXJ5U2VsZWN0b3JBbGwoc3BlYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBzZWw7XG4gICAgICAgIH0sXG4gICAgICAgIGdldE9mZnNldDpmdW5jdGlvbihlbCwgcmVsYXRpdmVUb1Jvb3QsIGNvbnRhaW5lcikge1xuICAgICAgICAgICAgZWwgPSBqc1BsdW1iLmdldEVsZW1lbnQoZWwpO1xuICAgICAgICAgICAgY29udGFpbmVyID0gY29udGFpbmVyIHx8IHRoaXMuZ2V0Q29udGFpbmVyKCk7XG4gICAgICAgICAgICB2YXIgb3V0ID0ge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0OiBlbC5vZmZzZXRMZWZ0LFxuICAgICAgICAgICAgICAgICAgICB0b3A6IGVsLm9mZnNldFRvcFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb3AgPSAocmVsYXRpdmVUb1Jvb3QgIHx8IChjb250YWluZXIgIT0gbnVsbCAmJiAoZWwgIT09IGNvbnRhaW5lciAmJiBlbC5vZmZzZXRQYXJlbnQgIT09IGNvbnRhaW5lcikpKSA/ICBlbC5vZmZzZXRQYXJlbnQgOiBudWxsLFxuICAgICAgICAgICAgICAgIF9tYXliZUFkanVzdFNjcm9sbCA9IGZ1bmN0aW9uKG9mZnNldFBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAob2Zmc2V0UGFyZW50ICE9IG51bGwgJiYgb2Zmc2V0UGFyZW50ICE9PSBkb2N1bWVudC5ib2R5ICYmIChvZmZzZXRQYXJlbnQuc2Nyb2xsVG9wID4gMCB8fCBvZmZzZXRQYXJlbnQuc2Nyb2xsTGVmdCA+IDApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXQubGVmdCAtPSBvZmZzZXRQYXJlbnQuc2Nyb2xsTGVmdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dC50b3AgLT0gb2Zmc2V0UGFyZW50LnNjcm9sbFRvcDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKTtcblxuICAgICAgICAgICAgd2hpbGUgKG9wICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBvdXQubGVmdCArPSBvcC5vZmZzZXRMZWZ0O1xuICAgICAgICAgICAgICAgIG91dC50b3AgKz0gb3Aub2Zmc2V0VG9wO1xuICAgICAgICAgICAgICAgIF9tYXliZUFkanVzdFNjcm9sbChvcCk7XG4gICAgICAgICAgICAgICAgb3AgPSByZWxhdGl2ZVRvUm9vdCA/IG9wLm9mZnNldFBhcmVudCA6XG4gICAgICAgICAgICAgICAgICAgICAgICBvcC5vZmZzZXRQYXJlbnQgPT09IGNvbnRhaW5lciA/IG51bGwgOiBvcC5vZmZzZXRQYXJlbnQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlmIGNvbnRhaW5lciBpcyBzY3JvbGxlZCBhbmQgdGhlIGVsZW1lbnQgKG9yIGl0cyBvZmZzZXQgcGFyZW50KSBpcyBub3QgYWJzb2x1dGUgb3IgZml4ZWQsIGFkanVzdCBhY2NvcmRpbmdseS5cbiAgICAgICAgICAgIGlmIChjb250YWluZXIgIT0gbnVsbCAmJiAhcmVsYXRpdmVUb1Jvb3QgJiYgKGNvbnRhaW5lci5zY3JvbGxUb3AgPiAwIHx8IGNvbnRhaW5lci5zY3JvbGxMZWZ0ID4gMCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHAgPSBlbC5vZmZzZXRQYXJlbnQgIT0gbnVsbCA/IHRoaXMuZ2V0U3R5bGUoZWwub2Zmc2V0UGFyZW50LCBcInBvc2l0aW9uXCIpIDogXCJzdGF0aWNcIixcbiAgICAgICAgICAgICAgICAgICAgcCA9IHRoaXMuZ2V0U3R5bGUoZWwsIFwicG9zaXRpb25cIik7XG4gICAgICAgICAgICAgICAgaWYgKHAgIT09IFwiYWJzb2x1dGVcIiAmJiBwICE9PSBcImZpeGVkXCIgJiYgcHAgIT09IFwiYWJzb2x1dGVcIiAmJiBwcCAhPT0gXCJmaXhlZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dC5sZWZ0IC09IGNvbnRhaW5lci5zY3JvbGxMZWZ0O1xuICAgICAgICAgICAgICAgICAgICBvdXQudG9wIC09IGNvbnRhaW5lci5zY3JvbGxUb3A7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSxcbiAgICAgICAgLy9cbiAgICAgICAgLy8gcmV0dXJuIHgreSBwcm9wb3J0aW9uIG9mIHRoZSBnaXZlbiBlbGVtZW50J3Mgc2l6ZSBjb3JyZXNwb25kaW5nIHRvIHRoZSBsb2NhdGlvbiBvZiB0aGUgZ2l2ZW4gZXZlbnQuXG4gICAgICAgIC8vXG4gICAgICAgIGdldFBvc2l0aW9uT25FbGVtZW50OiBmdW5jdGlvbiAoZXZ0LCBlbCwgem9vbSkge1xuICAgICAgICAgICAgdmFyIGJveCA9IHR5cGVvZiBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QgIT09IFwidW5kZWZpbmVkXCIgPyBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSA6IHsgbGVmdDogMCwgdG9wOiAwLCB3aWR0aDogMCwgaGVpZ2h0OiAwIH0sXG4gICAgICAgICAgICAgICAgYm9keSA9IGRvY3VtZW50LmJvZHksXG4gICAgICAgICAgICAgICAgZG9jRWxlbSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCxcbiAgICAgICAgICAgICAgICBzY3JvbGxUb3AgPSB3aW5kb3cucGFnZVlPZmZzZXQgfHwgZG9jRWxlbS5zY3JvbGxUb3AgfHwgYm9keS5zY3JvbGxUb3AsXG4gICAgICAgICAgICAgICAgc2Nyb2xsTGVmdCA9IHdpbmRvdy5wYWdlWE9mZnNldCB8fCBkb2NFbGVtLnNjcm9sbExlZnQgfHwgYm9keS5zY3JvbGxMZWZ0LFxuICAgICAgICAgICAgICAgIGNsaWVudFRvcCA9IGRvY0VsZW0uY2xpZW50VG9wIHx8IGJvZHkuY2xpZW50VG9wIHx8IDAsXG4gICAgICAgICAgICAgICAgY2xpZW50TGVmdCA9IGRvY0VsZW0uY2xpZW50TGVmdCB8fCBib2R5LmNsaWVudExlZnQgfHwgMCxcbiAgICAgICAgICAgICAgICBwc3QgPSAwLFxuICAgICAgICAgICAgICAgIHBzbCA9IDAsXG4gICAgICAgICAgICAgICAgdG9wID0gYm94LnRvcCArIHNjcm9sbFRvcCAtIGNsaWVudFRvcCArIChwc3QgKiB6b29tKSxcbiAgICAgICAgICAgICAgICBsZWZ0ID0gYm94LmxlZnQgKyBzY3JvbGxMZWZ0IC0gY2xpZW50TGVmdCArIChwc2wgKiB6b29tKSxcbiAgICAgICAgICAgICAgICBjbCA9IGpzUGx1bWIucGFnZUxvY2F0aW9uKGV2dCksXG4gICAgICAgICAgICAgICAgdyA9IGJveC53aWR0aCB8fCAoZWwub2Zmc2V0V2lkdGggKiB6b29tKSxcbiAgICAgICAgICAgICAgICBoID0gYm94LmhlaWdodCB8fCAoZWwub2Zmc2V0SGVpZ2h0ICogem9vbSksXG4gICAgICAgICAgICAgICAgeCA9IChjbFswXSAtIGxlZnQpIC8gdyxcbiAgICAgICAgICAgICAgICB5ID0gKGNsWzFdIC0gdG9wKSAvIGg7XG5cbiAgICAgICAgICAgIHJldHVybiBbIHgsIHkgXTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0cyB0aGUgYWJzb2x1dGUgcG9zaXRpb24gb2Ygc29tZSBlbGVtZW50IGFzIHJlYWQgZnJvbSB0aGUgbGVmdC90b3AgcHJvcGVydGllcyBpbiBpdHMgc3R5bGUuXG4gICAgICAgICAqIEBtZXRob2QgZ2V0QWJzb2x1dGVQb3NpdGlvblxuICAgICAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsIFRoZSBlbGVtZW50IHRvIHJldHJpZXZlIHRoZSBhYnNvbHV0ZSBjb29yZGluYXRlcyBmcm9tLiAqKk5vdGUqKiB0aGlzIGlzIGEgRE9NIGVsZW1lbnQsIG5vdCBhIHNlbGVjdG9yIGZyb20gdGhlIHVuZGVybHlpbmcgbGlicmFyeS5cbiAgICAgICAgICogQHJldHVybiB7TnVtYmVyW119IFtsZWZ0LCB0b3BdIHBpeGVsIHZhbHVlcy5cbiAgICAgICAgICovXG4gICAgICAgIGdldEFic29sdXRlUG9zaXRpb246IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgdmFyIF9vbmUgPSBmdW5jdGlvbiAocykge1xuICAgICAgICAgICAgICAgIHZhciBzcyA9IGVsLnN0eWxlW3NdO1xuICAgICAgICAgICAgICAgIGlmIChzcykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChzcy5zdWJzdHJpbmcoMCwgc3MubGVuZ3RoIC0gMikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gWyBfb25lKFwibGVmdFwiKSwgX29uZShcInRvcFwiKSBdO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIHRoZSBhYnNvbHV0ZSBwb3NpdGlvbiBvZiBzb21lIGVsZW1lbnQgYnkgc2V0dGluZyB0aGUgbGVmdC90b3AgcHJvcGVydGllcyBpbiBpdHMgc3R5bGUuXG4gICAgICAgICAqIEBtZXRob2Qgc2V0QWJzb2x1dGVQb3NpdGlvblxuICAgICAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsIFRoZSBlbGVtZW50IHRvIHNldCB0aGUgYWJzb2x1dGUgY29vcmRpbmF0ZXMgb24uICoqTm90ZSoqIHRoaXMgaXMgYSBET00gZWxlbWVudCwgbm90IGEgc2VsZWN0b3IgZnJvbSB0aGUgdW5kZXJseWluZyBsaWJyYXJ5LlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcltdfSB4eSB4IGFuZCB5IGNvb3JkaW5hdGVzXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyW119IFthbmltYXRlRnJvbV0gT3B0aW9uYWwgcHJldmlvdXMgeHkgdG8gYW5pbWF0ZSBmcm9tLlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gW2FuaW1hdGVPcHRpb25zXSBPcHRpb25zIGZvciB0aGUgYW5pbWF0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgc2V0QWJzb2x1dGVQb3NpdGlvbjogZnVuY3Rpb24gKGVsLCB4eSwgYW5pbWF0ZUZyb20sIGFuaW1hdGVPcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAoYW5pbWF0ZUZyb20pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFuaW1hdGUoZWwsIHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogXCIrPVwiICsgKHh5WzBdIC0gYW5pbWF0ZUZyb21bMF0pLFxuICAgICAgICAgICAgICAgICAgICB0b3A6IFwiKz1cIiArICh4eVsxXSAtIGFuaW1hdGVGcm9tWzFdKVxuICAgICAgICAgICAgICAgIH0sIGFuaW1hdGVPcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGVsLnN0eWxlLmxlZnQgPSB4eVswXSArIFwicHhcIjtcbiAgICAgICAgICAgICAgICBlbC5zdHlsZS50b3AgPSB4eVsxXSArIFwicHhcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGdldHMgdGhlIHNpemUgZm9yIHRoZSBlbGVtZW50LCBpbiBhbiBhcnJheSA6IFsgd2lkdGgsIGhlaWdodCBdLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0U2l6ZTogZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICByZXR1cm4gWyBlbC5vZmZzZXRXaWR0aCwgZWwub2Zmc2V0SGVpZ2h0IF07XG4gICAgICAgIH0sXG4gICAgICAgIGdldFdpZHRoOiBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIHJldHVybiBlbC5vZmZzZXRXaWR0aDtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0SGVpZ2h0OiBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIHJldHVybiBlbC5vZmZzZXRIZWlnaHQ7XG4gICAgICAgIH0sXG4gICAgICAgIGdldFJlbmRlck1vZGUgOiBmdW5jdGlvbigpIHsgcmV0dXJuIFwic3ZnXCI7IH1cblxuICAgIH0pO1xufSkuY2FsbCh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHRoaXMpO1xuXG4vKlxuICoganNQbHVtYiBDb21tdW5pdHkgRWRpdGlvblxuICpcbiAqIFByb3ZpZGVzIGEgd2F5IHRvIHZpc3VhbGx5IGNvbm5lY3QgZWxlbWVudHMgb24gYW4gSFRNTCBwYWdlLCB1c2luZyBTVkcuXG4gKlxuICogVGhpcyBmaWxlIGNvbnRhaW5zIGNvZGUgZm9yIGNvbXBvbmVudHMgdGhhdCBzdXBwb3J0IG92ZXJsYXlzLlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMCAtIDIwMTcganNQbHVtYiAoaGVsbG9AanNwbHVtYnRvb2xraXQuY29tKVxuICpcbiAqIGh0dHBzOi8vanNwbHVtYnRvb2xraXQuY29tXG4gKiBodHRwczovL2dpdGh1Yi5jb20vanNwbHVtYi9qc3BsdW1iXG4gKlxuICogRHVhbCBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGFuZCBHUEwyIGxpY2Vuc2VzLlxuICovXG47KGZ1bmN0aW9uKCkge1xuXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIHJvb3QgPSB0aGlzLCBfanAgPSByb290LmpzUGx1bWIsIF9qdSA9IHJvb3QuanNQbHVtYlV0aWw7XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gQkVHSU4gT3ZlcmxheUNhcGFibGVqc1BsdW1iVUlDb21wb25lbnQgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHZhciBfaW50ZXJuYWxMYWJlbE92ZXJsYXlJZCA9IFwiX19sYWJlbFwiLFxuICAgIC8vIHRoaXMgaXMgYSBzaG9ydGN1dCBoZWxwZXIgbWV0aG9kIHRvIGxldCBwZW9wbGUgYWRkIGEgbGFiZWwgYXNcbiAgICAvLyBvdmVybGF5LlxuICAgICAgICBfbWFrZUxhYmVsT3ZlcmxheSA9IGZ1bmN0aW9uIChjb21wb25lbnQsIHBhcmFtcykge1xuXG4gICAgICAgICAgICB2YXIgX3BhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgY3NzQ2xhc3M6IHBhcmFtcy5jc3NDbGFzcyxcbiAgICAgICAgICAgICAgICAgICAgbGFiZWxTdHlsZTogY29tcG9uZW50LmxhYmVsU3R5bGUsXG4gICAgICAgICAgICAgICAgICAgIGlkOiBfaW50ZXJuYWxMYWJlbE92ZXJsYXlJZCxcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50OiBjb21wb25lbnQsXG4gICAgICAgICAgICAgICAgICAgIF9qc1BsdW1iOiBjb21wb25lbnQuX2pzUGx1bWIuaW5zdGFuY2UgIC8vIFRPRE8gbm90IG5lY2Vzc2FyeSwgc2luY2UgdGhlIGluc3RhbmNlIGNhbiBiZSBhY2Nlc3NlZCB0aHJvdWdoIHRoZSBjb21wb25lbnQuXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBtZXJnZWRQYXJhbXMgPSBfanAuZXh0ZW5kKF9wYXJhbXMsIHBhcmFtcyk7XG5cbiAgICAgICAgICAgIHJldHVybiBuZXcgX2pwLk92ZXJsYXlzW2NvbXBvbmVudC5fanNQbHVtYi5pbnN0YW5jZS5nZXRSZW5kZXJNb2RlKCldLkxhYmVsKG1lcmdlZFBhcmFtcyk7XG4gICAgICAgIH0sXG4gICAgICAgIF9wcm9jZXNzT3ZlcmxheSA9IGZ1bmN0aW9uIChjb21wb25lbnQsIG8pIHtcbiAgICAgICAgICAgIHZhciBfbmV3T3ZlcmxheSA9IG51bGw7XG4gICAgICAgICAgICBpZiAoX2p1LmlzQXJyYXkobykpIHtcdC8vIHRoaXMgaXMgZm9yIHRoZSBzaG9ydGhhbmQgW1wiQXJyb3dcIiwgeyB3aWR0aDo1MCB9XSBzeW50YXhcbiAgICAgICAgICAgICAgICAvLyB0aGVyZSdzIGFsc28gYSB0aHJlZSBhcmcgdmVyc2lvbjpcbiAgICAgICAgICAgICAgICAvLyBbXCJBcnJvd1wiLCB7IHdpZHRoOjUwIH0sIHtsb2NhdGlvbjowLjd9XVxuICAgICAgICAgICAgICAgIC8vIHdoaWNoIG1lcmdlcyB0aGUgM3JkIGFyZyBpbnRvIHRoZSAybmQuXG4gICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBvWzBdLFxuICAgICAgICAgICAgICAgIC8vIG1ha2UgYSBjb3B5IG9mIHRoZSBvYmplY3Qgc28gYXMgbm90IHRvIG1lc3MgdXAgYW55b25lIGVsc2UncyByZWZlcmVuY2UuLi5cbiAgICAgICAgICAgICAgICAgICAgcCA9IF9qcC5leHRlbmQoe2NvbXBvbmVudDogY29tcG9uZW50LCBfanNQbHVtYjogY29tcG9uZW50Ll9qc1BsdW1iLmluc3RhbmNlfSwgb1sxXSk7XG4gICAgICAgICAgICAgICAgaWYgKG8ubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgICAgICAgICAgIF9qcC5leHRlbmQocCwgb1syXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF9uZXdPdmVybGF5ID0gbmV3IF9qcC5PdmVybGF5c1tjb21wb25lbnQuX2pzUGx1bWIuaW5zdGFuY2UuZ2V0UmVuZGVyTW9kZSgpXVt0eXBlXShwKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoby5jb25zdHJ1Y3RvciA9PT0gU3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgX25ld092ZXJsYXkgPSBuZXcgX2pwLk92ZXJsYXlzW2NvbXBvbmVudC5fanNQbHVtYi5pbnN0YW5jZS5nZXRSZW5kZXJNb2RlKCldW29dKHtjb21wb25lbnQ6IGNvbXBvbmVudCwgX2pzUGx1bWI6IGNvbXBvbmVudC5fanNQbHVtYi5pbnN0YW5jZX0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBfbmV3T3ZlcmxheSA9IG87XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9uZXdPdmVybGF5LmlkID0gX25ld092ZXJsYXkuaWQgfHwgX2p1LnV1aWQoKTtcbiAgICAgICAgICAgIGNvbXBvbmVudC5jYWNoZVR5cGVJdGVtKFwib3ZlcmxheVwiLCBfbmV3T3ZlcmxheSwgX25ld092ZXJsYXkuaWQpO1xuICAgICAgICAgICAgY29tcG9uZW50Ll9qc1BsdW1iLm92ZXJsYXlzW19uZXdPdmVybGF5LmlkXSA9IF9uZXdPdmVybGF5O1xuXG4gICAgICAgICAgICByZXR1cm4gX25ld092ZXJsYXk7XG4gICAgICAgIH07XG5cbiAgICBfanAuT3ZlcmxheUNhcGFibGVKc1BsdW1iVUlDb21wb25lbnQgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG5cbiAgICAgICAgcm9vdC5qc1BsdW1iVUlDb21wb25lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5fanNQbHVtYi5vdmVybGF5cyA9IHt9O1xuICAgICAgICB0aGlzLl9qc1BsdW1iLm92ZXJsYXlQb3NpdGlvbnMgPSB7fTtcblxuICAgICAgICBpZiAocGFyYW1zLmxhYmVsKSB7XG4gICAgICAgICAgICB0aGlzLmdldERlZmF1bHRUeXBlKCkub3ZlcmxheXNbX2ludGVybmFsTGFiZWxPdmVybGF5SWRdID0gW1wiTGFiZWxcIiwge1xuICAgICAgICAgICAgICAgIGxhYmVsOiBwYXJhbXMubGFiZWwsXG4gICAgICAgICAgICAgICAgbG9jYXRpb246IHBhcmFtcy5sYWJlbExvY2F0aW9uIHx8IHRoaXMuZGVmYXVsdExhYmVsTG9jYXRpb24gfHwgMC41LFxuICAgICAgICAgICAgICAgIGxhYmVsU3R5bGU6IHBhcmFtcy5sYWJlbFN0eWxlIHx8IHRoaXMuX2pzUGx1bWIuaW5zdGFuY2UuRGVmYXVsdHMuTGFiZWxTdHlsZSxcbiAgICAgICAgICAgICAgICBpZDpfaW50ZXJuYWxMYWJlbE92ZXJsYXlJZFxuICAgICAgICAgICAgfV07XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNldExpc3RlbmVyQ29tcG9uZW50ID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9qc1BsdW1iKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSBpbiB0aGlzLl9qc1BsdW1iLm92ZXJsYXlzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2pzUGx1bWIub3ZlcmxheXNbaV0uc2V0TGlzdGVuZXJDb21wb25lbnQoYyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICBfanAuT3ZlcmxheUNhcGFibGVKc1BsdW1iVUlDb21wb25lbnQuYXBwbHlUeXBlID0gZnVuY3Rpb24gKGNvbXBvbmVudCwgdCkge1xuICAgICAgICBpZiAodC5vdmVybGF5cykge1xuICAgICAgICAgICAgLy8gbG9vcCB0aHJvdWdoIHRoZSBvbmVzIGluIHRoZSB0eXBlLiBpZiBhbHJlYWR5IHByZXNlbnQgb24gdGhlIGNvbXBvbmVudCxcbiAgICAgICAgICAgIC8vIGRvbnQgcmVtb3ZlIG9yIHJlLWFkZC5cbiAgICAgICAgICAgIHZhciBrZWVwID0ge30sIGk7XG5cbiAgICAgICAgICAgIGZvciAoaSBpbiB0Lm92ZXJsYXlzKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgZXhpc3RpbmcgPSBjb21wb25lbnQuX2pzUGx1bWIub3ZlcmxheXNbdC5vdmVybGF5c1tpXVsxXS5pZF07XG4gICAgICAgICAgICAgICAgaWYgKGV4aXN0aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG1heWJlIHVwZGF0ZSBmcm9tIGRhdGEsIGlmIHRoZXJlIHdlcmUgcGFyYW1ldGVyaXNlZCB2YWx1ZXMgZm9yIGluc3RhbmNlLlxuICAgICAgICAgICAgICAgICAgICBleGlzdGluZy51cGRhdGVGcm9tKHQub3ZlcmxheXNbaV1bMV0pO1xuICAgICAgICAgICAgICAgICAgICBrZWVwW3Qub3ZlcmxheXNbaV1bMV0uaWRdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjID0gY29tcG9uZW50LmdldENhY2hlZFR5cGVJdGVtKFwib3ZlcmxheVwiLCB0Lm92ZXJsYXlzW2ldWzFdLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYy5yZWF0dGFjaChjb21wb25lbnQuX2pzUGx1bWIuaW5zdGFuY2UsIGNvbXBvbmVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjLnNldFZpc2libGUodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBtYXliZSB1cGRhdGUgZnJvbSBkYXRhLCBpZiB0aGVyZSB3ZXJlIHBhcmFtZXRlcmlzZWQgdmFsdWVzIGZvciBpbnN0YW5jZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGMudXBkYXRlRnJvbSh0Lm92ZXJsYXlzW2ldWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudC5fanNQbHVtYi5vdmVybGF5c1tjLmlkXSA9IGM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjID0gY29tcG9uZW50LmFkZE92ZXJsYXkodC5vdmVybGF5c1tpXSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAga2VlcFtjLmlkXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBub3cgbG9vcCB0aHJvdWdoIHRoZSBmdWxsIG92ZXJsYXlzIGFuZCByZW1vdmUgdGhvc2UgdGhhdCB3ZSBkb250IHdhbnQgdG8ga2VlcFxuICAgICAgICAgICAgZm9yIChpIGluIGNvbXBvbmVudC5fanNQbHVtYi5vdmVybGF5cykge1xuICAgICAgICAgICAgICAgIGlmIChrZWVwW2NvbXBvbmVudC5fanNQbHVtYi5vdmVybGF5c1tpXS5pZF0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQucmVtb3ZlT3ZlcmxheShjb21wb25lbnQuX2pzUGx1bWIub3ZlcmxheXNbaV0uaWQsIHRydWUpOyAvLyByZW1vdmUgb3ZlcmxheSBidXQgZG9udCBjbGVhbiBpdCB1cC5cbiAgICAgICAgICAgICAgICAgICAgLy8gdGhhdCB3b3VsZCByZW1vdmUgZXZlbnQgbGlzdGVuZXJzIGV0Yzsgb3ZlcmxheXMgYXJlIG5ldmVyIGRpc2NhcmRlZCBieSB0aGUgdHlwZXMgc3R1ZmYsIHRoZXkgYXJlXG4gICAgICAgICAgICAgICAgICAgIC8vIGp1c3QgZGV0YWNoZWQvcmVhdHRhY2hlZC5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgX2p1LmV4dGVuZChfanAuT3ZlcmxheUNhcGFibGVKc1BsdW1iVUlDb21wb25lbnQsIHJvb3QuanNQbHVtYlVJQ29tcG9uZW50LCB7XG5cbiAgICAgICAgc2V0SG92ZXI6IGZ1bmN0aW9uIChob3ZlciwgaWdub3JlQXR0YWNoZWRFbGVtZW50cykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2pzUGx1bWIgJiYgIXRoaXMuX2pzUGx1bWIuaW5zdGFuY2UuaXNDb25uZWN0aW9uQmVpbmdEcmFnZ2VkKCkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpIGluIHRoaXMuX2pzUGx1bWIub3ZlcmxheXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fanNQbHVtYi5vdmVybGF5c1tpXVtob3ZlciA/IFwiYWRkQ2xhc3NcIiA6IFwicmVtb3ZlQ2xhc3NcIl0odGhpcy5fanNQbHVtYi5pbnN0YW5jZS5ob3ZlckNsYXNzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGFkZE92ZXJsYXk6IGZ1bmN0aW9uIChvdmVybGF5LCBkb05vdFJlcGFpbnQpIHtcbiAgICAgICAgICAgIHZhciBvID0gX3Byb2Nlc3NPdmVybGF5KHRoaXMsIG92ZXJsYXkpO1xuICAgICAgICAgICAgaWYgKCFkb05vdFJlcGFpbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlcGFpbnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvO1xuICAgICAgICB9LFxuICAgICAgICBnZXRPdmVybGF5OiBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9qc1BsdW1iLm92ZXJsYXlzW2lkXTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0T3ZlcmxheXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9qc1BsdW1iLm92ZXJsYXlzO1xuICAgICAgICB9LFxuICAgICAgICBoaWRlT3ZlcmxheTogZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgICAgICB2YXIgbyA9IHRoaXMuZ2V0T3ZlcmxheShpZCk7XG4gICAgICAgICAgICBpZiAobykge1xuICAgICAgICAgICAgICAgIG8uaGlkZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBoaWRlT3ZlcmxheXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5fanNQbHVtYi5vdmVybGF5cykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2pzUGx1bWIub3ZlcmxheXNbaV0uaGlkZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzaG93T3ZlcmxheTogZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgICAgICB2YXIgbyA9IHRoaXMuZ2V0T3ZlcmxheShpZCk7XG4gICAgICAgICAgICBpZiAobykge1xuICAgICAgICAgICAgICAgIG8uc2hvdygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzaG93T3ZlcmxheXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5fanNQbHVtYi5vdmVybGF5cykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2pzUGx1bWIub3ZlcmxheXNbaV0uc2hvdygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICByZW1vdmVBbGxPdmVybGF5czogZnVuY3Rpb24gKGRvTm90UmVwYWludCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSBpbiB0aGlzLl9qc1BsdW1iLm92ZXJsYXlzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2pzUGx1bWIub3ZlcmxheXNbaV0uY2xlYW51cCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9qc1BsdW1iLm92ZXJsYXlzW2ldLmNsZWFudXAoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX2pzUGx1bWIub3ZlcmxheXMgPSB7fTtcbiAgICAgICAgICAgIHRoaXMuX2pzUGx1bWIub3ZlcmxheVBvc2l0aW9ucyA9IG51bGw7XG4gICAgICAgICAgICBpZiAoIWRvTm90UmVwYWludCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVwYWludCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICByZW1vdmVPdmVybGF5OiBmdW5jdGlvbiAob3ZlcmxheUlkLCBkb250Q2xlYW51cCkge1xuICAgICAgICAgICAgdmFyIG8gPSB0aGlzLl9qc1BsdW1iLm92ZXJsYXlzW292ZXJsYXlJZF07XG4gICAgICAgICAgICBpZiAobykge1xuICAgICAgICAgICAgICAgIG8uc2V0VmlzaWJsZShmYWxzZSk7XG4gICAgICAgICAgICAgICAgaWYgKCFkb250Q2xlYW51cCAmJiBvLmNsZWFudXApIHtcbiAgICAgICAgICAgICAgICAgICAgby5jbGVhbnVwKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9qc1BsdW1iLm92ZXJsYXlzW292ZXJsYXlJZF07XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2pzUGx1bWIub3ZlcmxheVBvc2l0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fanNQbHVtYi5vdmVybGF5UG9zaXRpb25zW292ZXJsYXlJZF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICByZW1vdmVPdmVybGF5czogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGogPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVPdmVybGF5KGFyZ3VtZW50c1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG1vdmVQYXJlbnQ6IGZ1bmN0aW9uIChuZXdQYXJlbnQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmJnQ2FudmFzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5iZ0NhbnZhcy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuYmdDYW52YXMpO1xuICAgICAgICAgICAgICAgIG5ld1BhcmVudC5hcHBlbmRDaGlsZCh0aGlzLmJnQ2FudmFzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuY2FudmFzICYmIHRoaXMuY2FudmFzLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbnZhcy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuY2FudmFzKTtcbiAgICAgICAgICAgICAgICBuZXdQYXJlbnQuYXBwZW5kQ2hpbGQodGhpcy5jYW52YXMpO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSBpbiB0aGlzLl9qc1BsdW1iLm92ZXJsYXlzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9qc1BsdW1iLm92ZXJsYXlzW2ldLmlzQXBwZW5kZWRBdFRvcExldmVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZWwgPSB0aGlzLl9qc1BsdW1iLm92ZXJsYXlzW2ldLmdldEVsZW1lbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3UGFyZW50LmFwcGVuZENoaWxkKGVsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZ2V0TGFiZWw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBsbyA9IHRoaXMuZ2V0T3ZlcmxheShfaW50ZXJuYWxMYWJlbE92ZXJsYXlJZCk7XG4gICAgICAgICAgICByZXR1cm4gbG8gIT0gbnVsbCA/IGxvLmdldExhYmVsKCkgOiBudWxsO1xuICAgICAgICB9LFxuICAgICAgICBnZXRMYWJlbE92ZXJsYXk6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldE92ZXJsYXkoX2ludGVybmFsTGFiZWxPdmVybGF5SWQpO1xuICAgICAgICB9LFxuICAgICAgICBzZXRMYWJlbDogZnVuY3Rpb24gKGwpIHtcbiAgICAgICAgICAgIHZhciBsbyA9IHRoaXMuZ2V0T3ZlcmxheShfaW50ZXJuYWxMYWJlbE92ZXJsYXlJZCk7XG4gICAgICAgICAgICBpZiAoIWxvKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmFtcyA9IGwuY29uc3RydWN0b3IgPT09IFN0cmluZyB8fCBsLmNvbnN0cnVjdG9yID09PSBGdW5jdGlvbiA/IHsgbGFiZWw6IGwgfSA6IGw7XG4gICAgICAgICAgICAgICAgbG8gPSBfbWFrZUxhYmVsT3ZlcmxheSh0aGlzLCBwYXJhbXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2pzUGx1bWIub3ZlcmxheXNbX2ludGVybmFsTGFiZWxPdmVybGF5SWRdID0gbG87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAobC5jb25zdHJ1Y3RvciA9PT0gU3RyaW5nIHx8IGwuY29uc3RydWN0b3IgPT09IEZ1bmN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvLnNldExhYmVsKGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGwubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvLnNldExhYmVsKGwubGFiZWwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChsLmxvY2F0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsby5zZXRMb2NhdGlvbihsLmxvY2F0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCF0aGlzLl9qc1BsdW1iLmluc3RhbmNlLmlzU3VzcGVuZERyYXdpbmcoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVwYWludCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjbGVhbnVwOiBmdW5jdGlvbiAoZm9yY2UpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5fanNQbHVtYi5vdmVybGF5cykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2pzUGx1bWIub3ZlcmxheXNbaV0uY2xlYW51cChmb3JjZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fanNQbHVtYi5vdmVybGF5c1tpXS5kZXN0cm95KGZvcmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmb3JjZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2pzUGx1bWIub3ZlcmxheXMgPSB7fTtcbiAgICAgICAgICAgICAgICB0aGlzLl9qc1BsdW1iLm92ZXJsYXlQb3NpdGlvbnMgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzZXRWaXNpYmxlOiBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgdGhpc1t2ID8gXCJzaG93T3ZlcmxheXNcIiA6IFwiaGlkZU92ZXJsYXlzXCJdKCk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldEFic29sdXRlT3ZlcmxheVBvc2l0aW9uOiBmdW5jdGlvbiAob3ZlcmxheSwgeHkpIHtcbiAgICAgICAgICAgIHRoaXMuX2pzUGx1bWIub3ZlcmxheVBvc2l0aW9uc1tvdmVybGF5LmlkXSA9IHh5O1xuICAgICAgICB9LFxuICAgICAgICBnZXRBYnNvbHV0ZU92ZXJsYXlQb3NpdGlvbjogZnVuY3Rpb24gKG92ZXJsYXkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9qc1BsdW1iLm92ZXJsYXlQb3NpdGlvbnMgPyB0aGlzLl9qc1BsdW1iLm92ZXJsYXlQb3NpdGlvbnNbb3ZlcmxheS5pZF0gOiBudWxsO1xuICAgICAgICB9LFxuICAgICAgICBfY2xhenpNYW5pcDpmdW5jdGlvbihhY3Rpb24sIGNsYXp6LCBkb250VXBkYXRlT3ZlcmxheXMpIHtcbiAgICAgICAgICAgIGlmICghZG9udFVwZGF0ZU92ZXJsYXlzKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSBpbiB0aGlzLl9qc1BsdW1iLm92ZXJsYXlzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2pzUGx1bWIub3ZlcmxheXNbaV1bYWN0aW9uICsgXCJDbGFzc1wiXShjbGF6eik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBhZGRDbGFzczpmdW5jdGlvbihjbGF6eiwgZG9udFVwZGF0ZU92ZXJsYXlzKSB7XG4gICAgICAgICAgICB0aGlzLl9jbGF6ek1hbmlwKFwiYWRkXCIsIGNsYXp6LCBkb250VXBkYXRlT3ZlcmxheXMpO1xuICAgICAgICB9LFxuICAgICAgICByZW1vdmVDbGFzczpmdW5jdGlvbihjbGF6eiwgZG9udFVwZGF0ZU92ZXJsYXlzKSB7XG4gICAgICAgICAgICB0aGlzLl9jbGF6ek1hbmlwKFwicmVtb3ZlXCIsIGNsYXp6LCBkb250VXBkYXRlT3ZlcmxheXMpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBFTkQgT3ZlcmxheUNhcGFibGVqc1BsdW1iVUlDb21wb25lbnQgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxufSkuY2FsbCh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHRoaXMpO1xuXG4vKlxuICoganNQbHVtYiBDb21tdW5pdHkgRWRpdGlvblxuICogXG4gKiBQcm92aWRlcyBhIHdheSB0byB2aXN1YWxseSBjb25uZWN0IGVsZW1lbnRzIG9uIGFuIEhUTUwgcGFnZSwgdXNpbmcgU1ZHLlxuICogXG4gKiBUaGlzIGZpbGUgY29udGFpbnMgdGhlIGNvZGUgZm9yIEVuZHBvaW50cy5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTAgLSAyMDE3IGpzUGx1bWIgKGhlbGxvQGpzcGx1bWJ0b29sa2l0LmNvbSlcbiAqIFxuICogaHR0cHM6Ly9qc3BsdW1idG9vbGtpdC5jb21cbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9qc3BsdW1iL2pzcGx1bWJcbiAqIFxuICogRHVhbCBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGFuZCBHUEwyIGxpY2Vuc2VzLlxuICovXG4oZnVuY3Rpb24gKCkge1xuXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIHJvb3QgPSB0aGlzLCBfanAgPSByb290LmpzUGx1bWIsIF9qdSA9IHJvb3QuanNQbHVtYlV0aWw7XG5cbiAgICAvLyBjcmVhdGUgdGhlIGRyYWcgaGFuZGxlciBmb3IgYSBjb25uZWN0aW9uXG4gICAgdmFyIF9tYWtlQ29ubmVjdGlvbkRyYWdIYW5kbGVyID0gZnVuY3Rpb24gKGVuZHBvaW50LCBwbGFjZWhvbGRlciwgX2pzUGx1bWIpIHtcbiAgICAgICAgdmFyIHN0b3BwZWQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRyYWc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RvcHBlZCkge1xuICAgICAgICAgICAgICAgICAgICBzdG9wcGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChwbGFjZWhvbGRlci5lbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfdWkgPSBfanNQbHVtYi5nZXRVSVBvc2l0aW9uKGFyZ3VtZW50cywgX2pzUGx1bWIuZ2V0Wm9vbSgpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF91aSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfanNQbHVtYi5zZXRQb3NpdGlvbihwbGFjZWhvbGRlci5lbGVtZW50LCBfdWkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF9qc1BsdW1iLnJlcGFpbnQocGxhY2Vob2xkZXIuZWxlbWVudCwgX3VpKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gYWx3YXlzIHJlcGFpbnQgdGhlIHNvdXJjZSBlbmRwb2ludCwgYmVjYXVzZSBvbmx5IGNvbnRpbnVvdXMvZHluYW1pYyBhbmNob3JzIGNhdXNlIHRoZSBlbmRwb2ludFxuICAgICAgICAgICAgICAgICAgICAvLyB0byBiZSByZXBhaW50ZWQsIHNvIHN0YXRpYyBhbmNob3JzIG5lZWQgdG8gYmUgdG9sZCAob3IgdGhlIGVuZHBvaW50IGdldHMgZHJhZ2dlZCBhcm91bmQpXG4gICAgICAgICAgICAgICAgICAgIGVuZHBvaW50LnBhaW50KHthbmNob3JQb2ludDplbmRwb2ludC5hbmNob3IuZ2V0Q3VycmVudExvY2F0aW9uKHtlbGVtZW50OmVuZHBvaW50fSl9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3RvcERyYWc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBzdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgLy8gY3JlYXRlcyBhIHBsYWNlaG9sZGVyIGRpdiBmb3IgZHJhZ2dpbmcgcHVycG9zZXMsIGFkZHMgaXQsIGFuZCBwcmUtY29tcHV0ZXMgaXRzIG9mZnNldC5cbiAgICB2YXIgX21ha2VEcmFnZ2FibGVQbGFjZWhvbGRlciA9IGZ1bmN0aW9uIChwbGFjZWhvbGRlciwgX2pzUGx1bWIsIGlwY28sIGlwcykge1xuICAgICAgICB2YXIgbiA9IF9qc1BsdW1iLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBwb3NpdGlvbiA6IFwiYWJzb2x1dGVcIiB9KTtcbiAgICAgICAgX2pzUGx1bWIuYXBwZW5kRWxlbWVudChuKTtcbiAgICAgICAgdmFyIGlkID0gX2pzUGx1bWIuZ2V0SWQobik7XG4gICAgICAgIF9qc1BsdW1iLnNldFBvc2l0aW9uKG4sIGlwY28pO1xuICAgICAgICBuLnN0eWxlLndpZHRoID0gaXBzWzBdICsgXCJweFwiO1xuICAgICAgICBuLnN0eWxlLmhlaWdodCA9IGlwc1sxXSArIFwicHhcIjtcbiAgICAgICAgX2pzUGx1bWIubWFuYWdlKGlkLCBuLCB0cnVlKTsgLy8gVFJBTlNJRU5UIE1BTkFHRVxuICAgICAgICAvLyBjcmVhdGUgYW5kIGFzc2lnbiBhbiBpZCwgYW5kIGluaXRpYWxpemUgdGhlIG9mZnNldC5cbiAgICAgICAgcGxhY2Vob2xkZXIuaWQgPSBpZDtcbiAgICAgICAgcGxhY2Vob2xkZXIuZWxlbWVudCA9IG47XG4gICAgfTtcblxuICAgIC8vIGNyZWF0ZSBhIGZsb2F0aW5nIGVuZHBvaW50IChmb3IgZHJhZyBjb25uZWN0aW9ucylcbiAgICB2YXIgX21ha2VGbG9hdGluZ0VuZHBvaW50ID0gZnVuY3Rpb24gKHBhaW50U3R5bGUsIHJlZmVyZW5jZUFuY2hvciwgZW5kcG9pbnQsIHJlZmVyZW5jZUNhbnZhcywgc291cmNlRWxlbWVudCwgX2pzUGx1bWIsIF9uZXdFbmRwb2ludCwgc2NvcGUpIHtcbiAgICAgICAgdmFyIGZsb2F0aW5nQW5jaG9yID0gbmV3IF9qcC5GbG9hdGluZ0FuY2hvcih7IHJlZmVyZW5jZTogcmVmZXJlbmNlQW5jaG9yLCByZWZlcmVuY2VDYW52YXM6IHJlZmVyZW5jZUNhbnZhcywganNQbHVtYkluc3RhbmNlOiBfanNQbHVtYiB9KTtcbiAgICAgICAgLy9zZXR0aW5nIHRoZSBzY29wZSBoZXJlIHNob3VsZCBub3QgYmUgdGhlIHdheSB0byBmaXggdGhhdCBtb290b29scyBpc3N1ZS4gIGl0IHNob3VsZCBiZSBmaXhlZCBieSBub3RcbiAgICAgICAgLy8gYWRkaW5nIHRoZSBmbG9hdGluZyBlbmRwb2ludCBhcyBhIGRyb3BwYWJsZS4gIHRoYXQgbWFrZXMgbW9yZSBzZW5zZSBhbnl3YXkhXG4gICAgICAgIC8vIFRSQU5TSUVOVCBNQU5BR0VcbiAgICAgICAgcmV0dXJuIF9uZXdFbmRwb2ludCh7XG4gICAgICAgICAgICBwYWludFN0eWxlOiBwYWludFN0eWxlLFxuICAgICAgICAgICAgZW5kcG9pbnQ6IGVuZHBvaW50LFxuICAgICAgICAgICAgYW5jaG9yOiBmbG9hdGluZ0FuY2hvcixcbiAgICAgICAgICAgIHNvdXJjZTogc291cmNlRWxlbWVudCxcbiAgICAgICAgICAgIHNjb3BlOiBzY29wZVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgdmFyIHR5cGVQYXJhbWV0ZXJzID0gWyBcImNvbm5lY3RvclN0eWxlXCIsIFwiY29ubmVjdG9ySG92ZXJTdHlsZVwiLCBcImNvbm5lY3Rvck92ZXJsYXlzXCIsXG4gICAgICAgIFwiY29ubmVjdG9yXCIsIFwiY29ubmVjdGlvblR5cGVcIiwgXCJjb25uZWN0b3JDbGFzc1wiLCBcImNvbm5lY3RvckhvdmVyQ2xhc3NcIiBdO1xuXG4gICAgLy8gYSBoZWxwZXIgZnVuY3Rpb24gdGhhdCB0cmllcyB0byBmaW5kIGEgY29ubmVjdGlvbiB0byB0aGUgZ2l2ZW4gZWxlbWVudCwgYW5kIHJldHVybnMgaXQgaWYgc28uIGlmIGVsZW1lbnRXaXRoUHJlY2VkZW5jZSBpcyBudWxsLFxuICAgIC8vIG9yIG5vIGNvbm5lY3Rpb24gdG8gaXQgaXMgZm91bmQsIHdlIHJldHVybiB0aGUgZmlyc3QgY29ubmVjdGlvbiBpbiBvdXIgbGlzdC5cbiAgICB2YXIgZmluZENvbm5lY3Rpb25Ub1VzZUZvckR5bmFtaWNBbmNob3IgPSBmdW5jdGlvbiAoZXAsIGVsZW1lbnRXaXRoUHJlY2VkZW5jZSkge1xuICAgICAgICB2YXIgaWR4ID0gMDtcbiAgICAgICAgaWYgKGVsZW1lbnRXaXRoUHJlY2VkZW5jZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVwLmNvbm5lY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVwLmNvbm5lY3Rpb25zW2ldLnNvdXJjZUlkID09PSBlbGVtZW50V2l0aFByZWNlZGVuY2UgfHwgZXAuY29ubmVjdGlvbnNbaV0udGFyZ2V0SWQgPT09IGVsZW1lbnRXaXRoUHJlY2VkZW5jZSkge1xuICAgICAgICAgICAgICAgICAgICBpZHggPSBpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZXAuY29ubmVjdGlvbnNbaWR4XTtcbiAgICB9O1xuXG4gICAgX2pwLkVuZHBvaW50ID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICB2YXIgX2pzUGx1bWIgPSBwYXJhbXMuX2pzUGx1bWIsXG4gICAgICAgICAgICBfbmV3Q29ubmVjdGlvbiA9IHBhcmFtcy5uZXdDb25uZWN0aW9uLFxuICAgICAgICAgICAgX25ld0VuZHBvaW50ID0gcGFyYW1zLm5ld0VuZHBvaW50O1xuXG4gICAgICAgIHRoaXMuaWRQcmVmaXggPSBcIl9qc3BsdW1iX2VfXCI7XG4gICAgICAgIHRoaXMuZGVmYXVsdExhYmVsTG9jYXRpb24gPSBbIDAuNSwgMC41IF07XG4gICAgICAgIHRoaXMuZGVmYXVsdE92ZXJsYXlLZXlzID0gW1wiT3ZlcmxheXNcIiwgXCJFbmRwb2ludE92ZXJsYXlzXCJdO1xuICAgICAgICBfanAuT3ZlcmxheUNhcGFibGVKc1BsdW1iVUlDb21wb25lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuLy8gVFlQRVxuXG4gICAgICAgIHRoaXMuYXBwZW5kVG9EZWZhdWx0VHlwZSh7XG4gICAgICAgICAgICBjb25uZWN0aW9uVHlwZTpwYXJhbXMuY29ubmVjdGlvblR5cGUsXG4gICAgICAgICAgICBtYXhDb25uZWN0aW9uczogcGFyYW1zLm1heENvbm5lY3Rpb25zID09IG51bGwgPyB0aGlzLl9qc1BsdW1iLmluc3RhbmNlLkRlZmF1bHRzLk1heENvbm5lY3Rpb25zIDogcGFyYW1zLm1heENvbm5lY3Rpb25zLCAvLyBtYXhpbXVtIG51bWJlciBvZiBjb25uZWN0aW9ucyB0aGlzIGVuZHBvaW50IGNhbiBiZSB0aGUgc291cmNlIG9mLixcbiAgICAgICAgICAgIHBhaW50U3R5bGU6IHBhcmFtcy5lbmRwb2ludFN0eWxlIHx8IHBhcmFtcy5wYWludFN0eWxlIHx8IHBhcmFtcy5zdHlsZSB8fCB0aGlzLl9qc1BsdW1iLmluc3RhbmNlLkRlZmF1bHRzLkVuZHBvaW50U3R5bGUgfHwgX2pwLkRlZmF1bHRzLkVuZHBvaW50U3R5bGUsXG4gICAgICAgICAgICBob3ZlclBhaW50U3R5bGU6IHBhcmFtcy5lbmRwb2ludEhvdmVyU3R5bGUgfHwgcGFyYW1zLmhvdmVyUGFpbnRTdHlsZSB8fCB0aGlzLl9qc1BsdW1iLmluc3RhbmNlLkRlZmF1bHRzLkVuZHBvaW50SG92ZXJTdHlsZSB8fCBfanAuRGVmYXVsdHMuRW5kcG9pbnRIb3ZlclN0eWxlLFxuICAgICAgICAgICAgY29ubmVjdG9yU3R5bGU6IHBhcmFtcy5jb25uZWN0b3JTdHlsZSxcbiAgICAgICAgICAgIGNvbm5lY3RvckhvdmVyU3R5bGU6IHBhcmFtcy5jb25uZWN0b3JIb3ZlclN0eWxlLFxuICAgICAgICAgICAgY29ubmVjdG9yQ2xhc3M6IHBhcmFtcy5jb25uZWN0b3JDbGFzcyxcbiAgICAgICAgICAgIGNvbm5lY3RvckhvdmVyQ2xhc3M6IHBhcmFtcy5jb25uZWN0b3JIb3ZlckNsYXNzLFxuICAgICAgICAgICAgY29ubmVjdG9yT3ZlcmxheXM6IHBhcmFtcy5jb25uZWN0b3JPdmVybGF5cyxcbiAgICAgICAgICAgIGNvbm5lY3RvcjogcGFyYW1zLmNvbm5lY3RvcixcbiAgICAgICAgICAgIGNvbm5lY3RvclRvb2x0aXA6IHBhcmFtcy5jb25uZWN0b3JUb29sdGlwXG4gICAgICAgIH0pO1xuXG4vLyBFTkQgVFlQRVxuXG4gICAgICAgIHRoaXMuX2pzUGx1bWIuZW5hYmxlZCA9ICEocGFyYW1zLmVuYWJsZWQgPT09IGZhbHNlKTtcbiAgICAgICAgdGhpcy5fanNQbHVtYi52aXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gX2pwLmdldEVsZW1lbnQocGFyYW1zLnNvdXJjZSk7XG4gICAgICAgIHRoaXMuX2pzUGx1bWIudXVpZCA9IHBhcmFtcy51dWlkO1xuICAgICAgICB0aGlzLl9qc1BsdW1iLmZsb2F0aW5nRW5kcG9pbnQgPSBudWxsO1xuICAgICAgICB2YXIgaW5QbGFjZUNvcHkgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5fanNQbHVtYi51dWlkKSB7XG4gICAgICAgICAgICBwYXJhbXMuZW5kcG9pbnRzQnlVVUlEW3RoaXMuX2pzUGx1bWIudXVpZF0gPSB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWxlbWVudElkID0gcGFyYW1zLmVsZW1lbnRJZDtcbiAgICAgICAgdGhpcy5kcmFnUHJveHkgPSBwYXJhbXMuZHJhZ1Byb3h5O1xuXG4gICAgICAgIHRoaXMuX2pzUGx1bWIuY29ubmVjdGlvbkNvc3QgPSBwYXJhbXMuY29ubmVjdGlvbkNvc3Q7XG4gICAgICAgIHRoaXMuX2pzUGx1bWIuY29ubmVjdGlvbnNEaXJlY3RlZCA9IHBhcmFtcy5jb25uZWN0aW9uc0RpcmVjdGVkO1xuICAgICAgICB0aGlzLl9qc1BsdW1iLmN1cnJlbnRBbmNob3JDbGFzcyA9IFwiXCI7XG4gICAgICAgIHRoaXMuX2pzUGx1bWIuZXZlbnRzID0ge307XG5cbiAgICAgICAgdmFyIGRlbGV0ZU9uRW1wdHkgPSBwYXJhbXMuZGVsZXRlT25FbXB0eSA9PT0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zZXREZWxldGVPbkVtcHR5ID0gZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgZGVsZXRlT25FbXB0eSA9IGQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIF91cGRhdGVBbmNob3JDbGFzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIHN0YXNoIG9sZCwgZ2V0IG5ld1xuICAgICAgICAgICAgdmFyIG9sZEFuY2hvckNsYXNzID0gX2pzUGx1bWIuZW5kcG9pbnRBbmNob3JDbGFzc1ByZWZpeCArIFwiLVwiICsgdGhpcy5fanNQbHVtYi5jdXJyZW50QW5jaG9yQ2xhc3M7XG4gICAgICAgICAgICB0aGlzLl9qc1BsdW1iLmN1cnJlbnRBbmNob3JDbGFzcyA9IHRoaXMuYW5jaG9yLmdldENzc0NsYXNzKCk7XG4gICAgICAgICAgICB2YXIgYW5jaG9yQ2xhc3MgPSBfanNQbHVtYi5lbmRwb2ludEFuY2hvckNsYXNzUHJlZml4ICsgKHRoaXMuX2pzUGx1bWIuY3VycmVudEFuY2hvckNsYXNzID8gXCItXCIgKyB0aGlzLl9qc1BsdW1iLmN1cnJlbnRBbmNob3JDbGFzcyA6IFwiXCIpO1xuXG4gICAgICAgICAgICB0aGlzLnJlbW92ZUNsYXNzKG9sZEFuY2hvckNsYXNzKTtcbiAgICAgICAgICAgIHRoaXMuYWRkQ2xhc3MoYW5jaG9yQ2xhc3MpO1xuICAgICAgICAgICAgLy8gYWRkIGFuZCByZW1vdmUgYXQgdGhlIHNhbWUgdGltZSB0byByZWR1Y2UgdGhlIG51bWJlciBvZiByZWZsb3dzLlxuICAgICAgICAgICAgX2pwLnVwZGF0ZUNsYXNzZXModGhpcy5lbGVtZW50LCBhbmNob3JDbGFzcywgb2xkQW5jaG9yQ2xhc3MpO1xuICAgICAgICB9LmJpbmQodGhpcyk7XG5cbiAgICAgICAgdGhpcy5wcmVwYXJlQW5jaG9yID0gZnVuY3Rpb24oYW5jaG9yUGFyYW1zKSB7XG4gICAgICAgICAgICB2YXIgYSA9IHRoaXMuX2pzUGx1bWIuaW5zdGFuY2UubWFrZUFuY2hvcihhbmNob3JQYXJhbXMsIHRoaXMuZWxlbWVudElkLCBfanNQbHVtYik7XG4gICAgICAgICAgICBhLmJpbmQoXCJhbmNob3JDaGFuZ2VkXCIsIGZ1bmN0aW9uIChjdXJyZW50QW5jaG9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maXJlKFwiYW5jaG9yQ2hhbmdlZFwiLCB7ZW5kcG9pbnQ6IHRoaXMsIGFuY2hvcjogY3VycmVudEFuY2hvcn0pO1xuICAgICAgICAgICAgICAgIF91cGRhdGVBbmNob3JDbGFzcygpO1xuICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuc2V0UHJlcGFyZWRBbmNob3IgPSBmdW5jdGlvbihhbmNob3IsIGRvTm90UmVwYWludCkge1xuICAgICAgICAgICAgdGhpcy5fanNQbHVtYi5pbnN0YW5jZS5jb250aW51b3VzQW5jaG9yRmFjdG9yeS5jbGVhcih0aGlzLmVsZW1lbnRJZCk7XG4gICAgICAgICAgICB0aGlzLmFuY2hvciA9IGFuY2hvcjtcbiAgICAgICAgICAgIF91cGRhdGVBbmNob3JDbGFzcygpO1xuXG4gICAgICAgICAgICBpZiAoIWRvTm90UmVwYWludCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2pzUGx1bWIuaW5zdGFuY2UucmVwYWludCh0aGlzLmVsZW1lbnRJZCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuc2V0QW5jaG9yID0gZnVuY3Rpb24gKGFuY2hvclBhcmFtcywgZG9Ob3RSZXBhaW50KSB7XG4gICAgICAgICAgICB2YXIgYSA9IHRoaXMucHJlcGFyZUFuY2hvcihhbmNob3JQYXJhbXMpO1xuICAgICAgICAgICAgdGhpcy5zZXRQcmVwYXJlZEFuY2hvcihhLCBkb05vdFJlcGFpbnQpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGludGVybmFsSG92ZXIgPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbm5lY3Rpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY29ubmVjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uc1tpXS5zZXRIb3ZlcihzdGF0ZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0SG92ZXIoc3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LmJpbmQodGhpcyk7XG5cbiAgICAgICAgdGhpcy5iaW5kKFwibW91c2VvdmVyXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGludGVybmFsSG92ZXIodHJ1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmJpbmQoXCJtb3VzZW91dFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpbnRlcm5hbEhvdmVyKGZhbHNlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gQU5DSE9SIE1BTkFHRVJcbiAgICAgICAgaWYgKCFwYXJhbXMuX3RyYW5zaWVudCkgeyAvLyBpbiBwbGFjZSBjb3BpZXMsIGZvciBleGFtcGxlLCBhcmUgdHJhbnNpZW50LiAgdGhleSB3aWxsIG5ldmVyIG5lZWQgdG8gYmUgcmV0cmlldmVkIGR1cmluZyBhIHBhaW50IGN5Y2xlLCBiZWNhdXNlIHRoZXkgZG9udCBtb3ZlLCBhbmQgdGhlbiB0aGV5IGFyZSBkZWxldGVkLlxuICAgICAgICAgICAgdGhpcy5fanNQbHVtYi5pbnN0YW5jZS5hbmNob3JNYW5hZ2VyLmFkZCh0aGlzLCB0aGlzLmVsZW1lbnRJZCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnByZXBhcmVFbmRwb2ludCA9IGZ1bmN0aW9uKGVwLCB0eXBlSWQpIHtcbiAgICAgICAgICAgIHZhciBfZSA9IGZ1bmN0aW9uICh0LCBwKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJtID0gX2pzUGx1bWIuZ2V0UmVuZGVyTW9kZSgpO1xuICAgICAgICAgICAgICAgIGlmIChfanAuRW5kcG9pbnRzW3JtXVt0XSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IF9qcC5FbmRwb2ludHNbcm1dW3RdKHApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIV9qc1BsdW1iLkRlZmF1bHRzLkRvTm90VGhyb3dFcnJvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgeyBtc2c6IFwianNQbHVtYjogdW5rbm93biBlbmRwb2ludCB0eXBlICdcIiArIHQgKyBcIidcIiB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciBlbmRwb2ludEFyZ3MgPSB7XG4gICAgICAgICAgICAgICAgX2pzUGx1bWI6IHRoaXMuX2pzUGx1bWIuaW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgY3NzQ2xhc3M6IHBhcmFtcy5jc3NDbGFzcyxcbiAgICAgICAgICAgICAgICBjb250YWluZXI6IHBhcmFtcy5jb250YWluZXIsXG4gICAgICAgICAgICAgICAgdG9vbHRpcDogcGFyYW1zLnRvb2x0aXAsXG4gICAgICAgICAgICAgICAgY29ubmVjdG9yVG9vbHRpcDogcGFyYW1zLmNvbm5lY3RvclRvb2x0aXAsXG4gICAgICAgICAgICAgICAgZW5kcG9pbnQ6IHRoaXNcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciBlbmRwb2ludDtcblxuICAgICAgICAgICAgaWYgKF9qdS5pc1N0cmluZyhlcCkpIHtcbiAgICAgICAgICAgICAgICBlbmRwb2ludCA9IF9lKGVwLCBlbmRwb2ludEFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoX2p1LmlzQXJyYXkoZXApKSB7XG4gICAgICAgICAgICAgICAgZW5kcG9pbnRBcmdzID0gX2p1Lm1lcmdlKGVwWzFdLCBlbmRwb2ludEFyZ3MpO1xuICAgICAgICAgICAgICAgIGVuZHBvaW50ID0gX2UoZXBbMF0sIGVuZHBvaW50QXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbmRwb2ludCA9IGVwLmNsb25lKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGFzc2lnbiBhIGNsb25lIGZ1bmN0aW9uIHVzaW5nIGEgY29weSBvZiBlbmRwb2ludEFyZ3MuIHRoaXMgaXMgdXNlZCB3aGVuIGEgZHJhZyBzdGFydHM6IHRoZSBlbmRwb2ludCB0aGF0IHdhcyBkcmFnZ2VkIGlzIGNsb25lZCxcbiAgICAgICAgICAgIC8vIGFuZCB0aGUgY2xvbmUgaXMgbGVmdCBpbiBpdHMgcGxhY2Ugd2hpbGUgdGhlIG9yaWdpbmFsIG9uZSBnb2VzIG9mZiBvbiBhIG1hZ2ljYWwgam91cm5leS5cbiAgICAgICAgICAgIC8vIHRoZSBjb3B5IGlzIHRvIGdldCBhcm91bmQgYSBjbG9zdXJlIHByb2JsZW0sIGluIHdoaWNoIGVuZHBvaW50QXJncyBlbmRzIHVwIGdldHRpbmcgc2hhcmVkIGJ5XG4gICAgICAgICAgICAvLyB0aGUgd2hvbGUgd29ybGQuXG4gICAgICAgICAgICAvL3ZhciBhcmdzRm9yQ2xvbmUgPSBqc1BsdW1iLmV4dGVuZCh7fSwgZW5kcG9pbnRBcmdzKTtcbiAgICAgICAgICAgIGVuZHBvaW50LmNsb25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIC8vIFRPRE8gdGhpcywgYW5kIHRoZSBjb2RlIGFib3ZlLCBjYW4gYmUgcmVmYWN0b3JlZCB0byBiZSBtb3JlIGRyeS5cbiAgICAgICAgICAgICAgICBpZiAoX2p1LmlzU3RyaW5nKGVwKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2UoZXAsIGVuZHBvaW50QXJncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKF9qdS5pc0FycmF5KGVwKSkge1xuICAgICAgICAgICAgICAgICAgICBlbmRwb2ludEFyZ3MgPSBfanUubWVyZ2UoZXBbMV0sIGVuZHBvaW50QXJncyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfZShlcFswXSwgZW5kcG9pbnRBcmdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LmJpbmQodGhpcyk7XG5cbiAgICAgICAgICAgIGVuZHBvaW50LnR5cGVJZCA9IHR5cGVJZDtcbiAgICAgICAgICAgIHJldHVybiBlbmRwb2ludDtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLnNldEVuZHBvaW50ID0gZnVuY3Rpb24oZXAsIGRvTm90UmVwYWludCkge1xuICAgICAgICAgICAgdmFyIF9lcCA9IHRoaXMucHJlcGFyZUVuZHBvaW50KGVwKTtcbiAgICAgICAgICAgIHRoaXMuc2V0UHJlcGFyZWRFbmRwb2ludChfZXAsIHRydWUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuc2V0UHJlcGFyZWRFbmRwb2ludCA9IGZ1bmN0aW9uIChlcCwgZG9Ob3RSZXBhaW50KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5lbmRwb2ludCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbmRwb2ludC5jbGVhbnVwKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbmRwb2ludC5kZXN0cm95KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmVuZHBvaW50ID0gZXA7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSB0aGlzLmVuZHBvaW50LnR5cGU7XG4gICAgICAgICAgICB0aGlzLmNhbnZhcyA9IHRoaXMuZW5kcG9pbnQuY2FudmFzO1xuICAgICAgICB9O1xuXG4gICAgICAgIF9qcC5leHRlbmQodGhpcywgcGFyYW1zLCB0eXBlUGFyYW1ldGVycyk7XG5cbiAgICAgICAgdGhpcy5pc1NvdXJjZSA9IHBhcmFtcy5pc1NvdXJjZSB8fCBmYWxzZTtcbiAgICAgICAgdGhpcy5pc1RlbXBvcmFyeVNvdXJjZSA9IHBhcmFtcy5pc1RlbXBvcmFyeVNvdXJjZSB8fCBmYWxzZTtcbiAgICAgICAgdGhpcy5pc1RhcmdldCA9IHBhcmFtcy5pc1RhcmdldCB8fCBmYWxzZTtcblxuICAgICAgICB0aGlzLmNvbm5lY3Rpb25zID0gcGFyYW1zLmNvbm5lY3Rpb25zIHx8IFtdO1xuICAgICAgICB0aGlzLmNvbm5lY3RvclBvaW50ZXJFdmVudHMgPSBwYXJhbXNbXCJjb25uZWN0b3ItcG9pbnRlci1ldmVudHNcIl07XG5cbiAgICAgICAgdGhpcy5zY29wZSA9IHBhcmFtcy5zY29wZSB8fCBfanNQbHVtYi5nZXREZWZhdWx0U2NvcGUoKTtcbiAgICAgICAgdGhpcy50aW1lc3RhbXAgPSBudWxsO1xuICAgICAgICB0aGlzLnJlYXR0YWNoQ29ubmVjdGlvbnMgPSBwYXJhbXMucmVhdHRhY2ggfHwgX2pzUGx1bWIuRGVmYXVsdHMuUmVhdHRhY2hDb25uZWN0aW9ucztcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uc0RldGFjaGFibGUgPSBfanNQbHVtYi5EZWZhdWx0cy5Db25uZWN0aW9uc0RldGFjaGFibGU7XG4gICAgICAgIGlmIChwYXJhbXMuY29ubmVjdGlvbnNEZXRhY2hhYmxlID09PSBmYWxzZSB8fCBwYXJhbXMuZGV0YWNoYWJsZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbnNEZXRhY2hhYmxlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kcmFnQWxsb3dlZFdoZW5GdWxsID0gcGFyYW1zLmRyYWdBbGxvd2VkV2hlbkZ1bGwgIT09IGZhbHNlO1xuXG4gICAgICAgIGlmIChwYXJhbXMub25NYXhDb25uZWN0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5iaW5kKFwibWF4Q29ubmVjdGlvbnNcIiwgcGFyYW1zLm9uTWF4Q29ubmVjdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gYWRkIGEgY29ubmVjdGlvbi4gbm90IHBhcnQgb2YgcHVibGljIEFQSS5cbiAgICAgICAgLy9cbiAgICAgICAgdGhpcy5hZGRDb25uZWN0aW9uID0gZnVuY3Rpb24gKGNvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbnMucHVzaChjb25uZWN0aW9uKTtcbiAgICAgICAgICAgIHRoaXNbKHRoaXMuY29ubmVjdGlvbnMubGVuZ3RoID4gMCA/IFwiYWRkXCIgOiBcInJlbW92ZVwiKSArIFwiQ2xhc3NcIl0oX2pzUGx1bWIuZW5kcG9pbnRDb25uZWN0ZWRDbGFzcyk7XG4gICAgICAgICAgICB0aGlzWyh0aGlzLmlzRnVsbCgpID8gXCJhZGRcIiA6IFwicmVtb3ZlXCIpICsgXCJDbGFzc1wiXShfanNQbHVtYi5lbmRwb2ludEZ1bGxDbGFzcyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5kZXRhY2hGcm9tQ29ubmVjdGlvbiA9IGZ1bmN0aW9uIChjb25uZWN0aW9uLCBpZHgsIGRvTm90Q2xlYW51cCkge1xuICAgICAgICAgICAgaWR4ID0gaWR4ID09IG51bGwgPyB0aGlzLmNvbm5lY3Rpb25zLmluZGV4T2YoY29ubmVjdGlvbikgOiBpZHg7XG4gICAgICAgICAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25zLnNwbGljZShpZHgsIDEpO1xuICAgICAgICAgICAgICAgIHRoaXNbKHRoaXMuY29ubmVjdGlvbnMubGVuZ3RoID4gMCA/IFwiYWRkXCIgOiBcInJlbW92ZVwiKSArIFwiQ2xhc3NcIl0oX2pzUGx1bWIuZW5kcG9pbnRDb25uZWN0ZWRDbGFzcyk7XG4gICAgICAgICAgICAgICAgdGhpc1sodGhpcy5pc0Z1bGwoKSA/IFwiYWRkXCIgOiBcInJlbW92ZVwiKSArIFwiQ2xhc3NcIl0oX2pzUGx1bWIuZW5kcG9pbnRGdWxsQ2xhc3MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWRvTm90Q2xlYW51cCAmJiBkZWxldGVPbkVtcHR5ICYmIHRoaXMuY29ubmVjdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgX2pzUGx1bWIuZGVsZXRlT2JqZWN0KHtcbiAgICAgICAgICAgICAgICAgICAgZW5kcG9pbnQ6IHRoaXMsXG4gICAgICAgICAgICAgICAgICAgIGZpcmVFdmVudDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZUF0dGFjaGVkT2JqZWN0czogZG9Ob3RDbGVhbnVwICE9PSB0cnVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5kZWxldGVFdmVyeUNvbm5lY3Rpb24gPSBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgICAgICAgIHZhciBjID0gdGhpcy5jb25uZWN0aW9ucy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGM7IGkrKykge1xuICAgICAgICAgICAgICAgIF9qc1BsdW1iLmRlbGV0ZUNvbm5lY3Rpb24odGhpcy5jb25uZWN0aW9uc1swXSwgcGFyYW1zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmRldGFjaEZyb20gPSBmdW5jdGlvbiAodGFyZ2V0RW5kcG9pbnQsIGZpcmVFdmVudCwgb3JpZ2luYWxFdmVudCkge1xuICAgICAgICAgICAgdmFyIGMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jb25uZWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbm5lY3Rpb25zW2ldLmVuZHBvaW50c1sxXSA9PT0gdGFyZ2V0RW5kcG9pbnQgfHwgdGhpcy5jb25uZWN0aW9uc1tpXS5lbmRwb2ludHNbMF0gPT09IHRhcmdldEVuZHBvaW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGMucHVzaCh0aGlzLmNvbm5lY3Rpb25zW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMCwgY291bnQgPSBjLmxlbmd0aDsgaiA8IGNvdW50OyBqKyspIHtcbiAgICAgICAgICAgICAgICBfanNQbHVtYi5kZWxldGVDb25uZWN0aW9uKGNbMF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5nZXRFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudDtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLnNldEVsZW1lbnQgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIHZhciBwYXJlbnRJZCA9IHRoaXMuX2pzUGx1bWIuaW5zdGFuY2UuZ2V0SWQoZWwpLFxuICAgICAgICAgICAgICAgIGN1cklkID0gdGhpcy5lbGVtZW50SWQ7XG4gICAgICAgICAgICAvLyByZW1vdmUgdGhlIGVuZHBvaW50IGZyb20gdGhlIGxpc3QgZm9yIHRoZSBjdXJyZW50IGVuZHBvaW50J3MgZWxlbWVudFxuICAgICAgICAgICAgX2p1LnJlbW92ZVdpdGhGdW5jdGlvbihwYXJhbXMuZW5kcG9pbnRzQnlFbGVtZW50W3RoaXMuZWxlbWVudElkXSwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZS5pZCA9PT0gdGhpcy5pZDtcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQgPSBfanAuZ2V0RWxlbWVudChlbCk7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnRJZCA9IF9qc1BsdW1iLmdldElkKHRoaXMuZWxlbWVudCk7XG4gICAgICAgICAgICBfanNQbHVtYi5hbmNob3JNYW5hZ2VyLnJlaG9tZUVuZHBvaW50KHRoaXMsIGN1cklkLCB0aGlzLmVsZW1lbnQpO1xuICAgICAgICAgICAgX2pzUGx1bWIuZHJhZ01hbmFnZXIuZW5kcG9pbnRBZGRlZCh0aGlzLmVsZW1lbnQpO1xuICAgICAgICAgICAgX2p1LmFkZFRvTGlzdChwYXJhbXMuZW5kcG9pbnRzQnlFbGVtZW50LCBwYXJlbnRJZCwgdGhpcyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogcHJpdmF0ZSBidXQgbXVzdCBiZSBleHBvc2VkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tYWtlSW5QbGFjZUNvcHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbG9jID0gdGhpcy5hbmNob3IuZ2V0Q3VycmVudExvY2F0aW9uKHtlbGVtZW50OiB0aGlzfSksXG4gICAgICAgICAgICAgICAgbyA9IHRoaXMuYW5jaG9yLmdldE9yaWVudGF0aW9uKHRoaXMpLFxuICAgICAgICAgICAgICAgIGFjYyA9IHRoaXMuYW5jaG9yLmdldENzc0NsYXNzKCksXG4gICAgICAgICAgICAgICAgaW5QbGFjZUFuY2hvciA9IHtcbiAgICAgICAgICAgICAgICAgICAgYmluZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBjb21wdXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyBsb2NbMF0sIGxvY1sxXSBdO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBnZXRDdXJyZW50TG9jYXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbIGxvY1swXSwgbG9jWzFdIF07XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGdldE9yaWVudGF0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbztcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0Q3NzQ2xhc3M6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXR1cm4gX25ld0VuZHBvaW50KHtcbiAgICAgICAgICAgICAgICBkcm9wT3B0aW9uczogcGFyYW1zLmRyb3BPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFuY2hvcjogaW5QbGFjZUFuY2hvcixcbiAgICAgICAgICAgICAgICBzb3VyY2U6IHRoaXMuZWxlbWVudCxcbiAgICAgICAgICAgICAgICBwYWludFN0eWxlOiB0aGlzLmdldFBhaW50U3R5bGUoKSxcbiAgICAgICAgICAgICAgICBlbmRwb2ludDogcGFyYW1zLmhpZGVPbkRyYWcgPyBcIkJsYW5rXCIgOiB0aGlzLmVuZHBvaW50LFxuICAgICAgICAgICAgICAgIF90cmFuc2llbnQ6IHRydWUsXG4gICAgICAgICAgICAgICAgc2NvcGU6IHRoaXMuc2NvcGUsXG4gICAgICAgICAgICAgICAgcmVmZXJlbmNlOnRoaXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiByZXR1cm5zIGEgY29ubmVjdGlvbiBmcm9tIHRoZSBwb29sOyB1c2VkIHdoZW4gZHJhZ2dpbmcgc3RhcnRzLiAganVzdCBnZXRzIHRoZSBoZWFkIG9mIHRoZSBhcnJheSBpZiBpdCBjYW4uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbm5lY3RvclNlbGVjdG9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHRoaXMuY29ubmVjdGlvbnNbMF07XG4gICAgICAgICAgICBpZiAoY2FuZGlkYXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy5jb25uZWN0aW9ucy5sZW5ndGggPCB0aGlzLl9qc1BsdW1iLm1heENvbm5lY3Rpb25zKSB8fCB0aGlzLl9qc1BsdW1iLm1heENvbm5lY3Rpb25zID09PSAtMSA/IG51bGwgOiBjYW5kaWRhdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5zZXRTdHlsZSA9IHRoaXMuc2V0UGFpbnRTdHlsZTtcblxuICAgICAgICB0aGlzLnBhaW50ID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICAgICAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICAgICAgICAgICAgdmFyIHRpbWVzdGFtcCA9IHBhcmFtcy50aW1lc3RhbXAsIHJlY2FsYyA9ICEocGFyYW1zLnJlY2FsYyA9PT0gZmFsc2UpO1xuICAgICAgICAgICAgaWYgKCF0aW1lc3RhbXAgfHwgdGhpcy50aW1lc3RhbXAgIT09IHRpbWVzdGFtcCkge1xuXG4gICAgICAgICAgICAgICAgdmFyIGluZm8gPSBfanNQbHVtYi51cGRhdGVPZmZzZXQoeyBlbElkOiB0aGlzLmVsZW1lbnRJZCwgdGltZXN0YW1wOiB0aW1lc3RhbXAgfSk7XG5cbiAgICAgICAgICAgICAgICB2YXIgeHkgPSBwYXJhbXMub2Zmc2V0ID8gcGFyYW1zLm9mZnNldC5vIDogaW5mby5vO1xuICAgICAgICAgICAgICAgIGlmICh4eSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhcCA9IHBhcmFtcy5hbmNob3JQb2ludCwgY29ubmVjdG9yUGFpbnRTdHlsZSA9IHBhcmFtcy5jb25uZWN0b3JQYWludFN0eWxlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXAgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdoID0gcGFyYW1zLmRpbWVuc2lvbnMgfHwgaW5mby5zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuY2hvclBhcmFtcyA9IHsgeHk6IFsgeHkubGVmdCwgeHkudG9wIF0sIHdoOiB3aCwgZWxlbWVudDogdGhpcywgdGltZXN0YW1wOiB0aW1lc3RhbXAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZWNhbGMgJiYgdGhpcy5hbmNob3IuaXNEeW5hbWljICYmIHRoaXMuY29ubmVjdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjID0gZmluZENvbm5lY3Rpb25Ub1VzZUZvckR5bmFtaWNBbmNob3IodGhpcywgcGFyYW1zLmVsZW1lbnRXaXRoUHJlY2VkZW5jZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9JZHggPSBjLmVuZHBvaW50c1swXSA9PT0gdGhpcyA/IDEgOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvSWQgPSBvSWR4ID09PSAwID8gYy5zb3VyY2VJZCA6IGMudGFyZ2V0SWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9JbmZvID0gX2pzUGx1bWIuZ2V0Q2FjaGVkRGF0YShvSWQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvT2Zmc2V0ID0gb0luZm8ubywgb1dIID0gb0luZm8ucztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmNob3JQYXJhbXMudHh5ID0gWyBvT2Zmc2V0LmxlZnQsIG9PZmZzZXQudG9wIF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5jaG9yUGFyYW1zLnR3aCA9IG9XSDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmNob3JQYXJhbXMudEVsZW1lbnQgPSBjLmVuZHBvaW50c1tvSWR4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGFwID0gdGhpcy5hbmNob3IuY29tcHV0ZShhbmNob3JQYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbmRwb2ludC5jb21wdXRlKGFwLCB0aGlzLmFuY2hvci5nZXRPcmllbnRhdGlvbih0aGlzKSwgdGhpcy5fanNQbHVtYi5wYWludFN0eWxlSW5Vc2UsIGNvbm5lY3RvclBhaW50U3R5bGUgfHwgdGhpcy5wYWludFN0eWxlSW5Vc2UpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVuZHBvaW50LnBhaW50KHRoaXMuX2pzUGx1bWIucGFpbnRTdHlsZUluVXNlLCB0aGlzLmFuY2hvcik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGltZXN0YW1wID0gdGltZXN0YW1wO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIHBhaW50IG92ZXJsYXlzXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5fanNQbHVtYi5vdmVybGF5cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2pzUGx1bWIub3ZlcmxheXMuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbyA9IHRoaXMuX2pzUGx1bWIub3ZlcmxheXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG8uaXNWaXNpYmxlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fanNQbHVtYi5vdmVybGF5UGxhY2VtZW50c1tpXSA9IG8uZHJhdyh0aGlzLmVuZHBvaW50LCB0aGlzLl9qc1BsdW1iLnBhaW50U3R5bGVJblVzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG8ucGFpbnQodGhpcy5fanNQbHVtYi5vdmVybGF5UGxhY2VtZW50c1tpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuZ2V0VHlwZURlc2NyaXB0b3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJlbmRwb2ludFwiO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmlzVmlzaWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9qc1BsdW1iLnZpc2libGU7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5yZXBhaW50ID0gdGhpcy5wYWludDtcblxuICAgICAgICB2YXIgZHJhZ2dpbmdJbml0aWFsaXNlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmluaXREcmFnZ2FibGUgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIC8vIGlzIHRoaXMgYSBjb25uZWN0aW9uIHNvdXJjZT8gd2UgbWFrZSBpdCBkcmFnZ2FibGUgYW5kIGhhdmUgdGhlXG4gICAgICAgICAgICAvLyBkcmFnIGxpc3RlbmVyIG1haW50YWluIGEgY29ubmVjdGlvbiB3aXRoIGEgZmxvYXRpbmcgZW5kcG9pbnQuXG4gICAgICAgICAgICBpZiAoIWRyYWdnaW5nSW5pdGlhbGlzZWQgJiYgX2pwLmlzRHJhZ1N1cHBvcnRlZCh0aGlzLmVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBsYWNlaG9sZGVySW5mbyA9IHsgaWQ6IG51bGwsIGVsZW1lbnQ6IG51bGwgfSxcbiAgICAgICAgICAgICAgICAgICAganBjID0gbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmdKcGMgPSBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmdKcGNQYXJhbXMgPSBudWxsLFxuICAgICAgICAgICAgICAgICAgICBfZHJhZ0hhbmRsZXIgPSBfbWFrZUNvbm5lY3Rpb25EcmFnSGFuZGxlcih0aGlzLCBwbGFjZWhvbGRlckluZm8sIF9qc1BsdW1iKSxcbiAgICAgICAgICAgICAgICAgICAgZHJhZ09wdGlvbnMgPSBwYXJhbXMuZHJhZ09wdGlvbnMgfHwge30sXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRPcHRzID0ge30sXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0RXZlbnQgPSBfanAuZHJhZ0V2ZW50cy5zdGFydCxcbiAgICAgICAgICAgICAgICAgICAgc3RvcEV2ZW50ID0gX2pwLmRyYWdFdmVudHMuc3RvcCxcbiAgICAgICAgICAgICAgICAgICAgZHJhZ0V2ZW50ID0gX2pwLmRyYWdFdmVudHMuZHJhZyxcbiAgICAgICAgICAgICAgICAgICAgYmVmb3JlU3RhcnRFdmVudCA9IF9qcC5kcmFnRXZlbnRzLmJlZm9yZVN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICBwYXlsb2FkO1xuXG4gICAgICAgICAgICAgICAgLy8gcmVzcG9uZCB0byBiZWZvcmVTdGFydCBmcm9tIGthdGF2b3JpbzsgdGhpcyB3aWxsIGhhdmUsIG9wdGlvbmFsbHksIGEgcGF5bG9hZCBvZiBhdHRyaWJ1dGUgdmFsdWVzXG4gICAgICAgICAgICAgICAgLy8gdGhhdCB3ZXJlIHBsYWNlZCB0aGVyZSBieSB0aGUgbWFrZVNvdXJjZSBtb3VzZWRvd24gbGlzdGVuZXIuXG4gICAgICAgICAgICAgICAgdmFyIGJlZm9yZVN0YXJ0ID0gZnVuY3Rpb24oYmVmb3JlU3RhcnRQYXJhbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcGF5bG9hZCA9IGJlZm9yZVN0YXJ0UGFyYW1zLmUucGF5bG9hZCB8fCB7fTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gZnVuY3Rpb24gKHN0YXJ0UGFyYW1zKSB7XG5cbi8vIC0tLS0tLS0tLS0tLS0gICBmaXJzdCwgZ2V0IGEgY29ubmVjdGlvbiB0byBkcmFnLiB0aGlzIG1heSBiZSBudWxsLCBpbiB3aGljaCBjYXNlIHdlIGFyZSBkcmFnZ2luZyBhIG5ldyBvbmUuXG5cbiAgICAgICAgICAgICAgICAgICAganBjID0gdGhpcy5jb25uZWN0b3JTZWxlY3RvcigpO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBub3cgYSBidW5jaCBvZiB0ZXN0cyBhYm91dCB3aGV0aGVyIG9yIG5vdCB0byBwcm9jZWVkIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICAgICAgICAgICAgICB2YXIgX2NvbnRpbnVlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgbm90IGVuYWJsZWQsIHJldHVyblxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaXNFbmFibGVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jb250aW51ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIG5vIGNvbm5lY3Rpb24gYW5kIHdlJ3JlIG5vdCBhIHNvdXJjZSAtIG9yIHRlbXBvcmFyaWx5IGEgc291cmNlLCBhcyBpcyB0aGUgY2FzZSB3aXRoIG1ha2VTb3VyY2UgLSByZXR1cm4uXG4gICAgICAgICAgICAgICAgICAgIGlmIChqcGMgPT0gbnVsbCAmJiAhdGhpcy5pc1NvdXJjZSAmJiAhdGhpcy5pc1RlbXBvcmFyeVNvdXJjZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRpbnVlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIGlmIHdlJ3JlIGZ1bGwgYW5kIG5vdCBhbGxvd2VkIHRvIGRyYWcsIGFsc28gcmV0dXJuIGZhbHNlLlxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pc1NvdXJjZSAmJiB0aGlzLmlzRnVsbCgpICYmICEoanBjICE9IG51bGwgJiYgdGhpcy5kcmFnQWxsb3dlZFdoZW5GdWxsKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRpbnVlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIGNvbm5lY3Rpb24gd2FzIHNldHVwIGFzIG5vdCBkZXRhY2hhYmxlIG9yIG9uZSBvZiBpdHMgZW5kcG9pbnRzXG4gICAgICAgICAgICAgICAgICAgIC8vIHdhcyBzZXR1cCBhcyBjb25uZWN0aW9uc0RldGFjaGFibGUgPSBmYWxzZSwgb3IgRGVmYXVsdHMuQ29ubmVjdGlvbnNEZXRhY2hhYmxlXG4gICAgICAgICAgICAgICAgICAgIC8vIGlzIHNldCB0byBmYWxzZS4uLlxuICAgICAgICAgICAgICAgICAgICBpZiAoanBjICE9IG51bGwgJiYgIWpwYy5pc0RldGFjaGFibGUodGhpcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jb250aW51ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGJlZm9yZURyYWcgPSBfanNQbHVtYi5jaGVja0NvbmRpdGlvbihqcGMgPT0gbnVsbCA/IFwiYmVmb3JlRHJhZ1wiIDogXCJiZWZvcmVTdGFydERldGFjaFwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmRwb2ludDp0aGlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlOnRoaXMuZWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZUlkOnRoaXMuZWxlbWVudElkLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbjpqcGNcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChiZWZvcmVEcmFnID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRpbnVlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gZWxzZSB3ZSBtaWdodCBoYXZlIGJlZW4gZ2l2ZW4gc29tZSBkYXRhLiB3ZSdsbCBwYXNzIGl0IGluIHRvIGEgbmV3IGNvbm5lY3Rpb24gYXMgJ2RhdGEnLlxuICAgICAgICAgICAgICAgICAgICAvLyBoZXJlIHdlIGFsc28gbWVyZ2UgaW4gdGhlIG9wdGlvbmFsIHBheWxvYWQgd2Ugd2VyZSBnaXZlbiBvbiBtb3VzZWRvd24uXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBiZWZvcmVEcmFnID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfanAuZXh0ZW5kKGJlZm9yZURyYWcsIHBheWxvYWQgfHwge30pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3IgaWYgbm8gYmVmb3JlRHJhZyBkYXRhLCBtYXliZSB1c2UgdGhlIHBheWxvYWQgb24gaXRzIG93bi5cbiAgICAgICAgICAgICAgICAgICAgICAgIGJlZm9yZURyYWcgPSBwYXlsb2FkIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKF9jb250aW51ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgZm9yIG1vb3Rvb2xzIGFuZCB5dWkuIHJldHVybmluZyBmYWxzZSBmcm9tIHRoaXMgY2F1c2VzIGpxdWVyeSB0byBzdG9wIGRyYWcuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgZXZlbnRzIGFyZSB3cmFwcGVkIGluIGJvdGggbW9vdG9vbHMgYW5kIHl1aSBhbnl3YXksIGJ1dCBpIGRvbid0IHRoaW5rIHJldHVybmluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZmFsc2UgZnJvbSB0aGUgc3RhcnQgY2FsbGJhY2sgd291bGQgc3RvcCBhIGRyYWcuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2pzUGx1bWIuc3RvcERyYWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfanNQbHVtYi5zdG9wRHJhZyh0aGlzLmNhbnZhcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBfZHJhZ0hhbmRsZXIuc3RvcERyYWcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICAgICAgICAgICAgICAvLyBvayB0byBwcm9jZWVkLlxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGNsZWFyIGhvdmVyIGZvciBhbGwgY29ubmVjdGlvbnMgZm9yIHRoaXMgZW5kcG9pbnQgYmVmb3JlIGNvbnRpbnVpbmcuXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jb25uZWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uc1tpXS5zZXRIb3ZlcihmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZENsYXNzKFwiZW5kcG9pbnREcmFnXCIpO1xuICAgICAgICAgICAgICAgICAgICBfanNQbHVtYi5zZXRDb25uZWN0aW9uQmVpbmdEcmFnZ2VkKHRydWUpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHdlJ3JlIG5vdCBmdWxsIGJ1dCB0aGVyZSB3YXMgYSBjb25uZWN0aW9uLCBtYWtlIGl0IG51bGwuIHdlJ2xsIGNyZWF0ZSBhIG5ldyBvbmUuXG4gICAgICAgICAgICAgICAgICAgIGlmIChqcGMgJiYgIXRoaXMuaXNGdWxsKCkgJiYgdGhpcy5pc1NvdXJjZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAganBjID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIF9qc1BsdW1iLnVwZGF0ZU9mZnNldCh7IGVsSWQ6IHRoaXMuZWxlbWVudElkIH0pO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tICAgIG1ha2UgdGhlIGVsZW1lbnQgd2Ugd2lsbCBkcmFnIGFyb3VuZCwgYW5kIHBvc2l0aW9uIGl0IC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGlwY28gPSB0aGlzLl9qc1BsdW1iLmluc3RhbmNlLmdldE9mZnNldCh0aGlzLmNhbnZhcyksXG4gICAgICAgICAgICAgICAgICAgICAgICBjYW52YXNFbGVtZW50ID0gdGhpcy5jYW52YXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBpcHMgPSB0aGlzLl9qc1BsdW1iLmluc3RhbmNlLmdldFNpemUodGhpcy5jYW52YXMpO1xuXG4gICAgICAgICAgICAgICAgICAgIF9tYWtlRHJhZ2dhYmxlUGxhY2Vob2xkZXIocGxhY2Vob2xkZXJJbmZvLCBfanNQbHVtYiwgaXBjbywgaXBzKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBzdG9yZSB0aGUgaWQgb2YgdGhlIGRyYWdnaW5nIGRpdiBhbmQgdGhlIHNvdXJjZSBlbGVtZW50LiB0aGUgZHJvcCBmdW5jdGlvbiB3aWxsIHBpY2sgdGhlc2UgdXAuICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBfanNQbHVtYi5zZXRBdHRyaWJ1dGVzKHRoaXMuY2FudmFzLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcImRyYWdJZFwiOiBwbGFjZWhvbGRlckluZm8uaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBcImVsSWRcIjogdGhpcy5lbGVtZW50SWRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0gY3JlYXRlIGFuIGVuZHBvaW50IHRoYXQgd2lsbCBiZSBvdXIgZmxvYXRpbmcgZW5kcG9pbnQgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGVuZHBvaW50VG9GbG9hdCA9IHRoaXMuZHJhZ1Byb3h5IHx8IHRoaXMuZW5kcG9pbnQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmRyYWdQcm94eSA9PSBudWxsICYmIHRoaXMuY29ubmVjdGlvblR5cGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFhZSA9IHRoaXMuX2pzUGx1bWIuaW5zdGFuY2UuZGVyaXZlRW5kcG9pbnRBbmRBbmNob3JTcGVjKHRoaXMuY29ubmVjdGlvblR5cGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFhZS5lbmRwb2ludHNbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmRwb2ludFRvRmxvYXQgPSBhYWUuZW5kcG9pbnRzWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBjZW50ZXJBbmNob3IgPSB0aGlzLl9qc1BsdW1iLmluc3RhbmNlLm1ha2VBbmNob3IoXCJDZW50ZXJcIik7XG4gICAgICAgICAgICAgICAgICAgIGNlbnRlckFuY2hvci5pc0Zsb2F0aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fanNQbHVtYi5mbG9hdGluZ0VuZHBvaW50ID0gX21ha2VGbG9hdGluZ0VuZHBvaW50KHRoaXMuZ2V0UGFpbnRTdHlsZSgpLCBjZW50ZXJBbmNob3IsIGVuZHBvaW50VG9GbG9hdCwgdGhpcy5jYW52YXMsIHBsYWNlaG9sZGVySW5mby5lbGVtZW50LCBfanNQbHVtYiwgX25ld0VuZHBvaW50LCB0aGlzLnNjb3BlKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9zYXZlZEFuY2hvciA9IHRoaXMuX2pzUGx1bWIuZmxvYXRpbmdFbmRwb2ludC5hbmNob3I7XG5cblxuICAgICAgICAgICAgICAgICAgICBpZiAoanBjID09IG51bGwpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRIb3ZlcihmYWxzZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY3JlYXRlIGEgY29ubmVjdGlvbi4gb25lIGVuZCBpcyB0aGlzIGVuZHBvaW50LCB0aGUgb3RoZXIgaXMgYSBmbG9hdGluZyBlbmRwb2ludC4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAganBjID0gX25ld0Nvbm5lY3Rpb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZUVuZHBvaW50OiB0aGlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldEVuZHBvaW50OiB0aGlzLl9qc1BsdW1iLmZsb2F0aW5nRW5kcG9pbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlOiB0aGlzLmVsZW1lbnQsICAvLyBmb3IgbWFrZVNvdXJjZSB3aXRoIHBhcmVudCBvcHRpb24uICBlbnN1cmUgc291cmNlIGVsZW1lbnQgaXMgcmVwcmVzZW50ZWQgY29ycmVjdGx5LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldDogcGxhY2Vob2xkZXJJbmZvLmVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5jaG9yczogWyB0aGlzLmFuY2hvciwgdGhpcy5fanNQbHVtYi5mbG9hdGluZ0VuZHBvaW50LmFuY2hvciBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhaW50U3R5bGU6IHBhcmFtcy5jb25uZWN0b3JTdHlsZSwgLy8gdGhpcyBjYW4gYmUgbnVsbC4gQ29ubmVjdGlvbiB3aWxsIHVzZSB0aGUgZGVmYXVsdC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBob3ZlclBhaW50U3R5bGU6IHBhcmFtcy5jb25uZWN0b3JIb3ZlclN0eWxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbm5lY3RvcjogcGFyYW1zLmNvbm5lY3RvciwgLy8gdGhpcyBjYW4gYWxzbyBiZSBudWxsLiBDb25uZWN0aW9uIHdpbGwgdXNlIHRoZSBkZWZhdWx0LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJsYXlzOiBwYXJhbXMuY29ubmVjdG9yT3ZlcmxheXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogdGhpcy5jb25uZWN0aW9uVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjc3NDbGFzczogdGhpcy5jb25uZWN0b3JDbGFzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBob3ZlckNsYXNzOiB0aGlzLmNvbm5lY3RvckhvdmVyQ2xhc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGU6cGFyYW1zLnNjb3BlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6YmVmb3JlRHJhZ1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBqcGMucGVuZGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBqcGMuYWRkQ2xhc3MoX2pzUGx1bWIuZHJhZ2dpbmdDbGFzcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9qc1BsdW1iLmZsb2F0aW5nRW5kcG9pbnQuYWRkQ2xhc3MoX2pzUGx1bWIuZHJhZ2dpbmdDbGFzcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9qc1BsdW1iLmZsb2F0aW5nRW5kcG9pbnQuYW5jaG9yID0gX3NhdmVkQW5jaG9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZmlyZSBhbiBldmVudCB0aGF0IGluZm9ybXMgdGhhdCBhIGNvbm5lY3Rpb24gaXMgYmVpbmcgZHJhZ2dlZFxuICAgICAgICAgICAgICAgICAgICAgICAgX2pzUGx1bWIuZmlyZShcImNvbm5lY3Rpb25EcmFnXCIsIGpwYyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlZ2lzdGVyIHRoZSBuZXcgY29ubmVjdGlvbiBvbiB0aGUgZHJhZyBtYW5hZ2VyLiBUaGlzIGNvbm5lY3Rpb24sIGF0IHRoaXMgcG9pbnQsIGlzICdwZW5kaW5nJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFuZCBoYXMgYXMgaXRzIHRhcmdldCBhIHRlbXBvcmFyeSBlbGVtZW50ICh0aGUgJ3BsYWNlaG9sZGVyJykuIElmIHRoZSBjb25uZWN0aW9uIHN1YnNlcXVlbnRseVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYmVjb21lcyBlc3RhYmxpc2hlZCwgdGhlIGFuY2hvciBtYW5hZ2VyIGlzIGluZm9ybWVkIHRoYXQgdGhlIHRhcmdldCBvZiB0aGUgY29ubmVjdGlvbiBoYXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoYW5nZWQuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIF9qc1BsdW1iLmFuY2hvck1hbmFnZXIubmV3Q29ubmVjdGlvbihqcGMpO1xuXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZ0pwYyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBqcGMuc2V0SG92ZXIoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbmV3IGFuY2hvciBpZHhcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhbmNob3JJZHggPSBqcGMuZW5kcG9pbnRzWzBdLmlkID09PSB0aGlzLmlkID8gMCA6IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRldGFjaEZyb21Db25uZWN0aW9uKGpwYywgbnVsbCwgdHJ1ZSk7ICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRldGFjaCBmcm9tIHRoZSBjb25uZWN0aW9uIHdoaWxlIGRyYWdnaW5nIGlzIG9jY3VycmluZy4gYnV0IGRvbnQgY2xlYW51cCBhdXRvbWF0aWNhbGx5LlxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzdG9yZSB0aGUgb3JpZ2luYWwgc2NvcGUgKGlzc3VlIDU3KVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRyYWdTY29wZSA9IF9qc1BsdW1iLmdldERyYWdTY29wZShjYW52YXNFbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9qc1BsdW1iLnNldEF0dHJpYnV0ZSh0aGlzLmNhbnZhcywgXCJvcmlnaW5hbFNjb3BlXCIsIGRyYWdTY29wZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZpcmUgYW4gZXZlbnQgdGhhdCBpbmZvcm1zIHRoYXQgYSBjb25uZWN0aW9uIGlzIGJlaW5nIGRyYWdnZWQuIHdlIGRvIHRoaXMgYmVmb3JlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZXBsYWNpbmcgdGhlIG9yaWdpbmFsIHRhcmdldCB3aXRoIHRoZSBmbG9hdGluZyBlbGVtZW50IGluZm8uXG4gICAgICAgICAgICAgICAgICAgICAgICBfanNQbHVtYi5maXJlKFwiY29ubmVjdGlvbkRyYWdcIiwganBjKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm93IHdlIHJlcGxhY2Ugb3Vyc2VsdmVzIHdpdGggdGhlIHRlbXBvcmFyeSBkaXYgd2UgY3JlYXRlZCBhYm92ZTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhbmNob3JJZHggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZ0pwY1BhcmFtcyA9IFsganBjLnNvdXJjZSwganBjLnNvdXJjZUlkLCBjYW52YXNFbGVtZW50LCBkcmFnU2NvcGUgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfanNQbHVtYi5hbmNob3JNYW5hZ2VyLnNvdXJjZUNoYW5nZWQoanBjLmVuZHBvaW50c1thbmNob3JJZHhdLmVsZW1lbnRJZCwgcGxhY2Vob2xkZXJJbmZvLmlkLCBqcGMsIHBsYWNlaG9sZGVySW5mby5lbGVtZW50KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZ0pwY1BhcmFtcyA9IFsganBjLnRhcmdldCwganBjLnRhcmdldElkLCBjYW52YXNFbGVtZW50LCBkcmFnU2NvcGUgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqcGMudGFyZ2V0ID0gcGxhY2Vob2xkZXJJbmZvLmVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAganBjLnRhcmdldElkID0gcGxhY2Vob2xkZXJJbmZvLmlkO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2pzUGx1bWIuYW5jaG9yTWFuYWdlci51cGRhdGVPdGhlckVuZHBvaW50KGpwYy5zb3VyY2VJZCwganBjLmVuZHBvaW50c1thbmNob3JJZHhdLmVsZW1lbnRJZCwganBjLnRhcmdldElkLCBqcGMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzdG9yZSB0aGUgb3JpZ2luYWwgZW5kcG9pbnQgYW5kIGFzc2lnbiB0aGUgbmV3IGZsb2F0aW5nIGVuZHBvaW50IGZvciB0aGUgZHJhZy5cbiAgICAgICAgICAgICAgICAgICAgICAgIGpwYy5zdXNwZW5kZWRFbmRwb2ludCA9IGpwYy5lbmRwb2ludHNbYW5jaG9ySWR4XTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUFJPVklERSBUSEUgU1VTUEVOREVEIEVMRU1FTlQsIEJFIElUIEEgU09VUkNFIE9SIFRBUkdFVCAoSVNTVUUgMzkpXG4gICAgICAgICAgICAgICAgICAgICAgICBqcGMuc3VzcGVuZGVkRWxlbWVudCA9IGpwYy5lbmRwb2ludHNbYW5jaG9ySWR4XS5nZXRFbGVtZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBqcGMuc3VzcGVuZGVkRWxlbWVudElkID0ganBjLmVuZHBvaW50c1thbmNob3JJZHhdLmVsZW1lbnRJZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGpwYy5zdXNwZW5kZWRFbGVtZW50VHlwZSA9IGFuY2hvcklkeCA9PT0gMCA/IFwic291cmNlXCIgOiBcInRhcmdldFwiO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBqcGMuc3VzcGVuZGVkRW5kcG9pbnQuc2V0SG92ZXIoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fanNQbHVtYi5mbG9hdGluZ0VuZHBvaW50LnJlZmVyZW5jZUVuZHBvaW50ID0ganBjLnN1c3BlbmRlZEVuZHBvaW50O1xuICAgICAgICAgICAgICAgICAgICAgICAganBjLmVuZHBvaW50c1thbmNob3JJZHhdID0gdGhpcy5fanNQbHVtYi5mbG9hdGluZ0VuZHBvaW50O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBqcGMuYWRkQ2xhc3MoX2pzUGx1bWIuZHJhZ2dpbmdDbGFzcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9qc1BsdW1iLmZsb2F0aW5nRW5kcG9pbnQuYWRkQ2xhc3MoX2pzUGx1bWIuZHJhZ2dpbmdDbGFzcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyByZWdpc3RlciBpdCBhbmQgcmVnaXN0ZXIgY29ubmVjdGlvbiBvbiBpdC5cbiAgICAgICAgICAgICAgICAgICAgX2pzUGx1bWIuZmxvYXRpbmdDb25uZWN0aW9uc1twbGFjZWhvbGRlckluZm8uaWRdID0ganBjO1xuICAgICAgICAgICAgICAgICAgICAvLyBvbmx5IHJlZ2lzdGVyIGZvciB0aGUgdGFyZ2V0IGVuZHBvaW50OyB3ZSB3aWxsIG5vdCBiZSBkcmFnZ2luZyB0aGUgc291cmNlIGF0IGFueSB0aW1lXG4gICAgICAgICAgICAgICAgICAgIC8vIGJlZm9yZSB0aGlzIGNvbm5lY3Rpb24gaXMgZWl0aGVyIGRpc2NhcmRlZCBvciBtYWRlIGludG8gYSBwZXJtYW5lbnQgY29ubmVjdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgX2p1LmFkZFRvTGlzdChwYXJhbXMuZW5kcG9pbnRzQnlFbGVtZW50LCBwbGFjZWhvbGRlckluZm8uaWQsIHRoaXMuX2pzUGx1bWIuZmxvYXRpbmdFbmRwb2ludCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRlbGwganNwbHVtYiBhYm91dCBpdFxuICAgICAgICAgICAgICAgICAgICBfanNQbHVtYi5jdXJyZW50bHlEcmFnZ2luZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpO1xuXG4gICAgICAgICAgICAgICAgdmFyIHN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIF9qc1BsdW1iLnNldENvbm5lY3Rpb25CZWluZ0RyYWdnZWQoZmFsc2UpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChqcGMgJiYganBjLmVuZHBvaW50cyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBnZXQgdGhlIGFjdHVhbCBkcm9wIGV2ZW50IChkZWNvZGUgZnJvbSBsaWJyYXJ5IGFyZ3MgdG8gc3RvcCBmdW5jdGlvbilcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvcmlnaW5hbEV2ZW50ID0gX2pzUGx1bWIuZ2V0RHJvcEV2ZW50KGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB1bmxvY2sgdGhlIG90aGVyIGVuZHBvaW50IChpZiBpdCBpcyBkeW5hbWljLCBpdCB3b3VsZCBoYXZlIGJlZW4gbG9ja2VkIGF0IGRyYWcgc3RhcnQpXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaWR4ID0gX2pzUGx1bWIuZ2V0RmxvYXRpbmdBbmNob3JJbmRleChqcGMpO1xuICAgICAgICAgICAgICAgICAgICAgICAganBjLmVuZHBvaW50c1tpZHggPT09IDAgPyAxIDogMF0uYW5jaG9yLmxvY2tlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogRG9udCB3YW50IHRvIGtub3cgYWJvdXQgY3NzIGNsYXNzZXMgaW5zaWRlIGpzcGx1bWIsIGlkZWFsbHkuXG4gICAgICAgICAgICAgICAgICAgICAgICBqcGMucmVtb3ZlQ2xhc3MoX2pzUGx1bWIuZHJhZ2dpbmdDbGFzcyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHdlIGhhdmUgdGhlIGZsb2F0aW5nIGVuZHBvaW50IHRoZW4gdGhlIGNvbm5lY3Rpb24gaGFzIG5vdCBiZWVuIGRyb3BwZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9uIGFub3RoZXIgZW5kcG9pbnQuICBJZiBpdCBpcyBhIG5ldyBjb25uZWN0aW9uIHdlIHRocm93IGl0IGF3YXkuIElmIGl0IGlzIGFuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBleGlzdGluZyBjb25uZWN0aW9uIHdlIGNoZWNrIHRvIHNlZSBpZiB3ZSBzaG91bGQgcmVhdHRhY2ggaXQsIHRocm93aW5nIGl0IGF3YXlcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIG5vdC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9qc1BsdW1iICYmIChqcGMuZGVsZXRlQ29ubmVjdGlvbk5vdyB8fCBqcGMuZW5kcG9pbnRzW2lkeF0gPT09IHRoaXMuX2pzUGx1bWIuZmxvYXRpbmdFbmRwb2ludCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyA2YS4gaWYgdGhlIGNvbm5lY3Rpb24gd2FzIGFuIGV4aXN0aW5nIG9uZS4uLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleGlzdGluZ0pwYyAmJiBqcGMuc3VzcGVuZGVkRW5kcG9pbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZml4IGZvciBpc3N1ZTM1LCB0aGFua3MgU3lsdmFpbiBHaXphcmQ6IHdoZW4gZmlyaW5nIHRoZSBkZXRhY2ggZXZlbnQgbWFrZSBzdXJlIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmbG9hdGluZyBlbmRwb2ludCBoYXMgYmVlbiByZXBsYWNlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlkeCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAganBjLmZsb2F0aW5nRWxlbWVudCA9IGpwYy5zb3VyY2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqcGMuZmxvYXRpbmdJZCA9IGpwYy5zb3VyY2VJZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpwYy5mbG9hdGluZ0VuZHBvaW50ID0ganBjLmVuZHBvaW50c1swXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpwYy5mbG9hdGluZ0luZGV4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpwYy5zb3VyY2UgPSBleGlzdGluZ0pwY1BhcmFtc1swXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpwYy5zb3VyY2VJZCA9IGV4aXN0aW5nSnBjUGFyYW1zWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8ga2VlcCBhIGNvcHkgb2YgdGhlIGZsb2F0aW5nIGVsZW1lbnQ7IHRoZSBhbmNob3IgbWFuYWdlciB3aWxsIHdhbnQgdG8gY2xlYW4gdXAuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqcGMuZmxvYXRpbmdFbGVtZW50ID0ganBjLnRhcmdldDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpwYy5mbG9hdGluZ0lkID0ganBjLnRhcmdldElkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAganBjLmZsb2F0aW5nRW5kcG9pbnQgPSBqcGMuZW5kcG9pbnRzWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAganBjLmZsb2F0aW5nSW5kZXggPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAganBjLnRhcmdldCA9IGV4aXN0aW5nSnBjUGFyYW1zWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAganBjLnRhcmdldElkID0gZXhpc3RpbmdKcGNQYXJhbXNbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmUgPSB0aGlzLl9qc1BsdW1iLmZsb2F0aW5nRW5kcG9pbnQ7IC8vIHN0b3JlIGZvciBsYXRlciByZW1vdmFsLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZXN0b3JlIHRoZSBvcmlnaW5hbCBzY29wZSAoaXNzdWUgNTcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9qc1BsdW1iLnNldERyYWdTY29wZShleGlzdGluZ0pwY1BhcmFtc1syXSwgZXhpc3RpbmdKcGNQYXJhbXNbM10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqcGMuZW5kcG9pbnRzW2lkeF0gPSBqcGMuc3VzcGVuZGVkRW5kcG9pbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElGIHRoZSBjb25uZWN0aW9uIHNob3VsZCBiZSByZWF0dGFjaGVkLCBvciB0aGUgb3RoZXIgZW5kcG9pbnQgcmVmdXNlcyBkZXRhY2gsIHRoZW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVzZXQgdGhlIGNvbm5lY3Rpb24gdG8gaXRzIG9yaWdpbmFsIHN0YXRlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vaWYgKGpwYy5pc1JlYXR0YWNoKCkgfHwganBjLl9mb3JjZVJlYXR0YWNoIHx8IGpwYy5fZm9yY2VEZXRhY2ggfHwgIWpwYy5lbmRwb2ludHNbaWR4ID09PSAwID8gMSA6IDBdLmRldGFjaCh7Y29ubmVjdGlvbjpqcGMsIGlnbm9yZVRhcmdldDpmYWxzZSwgZm9yY2VEZXRhY2g6ZmFsc2UsIGZpcmVFdmVudDp0cnVlLCBvcmlnaW5hbEV2ZW50Om9yaWdpbmFsRXZlbnQsIGVuZHBvaW50QmVpbmdEZWxldGVkOnRydWV9KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoanBjLmlzUmVhdHRhY2goKSB8fCBqcGMuX2ZvcmNlUmVhdHRhY2ggfHwganBjLl9mb3JjZURldGFjaCB8fCAhX2pzUGx1bWIuZGVsZXRlQ29ubmVjdGlvbihqcGMpKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpwYy5zZXRIb3ZlcihmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqcGMuX2ZvcmNlRGV0YWNoID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpwYy5fZm9yY2VSZWF0dGFjaCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9qc1BsdW1iLmZsb2F0aW5nRW5kcG9pbnQuZGV0YWNoRnJvbUNvbm5lY3Rpb24oanBjKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpwYy5zdXNwZW5kZWRFbmRwb2ludC5hZGRDb25uZWN0aW9uKGpwYyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gdGhpcyBjb2RlIGlzIGR1cGxpY2F0ZWQgaW4gbG90cyBvZiBwbGFjZXMuLi5hbmQgdGhlcmUgaXMgbm90aGluZyBleHRlcm5hbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW4gdGhlIGNvZGU7IGl0IGFsbCByZWZlcnMgdG8gdGhlIGNvbm5lY3Rpb24gaXRzZWxmLiB3ZSBjb3VsZCBhZGQgYVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYGNoZWNrU2FuaXR5KGNvbm5lY3Rpb24pYCBtZXRob2QgdG8gYW5jaG9yTWFuYWdlciB0aGF0IGRpZCB0aGlzLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlkeCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9qc1BsdW1iLmFuY2hvck1hbmFnZXIudXBkYXRlT3RoZXJFbmRwb2ludChqcGMuc291cmNlSWQsIGpwYy5mbG9hdGluZ0lkLCBqcGMudGFyZ2V0SWQsIGpwYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfanNQbHVtYi5hbmNob3JNYW5hZ2VyLnNvdXJjZUNoYW5nZWQoanBjLmZsb2F0aW5nSWQsIGpwYy5zb3VyY2VJZCwganBjLCBqcGMuc291cmNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2pzUGx1bWIucmVwYWludChleGlzdGluZ0pwY1BhcmFtc1sxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfanNQbHVtYi5kZWxldGVPYmplY3Qoe2VuZHBvaW50OiBmZX0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBtYWtlVGFyZ2V0cyBzZXRzIHRoaXMgZmxhZywgdG8gdGVsbCB1cyB3ZSBoYXZlIGJlZW4gcmVwbGFjZWQgYW5kIHNob3VsZCBkZWxldGUgdGhpcyBvYmplY3QuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5kZWxldGVBZnRlckRyYWdTdG9wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2pzUGx1bWIuZGVsZXRlT2JqZWN0KHtlbmRwb2ludDogdGhpc30pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2pzUGx1bWIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGFpbnQoe3JlY2FsYzogZmFsc2V9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFsdGhvdWdoIHRoZSBjb25uZWN0aW9uIGlzIG5vIGxvbmdlciB2YWxpZCwgdGhlcmUgYXJlIHVzZSBjYXNlcyB3aGVyZSB0aGlzIGlzIHVzZWZ1bC5cbiAgICAgICAgICAgICAgICAgICAgICAgIF9qc1BsdW1iLmZpcmUoXCJjb25uZWN0aW9uRHJhZ1N0b3BcIiwganBjLCBvcmlnaW5hbEV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZpcmUgdGhpcyBldmVudCB0byBnaXZlIHBlb3BsZSBtb3JlIGZpbmUtZ3JhaW5lZCBjb250cm9sIChjb25uZWN0aW9uRHJhZ1N0b3AgZmlyZXMgYSBsb3QpXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoanBjLnBlbmRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfanNQbHVtYi5maXJlKFwiY29ubmVjdGlvbkFib3J0ZWRcIiwganBjLCBvcmlnaW5hbEV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRlbGwganNwbHVtYiB0aGF0IGRyYWdnaW5nIGlzIGZpbmlzaGVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgX2pzUGx1bWIuY3VycmVudGx5RHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGpwYy5zdXNwZW5kZWRFbGVtZW50ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGpwYy5zdXNwZW5kZWRFbmRwb2ludCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBqcGMgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgbm8gZW5kcG9pbnRzLCBqcGMgYWxyZWFkeSBjbGVhbmVkIHVwLiBidXQgc3RpbGwgd2Ugd2FudCB0byBlbnN1cmUgd2UncmUgcmVzZXQgcHJvcGVybHkuXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSB0aGUgZWxlbWVudCBhc3NvY2lhdGVkIHdpdGggdGhlIGZsb2F0aW5nIGVuZHBvaW50XG4gICAgICAgICAgICAgICAgICAgIC8vIChhbmQgaXRzIGFzc29jaWF0ZWQgZmxvYXRpbmcgZW5kcG9pbnQgYW5kIHZpc3VhbCBhcnRlZmFjdHMpXG4gICAgICAgICAgICAgICAgICAgIGlmIChwbGFjZWhvbGRlckluZm8gJiYgcGxhY2Vob2xkZXJJbmZvLmVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9qc1BsdW1iLnJlbW92ZShwbGFjZWhvbGRlckluZm8uZWxlbWVudCwgZmFsc2UsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgdGhlIGlucGxhY2UgY29weVxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5QbGFjZUNvcHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9qc1BsdW1iLmRlbGV0ZU9iamVjdCh7ZW5kcG9pbnQ6IGluUGxhY2VDb3B5fSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fanNQbHVtYikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWFrZSBvdXIgY2FudmFzIHZpc2libGUgKFRPRE86IGhhbmQgb2ZmIHRvIGxpYnJhcnk7IHdlIHNob3VsZCBub3Qga25vdyBhYm91dCBET00pXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbnZhcy5zdHlsZS52aXNpYmlsaXR5ID0gXCJ2aXNpYmxlXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB1bmxvY2sgb3VyIGFuY2hvclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hbmNob3IubG9ja2VkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjbGVhciBmbG9hdGluZyBhbmNob3IuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9qc1BsdW1iLmZsb2F0aW5nRW5kcG9pbnQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9LmJpbmQodGhpcyk7XG5cbiAgICAgICAgICAgICAgICBkcmFnT3B0aW9ucyA9IF9qcC5leHRlbmQoZGVmYXVsdE9wdHMsIGRyYWdPcHRpb25zKTtcbiAgICAgICAgICAgICAgICBkcmFnT3B0aW9ucy5zY29wZSA9IHRoaXMuc2NvcGUgfHwgZHJhZ09wdGlvbnMuc2NvcGU7XG4gICAgICAgICAgICAgICAgZHJhZ09wdGlvbnNbYmVmb3JlU3RhcnRFdmVudF0gPSBfanUud3JhcChkcmFnT3B0aW9uc1tiZWZvcmVTdGFydEV2ZW50XSwgYmVmb3JlU3RhcnQsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBkcmFnT3B0aW9uc1tzdGFydEV2ZW50XSA9IF9qdS53cmFwKGRyYWdPcHRpb25zW3N0YXJ0RXZlbnRdLCBzdGFydCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIC8vIGV4dHJhY3RlZCBkcmFnIGhhbmRsZXIgZnVuY3Rpb24gc28gY2FuIGJlIHVzZWQgYnkgbWFrZVNvdXJjZVxuICAgICAgICAgICAgICAgIGRyYWdPcHRpb25zW2RyYWdFdmVudF0gPSBfanUud3JhcChkcmFnT3B0aW9uc1tkcmFnRXZlbnRdLCBfZHJhZ0hhbmRsZXIuZHJhZyk7XG4gICAgICAgICAgICAgICAgZHJhZ09wdGlvbnNbc3RvcEV2ZW50XSA9IF9qdS53cmFwKGRyYWdPcHRpb25zW3N0b3BFdmVudF0sIHN0b3ApO1xuICAgICAgICAgICAgICAgIGRyYWdPcHRpb25zLm11bHRpcGxlRHJvcCA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgZHJhZ09wdGlvbnMuY2FuRHJhZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXNTb3VyY2UgfHwgdGhpcy5pc1RlbXBvcmFyeVNvdXJjZSB8fCAvKih0aGlzLmlzVGFyZ2V0ICYmICovdGhpcy5jb25uZWN0aW9ucy5sZW5ndGggPiAwLyopKi87XG4gICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpO1xuXG4gICAgICAgICAgICAgICAgX2pzUGx1bWIuaW5pdERyYWdnYWJsZSh0aGlzLmNhbnZhcywgZHJhZ09wdGlvbnMsIFwiaW50ZXJuYWxcIik7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmNhbnZhcy5fanNQbHVtYlJlbGF0ZWRFbGVtZW50ID0gdGhpcy5lbGVtZW50O1xuXG4gICAgICAgICAgICAgICAgZHJhZ2dpbmdJbml0aWFsaXNlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGVwID0gcGFyYW1zLmVuZHBvaW50IHx8IHRoaXMuX2pzUGx1bWIuaW5zdGFuY2UuRGVmYXVsdHMuRW5kcG9pbnQgfHwgX2pwLkRlZmF1bHRzLkVuZHBvaW50O1xuICAgICAgICB0aGlzLnNldEVuZHBvaW50KGVwLCB0cnVlKTtcbiAgICAgICAgdmFyIGFuY2hvclBhcmFtc1RvVXNlID0gcGFyYW1zLmFuY2hvciA/IHBhcmFtcy5hbmNob3IgOiBwYXJhbXMuYW5jaG9ycyA/IHBhcmFtcy5hbmNob3JzIDogKF9qc1BsdW1iLkRlZmF1bHRzLkFuY2hvciB8fCBcIlRvcFwiKTtcbiAgICAgICAgdGhpcy5zZXRBbmNob3IoYW5jaG9yUGFyYW1zVG9Vc2UsIHRydWUpO1xuXG4gICAgICAgIC8vIGZpbmFsbHksIHNldCB0eXBlIGlmIGl0IHdhcyBwcm92aWRlZFxuICAgICAgICB2YXIgdHlwZSA9IFsgXCJkZWZhdWx0XCIsIChwYXJhbXMudHlwZSB8fCBcIlwiKV0uam9pbihcIiBcIik7XG4gICAgICAgIHRoaXMuYWRkVHlwZSh0eXBlLCBwYXJhbXMuZGF0YSwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuY2FudmFzID0gdGhpcy5lbmRwb2ludC5jYW52YXM7XG4gICAgICAgIHRoaXMuY2FudmFzLl9qc1BsdW1iID0gdGhpcztcblxuICAgICAgICB0aGlzLmluaXREcmFnZ2FibGUoKTtcblxuICAgICAgICAvLyBwdWxsZWQgdGhpcyBvdXQgaW50byBhIGZ1bmN0aW9uIHNvIHdlIGNhbiByZXVzZSBpdCBmb3IgdGhlIGluUGxhY2VDb3B5IGNhbnZhczsgeW91IGNhbiBub3cgZHJvcCBkZXRhY2hlZCBjb25uZWN0aW9uc1xuICAgICAgICAvLyBiYWNrIG9udG8gdGhlIGVuZHBvaW50IHlvdSBkZXRhY2hlZCBpdCBmcm9tLlxuICAgICAgICB2YXIgX2luaXREcm9wVGFyZ2V0ID0gZnVuY3Rpb24gKGNhbnZhcywgaXNUcmFuc2llbnQsIGVuZHBvaW50LCByZWZlcmVuY2VFbmRwb2ludCkge1xuXG4gICAgICAgICAgICBpZiAoX2pwLmlzRHJvcFN1cHBvcnRlZCh0aGlzLmVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRyb3BPcHRpb25zID0gcGFyYW1zLmRyb3BPcHRpb25zIHx8IF9qc1BsdW1iLkRlZmF1bHRzLkRyb3BPcHRpb25zIHx8IF9qcC5EZWZhdWx0cy5Ecm9wT3B0aW9ucztcbiAgICAgICAgICAgICAgICBkcm9wT3B0aW9ucyA9IF9qcC5leHRlbmQoe30sIGRyb3BPcHRpb25zKTtcbiAgICAgICAgICAgICAgICBkcm9wT3B0aW9ucy5zY29wZSA9IGRyb3BPcHRpb25zLnNjb3BlIHx8IHRoaXMuc2NvcGU7XG4gICAgICAgICAgICAgICAgdmFyIGRyb3BFdmVudCA9IF9qcC5kcmFnRXZlbnRzLmRyb3AsXG4gICAgICAgICAgICAgICAgICAgIG92ZXJFdmVudCA9IF9qcC5kcmFnRXZlbnRzLm92ZXIsXG4gICAgICAgICAgICAgICAgICAgIG91dEV2ZW50ID0gX2pwLmRyYWdFdmVudHMub3V0LFxuICAgICAgICAgICAgICAgICAgICBfZXAgPSB0aGlzLFxuICAgICAgICAgICAgICAgICAgICBkcm9wID0gX2pzUGx1bWIuRW5kcG9pbnREcm9wSGFuZGxlcih7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRFbmRwb2ludDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfZXA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAganNQbHVtYjogX2pzUGx1bWIsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmFibGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVuZHBvaW50ICE9IG51bGwgPyBlbmRwb2ludC5pc0VuYWJsZWQoKSA6IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNGdWxsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVuZHBvaW50LmlzRnVsbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6IHRoaXMuZWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRJZDogdGhpcy5lbGVtZW50SWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc1NvdXJjZTogdGhpcy5pc1NvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzVGFyZ2V0OiB0aGlzLmlzVGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkQ2xhc3M6IGZ1bmN0aW9uIChjbGF6eikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9lcC5hZGRDbGFzcyhjbGF6eik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uIChjbGF6eikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9lcC5yZW1vdmVDbGFzcyhjbGF6eik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNEcm9wQWxsb3dlZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfZXAuaXNEcm9wQWxsb3dlZC5hcHBseShfZXAsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlOnJlZmVyZW5jZUVuZHBvaW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNSZWRyb3A6ZnVuY3Rpb24oanBjLCBkaFBhcmFtcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBqcGMuc3VzcGVuZGVkRW5kcG9pbnQgJiYgZGhQYXJhbXMucmVmZXJlbmNlICYmIChqcGMuc3VzcGVuZGVkRW5kcG9pbnQuaWQgPT09IGRoUGFyYW1zLnJlZmVyZW5jZS5pZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgZHJvcE9wdGlvbnNbZHJvcEV2ZW50XSA9IF9qdS53cmFwKGRyb3BPcHRpb25zW2Ryb3BFdmVudF0sIGRyb3AsIHRydWUpO1xuICAgICAgICAgICAgICAgIGRyb3BPcHRpb25zW292ZXJFdmVudF0gPSBfanUud3JhcChkcm9wT3B0aW9uc1tvdmVyRXZlbnRdLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkcmFnZ2FibGUgPSBfanAuZ2V0RHJhZ09iamVjdChhcmd1bWVudHMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgaWQgPSBfanNQbHVtYi5nZXRBdHRyaWJ1dGUoX2pwLmdldEVsZW1lbnQoZHJhZ2dhYmxlKSwgXCJkcmFnSWRcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICBfanBjID0gX2pzUGx1bWIuZmxvYXRpbmdDb25uZWN0aW9uc1tpZF07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKF9qcGMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlkeCA9IF9qc1BsdW1iLmdldEZsb2F0aW5nQW5jaG9ySW5kZXgoX2pwYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBoZXJlIHdlIHNob3VsZCBmaXJlIHRoZSAnb3ZlcicgZXZlbnQgaWYgd2UgYXJlIGEgdGFyZ2V0IGFuZCB0aGlzIGlzIGEgbmV3IGNvbm5lY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvciB3ZSBhcmUgdGhlIHNhbWUgYXMgdGhlIGZsb2F0aW5nIGVuZHBvaW50LlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9jb250ID0gKHRoaXMuaXNUYXJnZXQgJiYgaWR4ICE9PSAwKSB8fCAoX2pwYy5zdXNwZW5kZWRFbmRwb2ludCAmJiB0aGlzLnJlZmVyZW5jZUVuZHBvaW50ICYmIHRoaXMucmVmZXJlbmNlRW5kcG9pbnQuaWQgPT09IF9qcGMuc3VzcGVuZGVkRW5kcG9pbnQuaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9jb250KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJiID0gX2pzUGx1bWIuY2hlY2tDb25kaXRpb24oXCJjaGVja0Ryb3BBbGxvd2VkXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlRW5kcG9pbnQ6IF9qcGMuZW5kcG9pbnRzW2lkeF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldEVuZHBvaW50OiB0aGlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uOiBfanBjXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1soYmIgPyBcImFkZFwiIDogXCJyZW1vdmVcIikgKyBcIkNsYXNzXCJdKF9qc1BsdW1iLmVuZHBvaW50RHJvcEFsbG93ZWRDbGFzcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1soYmIgPyBcInJlbW92ZVwiIDogXCJhZGRcIikgKyBcIkNsYXNzXCJdKF9qc1BsdW1iLmVuZHBvaW50RHJvcEZvcmJpZGRlbkNsYXNzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfanBjLmVuZHBvaW50c1tpZHhdLmFuY2hvci5vdmVyKHRoaXMuYW5jaG9yLCB0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICAgICAgICAgICAgICBkcm9wT3B0aW9uc1tvdXRFdmVudF0gPSBfanUud3JhcChkcm9wT3B0aW9uc1tvdXRFdmVudF0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRyYWdnYWJsZSA9IF9qcC5nZXREcmFnT2JqZWN0KGFyZ3VtZW50cyksXG4gICAgICAgICAgICAgICAgICAgICAgICBpZCA9IGRyYWdnYWJsZSA9PSBudWxsID8gbnVsbCA6IF9qc1BsdW1iLmdldEF0dHJpYnV0ZShfanAuZ2V0RWxlbWVudChkcmFnZ2FibGUpLCBcImRyYWdJZFwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9qcGMgPSBpZCA/IF9qc1BsdW1iLmZsb2F0aW5nQ29ubmVjdGlvbnNbaWRdIDogbnVsbDtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoX2pwYyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaWR4ID0gX2pzUGx1bWIuZ2V0RmxvYXRpbmdBbmNob3JJbmRleChfanBjKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfY29udCA9ICh0aGlzLmlzVGFyZ2V0ICYmIGlkeCAhPT0gMCkgfHwgKF9qcGMuc3VzcGVuZGVkRW5kcG9pbnQgJiYgdGhpcy5yZWZlcmVuY2VFbmRwb2ludCAmJiB0aGlzLnJlZmVyZW5jZUVuZHBvaW50LmlkID09PSBfanBjLnN1c3BlbmRlZEVuZHBvaW50LmlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfY29udCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlQ2xhc3MoX2pzUGx1bWIuZW5kcG9pbnREcm9wQWxsb3dlZENsYXNzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUNsYXNzKF9qc1BsdW1iLmVuZHBvaW50RHJvcEZvcmJpZGRlbkNsYXNzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfanBjLmVuZHBvaW50c1tpZHhdLmFuY2hvci5vdXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICAgICAgICAgICAgICBfanNQbHVtYi5pbml0RHJvcHBhYmxlKGNhbnZhcywgZHJvcE9wdGlvbnMsIFwiaW50ZXJuYWxcIiwgaXNUcmFuc2llbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LmJpbmQodGhpcyk7XG5cbiAgICAgICAgLy8gSW5pdGlhbGlzZSB0aGUgZW5kcG9pbnQncyBjYW52YXMgYXMgYSBkcm9wIHRhcmdldC4gVGhlIGRyb3AgaGFuZGxlciB3aWxsIHRha2UgY2FyZSBvZiB0aGUgbG9naWMgb2Ygd2hldGhlclxuICAgICAgICAvLyBzb21ldGhpbmcgY2FuIGFjdHVhbGx5IGJlIGRyb3BwZWQuXG4gICAgICAgIGlmICghdGhpcy5hbmNob3IuaXNGbG9hdGluZykge1xuICAgICAgICAgICAgX2luaXREcm9wVGFyZ2V0KHRoaXMuY2FudmFzLCAhKHBhcmFtcy5fdHJhbnNpZW50IHx8IHRoaXMuYW5jaG9yLmlzRmxvYXRpbmcpLCB0aGlzLCBwYXJhbXMucmVmZXJlbmNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBfanUuZXh0ZW5kKF9qcC5FbmRwb2ludCwgX2pwLk92ZXJsYXlDYXBhYmxlSnNQbHVtYlVJQ29tcG9uZW50LCB7XG5cbiAgICAgICAgc2V0VmlzaWJsZTogZnVuY3Rpb24gKHYsIGRvTm90Q2hhbmdlQ29ubmVjdGlvbnMsIGRvTm90Tm90aWZ5T3RoZXJFbmRwb2ludCkge1xuICAgICAgICAgICAgdGhpcy5fanNQbHVtYi52aXNpYmxlID0gdjtcbiAgICAgICAgICAgIGlmICh0aGlzLmNhbnZhcykge1xuICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzLnN0eWxlLmRpc3BsYXkgPSB2ID8gXCJibG9ja1wiIDogXCJub25lXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzW3YgPyBcInNob3dPdmVybGF5c1wiIDogXCJoaWRlT3ZlcmxheXNcIl0oKTtcbiAgICAgICAgICAgIGlmICghZG9Ob3RDaGFuZ2VDb25uZWN0aW9ucykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jb25uZWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25zW2ldLnNldFZpc2libGUodik7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZG9Ob3ROb3RpZnlPdGhlckVuZHBvaW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb0lkeCA9IHRoaXMgPT09IHRoaXMuY29ubmVjdGlvbnNbaV0uZW5kcG9pbnRzWzBdID8gMSA6IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvbmx5IGNoYW5nZSB0aGUgb3RoZXIgZW5kcG9pbnQgaWYgdGhpcyBpcyBpdHMgb25seSBjb25uZWN0aW9uLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY29ubmVjdGlvbnNbaV0uZW5kcG9pbnRzW29JZHhdLmNvbm5lY3Rpb25zLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbnNbaV0uZW5kcG9pbnRzW29JZHhdLnNldFZpc2libGUodiwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGdldEF0dGFjaGVkRWxlbWVudHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpb25zO1xuICAgICAgICB9LFxuICAgICAgICBhcHBseVR5cGU6IGZ1bmN0aW9uICh0LCBkb05vdFJlcGFpbnQpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0UGFpbnRTdHlsZSh0LmVuZHBvaW50U3R5bGUgfHwgdC5wYWludFN0eWxlLCBkb05vdFJlcGFpbnQpO1xuICAgICAgICAgICAgdGhpcy5zZXRIb3ZlclBhaW50U3R5bGUodC5lbmRwb2ludEhvdmVyU3R5bGUgfHwgdC5ob3ZlclBhaW50U3R5bGUsIGRvTm90UmVwYWludCk7XG4gICAgICAgICAgICBpZiAodC5tYXhDb25uZWN0aW9ucyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fanNQbHVtYi5tYXhDb25uZWN0aW9ucyA9IHQubWF4Q29ubmVjdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodC5zY29wZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2NvcGUgPSB0LnNjb3BlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX2pwLmV4dGVuZCh0aGlzLCB0LCB0eXBlUGFyYW1ldGVycyk7XG4gICAgICAgICAgICBpZiAodC5jc3NDbGFzcyAhPSBudWxsICYmIHRoaXMuY2FudmFzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fanNQbHVtYi5pbnN0YW5jZS5hZGRDbGFzcyh0aGlzLmNhbnZhcywgdC5jc3NDbGFzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfanAuT3ZlcmxheUNhcGFibGVKc1BsdW1iVUlDb21wb25lbnQuYXBwbHlUeXBlKHRoaXMsIHQpO1xuICAgICAgICB9LFxuICAgICAgICBpc0VuYWJsZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9qc1BsdW1iLmVuYWJsZWQ7XG4gICAgICAgIH0sXG4gICAgICAgIHNldEVuYWJsZWQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB0aGlzLl9qc1BsdW1iLmVuYWJsZWQgPSBlO1xuICAgICAgICB9LFxuICAgICAgICBjbGVhbnVwOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYW5jaG9yQ2xhc3MgPSB0aGlzLl9qc1BsdW1iLmluc3RhbmNlLmVuZHBvaW50QW5jaG9yQ2xhc3NQcmVmaXggKyAodGhpcy5fanNQbHVtYi5jdXJyZW50QW5jaG9yQ2xhc3MgPyBcIi1cIiArIHRoaXMuX2pzUGx1bWIuY3VycmVudEFuY2hvckNsYXNzIDogXCJcIik7XG4gICAgICAgICAgICBfanAucmVtb3ZlQ2xhc3ModGhpcy5lbGVtZW50LCBhbmNob3JDbGFzcyk7XG4gICAgICAgICAgICB0aGlzLmFuY2hvciA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmVuZHBvaW50LmNsZWFudXAodHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLmVuZHBvaW50LmRlc3Ryb3koKTtcbiAgICAgICAgICAgIHRoaXMuZW5kcG9pbnQgPSBudWxsO1xuICAgICAgICAgICAgLy8gZHJhZy9kcm9wXG4gICAgICAgICAgICB0aGlzLl9qc1BsdW1iLmluc3RhbmNlLmRlc3Ryb3lEcmFnZ2FibGUodGhpcy5jYW52YXMsIFwiaW50ZXJuYWxcIik7XG4gICAgICAgICAgICB0aGlzLl9qc1BsdW1iLmluc3RhbmNlLmRlc3Ryb3lEcm9wcGFibGUodGhpcy5jYW52YXMsIFwiaW50ZXJuYWxcIik7XG4gICAgICAgIH0sXG4gICAgICAgIHNldEhvdmVyOiBmdW5jdGlvbiAoaCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZW5kcG9pbnQgJiYgdGhpcy5fanNQbHVtYiAmJiAhdGhpcy5fanNQbHVtYi5pbnN0YW5jZS5pc0Nvbm5lY3Rpb25CZWluZ0RyYWdnZWQoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZW5kcG9pbnQuc2V0SG92ZXIoaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGlzRnVsbDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2pzUGx1bWIubWF4Q29ubmVjdGlvbnMgPT09IDAgPyB0cnVlIDogISh0aGlzLmlzRmxvYXRpbmcoKSB8fCB0aGlzLl9qc1BsdW1iLm1heENvbm5lY3Rpb25zIDwgMCB8fCB0aGlzLmNvbm5lY3Rpb25zLmxlbmd0aCA8IHRoaXMuX2pzUGx1bWIubWF4Q29ubmVjdGlvbnMpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogcHJpdmF0ZSBidXQgbmVlZHMgdG8gYmUgZXhwb3NlZC5cbiAgICAgICAgICovXG4gICAgICAgIGlzRmxvYXRpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFuY2hvciAhPSBudWxsICYmIHRoaXMuYW5jaG9yLmlzRmxvYXRpbmc7XG4gICAgICAgIH0sXG4gICAgICAgIGlzQ29ubmVjdGVkVG86IGZ1bmN0aW9uIChlbmRwb2ludCkge1xuICAgICAgICAgICAgdmFyIGZvdW5kID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoZW5kcG9pbnQpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY29ubmVjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY29ubmVjdGlvbnNbaV0uZW5kcG9pbnRzWzFdID09PSBlbmRwb2ludCB8fCB0aGlzLmNvbm5lY3Rpb25zW2ldLmVuZHBvaW50c1swXSA9PT0gZW5kcG9pbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgICAgICB9LFxuICAgICAgICBnZXRDb25uZWN0aW9uQ29zdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2pzUGx1bWIuY29ubmVjdGlvbkNvc3Q7XG4gICAgICAgIH0sXG4gICAgICAgIHNldENvbm5lY3Rpb25Db3N0OiBmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgdGhpcy5fanNQbHVtYi5jb25uZWN0aW9uQ29zdCA9IGM7XG4gICAgICAgIH0sXG4gICAgICAgIGFyZUNvbm5lY3Rpb25zRGlyZWN0ZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9qc1BsdW1iLmNvbm5lY3Rpb25zRGlyZWN0ZWQ7XG4gICAgICAgIH0sXG4gICAgICAgIHNldENvbm5lY3Rpb25zRGlyZWN0ZWQ6IGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgICB0aGlzLl9qc1BsdW1iLmNvbm5lY3Rpb25zRGlyZWN0ZWQgPSBiO1xuICAgICAgICB9LFxuICAgICAgICBzZXRFbGVtZW50SWQ6IGZ1bmN0aW9uIChfZWxJZCkge1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50SWQgPSBfZWxJZDtcbiAgICAgICAgICAgIHRoaXMuYW5jaG9yLmVsZW1lbnRJZCA9IF9lbElkO1xuICAgICAgICB9LFxuICAgICAgICBzZXRSZWZlcmVuY2VFbGVtZW50OiBmdW5jdGlvbiAoX2VsKSB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQgPSBfanAuZ2V0RWxlbWVudChfZWwpO1xuICAgICAgICB9LFxuICAgICAgICBzZXREcmFnQWxsb3dlZFdoZW5GdWxsOiBmdW5jdGlvbiAoYWxsb3dlZCkge1xuICAgICAgICAgICAgdGhpcy5kcmFnQWxsb3dlZFdoZW5GdWxsID0gYWxsb3dlZDtcbiAgICAgICAgfSxcbiAgICAgICAgZXF1YWxzOiBmdW5jdGlvbiAoZW5kcG9pbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFuY2hvci5lcXVhbHMoZW5kcG9pbnQuYW5jaG9yKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0VXVpZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2pzUGx1bWIudXVpZDtcbiAgICAgICAgfSxcbiAgICAgICAgY29tcHV0ZUFuY2hvcjogZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYW5jaG9yLmNvbXB1dGUocGFyYW1zKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcm9vdC5qc1BsdW1iSW5zdGFuY2UucHJvdG90eXBlLkVuZHBvaW50RHJvcEhhbmRsZXIgPSBmdW5jdGlvbiAoZGhQYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlKSB7XG5cbiAgICAgICAgICAgIHZhciBfanNQbHVtYiA9IGRoUGFyYW1zLmpzUGx1bWI7XG5cbiAgICAgICAgICAgIC8vIHJlbW92ZSB0aGUgY2xhc3NlcyB0aGF0IGFyZSBhZGRlZCBkeW5hbWljYWxseS4gZHJvcCBpcyBuZWl0aGVyIGZvcmJpZGRlbiBub3IgYWxsb3dlZCBub3cgdGhhdFxuICAgICAgICAgICAgLy8gdGhlIGRyb3AgaXMgZmluaXNoaW5nLlxuICAgICAgICAgICAgZGhQYXJhbXMucmVtb3ZlQ2xhc3MoX2pzUGx1bWIuZW5kcG9pbnREcm9wQWxsb3dlZENsYXNzKTtcbiAgICAgICAgICAgIGRoUGFyYW1zLnJlbW92ZUNsYXNzKF9qc1BsdW1iLmVuZHBvaW50RHJvcEZvcmJpZGRlbkNsYXNzKTtcblxuICAgICAgICAgICAgdmFyIG9yaWdpbmFsRXZlbnQgPSBfanNQbHVtYi5nZXREcm9wRXZlbnQoYXJndW1lbnRzKSxcbiAgICAgICAgICAgICAgICBkcmFnZ2FibGUgPSBfanNQbHVtYi5nZXREcmFnT2JqZWN0KGFyZ3VtZW50cyksXG4gICAgICAgICAgICAgICAgaWQgPSBfanNQbHVtYi5nZXRBdHRyaWJ1dGUoZHJhZ2dhYmxlLCBcImRyYWdJZFwiKSxcbiAgICAgICAgICAgICAgICBlbElkID0gX2pzUGx1bWIuZ2V0QXR0cmlidXRlKGRyYWdnYWJsZSwgXCJlbElkXCIpLFxuICAgICAgICAgICAgICAgIHNjb3BlID0gX2pzUGx1bWIuZ2V0QXR0cmlidXRlKGRyYWdnYWJsZSwgXCJvcmlnaW5hbFNjb3BlXCIpLFxuICAgICAgICAgICAgICAgIGpwYyA9IF9qc1BsdW1iLmZsb2F0aW5nQ29ubmVjdGlvbnNbaWRdO1xuXG4gICAgICAgICAgICAvLyBpZiBubyBhY3RpdmUgY29ubmVjdGlvbiwgYmFpbC5cbiAgICAgICAgICAgIGlmIChqcGMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gY2FsY3VsYXRlIGlmIHRoaXMgaXMgYW4gZXhpc3RpbmcgY29ubmVjdGlvbi5cbiAgICAgICAgICAgIHZhciBleGlzdGluZ0Nvbm5lY3Rpb24gPSBqcGMuc3VzcGVuZGVkRW5kcG9pbnQgIT0gbnVsbDtcblxuICAgICAgICAgICAgLy8gaWYgc3VzcGVuZGVkIGVuZHBvaW50IGV4aXN0cyBidXQgaGFzIGJlZW4gY2xlYW5lZCB1cCwgYmFpbC4gVGhpcyBtZWFucyBpdCdzIGFuIGV4aXN0aW5nIGNvbm5lY3Rpb25cbiAgICAgICAgICAgIC8vIHRoYXQgaGFzIGJlZW4gZGV0YWNoZWQgYW5kIHdpbGwgc2hvcnRseSBiZSBkaXNjYXJkZWQuXG4gICAgICAgICAgICBpZiAoZXhpc3RpbmdDb25uZWN0aW9uICYmIGpwYy5zdXNwZW5kZWRFbmRwb2ludC5fanNQbHVtYiA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBnZXQgdGhlIGRyb3AgZW5kcG9pbnQuIGZvciBhIG5vcm1hbCBjb25uZWN0aW9uIHRoaXMgaXMganVzdCB0aGUgb25lIHRoYXQgd291bGQgcmVwbGFjZSB0aGUgY3VycmVudGx5XG4gICAgICAgICAgICAvLyBmbG9hdGluZyBlbmRwb2ludC4gZm9yIGEgbWFrZVRhcmdldCB0aGlzIGlzIGEgbmV3IGVuZHBvaW50IHRoYXQgaXMgY3JlYXRlZCBvbiBkcm9wLiBCdXQgd2UgbGVhdmUgdGhhdCB0b1xuICAgICAgICAgICAgLy8gdGhlIGhhbmRsZXIgdG8gZmlndXJlIG91dC5cbiAgICAgICAgICAgIHZhciBfZXAgPSBkaFBhcmFtcy5nZXRFbmRwb2ludChqcGMpO1xuXG4gICAgICAgICAgICAvLyBJZiB3ZSdyZSBub3QgZ2l2ZW4gYW4gZW5kcG9pbnQgdG8gdXNlLCBiYWlsLlxuICAgICAgICAgICAgaWYgKF9lcCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiB0aGlzIGlzIGEgZHJvcCBiYWNrIHdoZXJlIHRoZSBjb25uZWN0aW9uIGNhbWUgZnJvbSwgbWFyayBpdCBmb3JjZSByZWF0dGFjaCBhbmRcbiAgICAgICAgICAgIC8vIHJldHVybjsgdGhlIHN0b3AgaGFuZGxlciB3aWxsIHJlYXR0YWNoLiB3aXRob3V0IGZpcmluZyBhbiBldmVudC5cbiAgICAgICAgICAgIGlmIChkaFBhcmFtcy5pc1JlZHJvcChqcGMsIGRoUGFyYW1zKSkge1xuICAgICAgICAgICAgICAgIGpwYy5fZm9yY2VSZWF0dGFjaCA9IHRydWU7XG4gICAgICAgICAgICAgICAganBjLnNldEhvdmVyKGZhbHNlKTtcbiAgICAgICAgICAgICAgICBpZiAoZGhQYXJhbXMubWF5YmVDbGVhbnVwKSB7XG4gICAgICAgICAgICAgICAgICAgIGRoUGFyYW1zLm1heWJlQ2xlYW51cChfZXApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGVuc3VyZSB3ZSBkb250IGJvdGhlciB0cnlpbmcgdG8gZHJvcCBzb3VyY2VzIG9uIG5vbi1zb3VyY2UgZXBzLCBhbmQgc2FtZSBmb3IgdGFyZ2V0LlxuICAgICAgICAgICAgdmFyIGlkeCA9IF9qc1BsdW1iLmdldEZsb2F0aW5nQW5jaG9ySW5kZXgoanBjKTtcbiAgICAgICAgICAgIGlmICgoaWR4ID09PSAwICYmICFkaFBhcmFtcy5pc1NvdXJjZSl8fCAoaWR4ID09PSAxICYmICFkaFBhcmFtcy5pc1RhcmdldCkpe1xuICAgICAgICAgICAgICAgIGlmIChkaFBhcmFtcy5tYXliZUNsZWFudXApIHtcbiAgICAgICAgICAgICAgICAgICAgZGhQYXJhbXMubWF5YmVDbGVhbnVwKF9lcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRoUGFyYW1zLm9uRHJvcCkge1xuICAgICAgICAgICAgICAgIGRoUGFyYW1zLm9uRHJvcChqcGMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyByZXN0b3JlIHRoZSBvcmlnaW5hbCBzY29wZSBpZiBuZWNlc3NhcnkgKGlzc3VlIDU3KVxuICAgICAgICAgICAgaWYgKHNjb3BlKSB7XG4gICAgICAgICAgICAgICAgX2pzUGx1bWIuc2V0RHJhZ1Njb3BlKGRyYWdnYWJsZSwgc2NvcGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiB0aGUgdGFyZ2V0IG9mIHRoZSBkcm9wIGlzIGZ1bGwsIGZpcmUgYW4gZXZlbnQgKHdlIGFib3J0IGJlbG93KVxuICAgICAgICAgICAgLy8gbWFrZVRhcmdldDoga2VlcC5cbiAgICAgICAgICAgIHZhciBpc0Z1bGwgPSBkaFBhcmFtcy5pc0Z1bGwoZSk7XG4gICAgICAgICAgICBpZiAoaXNGdWxsKSB7XG4gICAgICAgICAgICAgICAgX2VwLmZpcmUoXCJtYXhDb25uZWN0aW9uc1wiLCB7XG4gICAgICAgICAgICAgICAgICAgIGVuZHBvaW50OiB0aGlzLFxuICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uOiBqcGMsXG4gICAgICAgICAgICAgICAgICAgIG1heENvbm5lY3Rpb25zOiBfZXAuX2pzUGx1bWIubWF4Q29ubmVjdGlvbnNcbiAgICAgICAgICAgICAgICB9LCBvcmlnaW5hbEV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBpZiBlbmRwb2ludCBlbmFibGVkLCBub3QgZnVsbCwgYW5kIG1hdGNoZXMgdGhlIGluZGV4IG9mIHRoZSBmbG9hdGluZyBlbmRwb2ludC4uLlxuICAgICAgICAgICAgaWYgKCFpc0Z1bGwgJiYgIGRoUGFyYW1zLmVuYWJsZWQoKSkge1xuICAgICAgICAgICAgICAgIHZhciBfZG9Db250aW51ZSA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAvLyBiZWZvcmUgdGVzdGluZyBmb3IgYmVmb3JlRHJvcCwgcmVzZXQgdGhlIGNvbm5lY3Rpb24ncyBzb3VyY2UvdGFyZ2V0IHRvIGJlIHRoZSBhY3R1YWwgRE9NIGVsZW1lbnRzXG4gICAgICAgICAgICAgICAgLy8gaW52b2x2ZWQgKHRoYXQgaXMsIHN0YXNoIGFueSB0ZW1wb3Jhcnkgc3R1ZmYgdXNlZCBmb3IgZHJhZ2dpbmcuIGJ1dCB3ZSBuZWVkIHRvIGtlZXAgaXQgYXJvdW5kIGluXG4gICAgICAgICAgICAgICAgLy8gb3JkZXIgdGhhdCB0aGUgYW5jaG9yIG1hbmFnZXIgY2FuIGNsZWFuIHRoaW5ncyB1cCBwcm9wZXJseSkuXG4gICAgICAgICAgICAgICAgaWYgKGlkeCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBqcGMuZmxvYXRpbmdFbGVtZW50ID0ganBjLnNvdXJjZTtcbiAgICAgICAgICAgICAgICAgICAganBjLmZsb2F0aW5nSWQgPSBqcGMuc291cmNlSWQ7XG4gICAgICAgICAgICAgICAgICAgIGpwYy5mbG9hdGluZ0VuZHBvaW50ID0ganBjLmVuZHBvaW50c1swXTtcbiAgICAgICAgICAgICAgICAgICAganBjLmZsb2F0aW5nSW5kZXggPSAwO1xuICAgICAgICAgICAgICAgICAgICBqcGMuc291cmNlID0gZGhQYXJhbXMuZWxlbWVudDtcbiAgICAgICAgICAgICAgICAgICAganBjLnNvdXJjZUlkID0gZGhQYXJhbXMuZWxlbWVudElkO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGpwYy5mbG9hdGluZ0VsZW1lbnQgPSBqcGMudGFyZ2V0O1xuICAgICAgICAgICAgICAgICAgICBqcGMuZmxvYXRpbmdJZCA9IGpwYy50YXJnZXRJZDtcbiAgICAgICAgICAgICAgICAgICAganBjLmZsb2F0aW5nRW5kcG9pbnQgPSBqcGMuZW5kcG9pbnRzWzFdO1xuICAgICAgICAgICAgICAgICAgICBqcGMuZmxvYXRpbmdJbmRleCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGpwYy50YXJnZXQgPSBkaFBhcmFtcy5lbGVtZW50O1xuICAgICAgICAgICAgICAgICAgICBqcGMudGFyZ2V0SWQgPSBkaFBhcmFtcy5lbGVtZW50SWQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhpcyBpcyBhbiBleGlzdGluZyBjb25uZWN0aW9uIGFuZCBkZXRhY2ggaXMgbm90IGFsbG93ZWQgd2Ugd29uJ3QgY29udGludWUuIFRoZSBjb25uZWN0aW9uJ3NcbiAgICAgICAgICAgICAgICAvLyBlbmRwb2ludHMgaGF2ZSBiZWVuIHJlaW5zdGF0ZWQ7IGV2ZXJ5dGhpbmcgaXMgYmFjayB0byBob3cgaXQgd2FzLlxuICAgICAgICAgICAgICAgIGlmIChleGlzdGluZ0Nvbm5lY3Rpb24gJiYganBjLnN1c3BlbmRlZEVuZHBvaW50LmlkICE9PSBfZXAuaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFqcGMuaXNEZXRhY2hBbGxvd2VkKGpwYykgfHwgIWpwYy5lbmRwb2ludHNbaWR4XS5pc0RldGFjaEFsbG93ZWQoanBjKSB8fCAhanBjLnN1c3BlbmRlZEVuZHBvaW50LmlzRGV0YWNoQWxsb3dlZChqcGMpIHx8ICFfanNQbHVtYi5jaGVja0NvbmRpdGlvbihcImJlZm9yZURldGFjaFwiLCBqcGMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfZG9Db250aW51ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4vLyAtLS0tLS0tLS0tLS0gd3JhcCB0aGUgZXhlY3V0aW9uIHBhdGggaW4gYSBmdW5jdGlvbiBzbyB3ZSBjYW4gc3VwcG9ydCBhc3luY2hyb25vdXMgYmVmb3JlRHJvcFxuXG4gICAgICAgICAgICAgICAgdmFyIGNvbnRpbnVlRnVuY3Rpb24gPSBmdW5jdGlvbiAob3B0aW9uYWxEYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSB0aGlzIGpwYyBmcm9tIHRoZSBjdXJyZW50IGVuZHBvaW50LCB3aGljaCBpcyBhIGZsb2F0aW5nIGVuZHBvaW50IHRoYXQgd2Ugd2lsbFxuICAgICAgICAgICAgICAgICAgICAvLyBzdWJzZXF1ZW50bHkgZGlzY2FyZC5cbiAgICAgICAgICAgICAgICAgICAganBjLmVuZHBvaW50c1tpZHhdLmRldGFjaEZyb21Db25uZWN0aW9uKGpwYyk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlcmUncyBhIHN1c3BlbmRlZCBlbmRwb2ludCwgZGV0YWNoIGl0IGZyb20gdGhlIGNvbm5lY3Rpb24uXG4gICAgICAgICAgICAgICAgICAgIGlmIChqcGMuc3VzcGVuZGVkRW5kcG9pbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGpwYy5zdXNwZW5kZWRFbmRwb2ludC5kZXRhY2hGcm9tQ29ubmVjdGlvbihqcGMpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAganBjLmVuZHBvaW50c1tpZHhdID0gX2VwO1xuICAgICAgICAgICAgICAgICAgICBfZXAuYWRkQ29ubmVjdGlvbihqcGMpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvcHkgb3VyIHBhcmFtZXRlcnMgaW4gdG8gdGhlIGNvbm5lY3Rpb246XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJhbXMgPSBfZXAuZ2V0UGFyYW1ldGVycygpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBhUGFyYW0gaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBqcGMuc2V0UGFyYW1ldGVyKGFQYXJhbSwgcGFyYW1zW2FQYXJhbV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFleGlzdGluZ0Nvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIG5vdCBhbiBleGlzdGluZyBjb25uZWN0aW9uIGFuZFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5kcmFnZ2FibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfanNQbHVtYi5pbml0RHJhZ2dhYmxlKHRoaXMuZWxlbWVudCwgZGhQYXJhbXMuZHJhZ09wdGlvbnMsIFwiaW50ZXJuYWxcIiwgX2pzUGx1bWIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN1c3BlbmRlZEVsZW1lbnRJZCA9IGpwYy5zdXNwZW5kZWRFbmRwb2ludC5lbGVtZW50SWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBfanNQbHVtYi5maXJlTW92ZUV2ZW50KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogaWR4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsU291cmNlSWQ6IGlkeCA9PT0gMCA/IHN1c3BlbmRlZEVsZW1lbnRJZCA6IGpwYy5zb3VyY2VJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdTb3VyY2VJZDogaWR4ID09PSAwID8gX2VwLmVsZW1lbnRJZCA6IGpwYy5zb3VyY2VJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbFRhcmdldElkOiBpZHggPT09IDEgPyBzdXNwZW5kZWRFbGVtZW50SWQgOiBqcGMudGFyZ2V0SWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3VGFyZ2V0SWQ6IGlkeCA9PT0gMSA/IF9lcC5lbGVtZW50SWQgOiBqcGMudGFyZ2V0SWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxTb3VyY2VFbmRwb2ludDogaWR4ID09PSAwID8ganBjLnN1c3BlbmRlZEVuZHBvaW50IDoganBjLmVuZHBvaW50c1swXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdTb3VyY2VFbmRwb2ludDogaWR4ID09PSAwID8gX2VwIDoganBjLmVuZHBvaW50c1swXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbFRhcmdldEVuZHBvaW50OiBpZHggPT09IDEgPyBqcGMuc3VzcGVuZGVkRW5kcG9pbnQgOiBqcGMuZW5kcG9pbnRzWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1RhcmdldEVuZHBvaW50OiBpZHggPT09IDEgPyBfZXAgOiBqcGMuZW5kcG9pbnRzWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb246IGpwY1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgb3JpZ2luYWxFdmVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoaWR4ID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfanNQbHVtYi5hbmNob3JNYW5hZ2VyLnVwZGF0ZU90aGVyRW5kcG9pbnQoanBjLnNvdXJjZUlkLCBqcGMuZmxvYXRpbmdJZCwganBjLnRhcmdldElkLCBqcGMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2pzUGx1bWIuYW5jaG9yTWFuYWdlci5zb3VyY2VDaGFuZ2VkKGpwYy5mbG9hdGluZ0lkLCBqcGMuc291cmNlSWQsIGpwYywganBjLnNvdXJjZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyB3aGVuIG1ha2VTb3VyY2UgaGFzIHVuaXF1ZUVuZHBvaW50OnRydWUsIHdlIHdhbnQgdG8gY3JlYXRlIGNvbm5lY3Rpb25zIHdpdGggbmV3IGVuZHBvaW50c1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGF0IGFyZSBzdWJzZXF1ZW50bHkgZGVsZXRlZC4gU28gbWFrZVNvdXJjZSBzZXRzIGBmaW5hbEVuZHBvaW50YCwgd2hpY2ggaXMgdGhlIEVuZHBvaW50IHRvXG4gICAgICAgICAgICAgICAgICAgIC8vIHdoaWNoIHRoZSBjb25uZWN0aW9uIHNob3VsZCBiZSBhdHRhY2hlZC4gVGhlIGBkZXRhY2hGcm9tQ29ubmVjdGlvbmAgY2FsbCBiZWxvdyByZXN1bHRzIGluIHRoZVxuICAgICAgICAgICAgICAgICAgICAvLyB0ZW1wb3JhcnkgZW5kcG9pbnQgYmVpbmcgY2xlYW5lZCB1cC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGpwYy5lbmRwb2ludHNbMF0uZmluYWxFbmRwb2ludCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF90b0RlbGV0ZSA9IGpwYy5lbmRwb2ludHNbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBfdG9EZWxldGUuZGV0YWNoRnJvbUNvbm5lY3Rpb24oanBjKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGpwYy5lbmRwb2ludHNbMF0gPSBqcGMuZW5kcG9pbnRzWzBdLmZpbmFsRW5kcG9pbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBqcGMuZW5kcG9pbnRzWzBdLmFkZENvbm5lY3Rpb24oanBjKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIG9wdGlvbmFsRGF0YSB3YXMgZ2l2ZW4sIG1lcmdlIGl0IG9udG8gdGhlIGNvbm5lY3Rpb24ncyBkYXRhLlxuICAgICAgICAgICAgICAgICAgICBpZiAoX2p1LmlzT2JqZWN0KG9wdGlvbmFsRGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGpwYy5tZXJnZURhdGEob3B0aW9uYWxEYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBmaW5hbGlzZSB3aWxsIGluZm9ybSB0aGUgYW5jaG9yIG1hbmFnZXIgYW5kIGFsc28gYWRkIHRvXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbm5lY3Rpb25zQnlTY29wZSBpZiBuZWNlc3NhcnkuXG4gICAgICAgICAgICAgICAgICAgIF9qc1BsdW1iLmZpbmFsaXNlQ29ubmVjdGlvbihqcGMsIG51bGwsIG9yaWdpbmFsRXZlbnQsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAganBjLnNldEhvdmVyKGZhbHNlKTtcblxuICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKTtcblxuICAgICAgICAgICAgICAgIHZhciBkb250Q29udGludWVGdW5jdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIGp1c3QgcHV0IGl0IGJhY2sgb24gdGhlIGVuZHBvaW50IGl0IHdhcyBvbiBiZWZvcmUgdGhlIGRyYWcuXG4gICAgICAgICAgICAgICAgICAgIGlmIChqcGMuc3VzcGVuZGVkRW5kcG9pbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGpwYy5lbmRwb2ludHNbaWR4XSA9IGpwYy5zdXNwZW5kZWRFbmRwb2ludDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGpwYy5zZXRIb3ZlcihmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBqcGMuX2ZvcmNlRGV0YWNoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpZHggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqcGMuc291cmNlID0ganBjLnN1c3BlbmRlZEVuZHBvaW50LmVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAganBjLnNvdXJjZUlkID0ganBjLnN1c3BlbmRlZEVuZHBvaW50LmVsZW1lbnRJZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAganBjLnRhcmdldCA9IGpwYy5zdXNwZW5kZWRFbmRwb2ludC5lbGVtZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpwYy50YXJnZXRJZCA9IGpwYy5zdXNwZW5kZWRFbmRwb2ludC5lbGVtZW50SWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBqcGMuc3VzcGVuZGVkRW5kcG9pbnQuYWRkQ29ubmVjdGlvbihqcGMpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIGNoZWNrU2FuaXR5XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaWR4ID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2pzUGx1bWIuYW5jaG9yTWFuYWdlci51cGRhdGVPdGhlckVuZHBvaW50KGpwYy5zb3VyY2VJZCwganBjLmZsb2F0aW5nSWQsIGpwYy50YXJnZXRJZCwganBjKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9qc1BsdW1iLmFuY2hvck1hbmFnZXIuc291cmNlQ2hhbmdlZChqcGMuZmxvYXRpbmdJZCwganBjLnNvdXJjZUlkLCBqcGMsIGpwYy5zb3VyY2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBfanNQbHVtYi5yZXBhaW50KGpwYy5zb3VyY2VJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBqcGMuX2ZvcmNlRGV0YWNoID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgICAgIC8vIG5vdyBjaGVjayBiZWZvcmVEcm9wLiAgdGhpcyB3aWxsIGJlIGF2YWlsYWJsZSBvbmx5IG9uIEVuZHBvaW50cyB0aGF0IGFyZSBzZXR1cCB0b1xuICAgICAgICAgICAgICAgIC8vIGhhdmUgYSBiZWZvcmVEcm9wIGNvbmRpdGlvbiAoYWx0aG91Z2gsIHNlY3JldGx5LCB1bmRlciB0aGUgaG9vZCBhbGwgRW5kcG9pbnRzIGFuZFxuICAgICAgICAgICAgICAgIC8vIHRoZSBDb25uZWN0aW9uIGhhdmUgdGhlbSwgYmVjYXVzZSB0aGV5IGFyZSBvbiBqc1BsdW1iVUlDb21wb25lbnQuICBzaGhoISksIGJlY2F1c2VcbiAgICAgICAgICAgICAgICAvLyBpdCBvbmx5IG1ha2VzIHNlbnNlIHRvIGhhdmUgaXQgb24gYSB0YXJnZXQgZW5kcG9pbnQuXG4gICAgICAgICAgICAgICAgX2RvQ29udGludWUgPSBfZG9Db250aW51ZSAmJiBkaFBhcmFtcy5pc0Ryb3BBbGxvd2VkKGpwYy5zb3VyY2VJZCwganBjLnRhcmdldElkLCBqcGMuc2NvcGUsIGpwYywgX2VwKTsvLyAmJiBqcGMucGVuZGluZztcblxuICAgICAgICAgICAgICAgIGlmIChfZG9Db250aW51ZSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZUZ1bmN0aW9uKF9kb0NvbnRpbnVlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkb250Q29udGludWVGdW5jdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRoUGFyYW1zLm1heWJlQ2xlYW51cCkge1xuICAgICAgICAgICAgICAgIGRoUGFyYW1zLm1heWJlQ2xlYW51cChfZXApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfanNQbHVtYi5jdXJyZW50bHlEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICB9O1xuICAgIH07XG59KS5jYWxsKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdGhpcyk7XG5cbi8qXG4gKiBqc1BsdW1iIENvbW11bml0eSBFZGl0aW9uXG4gKiBcbiAqIFByb3ZpZGVzIGEgd2F5IHRvIHZpc3VhbGx5IGNvbm5lY3QgZWxlbWVudHMgb24gYW4gSFRNTCBwYWdlLCB1c2luZyBTVkcuXG4gKiBcbiAqIFRoaXMgZmlsZSBjb250YWlucyB0aGUgY29kZSBmb3IgQ29ubmVjdGlvbnMuXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEwIC0gMjAxNyBqc1BsdW1iIChoZWxsb0Bqc3BsdW1idG9vbGtpdC5jb20pXG4gKiBcbiAqIGh0dHBzOi8vanNwbHVtYnRvb2xraXQuY29tXG4gKiBodHRwczovL2dpdGh1Yi5jb20vanNwbHVtYi9qc3BsdW1iXG4gKiBcbiAqIER1YWwgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBhbmQgR1BMMiBsaWNlbnNlcy5cbiAqL1xuO1xuKGZ1bmN0aW9uICgpIHtcblxuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciByb290ID0gdGhpcyxcbiAgICAgICAgX2pwID0gcm9vdC5qc1BsdW1iLFxuICAgICAgICBfanUgPSByb290LmpzUGx1bWJVdGlsO1xuXG4gICAgdmFyIG1ha2VDb25uZWN0b3IgPSBmdW5jdGlvbiAoX2pzUGx1bWIsIHJlbmRlck1vZGUsIGNvbm5lY3Rvck5hbWUsIGNvbm5lY3RvckFyZ3MsIGZvckNvbXBvbmVudCkge1xuICAgICAgICAgICAgaWYgKCFfanNQbHVtYi5EZWZhdWx0cy5Eb05vdFRocm93RXJyb3JzICYmIF9qcC5Db25uZWN0b3JzW3JlbmRlck1vZGVdW2Nvbm5lY3Rvck5hbWVdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB7IG1zZzogXCJqc1BsdW1iOiB1bmtub3duIGNvbm5lY3RvciB0eXBlICdcIiArIGNvbm5lY3Rvck5hbWUgKyBcIidcIiB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbmV3IF9qcC5Db25uZWN0b3JzW3JlbmRlck1vZGVdW2Nvbm5lY3Rvck5hbWVdKGNvbm5lY3RvckFyZ3MsIGZvckNvbXBvbmVudCk7XG4gICAgICAgIH0sXG4gICAgICAgIF9tYWtlQW5jaG9yID0gZnVuY3Rpb24gKGFuY2hvclBhcmFtcywgZWxlbWVudElkLCBfanNQbHVtYikge1xuICAgICAgICAgICAgcmV0dXJuIChhbmNob3JQYXJhbXMpID8gX2pzUGx1bWIubWFrZUFuY2hvcihhbmNob3JQYXJhbXMsIGVsZW1lbnRJZCwgX2pzUGx1bWIpIDogbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgX3VwZGF0ZUNvbm5lY3RlZENsYXNzID0gZnVuY3Rpb24gKGNvbm4sIGVsZW1lbnQsIF9qc1BsdW1iLCByZW1vdmUpIHtcbiAgICAgICAgICAgIGlmIChlbGVtZW50ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50Ll9qc1BsdW1iQ29ubmVjdGlvbnMgPSBlbGVtZW50Ll9qc1BsdW1iQ29ubmVjdGlvbnMgfHwge307XG4gICAgICAgICAgICAgICAgaWYgKHJlbW92ZSkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgZWxlbWVudC5fanNQbHVtYkNvbm5lY3Rpb25zW2Nvbm4uaWRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5fanNQbHVtYkNvbm5lY3Rpb25zW2Nvbm4uaWRdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoX2p1LmlzRW1wdHkoZWxlbWVudC5fanNQbHVtYkNvbm5lY3Rpb25zKSkge1xuICAgICAgICAgICAgICAgICAgICBfanNQbHVtYi5yZW1vdmVDbGFzcyhlbGVtZW50LCBfanNQbHVtYi5jb25uZWN0ZWRDbGFzcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBfanNQbHVtYi5hZGRDbGFzcyhlbGVtZW50LCBfanNQbHVtYi5jb25uZWN0ZWRDbGFzcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgX2pwLkNvbm5lY3Rpb24gPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgIHZhciBfbmV3RW5kcG9pbnQgPSBwYXJhbXMubmV3RW5kcG9pbnQ7XG5cbiAgICAgICAgdGhpcy5pZCA9IHBhcmFtcy5pZDtcbiAgICAgICAgdGhpcy5jb25uZWN0b3IgPSBudWxsO1xuICAgICAgICB0aGlzLmlkUHJlZml4ID0gXCJfanNwbHVtYl9jX1wiO1xuICAgICAgICB0aGlzLmRlZmF1bHRMYWJlbExvY2F0aW9uID0gMC41O1xuICAgICAgICB0aGlzLmRlZmF1bHRPdmVybGF5S2V5cyA9IFtcIk92ZXJsYXlzXCIsIFwiQ29ubmVjdGlvbk92ZXJsYXlzXCJdO1xuICAgICAgICAvLyBpZiBhIG5ldyBjb25uZWN0aW9uIGlzIHRoZSByZXN1bHQgb2YgbW92aW5nIHNvbWUgZXhpc3RpbmcgY29ubmVjdGlvbiwgcGFyYW1zLnByZXZpb3VzQ29ubmVjdGlvblxuICAgICAgICAvLyB3aWxsIGhhdmUgdGhhdCBDb25uZWN0aW9uIGluIGl0LiBsaXN0ZW5lcnMgZm9yIHRoZSBqc1BsdW1iQ29ubmVjdGlvbiBldmVudCBjYW4gbG9vayBmb3IgdGhhdFxuICAgICAgICAvLyBtZW1iZXIgYW5kIHRha2UgYWN0aW9uIGlmIHRoZXkgbmVlZCB0by5cbiAgICAgICAgdGhpcy5wcmV2aW91c0Nvbm5lY3Rpb24gPSBwYXJhbXMucHJldmlvdXNDb25uZWN0aW9uO1xuICAgICAgICB0aGlzLnNvdXJjZSA9IF9qcC5nZXRFbGVtZW50KHBhcmFtcy5zb3VyY2UpO1xuICAgICAgICB0aGlzLnRhcmdldCA9IF9qcC5nZXRFbGVtZW50KHBhcmFtcy50YXJnZXQpO1xuICAgICAgICAvLyBzb3VyY2VFbmRwb2ludCBhbmQgdGFyZ2V0RW5kcG9pbnQgb3ZlcnJpZGUgc291cmNlL3RhcmdldCwgaWYgdGhleSBhcmUgcHJlc2VudC4gYnV0IFxuICAgICAgICAvLyBzb3VyY2UgaXMgbm90IG92ZXJyaWRkZW4gaWYgdGhlIEVuZHBvaW50IGhhcyBkZWNsYXJlZCBpdCBpcyBub3QgdGhlIGZpbmFsIHRhcmdldCBvZiBhIGNvbm5lY3Rpb247XG4gICAgICAgIC8vIGluc3RlYWQgd2UgdXNlIHRoZSBzb3VyY2UgdGhhdCB0aGUgRW5kcG9pbnQgZGVjbGFyZXMgd2lsbCBiZSB0aGUgZmluYWwgc291cmNlIGVsZW1lbnQuXG4gICAgICAgIGlmIChwYXJhbXMuc291cmNlRW5kcG9pbnQpIHtcbiAgICAgICAgICAgIHRoaXMuc291cmNlID0gcGFyYW1zLnNvdXJjZUVuZHBvaW50LmdldEVsZW1lbnQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyYW1zLnRhcmdldEVuZHBvaW50KSB7XG4gICAgICAgICAgICB0aGlzLnRhcmdldCA9IHBhcmFtcy50YXJnZXRFbmRwb2ludC5nZXRFbGVtZW50KCk7XG4gICAgICAgIH1cblxuICAgICAgICBfanAuT3ZlcmxheUNhcGFibGVKc1BsdW1iVUlDb21wb25lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgICAgICB0aGlzLnNvdXJjZUlkID0gdGhpcy5fanNQbHVtYi5pbnN0YW5jZS5nZXRJZCh0aGlzLnNvdXJjZSk7XG4gICAgICAgIHRoaXMudGFyZ2V0SWQgPSB0aGlzLl9qc1BsdW1iLmluc3RhbmNlLmdldElkKHRoaXMudGFyZ2V0KTtcbiAgICAgICAgdGhpcy5zY29wZSA9IHBhcmFtcy5zY29wZTsgLy8gc2NvcGUgbWF5IGhhdmUgYmVlbiBwYXNzZWQgaW4gdG8gdGhlIGNvbm5lY3QgY2FsbC4gaWYgaXQgd2Fzbid0LCB3ZSB3aWxsIHB1bGwgaXQgZnJvbSB0aGUgc291cmNlIGVuZHBvaW50LCBhZnRlciBoYXZpbmcgaW5pdGlhbGlzZWQgdGhlIGVuZHBvaW50cy4gICAgICAgICAgICBcbiAgICAgICAgdGhpcy5lbmRwb2ludHMgPSBbXTtcbiAgICAgICAgdGhpcy5lbmRwb2ludFN0eWxlcyA9IFtdO1xuXG4gICAgICAgIHZhciBfanNQbHVtYiA9IHRoaXMuX2pzUGx1bWIuaW5zdGFuY2U7XG5cbiAgICAgICAgX2pzUGx1bWIubWFuYWdlKHRoaXMuc291cmNlSWQsIHRoaXMuc291cmNlKTtcbiAgICAgICAgX2pzUGx1bWIubWFuYWdlKHRoaXMudGFyZ2V0SWQsIHRoaXMudGFyZ2V0KTtcblxuICAgICAgICB0aGlzLl9qc1BsdW1iLnZpc2libGUgPSB0cnVlO1xuICAgICAgICB0aGlzLl9qc1BsdW1iLmVkaXRhYmxlID0gcGFyYW1zLmVkaXRhYmxlID09PSB0cnVlO1xuICAgICAgICB0aGlzLl9qc1BsdW1iLnBhcmFtcyA9IHtcbiAgICAgICAgICAgIGNzc0NsYXNzOiBwYXJhbXMuY3NzQ2xhc3MsXG4gICAgICAgICAgICBjb250YWluZXI6IHBhcmFtcy5jb250YWluZXIsXG4gICAgICAgICAgICBcInBvaW50ZXItZXZlbnRzXCI6IHBhcmFtc1tcInBvaW50ZXItZXZlbnRzXCJdLFxuICAgICAgICAgICAgZWRpdG9yUGFyYW1zOiBwYXJhbXMuZWRpdG9yUGFyYW1zLFxuICAgICAgICAgICAgb3ZlcmxheXM6IHBhcmFtcy5vdmVybGF5c1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9qc1BsdW1iLmxhc3RQYWludGVkQXQgPSBudWxsO1xuXG4gICAgICAgIC8vIGxpc3RlbiB0byBtb3VzZW92ZXIgYW5kIG1vdXNlb3V0IGV2ZW50cyBwYXNzZWQgZnJvbSB0aGUgY29udGFpbmVyIGRlbGVnYXRlLlxuICAgICAgICB0aGlzLmJpbmQoXCJtb3VzZW92ZXJcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5zZXRIb3Zlcih0cnVlKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5iaW5kKFwibW91c2VvdXRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5zZXRIb3ZlcihmYWxzZSk7XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICAgICAgdGhpcy5lZGl0YWJsZVJlcXVlc3RlZCA9IHBhcmFtcy5lZGl0YWJsZSAhPT0gZmFsc2U7XG4gICAgICAgIHRoaXMuc2V0RWRpdGFibGUgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0b3IgPyB0aGlzLmNvbm5lY3Rvci5zZXRFZGl0YWJsZShlKSA6IGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmlzRWRpdGFibGUgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuY29ubmVjdG9yID8gdGhpcy5jb25uZWN0b3IuaXNFZGl0YWJsZSgpIDogZmFsc2U7IH07XG4gICAgICAgIHRoaXMuaXNFZGl0aW5nID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmNvbm5lY3RvciA/IHRoaXMuY29ubmVjdG9yLmlzRWRpdGluZygpIDogZmFsc2U7IH07XG5cbi8vIElOSVRJQUxJU0FUSU9OIENPREVcblxuICAgICAgICB0aGlzLm1ha2VFbmRwb2ludCA9IGZ1bmN0aW9uIChpc1NvdXJjZSwgZWwsIGVsSWQsIGVwKSB7XG4gICAgICAgICAgICBlbElkID0gZWxJZCB8fCB0aGlzLl9qc1BsdW1iLmluc3RhbmNlLmdldElkKGVsKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByZXBhcmVFbmRwb2ludChfanNQbHVtYiwgX25ld0VuZHBvaW50LCB0aGlzLCBlcCwgaXNTb3VyY2UgPyAwIDogMSwgcGFyYW1zLCBlbCwgZWxJZCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gaWYgdHlwZSBnaXZlbiwgZ2V0IHRoZSBlbmRwb2ludCBkZWZpbml0aW9ucyBtYXBwaW5nIHRvIHRoYXQgdHlwZSBmcm9tIHRoZSBqc3BsdW1iIGluc3RhbmNlLCBhbmQgdXNlIHRob3NlLlxuICAgICAgICAvLyB3ZSBhcHBseSB0eXBlcyBhdCB0aGUgZW5kIG9mIHRoaXMgY29uc3RydWN0b3IgYnV0IGVuZHBvaW50cyBhcmUgb25seSBob25vdXJlZCBpbiBhIHR5cGUgZGVmaW5pdGlvbiBhdFxuICAgICAgICAvLyBjcmVhdGUgdGltZS5cbiAgICAgICAgaWYgKHBhcmFtcy50eXBlKSB7XG4gICAgICAgICAgICBwYXJhbXMuZW5kcG9pbnRzID0gcGFyYW1zLmVuZHBvaW50cyB8fCB0aGlzLl9qc1BsdW1iLmluc3RhbmNlLmRlcml2ZUVuZHBvaW50QW5kQW5jaG9yU3BlYyhwYXJhbXMudHlwZSkuZW5kcG9pbnRzO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGVTID0gdGhpcy5tYWtlRW5kcG9pbnQodHJ1ZSwgdGhpcy5zb3VyY2UsIHRoaXMuc291cmNlSWQsIHBhcmFtcy5zb3VyY2VFbmRwb2ludCksXG4gICAgICAgICAgICBlVCA9IHRoaXMubWFrZUVuZHBvaW50KGZhbHNlLCB0aGlzLnRhcmdldCwgdGhpcy50YXJnZXRJZCwgcGFyYW1zLnRhcmdldEVuZHBvaW50KTtcblxuICAgICAgICBpZiAoZVMpIHtcbiAgICAgICAgICAgIF9qdS5hZGRUb0xpc3QocGFyYW1zLmVuZHBvaW50c0J5RWxlbWVudCwgdGhpcy5zb3VyY2VJZCwgZVMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlVCkge1xuICAgICAgICAgICAgX2p1LmFkZFRvTGlzdChwYXJhbXMuZW5kcG9pbnRzQnlFbGVtZW50LCB0aGlzLnRhcmdldElkLCBlVCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgc2NvcGUgbm90IHNldCwgc2V0IGl0IHRvIGJlIHRoZSBzY29wZSBmb3IgdGhlIHNvdXJjZSBlbmRwb2ludC5cbiAgICAgICAgaWYgKCF0aGlzLnNjb3BlKSB7XG4gICAgICAgICAgICB0aGlzLnNjb3BlID0gdGhpcy5lbmRwb2ludHNbMF0uc2NvcGU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiBleHBsaWNpdGx5IHRvbGQgdG8gKG9yIG5vdCB0bykgZGVsZXRlIGVuZHBvaW50cyB3aGVuIGVtcHR5LCBvdmVycmlkZSBlbmRwb2ludCdzIHByZWZlcmVuY2VzXG4gICAgICAgIGlmIChwYXJhbXMuZGVsZXRlRW5kcG9pbnRzT25FbXB0eSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmVuZHBvaW50c1swXS5zZXREZWxldGVPbkVtcHR5KHBhcmFtcy5kZWxldGVFbmRwb2ludHNPbkVtcHR5KTtcbiAgICAgICAgICAgIHRoaXMuZW5kcG9pbnRzWzFdLnNldERlbGV0ZU9uRW1wdHkocGFyYW1zLmRlbGV0ZUVuZHBvaW50c09uRW1wdHkpO1xuICAgICAgICB9XG4vLyAgICAgICAgZWxzZSB7XG4vLyAgICAgICAgICAgIC8vIG90aGVyd2lzZSwgdW5sZXNzIHRoZSBlbmRwb2ludHMgc2F5IG90aGVyd2lzZSwgbWFyayB0aGVtIGZvciBkZWxldGlvbi5cbi8vICAgICAgICAgICAgaWYgKCF0aGlzLmVuZHBvaW50c1swXS5fZG9Ob3REZWxldGVPbkRldGFjaCkgdGhpcy5lbmRwb2ludHNbMF0uX2RlbGV0ZU9uRGV0YWNoID0gdHJ1ZTtcbi8vICAgICAgICAgICAgaWYgKCF0aGlzLmVuZHBvaW50c1sxXS5fZG9Ob3REZWxldGVPbkRldGFjaCkgdGhpcy5lbmRwb2ludHNbMV0uX2RlbGV0ZU9uRGV0YWNoID0gdHJ1ZTtcbi8vICAgICAgICB9XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIERFRkFVTFQgVFlQRSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICAvLyBERVRBQ0hBQkxFXG4gICAgICAgIHZhciBfZGV0YWNoYWJsZSA9IF9qc1BsdW1iLkRlZmF1bHRzLkNvbm5lY3Rpb25zRGV0YWNoYWJsZTtcbiAgICAgICAgaWYgKHBhcmFtcy5kZXRhY2hhYmxlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgX2RldGFjaGFibGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5lbmRwb2ludHNbMF0uY29ubmVjdGlvbnNEZXRhY2hhYmxlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgX2RldGFjaGFibGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5lbmRwb2ludHNbMV0uY29ubmVjdGlvbnNEZXRhY2hhYmxlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgX2RldGFjaGFibGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSRUFUVEFDSFxuICAgICAgICB2YXIgX3JlYXR0YWNoID0gcGFyYW1zLnJlYXR0YWNoIHx8IHRoaXMuZW5kcG9pbnRzWzBdLnJlYXR0YWNoQ29ubmVjdGlvbnMgfHwgdGhpcy5lbmRwb2ludHNbMV0ucmVhdHRhY2hDb25uZWN0aW9ucyB8fCBfanNQbHVtYi5EZWZhdWx0cy5SZWF0dGFjaENvbm5lY3Rpb25zO1xuXG4gICAgICAgIHRoaXMuYXBwZW5kVG9EZWZhdWx0VHlwZSh7XG4gICAgICAgICAgICBkZXRhY2hhYmxlOiBfZGV0YWNoYWJsZSxcbiAgICAgICAgICAgIHJlYXR0YWNoOiBfcmVhdHRhY2gsXG4gICAgICAgICAgICBwYWludFN0eWxlOnRoaXMuZW5kcG9pbnRzWzBdLmNvbm5lY3RvclN0eWxlIHx8IHRoaXMuZW5kcG9pbnRzWzFdLmNvbm5lY3RvclN0eWxlIHx8IHBhcmFtcy5wYWludFN0eWxlIHx8IF9qc1BsdW1iLkRlZmF1bHRzLlBhaW50U3R5bGUgfHwgX2pwLkRlZmF1bHRzLlBhaW50U3R5bGUsXG4gICAgICAgICAgICBob3ZlclBhaW50U3R5bGU6dGhpcy5lbmRwb2ludHNbMF0uY29ubmVjdG9ySG92ZXJTdHlsZSB8fCB0aGlzLmVuZHBvaW50c1sxXS5jb25uZWN0b3JIb3ZlclN0eWxlIHx8IHBhcmFtcy5ob3ZlclBhaW50U3R5bGUgfHwgX2pzUGx1bWIuRGVmYXVsdHMuSG92ZXJQYWludFN0eWxlIHx8IF9qcC5EZWZhdWx0cy5Ib3ZlclBhaW50U3R5bGVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIF9zdXNwZW5kZWRBdCA9IF9qc1BsdW1iLmdldFN1c3BlbmRlZEF0KCk7XG4gICAgICAgIGlmICghX2pzUGx1bWIuaXNTdXNwZW5kRHJhd2luZygpKSB7XG4gICAgICAgICAgICAvLyBwYWludCB0aGUgZW5kcG9pbnRzXG4gICAgICAgICAgICB2YXIgbXlJbmZvID0gX2pzUGx1bWIuZ2V0Q2FjaGVkRGF0YSh0aGlzLnNvdXJjZUlkKSxcbiAgICAgICAgICAgICAgICBteU9mZnNldCA9IG15SW5mby5vLCBteVdIID0gbXlJbmZvLnMsXG4gICAgICAgICAgICAgICAgb3RoZXJJbmZvID0gX2pzUGx1bWIuZ2V0Q2FjaGVkRGF0YSh0aGlzLnRhcmdldElkKSxcbiAgICAgICAgICAgICAgICBvdGhlck9mZnNldCA9IG90aGVySW5mby5vLFxuICAgICAgICAgICAgICAgIG90aGVyV0ggPSBvdGhlckluZm8ucyxcbiAgICAgICAgICAgICAgICBpbml0aWFsVGltZXN0YW1wID0gX3N1c3BlbmRlZEF0IHx8IF9qc1BsdW1iLnRpbWVzdGFtcCgpLFxuICAgICAgICAgICAgICAgIGFuY2hvckxvYyA9IHRoaXMuZW5kcG9pbnRzWzBdLmFuY2hvci5jb21wdXRlKHtcbiAgICAgICAgICAgICAgICAgICAgeHk6IFsgbXlPZmZzZXQubGVmdCwgbXlPZmZzZXQudG9wIF0sIHdoOiBteVdILCBlbGVtZW50OiB0aGlzLmVuZHBvaW50c1swXSxcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudElkOiB0aGlzLmVuZHBvaW50c1swXS5lbGVtZW50SWQsXG4gICAgICAgICAgICAgICAgICAgIHR4eTogWyBvdGhlck9mZnNldC5sZWZ0LCBvdGhlck9mZnNldC50b3AgXSwgdHdoOiBvdGhlcldILCB0RWxlbWVudDogdGhpcy5lbmRwb2ludHNbMV0sXG4gICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogaW5pdGlhbFRpbWVzdGFtcFxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB0aGlzLmVuZHBvaW50c1swXS5wYWludCh7IGFuY2hvckxvYzogYW5jaG9yTG9jLCB0aW1lc3RhbXA6IGluaXRpYWxUaW1lc3RhbXAgfSk7XG5cbiAgICAgICAgICAgIGFuY2hvckxvYyA9IHRoaXMuZW5kcG9pbnRzWzFdLmFuY2hvci5jb21wdXRlKHtcbiAgICAgICAgICAgICAgICB4eTogWyBvdGhlck9mZnNldC5sZWZ0LCBvdGhlck9mZnNldC50b3AgXSwgd2g6IG90aGVyV0gsIGVsZW1lbnQ6IHRoaXMuZW5kcG9pbnRzWzFdLFxuICAgICAgICAgICAgICAgIGVsZW1lbnRJZDogdGhpcy5lbmRwb2ludHNbMV0uZWxlbWVudElkLFxuICAgICAgICAgICAgICAgIHR4eTogWyBteU9mZnNldC5sZWZ0LCBteU9mZnNldC50b3AgXSwgdHdoOiBteVdILCB0RWxlbWVudDogdGhpcy5lbmRwb2ludHNbMF0sXG4gICAgICAgICAgICAgICAgdGltZXN0YW1wOiBpbml0aWFsVGltZXN0YW1wXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuZW5kcG9pbnRzWzFdLnBhaW50KHsgYW5jaG9yTG9jOiBhbmNob3JMb2MsIHRpbWVzdGFtcDogaW5pdGlhbFRpbWVzdGFtcCB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZ2V0VHlwZURlc2NyaXB0b3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJjb25uZWN0aW9uXCI7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ2V0QXR0YWNoZWRFbGVtZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVuZHBvaW50cztcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmlzRGV0YWNoYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9qc1BsdW1iLmRldGFjaGFibGUgPT09IHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc2V0RGV0YWNoYWJsZSA9IGZ1bmN0aW9uIChkZXRhY2hhYmxlKSB7XG4gICAgICAgICAgICB0aGlzLl9qc1BsdW1iLmRldGFjaGFibGUgPSBkZXRhY2hhYmxlID09PSB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmlzUmVhdHRhY2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fanNQbHVtYi5yZWF0dGFjaCA9PT0gdHJ1ZSB8fCB0aGlzLmVuZHBvaW50c1swXS5yZWF0dGFjaENvbm5lY3Rpb25zID09PSB0cnVlIHx8IHRoaXMuZW5kcG9pbnRzWzFdLnJlYXR0YWNoQ29ubmVjdGlvbnMgPT09IHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc2V0UmVhdHRhY2ggPSBmdW5jdGlvbiAocmVhdHRhY2gpIHtcbiAgICAgICAgICAgIHRoaXMuX2pzUGx1bWIucmVhdHRhY2ggPSByZWF0dGFjaCA9PT0gdHJ1ZTtcbiAgICAgICAgfTtcblxuLy8gICAgICAgIHRoaXNbXCJkZWxldGVcIl0gPSBmdW5jdGlvbigpIHtcbi8vICAgICAgICAgICAgdGhpcy5lbmRwb2ludHNbMF0uZGV0YWNoRnJvbUNvbm5lY3Rpb24odGhpcyk7XG4vLyAgICAgICAgICAgIHRoaXMuZW5kcG9pbnRzWzFdLmRldGFjaEZyb21Db25uZWN0aW9uKHRoaXMpO1xuLy8gICAgICAgICAgICBwYXJhbXMuZGVsZXRlQ29ubmVjdGlvbih0aGlzKTtcbi8vICAgICAgICB9O1xuXG4vLyBFTkQgSU5JVElBTElTQVRJT04gQ09ERVxuXG5cbi8vIENPU1QgKyBESVJFQ1RJT05BTElUWVxuICAgICAgICAvLyBpZiBjb3N0IG5vdCBzdXBwbGllZCwgdHJ5IHRvIGluaGVyaXQgZnJvbSBzb3VyY2UgZW5kcG9pbnRcbiAgICAgICAgdGhpcy5fanNQbHVtYi5jb3N0ID0gcGFyYW1zLmNvc3QgfHwgdGhpcy5lbmRwb2ludHNbMF0uZ2V0Q29ubmVjdGlvbkNvc3QoKTtcbiAgICAgICAgdGhpcy5fanNQbHVtYi5kaXJlY3RlZCA9IHBhcmFtcy5kaXJlY3RlZDtcbiAgICAgICAgLy8gaW5oZXJpdCBkaXJlY3RlZCBmbGFnIGlmIHNldCBubyBzb3VyY2UgZW5kcG9pbnRcbiAgICAgICAgaWYgKHBhcmFtcy5kaXJlY3RlZCA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9qc1BsdW1iLmRpcmVjdGVkID0gdGhpcy5lbmRwb2ludHNbMF0uYXJlQ29ubmVjdGlvbnNEaXJlY3RlZCgpO1xuICAgICAgICB9XG4vLyBFTkQgQ09TVCArIERJUkVDVElPTkFMSVRZXG5cbi8vIFBBUkFNRVRFUlNcbiAgICAgICAgLy8gbWVyZ2UgYWxsIHRoZSBwYXJhbWV0ZXJzIG9iamVjdHMgaW50byB0aGUgY29ubmVjdGlvbi4gIHBhcmFtZXRlcnMgc2V0XG4gICAgICAgIC8vIG9uIHRoZSBjb25uZWN0aW9uIHRha2UgcHJlY2VkZW5jZTsgdGhlbiBzb3VyY2UgZW5kcG9pbnQgcGFyYW1zLCB0aGVuXG4gICAgICAgIC8vIGZpbmFsbHkgdGFyZ2V0IGVuZHBvaW50IHBhcmFtcy5cbiAgICAgICAgdmFyIF9wID0gX2pwLmV4dGVuZCh7fSwgdGhpcy5lbmRwb2ludHNbMV0uZ2V0UGFyYW1ldGVycygpKTtcbiAgICAgICAgX2pwLmV4dGVuZChfcCwgdGhpcy5lbmRwb2ludHNbMF0uZ2V0UGFyYW1ldGVycygpKTtcbiAgICAgICAgX2pwLmV4dGVuZChfcCwgdGhpcy5nZXRQYXJhbWV0ZXJzKCkpO1xuICAgICAgICB0aGlzLnNldFBhcmFtZXRlcnMoX3ApO1xuLy8gRU5EIFBBUkFNRVRFUlNcblxuLy8gUEFJTlRJTkdcblxuICAgICAgICB0aGlzLnNldENvbm5lY3Rvcih0aGlzLmVuZHBvaW50c1swXS5jb25uZWN0b3IgfHwgdGhpcy5lbmRwb2ludHNbMV0uY29ubmVjdG9yIHx8IHBhcmFtcy5jb25uZWN0b3IgfHwgX2pzUGx1bWIuRGVmYXVsdHMuQ29ubmVjdG9yIHx8IF9qcC5EZWZhdWx0cy5Db25uZWN0b3IsIHRydWUpO1xuICAgICAgICBpZiAocGFyYW1zLmdlb21ldHJ5KSB7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rvci5zZXRHZW9tZXRyeShwYXJhbXMuZ2VvbWV0cnkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkYXRhID0gcGFyYW1zLmRhdGEgPT0gbnVsbCB8fCAhX2p1LmlzT2JqZWN0KHBhcmFtcy5kYXRhKSA/IHt9IDogcGFyYW1zLmRhdGE7XG4gICAgICAgIHRoaXMuZ2V0RGF0YSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gZGF0YTsgfTtcbiAgICAgICAgdGhpcy5zZXREYXRhID0gZnVuY3Rpb24oZCkgeyBkYXRhID0gZCB8fCB7fTsgfTtcbiAgICAgICAgdGhpcy5tZXJnZURhdGEgPSBmdW5jdGlvbihkKSB7IGRhdGEgPSBfanAuZXh0ZW5kKGRhdGEsIGQpOyB9O1xuXG4gICAgICAgIC8vIHRoZSB2ZXJ5IGxhc3QgdGhpbmcgd2UgZG8gaXMgYXBwbHkgdHlwZXMsIGlmIHRoZXJlIGFyZSBhbnkuXG4gICAgICAgIHZhciBfdHlwZXMgPSBbIFwiZGVmYXVsdFwiLCB0aGlzLmVuZHBvaW50c1swXS5jb25uZWN0aW9uVHlwZSwgdGhpcy5lbmRwb2ludHNbMV0uY29ubmVjdGlvblR5cGUsICBwYXJhbXMudHlwZSBdLmpvaW4oXCIgXCIpO1xuICAgICAgICBpZiAoL1teXFxzXS8udGVzdChfdHlwZXMpKSB7XG4gICAgICAgICAgICB0aGlzLmFkZFR5cGUoX3R5cGVzLCBwYXJhbXMuZGF0YSwgdHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnVwZGF0ZUNvbm5lY3RlZENsYXNzKCk7XG5cbi8vIEVORCBQQUlOVElORyAgICBcbiAgICB9O1xuXG4gICAgX2p1LmV4dGVuZChfanAuQ29ubmVjdGlvbiwgX2pwLk92ZXJsYXlDYXBhYmxlSnNQbHVtYlVJQ29tcG9uZW50LCB7XG4gICAgICAgIGFwcGx5VHlwZTogZnVuY3Rpb24gKHQsIGRvTm90UmVwYWludCwgdHlwZU1hcCkge1xuXG4gICAgICAgICAgICAvLyBub25lIG9mIHRoZXNlIHRoaW5ncyByZXN1bHQgaW4gdGhlIGNyZWF0aW9uIG9mIG9iamVjdHMgc28gY2FuIGJlIGlnbm9yZWQuXG4gICAgICAgICAgICBpZiAodC5kZXRhY2hhYmxlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldERldGFjaGFibGUodC5kZXRhY2hhYmxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0LnJlYXR0YWNoICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFJlYXR0YWNoKHQucmVhdHRhY2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHQuc2NvcGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNjb3BlID0gdC5zY29wZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHQuY3NzQ2xhc3MgIT0gbnVsbCAmJiB0aGlzLmNhbnZhcykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2pzUGx1bWIuaW5zdGFuY2UuYWRkQ2xhc3ModGhpcy5jYW52YXMsIHQuY3NzQ2xhc3MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgX2FuY2hvcnMgPSBudWxsO1xuICAgICAgICAgICAgLy8gdGhpcyBhbHNvIHJlc3VsdHMgaW4gdGhlIGNyZWF0aW9uIG9mIG9iamVjdHMuXG4gICAgICAgICAgICBpZiAodC5hbmNob3IpIHtcbiAgICAgICAgICAgICAgICAvLyBub3RlIHRoYXQgZXZlbiBpZiB0aGUgcGFyYW0gd2FzIGFuY2hvciwgd2Ugc3RvcmUgYGFuY2hvcnNgLlxuICAgICAgICAgICAgICAgIF9hbmNob3JzID0gdGhpcy5nZXRDYWNoZWRUeXBlSXRlbShcImFuY2hvcnNcIiwgdHlwZU1hcC5hbmNob3IpO1xuICAgICAgICAgICAgICAgIGlmIChfYW5jaG9ycyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIF9hbmNob3JzID0gWyB0aGlzLl9qc1BsdW1iLmluc3RhbmNlLm1ha2VBbmNob3IodC5hbmNob3IpLCB0aGlzLl9qc1BsdW1iLmluc3RhbmNlLm1ha2VBbmNob3IodC5hbmNob3IpIF07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FjaGVUeXBlSXRlbShcImFuY2hvcnNcIiwgX2FuY2hvcnMsIHR5cGVNYXAuYW5jaG9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0LmFuY2hvcnMpIHtcbiAgICAgICAgICAgICAgICBfYW5jaG9ycyA9IHRoaXMuZ2V0Q2FjaGVkVHlwZUl0ZW0oXCJhbmNob3JzXCIsIHR5cGVNYXAuYW5jaG9ycyk7XG4gICAgICAgICAgICAgICAgaWYgKF9hbmNob3JzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgX2FuY2hvcnMgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9qc1BsdW1iLmluc3RhbmNlLm1ha2VBbmNob3IodC5hbmNob3JzWzBdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2pzUGx1bWIuaW5zdGFuY2UubWFrZUFuY2hvcih0LmFuY2hvcnNbMV0pXG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FjaGVUeXBlSXRlbShcImFuY2hvcnNcIiwgX2FuY2hvcnMsIHR5cGVNYXAuYW5jaG9ycyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKF9hbmNob3JzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVuZHBvaW50c1swXS5hbmNob3IgPSBfYW5jaG9yc1swXTtcbiAgICAgICAgICAgICAgICB0aGlzLmVuZHBvaW50c1sxXS5hbmNob3IgPSBfYW5jaG9yc1sxXTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5lbmRwb2ludHNbMV0uYW5jaG9yLmlzRHluYW1pYykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9qc1BsdW1iLmluc3RhbmNlLnJlcGFpbnQodGhpcy5lbmRwb2ludHNbMV0uZWxlbWVudElkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9qcC5PdmVybGF5Q2FwYWJsZUpzUGx1bWJVSUNvbXBvbmVudC5hcHBseVR5cGUodGhpcywgdCk7XG4gICAgICAgIH0sXG4gICAgICAgIGFkZENsYXNzOiBmdW5jdGlvbiAoYywgaW5mb3JtRW5kcG9pbnRzKSB7XG4gICAgICAgICAgICBpZiAoaW5mb3JtRW5kcG9pbnRzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbmRwb2ludHNbMF0uYWRkQ2xhc3MoYyk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbmRwb2ludHNbMV0uYWRkQ2xhc3MoYyk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3VzcGVuZGVkRW5kcG9pbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdXNwZW5kZWRFbmRwb2ludC5hZGRDbGFzcyhjKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25uZWN0b3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3Rvci5hZGRDbGFzcyhjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uIChjLCBpbmZvcm1FbmRwb2ludHMpIHtcbiAgICAgICAgICAgIGlmIChpbmZvcm1FbmRwb2ludHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVuZHBvaW50c1swXS5yZW1vdmVDbGFzcyhjKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVuZHBvaW50c1sxXS5yZW1vdmVDbGFzcyhjKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdXNwZW5kZWRFbmRwb2ludCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN1c3BlbmRlZEVuZHBvaW50LnJlbW92ZUNsYXNzKGMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbm5lY3Rvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdG9yLnJlbW92ZUNsYXNzKGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBpc1Zpc2libGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9qc1BsdW1iLnZpc2libGU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldFZpc2libGU6IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICB0aGlzLl9qc1BsdW1iLnZpc2libGUgPSB2O1xuICAgICAgICAgICAgaWYgKHRoaXMuY29ubmVjdG9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0b3Iuc2V0VmlzaWJsZSh2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmVwYWludCgpO1xuICAgICAgICB9LFxuICAgICAgICBjbGVhbnVwOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUNvbm5lY3RlZENsYXNzKHRydWUpO1xuICAgICAgICAgICAgdGhpcy5lbmRwb2ludHMgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5zb3VyY2UgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy50YXJnZXQgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29ubmVjdG9yICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3Rvci5jbGVhbnVwKHRydWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdG9yLmRlc3Ryb3kodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3RvciA9IG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIHVwZGF0ZUNvbm5lY3RlZENsYXNzOmZ1bmN0aW9uKHJlbW92ZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2pzUGx1bWIpIHtcbiAgICAgICAgICAgICAgICBfdXBkYXRlQ29ubmVjdGVkQ2xhc3ModGhpcywgdGhpcy5zb3VyY2UsIHRoaXMuX2pzUGx1bWIuaW5zdGFuY2UsIHJlbW92ZSk7XG4gICAgICAgICAgICAgICAgX3VwZGF0ZUNvbm5lY3RlZENsYXNzKHRoaXMsIHRoaXMudGFyZ2V0LCB0aGlzLl9qc1BsdW1iLmluc3RhbmNlLCByZW1vdmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzZXRIb3ZlcjogZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25uZWN0b3IgJiYgdGhpcy5fanNQbHVtYiAmJiAhdGhpcy5fanNQbHVtYi5pbnN0YW5jZS5pc0Nvbm5lY3Rpb25CZWluZ0RyYWdnZWQoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdG9yLnNldEhvdmVyKHN0YXRlKTtcbiAgICAgICAgICAgICAgICByb290LmpzUGx1bWJbc3RhdGUgPyBcImFkZENsYXNzXCIgOiBcInJlbW92ZUNsYXNzXCJdKHRoaXMuc291cmNlLCB0aGlzLl9qc1BsdW1iLmluc3RhbmNlLmhvdmVyU291cmNlQ2xhc3MpO1xuICAgICAgICAgICAgICAgIHJvb3QuanNQbHVtYltzdGF0ZSA/IFwiYWRkQ2xhc3NcIiA6IFwicmVtb3ZlQ2xhc3NcIl0odGhpcy50YXJnZXQsIHRoaXMuX2pzUGx1bWIuaW5zdGFuY2UuaG92ZXJUYXJnZXRDbGFzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGdldFV1aWRzOmZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIFsgdGhpcy5lbmRwb2ludHNbMF0uZ2V0VXVpZCgpLCB0aGlzLmVuZHBvaW50c1sxXS5nZXRVdWlkKCkgXTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0Q29zdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2pzUGx1bWIgPyB0aGlzLl9qc1BsdW1iLmNvc3QgOiAtSW5maW5pdHk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldENvc3Q6IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICB0aGlzLl9qc1BsdW1iLmNvc3QgPSBjO1xuICAgICAgICB9LFxuICAgICAgICBpc0RpcmVjdGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fanNQbHVtYi5kaXJlY3RlZCA9PT0gdHJ1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0Q29ubmVjdG9yOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0b3I7XG4gICAgICAgIH0sXG4gICAgICAgIGdldEdlb21ldHJ5IDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0b3IgPyB0aGlzLmNvbm5lY3Rvci5nZXRHZW9tZXRyeSgpIDogbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0R2VvbWV0cnkgOiBmdW5jdGlvbihnKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25uZWN0b3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3Rvci5zZXRHZW9tZXRyeShnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcHJlcGFyZUNvbm5lY3RvcjpmdW5jdGlvbihjb25uZWN0b3JTcGVjLCB0eXBlSWQpIHtcbiAgICAgICAgICAgIHZhciBjb25uZWN0b3JBcmdzID0ge1xuICAgICAgICAgICAgICAgICAgICBfanNQbHVtYjogdGhpcy5fanNQbHVtYi5pbnN0YW5jZSxcbiAgICAgICAgICAgICAgICAgICAgY3NzQ2xhc3M6ICh0aGlzLl9qc1BsdW1iLnBhcmFtcy5jc3NDbGFzcyB8fCBcIlwiKSArICh0aGlzLmlzRWRpdGFibGUoKSA/IHRoaXMuX2pzUGx1bWIuaW5zdGFuY2UuZWRpdGFibGVDb25uZWN0b3JDbGFzcyA6IFwiXCIpLFxuICAgICAgICAgICAgICAgICAgICBjb250YWluZXI6IHRoaXMuX2pzUGx1bWIucGFyYW1zLmNvbnRhaW5lcixcbiAgICAgICAgICAgICAgICAgICAgXCJwb2ludGVyLWV2ZW50c1wiOiB0aGlzLl9qc1BsdW1iLnBhcmFtc1tcInBvaW50ZXItZXZlbnRzXCJdLFxuICAgICAgICAgICAgICAgICAgICBlZGl0YWJsZTp0aGlzLmVkaXRhYmxlUmVxdWVzdGVkXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICByZW5kZXJNb2RlID0gdGhpcy5fanNQbHVtYi5pbnN0YW5jZS5nZXRSZW5kZXJNb2RlKCksXG4gICAgICAgICAgICAgICAgY29ubmVjdG9yO1xuXG4gICAgICAgICAgICBpZiAoX2p1LmlzU3RyaW5nKGNvbm5lY3RvclNwZWMpKSB7XG4gICAgICAgICAgICAgICAgY29ubmVjdG9yID0gbWFrZUNvbm5lY3Rvcih0aGlzLl9qc1BsdW1iLmluc3RhbmNlLCByZW5kZXJNb2RlLCBjb25uZWN0b3JTcGVjLCBjb25uZWN0b3JBcmdzLCB0aGlzKTtcbiAgICAgICAgICAgIH0gLy8gbGV0cyB5b3UgdXNlIGEgc3RyaW5nIGFzIHNob3J0aGFuZC5cbiAgICAgICAgICAgIGVsc2UgaWYgKF9qdS5pc0FycmF5KGNvbm5lY3RvclNwZWMpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbm5lY3RvclNwZWMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3RvciA9IG1ha2VDb25uZWN0b3IodGhpcy5fanNQbHVtYi5pbnN0YW5jZSwgcmVuZGVyTW9kZSwgY29ubmVjdG9yU3BlY1swXSwgY29ubmVjdG9yQXJncywgdGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25uZWN0b3IgPSBtYWtlQ29ubmVjdG9yKHRoaXMuX2pzUGx1bWIuaW5zdGFuY2UsIHJlbmRlck1vZGUsIGNvbm5lY3RvclNwZWNbMF0sIF9qdS5tZXJnZShjb25uZWN0b3JTcGVjWzFdLCBjb25uZWN0b3JBcmdzKSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVJZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29ubmVjdG9yLnR5cGVJZCA9IHR5cGVJZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb25uZWN0b3I7XG4gICAgICAgIH0sXG4gICAgICAgIHNldFByZXBhcmVkQ29ubmVjdG9yOiBmdW5jdGlvbihjb25uZWN0b3IsIGRvTm90UmVwYWludCwgZG9Ob3RDaGFuZ2VMaXN0ZW5lckNvbXBvbmVudCwgdHlwZUlkKSB7XG5cbiAgICAgICAgICAgIHZhciBwcmV2aW91cywgcHJldmlvdXNDbGFzc2VzID0gXCJcIjtcbiAgICAgICAgICAgIC8vIHRoZSBjb25uZWN0b3Igd2lsbCBub3QgYmUgY2xlYW5lZCB1cCBpZiBpdCB3YXMgc2V0IGFzIHBhcnQgb2YgYSB0eXBlLCBiZWNhdXNlIGB0eXBlSWRgIHdpbGwgYmUgc2V0IG9uIGl0XG4gICAgICAgICAgICAvLyBhbmQgd2UgaGF2ZW50IHBhc3NlZCBpbiBgdHJ1ZWAgZm9yIFwiZm9yY2VcIiBoZXJlLlxuICAgICAgICAgICAgaWYgKHRoaXMuY29ubmVjdG9yICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBwcmV2aW91cyA9IHRoaXMuY29ubmVjdG9yO1xuICAgICAgICAgICAgICAgIHByZXZpb3VzQ2xhc3NlcyA9IHByZXZpb3VzLmdldENsYXNzKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0b3IuY2xlYW51cCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdG9yLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5jb25uZWN0b3IgPSBjb25uZWN0b3I7XG4gICAgICAgICAgICBpZiAodHlwZUlkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYWNoZVR5cGVJdGVtKFwiY29ubmVjdG9yXCIsIGNvbm5lY3RvciwgdHlwZUlkKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5jYW52YXMgPSB0aGlzLmNvbm5lY3Rvci5jYW52YXM7XG4gICAgICAgICAgICB0aGlzLmJnQ2FudmFzID0gdGhpcy5jb25uZWN0b3IuYmdDYW52YXM7XG5cbiAgICAgICAgICAgIC8vIHB1dCBjbGFzc2VzIGZyb20gcHJpb3IgY29ubmVjdG9yIG9udG8gdGhlIGNhbnZhc1xuICAgICAgICAgICAgdGhpcy5hZGRDbGFzcyhwcmV2aW91c0NsYXNzZXMpO1xuXG4gICAgICAgICAgICAvLyBuZXc6IGluc3RlYWQgb2YgYmluZGluZyBsaXN0ZW5lcnMgcGVyIGNvbm5lY3Rvciwgd2Ugbm93IGp1c3QgaGF2ZSBvbmUgZGVsZWdhdGUgb24gdGhlIGNvbnRhaW5lci5cbiAgICAgICAgICAgIC8vIHNvIGZvciB0aGF0IGhhbmRsZXIgd2Ugc2V0IHRoZSBjb25uZWN0aW9uIGFzIHRoZSAnX2pzUGx1bWInIG1lbWJlciBvZiB0aGUgY2FudmFzIGVsZW1lbnQsIGFuZFxuICAgICAgICAgICAgLy8gYmdDYW52YXMsIGlmIGl0IGV4aXN0cywgd2hpY2ggaXQgZG9lcyByaWdodCBub3cgaW4gdGhlIFZNTCByZW5kZXJlciwgc28gaXQgd29uJ3QgZnJvbSB2IDIuMC4wIG9ud2FyZHMuXG4gICAgICAgICAgICBpZiAodGhpcy5jYW52YXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbnZhcy5fanNQbHVtYiA9IHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5iZ0NhbnZhcykge1xuICAgICAgICAgICAgICAgIHRoaXMuYmdDYW52YXMuX2pzUGx1bWIgPSB0aGlzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocHJldmlvdXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhciBvID0gdGhpcy5nZXRPdmVybGF5cygpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgby5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAob1tpXS50cmFuc2Zlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgb1tpXS50cmFuc2Zlcih0aGlzLmNvbm5lY3Rvcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghZG9Ob3RDaGFuZ2VMaXN0ZW5lckNvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0TGlzdGVuZXJDb21wb25lbnQodGhpcy5jb25uZWN0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFkb05vdFJlcGFpbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlcGFpbnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc2V0Q29ubmVjdG9yOiBmdW5jdGlvbiAoY29ubmVjdG9yU3BlYywgZG9Ob3RSZXBhaW50LCBkb05vdENoYW5nZUxpc3RlbmVyQ29tcG9uZW50LCB0eXBlSWQpIHtcbiAgICAgICAgICAgIHZhciBjb25uZWN0b3IgPSB0aGlzLnByZXBhcmVDb25uZWN0b3IoY29ubmVjdG9yU3BlYywgdHlwZUlkKTtcbiAgICAgICAgICAgIHRoaXMuc2V0UHJlcGFyZWRDb25uZWN0b3IoY29ubmVjdG9yLCBkb05vdFJlcGFpbnQsIGRvTm90Q2hhbmdlTGlzdGVuZXJDb21wb25lbnQsIHR5cGVJZCk7XG4gICAgICAgIH0sXG4gICAgICAgIHBhaW50OiBmdW5jdGlvbiAocGFyYW1zKSB7XG5cbiAgICAgICAgICAgIGlmICghdGhpcy5fanNQbHVtYi5pbnN0YW5jZS5pc1N1c3BlbmREcmF3aW5nKCkgJiYgdGhpcy5fanNQbHVtYi52aXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICAgICAgICAgICAgICAgIHZhciB0aW1lc3RhbXAgPSBwYXJhbXMudGltZXN0YW1wLFxuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBtb3Zpbmcgb2JqZWN0IGlzIG5vdCB0aGUgc291cmNlIHdlIG11c3QgdHJhbnNwb3NlIHRoZSB0d28gcmVmZXJlbmNlcy5cbiAgICAgICAgICAgICAgICAgICAgc3dhcCA9IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICB0SWQgPSBzd2FwID8gdGhpcy5zb3VyY2VJZCA6IHRoaXMudGFyZ2V0SWQsIHNJZCA9IHN3YXAgPyB0aGlzLnRhcmdldElkIDogdGhpcy5zb3VyY2VJZCxcbiAgICAgICAgICAgICAgICAgICAgdElkeCA9IHN3YXAgPyAwIDogMSwgc0lkeCA9IHN3YXAgPyAxIDogMDtcblxuICAgICAgICAgICAgICAgIGlmICh0aW1lc3RhbXAgPT0gbnVsbCB8fCB0aW1lc3RhbXAgIT09IHRoaXMuX2pzUGx1bWIubGFzdFBhaW50ZWRBdCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc291cmNlSW5mbyA9IHRoaXMuX2pzUGx1bWIuaW5zdGFuY2UudXBkYXRlT2Zmc2V0KHtlbElkOnNJZH0pLm8sXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRJbmZvID0gdGhpcy5fanNQbHVtYi5pbnN0YW5jZS51cGRhdGVPZmZzZXQoe2VsSWQ6dElkfSkubyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNFID0gdGhpcy5lbmRwb2ludHNbc0lkeF0sIHRFID0gdGhpcy5lbmRwb2ludHNbdElkeF07XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHNBbmNob3JQID0gc0UuYW5jaG9yLmdldEN1cnJlbnRMb2NhdGlvbih7eHk6IFtzb3VyY2VJbmZvLmxlZnQsIHNvdXJjZUluZm8udG9wXSwgd2g6IFtzb3VyY2VJbmZvLndpZHRoLCBzb3VyY2VJbmZvLmhlaWdodF0sIGVsZW1lbnQ6IHNFLCB0aW1lc3RhbXA6IHRpbWVzdGFtcH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgdEFuY2hvclAgPSB0RS5hbmNob3IuZ2V0Q3VycmVudExvY2F0aW9uKHt4eTogW3RhcmdldEluZm8ubGVmdCwgdGFyZ2V0SW5mby50b3BdLCB3aDogW3RhcmdldEluZm8ud2lkdGgsIHRhcmdldEluZm8uaGVpZ2h0XSwgZWxlbWVudDogdEUsIHRpbWVzdGFtcDogdGltZXN0YW1wfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0b3IucmVzZXRCb3VuZHMoKTtcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3Rvci5jb21wdXRlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZVBvczogc0FuY2hvclAsXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRQb3M6IHRBbmNob3JQLFxuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlRW5kcG9pbnQ6IHRoaXMuZW5kcG9pbnRzW3NJZHhdLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0RW5kcG9pbnQ6IHRoaXMuZW5kcG9pbnRzW3RJZHhdLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJzdHJva2Utd2lkdGhcIjogdGhpcy5fanNQbHVtYi5wYWludFN0eWxlSW5Vc2Uuc3Ryb2tlV2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VJbmZvOiBzb3VyY2VJbmZvLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0SW5mbzogdGFyZ2V0SW5mb1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgb3ZlcmxheUV4dGVudHMgPSB7IG1pblg6IEluZmluaXR5LCBtaW5ZOiBJbmZpbml0eSwgbWF4WDogLUluZmluaXR5LCBtYXhZOiAtSW5maW5pdHkgfTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBjb21wdXRlIG92ZXJsYXlzLiB3ZSBkbyB0aGlzIGZpcnN0IHNvIHdlIGNhbiBnZXQgdGhlaXIgcGxhY2VtZW50cywgYW5kIGFkanVzdCB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gY29udGFpbmVyIGlmIG5lZWRzIGJlIChpZiBhbiBvdmVybGF5IHdvdWxkIGJlIGNsaXBwZWQpXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5fanNQbHVtYi5vdmVybGF5cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2pzUGx1bWIub3ZlcmxheXMuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbyA9IHRoaXMuX2pzUGx1bWIub3ZlcmxheXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG8uaXNWaXNpYmxlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fanNQbHVtYi5vdmVybGF5UGxhY2VtZW50c1tpXSA9IG8uZHJhdyh0aGlzLmNvbm5lY3RvciwgdGhpcy5fanNQbHVtYi5wYWludFN0eWxlSW5Vc2UsIHRoaXMuZ2V0QWJzb2x1dGVPdmVybGF5UG9zaXRpb24obykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdmVybGF5RXh0ZW50cy5taW5YID0gTWF0aC5taW4ob3ZlcmxheUV4dGVudHMubWluWCwgdGhpcy5fanNQbHVtYi5vdmVybGF5UGxhY2VtZW50c1tpXS5taW5YKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmxheUV4dGVudHMubWF4WCA9IE1hdGgubWF4KG92ZXJsYXlFeHRlbnRzLm1heFgsIHRoaXMuX2pzUGx1bWIub3ZlcmxheVBsYWNlbWVudHNbaV0ubWF4WCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJsYXlFeHRlbnRzLm1pblkgPSBNYXRoLm1pbihvdmVybGF5RXh0ZW50cy5taW5ZLCB0aGlzLl9qc1BsdW1iLm92ZXJsYXlQbGFjZW1lbnRzW2ldLm1pblkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdmVybGF5RXh0ZW50cy5tYXhZID0gTWF0aC5tYXgob3ZlcmxheUV4dGVudHMubWF4WSwgdGhpcy5fanNQbHVtYi5vdmVybGF5UGxhY2VtZW50c1tpXS5tYXhZKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB2YXIgbGluZVdpZHRoID0gcGFyc2VGbG9hdCh0aGlzLl9qc1BsdW1iLnBhaW50U3R5bGVJblVzZS5zdHJva2VXaWR0aCB8fCAxKSAvIDIsXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRsaW5lV2lkdGggPSBwYXJzZUZsb2F0KHRoaXMuX2pzUGx1bWIucGFpbnRTdHlsZUluVXNlLnN0cm9rZVdpZHRoIHx8IDApLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZW50cyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4bWluOiBNYXRoLm1pbih0aGlzLmNvbm5lY3Rvci5ib3VuZHMubWluWCAtIChsaW5lV2lkdGggKyBvdXRsaW5lV2lkdGgpLCBvdmVybGF5RXh0ZW50cy5taW5YKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5bWluOiBNYXRoLm1pbih0aGlzLmNvbm5lY3Rvci5ib3VuZHMubWluWSAtIChsaW5lV2lkdGggKyBvdXRsaW5lV2lkdGgpLCBvdmVybGF5RXh0ZW50cy5taW5ZKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4bWF4OiBNYXRoLm1heCh0aGlzLmNvbm5lY3Rvci5ib3VuZHMubWF4WCArIChsaW5lV2lkdGggKyBvdXRsaW5lV2lkdGgpLCBvdmVybGF5RXh0ZW50cy5tYXhYKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5bWF4OiBNYXRoLm1heCh0aGlzLmNvbm5lY3Rvci5ib3VuZHMubWF4WSArIChsaW5lV2lkdGggKyBvdXRsaW5lV2lkdGgpLCBvdmVybGF5RXh0ZW50cy5tYXhZKVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgLy8gcGFpbnQgdGhlIGNvbm5lY3Rvci5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0b3IucGFpbnQodGhpcy5fanNQbHVtYi5wYWludFN0eWxlSW5Vc2UsIG51bGwsIGV4dGVudHMpO1xuICAgICAgICAgICAgICAgICAgICAvLyBhbmQgdGhlbiB0aGUgb3ZlcmxheXNcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiBpbiB0aGlzLl9qc1BsdW1iLm92ZXJsYXlzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fanNQbHVtYi5vdmVybGF5cy5oYXNPd25Qcm9wZXJ0eShqKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwID0gdGhpcy5fanNQbHVtYi5vdmVybGF5c1tqXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocC5pc1Zpc2libGUoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLnBhaW50KHRoaXMuX2pzUGx1bWIub3ZlcmxheVBsYWNlbWVudHNbal0sIGV4dGVudHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9qc1BsdW1iLmxhc3RQYWludGVkQXQgPSB0aW1lc3RhbXA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHJlcGFpbnQ6IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgICAgICAgICAgIHRoaXMucGFpbnQoeyBlbElkOiB0aGlzLnNvdXJjZUlkLCByZWNhbGM6ICEocGFyYW1zLnJlY2FsYyA9PT0gZmFsc2UpLCB0aW1lc3RhbXA6IHBhcmFtcy50aW1lc3RhbXB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgcHJlcGFyZUVuZHBvaW50OiBmdW5jdGlvbiAoX2pzUGx1bWIsIF9uZXdFbmRwb2ludCwgY29ubiwgZXhpc3RpbmcsIGluZGV4LCBwYXJhbXMsIGVsZW1lbnQsIGVsZW1lbnRJZCkge1xuICAgICAgICAgICAgdmFyIGU7XG4gICAgICAgICAgICBpZiAoZXhpc3RpbmcpIHtcbiAgICAgICAgICAgICAgICBjb25uLmVuZHBvaW50c1tpbmRleF0gPSBleGlzdGluZztcbiAgICAgICAgICAgICAgICBleGlzdGluZy5hZGRDb25uZWN0aW9uKGNvbm4pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIXBhcmFtcy5lbmRwb2ludHMpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLmVuZHBvaW50cyA9IFsgbnVsbCwgbnVsbCBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgZXAgPSBwYXJhbXMuZW5kcG9pbnRzW2luZGV4XSB8fCBwYXJhbXMuZW5kcG9pbnQgfHwgX2pzUGx1bWIuRGVmYXVsdHMuRW5kcG9pbnRzW2luZGV4XSB8fCBfanAuRGVmYXVsdHMuRW5kcG9pbnRzW2luZGV4XSB8fCBfanNQbHVtYi5EZWZhdWx0cy5FbmRwb2ludCB8fCBfanAuRGVmYXVsdHMuRW5kcG9pbnQ7XG4gICAgICAgICAgICAgICAgaWYgKCFwYXJhbXMuZW5kcG9pbnRTdHlsZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLmVuZHBvaW50U3R5bGVzID0gWyBudWxsLCBudWxsIF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghcGFyYW1zLmVuZHBvaW50SG92ZXJTdHlsZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLmVuZHBvaW50SG92ZXJTdHlsZXMgPSBbIG51bGwsIG51bGwgXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGVzID0gcGFyYW1zLmVuZHBvaW50U3R5bGVzW2luZGV4XSB8fCBwYXJhbXMuZW5kcG9pbnRTdHlsZSB8fCBfanNQbHVtYi5EZWZhdWx0cy5FbmRwb2ludFN0eWxlc1tpbmRleF0gfHwgX2pwLkRlZmF1bHRzLkVuZHBvaW50U3R5bGVzW2luZGV4XSB8fCBfanNQbHVtYi5EZWZhdWx0cy5FbmRwb2ludFN0eWxlIHx8IF9qcC5EZWZhdWx0cy5FbmRwb2ludFN0eWxlO1xuICAgICAgICAgICAgICAgIC8vIEVuZHBvaW50cyBkZXJpdmUgdGhlaXIgZmlsbCBmcm9tIHRoZSBjb25uZWN0b3IncyBzdHJva2UsIGlmIG5vIGZpbGwgd2FzIHNwZWNpZmllZC5cbiAgICAgICAgICAgICAgICBpZiAoZXMuZmlsbCA9PSBudWxsICYmIHBhcmFtcy5wYWludFN0eWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgZXMuZmlsbCA9IHBhcmFtcy5wYWludFN0eWxlLnN0cm9rZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoZXMub3V0bGluZVN0cm9rZSA9PSBudWxsICYmIHBhcmFtcy5wYWludFN0eWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgZXMub3V0bGluZVN0cm9rZSA9IHBhcmFtcy5wYWludFN0eWxlLm91dGxpbmVTdHJva2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChlcy5vdXRsaW5lV2lkdGggPT0gbnVsbCAmJiBwYXJhbXMucGFpbnRTdHlsZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGVzLm91dGxpbmVXaWR0aCA9IHBhcmFtcy5wYWludFN0eWxlLm91dGxpbmVXaWR0aDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgZWhzID0gcGFyYW1zLmVuZHBvaW50SG92ZXJTdHlsZXNbaW5kZXhdIHx8IHBhcmFtcy5lbmRwb2ludEhvdmVyU3R5bGUgfHwgX2pzUGx1bWIuRGVmYXVsdHMuRW5kcG9pbnRIb3ZlclN0eWxlc1tpbmRleF0gfHwgX2pwLkRlZmF1bHRzLkVuZHBvaW50SG92ZXJTdHlsZXNbaW5kZXhdIHx8IF9qc1BsdW1iLkRlZmF1bHRzLkVuZHBvaW50SG92ZXJTdHlsZSB8fCBfanAuRGVmYXVsdHMuRW5kcG9pbnRIb3ZlclN0eWxlO1xuICAgICAgICAgICAgICAgIC8vIGVuZHBvaW50IGhvdmVyIGZpbGwgc3R5bGUgaXMgZGVyaXZlZCBmcm9tIGNvbm5lY3RvcidzIGhvdmVyIHN0cm9rZSBzdHlsZVxuICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuaG92ZXJQYWludFN0eWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVocyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlaHMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZWhzLmZpbGwgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWhzLmZpbGwgPSBwYXJhbXMuaG92ZXJQYWludFN0eWxlLnN0cm9rZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgYSA9IHBhcmFtcy5hbmNob3JzID8gcGFyYW1zLmFuY2hvcnNbaW5kZXhdIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcy5hbmNob3IgPyBwYXJhbXMuYW5jaG9yIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfbWFrZUFuY2hvcihfanNQbHVtYi5EZWZhdWx0cy5BbmNob3JzW2luZGV4XSwgZWxlbWVudElkLCBfanNQbHVtYikgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfbWFrZUFuY2hvcihfanAuRGVmYXVsdHMuQW5jaG9yc1tpbmRleF0sIGVsZW1lbnRJZCwgX2pzUGx1bWIpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX21ha2VBbmNob3IoX2pzUGx1bWIuRGVmYXVsdHMuQW5jaG9yLCBlbGVtZW50SWQsIF9qc1BsdW1iKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9tYWtlQW5jaG9yKF9qcC5EZWZhdWx0cy5BbmNob3IsIGVsZW1lbnRJZCwgX2pzUGx1bWIpLFxuICAgICAgICAgICAgICAgICAgICB1ID0gcGFyYW1zLnV1aWRzID8gcGFyYW1zLnV1aWRzW2luZGV4XSA6IG51bGw7XG5cbiAgICAgICAgICAgICAgICBlID0gX25ld0VuZHBvaW50KHtcbiAgICAgICAgICAgICAgICAgICAgcGFpbnRTdHlsZTogZXMsIGhvdmVyUGFpbnRTdHlsZTogZWhzLCBlbmRwb2ludDogZXAsIGNvbm5lY3Rpb25zOiBbIGNvbm4gXSxcbiAgICAgICAgICAgICAgICAgICAgdXVpZDogdSwgYW5jaG9yOiBhLCBzb3VyY2U6IGVsZW1lbnQsIHNjb3BlOiBwYXJhbXMuc2NvcGUsXG4gICAgICAgICAgICAgICAgICAgIHJlYXR0YWNoOiBwYXJhbXMucmVhdHRhY2ggfHwgX2pzUGx1bWIuRGVmYXVsdHMuUmVhdHRhY2hDb25uZWN0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgZGV0YWNoYWJsZTogcGFyYW1zLmRldGFjaGFibGUgfHwgX2pzUGx1bWIuRGVmYXVsdHMuQ29ubmVjdGlvbnNEZXRhY2hhYmxlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKGV4aXN0aW5nID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5zZXREZWxldGVPbkVtcHR5KHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25uLmVuZHBvaW50c1tpbmRleF0gPSBlO1xuXG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5kcmF3RW5kcG9pbnRzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICBlLnNldFZpc2libGUoZmFsc2UsIHRydWUsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGU7XG4gICAgICAgIH1cblxuICAgIH0pOyAvLyBFTkQgQ29ubmVjdGlvbiBjbGFzcyAgICAgICAgICAgIFxufSkuY2FsbCh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHRoaXMpO1xuXG4vKlxuICoganNQbHVtYiBDb21tdW5pdHkgRWRpdGlvblxuICogXG4gKiBQcm92aWRlcyBhIHdheSB0byB2aXN1YWxseSBjb25uZWN0IGVsZW1lbnRzIG9uIGFuIEhUTUwgcGFnZSwgdXNpbmcgU1ZHLlxuICogXG4gKiBUaGlzIGZpbGUgY29udGFpbnMgdGhlIGNvZGUgZm9yIGNyZWF0aW5nIGFuZCBtYW5pcHVsYXRpbmcgYW5jaG9ycy5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTAgLSAyMDE3IGpzUGx1bWIgKGhlbGxvQGpzcGx1bWJ0b29sa2l0LmNvbSlcbiAqIFxuICogaHR0cHM6Ly9qc3BsdW1idG9vbGtpdC5jb21cbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9qc3BsdW1iL2pzcGx1bWJcbiAqIFxuICogRHVhbCBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGFuZCBHUEwyIGxpY2Vuc2VzLlxuICovXG47XG4oZnVuY3Rpb24gKCkge1xuXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICB2YXIgcm9vdCA9IHRoaXMsXG4gICAgICAgIF9qdSA9IHJvb3QuanNQbHVtYlV0aWwsXG4gICAgICAgIF9qcCA9IHJvb3QuanNQbHVtYjtcblxuICAgIC8vXG4gICAgLy8gbWFuYWdlcyBhbmNob3JzIGZvciBhbGwgZWxlbWVudHMuXG4gICAgLy9cbiAgICBfanAuQW5jaG9yTWFuYWdlciA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hbUVuZHBvaW50cyA9IHt9LFxuICAgICAgICAgICAgY29udGludW91c0FuY2hvckxvY2F0aW9ucyA9IHt9LFxuICAgICAgICAgICAgdXNlckRlZmluZWRDb250aW51b3VzQW5jaG9yTG9jYXRpb25zID0ge30sXG4gICAgICAgICAgICBjb250aW51b3VzQW5jaG9yT3JpZW50YXRpb25zID0ge30sXG4gICAgICAgICAgICBPcmllbnRhdGlvbiA9IHsgSE9SSVpPTlRBTDogXCJob3Jpem9udGFsXCIsIFZFUlRJQ0FMOiBcInZlcnRpY2FsXCIsIERJQUdPTkFMOiBcImRpYWdvbmFsXCIsIElERU5USVRZOiBcImlkZW50aXR5XCIgfSxcbiAgICAgICAgICAgIGF4ZXMgPSBbXCJsZWZ0XCIsIFwidG9wXCIsIFwicmlnaHRcIiwgXCJib3R0b21cIl0sXG4gICAgICAgICAgICBjb25uZWN0aW9uc0J5RWxlbWVudElkID0ge30sXG4gICAgICAgICAgICBzZWxmID0gdGhpcyxcbiAgICAgICAgICAgIGFuY2hvckxpc3RzID0ge30sXG4gICAgICAgICAgICBqc1BsdW1iSW5zdGFuY2UgPSBwYXJhbXMuanNQbHVtYkluc3RhbmNlLFxuICAgICAgICAgICAgZmxvYXRpbmdDb25uZWN0aW9ucyA9IHt9LFxuICAgICAgICAgICAgY2FsY3VsYXRlT3JpZW50YXRpb24gPSBmdW5jdGlvbiAoc291cmNlSWQsIHRhcmdldElkLCBzZCwgdGQsIHNvdXJjZUFuY2hvciwgdGFyZ2V0QW5jaG9yKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoc291cmNlSWQgPT09IHRhcmdldElkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcmllbnRhdGlvbjogT3JpZW50YXRpb24uSURFTlRJVFksXG4gICAgICAgICAgICAgICAgICAgICAgICBhOiBbXCJ0b3BcIiwgXCJ0b3BcIl1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgdGhldGEgPSBNYXRoLmF0YW4yKCh0ZC5jZW50ZXJ5IC0gc2QuY2VudGVyeSksICh0ZC5jZW50ZXJ4IC0gc2QuY2VudGVyeCkpLFxuICAgICAgICAgICAgICAgICAgICB0aGV0YTIgPSBNYXRoLmF0YW4yKChzZC5jZW50ZXJ5IC0gdGQuY2VudGVyeSksIChzZC5jZW50ZXJ4IC0gdGQuY2VudGVyeCkpO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgICAgICAgICAgLy8gaW1wcm92ZWQgZmFjZSBjYWxjdWxhdGlvbi4gZ2V0IG1pZHBvaW50cyBvZiBlYWNoIGZhY2UgZm9yIHNvdXJjZSBhbmQgdGFyZ2V0LCB0aGVuIHB1dCBpbiBhbiBhcnJheSB3aXRoIGFsbCBjb21iaW5hdGlvbnMgb2ZcbiAgICAgICAgICAgICAgICAvLyBzb3VyY2UvdGFyZ2V0IGZhY2VzLiBzb3J0IHRoaXMgYXJyYXkgYnkgZGlzdGFuY2UgYmV0d2VlbiBtaWRwb2ludHMuIHRoZSBlbnRyeSBhdCBpbmRleCAwIGlzIG91ciBwcmVmZXJyZWQgb3B0aW9uLiB3ZSBjYW5cbiAgICAgICAgICAgICAgICAvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBvbmUgYnkgb25lIHVudGlsIHdlIGZpbmQgYW4gZW50cnkgaW4gd2hpY2ggZWFjaCByZXF1ZXN0ZWQgZmFjZSBpcyBzdXBwb3J0ZWQuXG4gICAgICAgICAgICAgICAgdmFyIGNhbmRpZGF0ZXMgPSBbXSwgbWlkcG9pbnRzID0geyB9O1xuICAgICAgICAgICAgICAgIChmdW5jdGlvbiAodHlwZXMsIGRpbSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtaWRwb2ludHNbdHlwZXNbaV1dID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwibGVmdFwiOiBbIGRpbVtpXS5sZWZ0LCBkaW1baV0uY2VudGVyeSBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwicmlnaHRcIjogWyBkaW1baV0ucmlnaHQsIGRpbVtpXS5jZW50ZXJ5IF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ0b3BcIjogWyBkaW1baV0uY2VudGVyeCwgZGltW2ldLnRvcCBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiYm90dG9tXCI6IFsgZGltW2ldLmNlbnRlcnggLCBkaW1baV0uYm90dG9tXVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pKFsgXCJzb3VyY2VcIiwgXCJ0YXJnZXRcIiBdLCBbIHNkLCB0ZCBdKTtcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIHNmID0gMDsgc2YgPCBheGVzLmxlbmd0aDsgc2YrKykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB0ZiA9IDA7IHRmIDwgYXhlcy5sZW5ndGg7IHRmKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbmRpZGF0ZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlOiBheGVzW3NmXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IGF4ZXNbdGZdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3Q6IEJpbHRvbmcubGluZUxlbmd0aChtaWRwb2ludHMuc291cmNlW2F4ZXNbc2ZdXSwgbWlkcG9pbnRzLnRhcmdldFtheGVzW3RmXV0pXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNhbmRpZGF0ZXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYS5kaXN0IDwgYi5kaXN0ID8gLTEgOiBhLmRpc3QgPiBiLmRpc3QgPyAxIDogMDtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vIG5vdyBnbyB0aHJvdWdoIHRoaXMgbGlzdCBhbmQgdHJ5IHRvIGdldCBhbiBlbnRyeSB0aGF0IHNhdGlzZmllcyBib3RoICh0aGVyZSB3aWxsIGJlIG9uZSwgdW5sZXNzIG9uZSBvZiB0aGUgYW5jaG9yc1xuICAgICAgICAgICAgICAgIC8vIGRlY2xhcmVzIG5vIGF2YWlsYWJsZSBmYWNlcylcbiAgICAgICAgICAgICAgICB2YXIgc291cmNlRWRnZSA9IGNhbmRpZGF0ZXNbMF0uc291cmNlLCB0YXJnZXRFZGdlID0gY2FuZGlkYXRlc1swXS50YXJnZXQ7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYW5kaWRhdGVzLmxlbmd0aDsgaSsrKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzb3VyY2VBbmNob3IuaXNDb250aW51b3VzIHx8IHNvdXJjZUFuY2hvci5pc0VkZ2VTdXBwb3J0ZWQoY2FuZGlkYXRlc1tpXS5zb3VyY2UpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VFZGdlID0gY2FuZGlkYXRlc1tpXS5zb3VyY2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VFZGdlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICghdGFyZ2V0QW5jaG9yLmlzQ29udGludW91cyB8fCB0YXJnZXRBbmNob3IuaXNFZGdlU3VwcG9ydGVkKGNhbmRpZGF0ZXNbaV0udGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0RWRnZSA9IGNhbmRpZGF0ZXNbaV0udGFyZ2V0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0RWRnZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoc291cmNlRWRnZSAhPSBudWxsICYmIHRhcmdldEVkZ2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBhOiBbIHNvdXJjZUVkZ2UsIHRhcmdldEVkZ2UgXSxcbiAgICAgICAgICAgICAgICAgICAgdGhldGE6IHRoZXRhLFxuICAgICAgICAgICAgICAgICAgICB0aGV0YTI6IHRoZXRhMlxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICAvLyB1c2VkIGJ5IHBsYWNlQW5jaG9ycyBmdW5jdGlvblxuICAgICAgICAgICAgcGxhY2VBbmNob3JzT25MaW5lID0gZnVuY3Rpb24gKGRlc2MsIGVsZW1lbnREaW1lbnNpb25zLCBlbGVtZW50UG9zaXRpb24sIGNvbm5lY3Rpb25zLCBob3Jpem9udGFsLCBvdGhlck11bHRpcGxpZXIsIHJldmVyc2UpIHtcbiAgICAgICAgICAgICAgICB2YXIgYSA9IFtdLCBzdGVwID0gZWxlbWVudERpbWVuc2lvbnNbaG9yaXpvbnRhbCA/IDAgOiAxXSAvIChjb25uZWN0aW9ucy5sZW5ndGggKyAxKTtcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29ubmVjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbCA9IChpICsgMSkgKiBzdGVwLCBvdGhlciA9IG90aGVyTXVsdGlwbGllciAqIGVsZW1lbnREaW1lbnNpb25zW2hvcml6b250YWwgPyAxIDogMF07XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSBlbGVtZW50RGltZW5zaW9uc1tob3Jpem9udGFsID8gMCA6IDFdIC0gdmFsO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGR4ID0gKGhvcml6b250YWwgPyB2YWwgOiBvdGhlciksIHggPSBlbGVtZW50UG9zaXRpb25bMF0gKyBkeCwgeHAgPSBkeCAvIGVsZW1lbnREaW1lbnNpb25zWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgZHkgPSAoaG9yaXpvbnRhbCA/IG90aGVyIDogdmFsKSwgeSA9IGVsZW1lbnRQb3NpdGlvblsxXSArIGR5LCB5cCA9IGR5IC8gZWxlbWVudERpbWVuc2lvbnNbMV07XG5cbiAgICAgICAgICAgICAgICAgICAgYS5wdXNoKFsgeCwgeSwgeHAsIHlwLCBjb25uZWN0aW9uc1tpXVsxXSwgY29ubmVjdGlvbnNbaV1bMl0gXSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgICAgICB9LFxuICAgICAgICAvLyB1c2VkIGJ5IGVkZ2VTb3J0RnVuY3Rpb25zXG4gICAgICAgICAgICBjdXJyeVNvcnQgPSBmdW5jdGlvbiAocmV2ZXJzZUFuZ2xlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgciA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXZlcnNlQW5nbGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByID0gYVswXVswXSA8IGJbMF1bMF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByID0gYVswXVswXSA+IGJbMF1bMF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHIgPT09IGZhbHNlID8gLTEgOiAxO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICAvLyB1c2VkIGJ5IGVkZ2VTb3J0RnVuY3Rpb25zXG4gICAgICAgICAgICBsZWZ0U29ydCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICAgICAgLy8gZmlyc3QgZ2V0IGFkanVzdGVkIHZhbHVlc1xuICAgICAgICAgICAgICAgIHZhciBwMSA9IGFbMF1bMF0gPCAwID8gLU1hdGguUEkgLSBhWzBdWzBdIDogTWF0aC5QSSAtIGFbMF1bMF0sXG4gICAgICAgICAgICAgICAgICAgIHAyID0gYlswXVswXSA8IDAgPyAtTWF0aC5QSSAtIGJbMF1bMF0gOiBNYXRoLlBJIC0gYlswXVswXTtcbiAgICAgICAgICAgICAgICBpZiAocDEgPiBwMikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAvLyB1c2VkIGJ5IHBsYWNlQW5jaG9yc1xuICAgICAgICAgICAgZWRnZVNvcnRGdW5jdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgXCJ0b3BcIjogZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFbMF0gPiBiWzBdID8gMSA6IC0xO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJyaWdodFwiOiBjdXJyeVNvcnQodHJ1ZSksXG4gICAgICAgICAgICAgICAgXCJib3R0b21cIjogY3VycnlTb3J0KHRydWUpLFxuICAgICAgICAgICAgICAgIFwibGVmdFwiOiBsZWZ0U29ydFxuICAgICAgICAgICAgfSxcbiAgICAgICAgLy8gdXNlZCBieSBwbGFjZUFuY2hvcnNcbiAgICAgICAgICAgIF9zb3J0SGVscGVyID0gZnVuY3Rpb24gKF9hcnJheSwgX2ZuKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9hcnJheS5zb3J0KF9mbik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAvLyB1c2VkIGJ5IEFuY2hvck1hbmFnZXIucmVkcmF3XG4gICAgICAgICAgICBwbGFjZUFuY2hvcnMgPSBmdW5jdGlvbiAoZWxlbWVudElkLCBfYW5jaG9yTGlzdHMpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2QgPSBqc1BsdW1iSW5zdGFuY2UuZ2V0Q2FjaGVkRGF0YShlbGVtZW50SWQpLCBzUyA9IGNkLnMsIHNPID0gY2QubyxcbiAgICAgICAgICAgICAgICAgICAgcGxhY2VTb21lQW5jaG9ycyA9IGZ1bmN0aW9uIChkZXNjLCBlbGVtZW50RGltZW5zaW9ucywgZWxlbWVudFBvc2l0aW9uLCB1bnNvcnRlZENvbm5lY3Rpb25zLCBpc0hvcml6b250YWwsIG90aGVyTXVsdGlwbGllciwgb3JpZW50YXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1bnNvcnRlZENvbm5lY3Rpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2MgPSBfc29ydEhlbHBlcih1bnNvcnRlZENvbm5lY3Rpb25zLCBlZGdlU29ydEZ1bmN0aW9uc1tkZXNjXSksIC8vIHB1dHMgdGhlbSBpbiBvcmRlciBiYXNlZCBvbiB0aGUgdGFyZ2V0IGVsZW1lbnQncyBwb3Mgb24gc2NyZWVuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldmVyc2UgPSBkZXNjID09PSBcInJpZ2h0XCIgfHwgZGVzYyA9PT0gXCJ0b3BcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5jaG9ycyA9IHBsYWNlQW5jaG9yc09uTGluZShkZXNjLCBlbGVtZW50RGltZW5zaW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRQb3NpdGlvbiwgc2MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0hvcml6b250YWwsIG90aGVyTXVsdGlwbGllciwgcmV2ZXJzZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0YWtlcyBhIGNvbXB1dGVkIGFuY2hvciBwb3NpdGlvbiBhbmQgYWRqdXN0cyBpdCBmb3IgcGFyZW50IG9mZnNldCBhbmQgc2Nyb2xsLCB0aGVuIHN0b3JlcyBpdC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3NldEFuY2hvckxvY2F0aW9uID0gZnVuY3Rpb24gKGVuZHBvaW50LCBhbmNob3JQb3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludW91c0FuY2hvckxvY2F0aW9uc1tlbmRwb2ludC5pZF0gPSBbIGFuY2hvclBvc1swXSwgYW5jaG9yUG9zWzFdLCBhbmNob3JQb3NbMl0sIGFuY2hvclBvc1szXSBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51b3VzQW5jaG9yT3JpZW50YXRpb25zW2VuZHBvaW50LmlkXSA9IG9yaWVudGF0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFuY2hvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGMgPSBhbmNob3JzW2ldWzRdLCB3ZUFyZVNvdXJjZSA9IGMuZW5kcG9pbnRzWzBdLmVsZW1lbnRJZCA9PT0gZWxlbWVudElkLCB3ZUFyZVRhcmdldCA9IGMuZW5kcG9pbnRzWzFdLmVsZW1lbnRJZCA9PT0gZWxlbWVudElkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAod2VBcmVTb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9zZXRBbmNob3JMb2NhdGlvbihjLmVuZHBvaW50c1swXSwgYW5jaG9yc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdlQXJlVGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfc2V0QW5jaG9yTG9jYXRpb24oYy5lbmRwb2ludHNbMV0sIGFuY2hvcnNbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgcGxhY2VTb21lQW5jaG9ycyhcImJvdHRvbVwiLCBzUywgW3NPLmxlZnQsIHNPLnRvcF0sIF9hbmNob3JMaXN0cy5ib3R0b20sIHRydWUsIDEsIFswLCAxXSk7XG4gICAgICAgICAgICAgICAgcGxhY2VTb21lQW5jaG9ycyhcInRvcFwiLCBzUywgW3NPLmxlZnQsIHNPLnRvcF0sIF9hbmNob3JMaXN0cy50b3AsIHRydWUsIDAsIFswLCAtMV0pO1xuICAgICAgICAgICAgICAgIHBsYWNlU29tZUFuY2hvcnMoXCJsZWZ0XCIsIHNTLCBbc08ubGVmdCwgc08udG9wXSwgX2FuY2hvckxpc3RzLmxlZnQsIGZhbHNlLCAwLCBbLTEsIDBdKTtcbiAgICAgICAgICAgICAgICBwbGFjZVNvbWVBbmNob3JzKFwicmlnaHRcIiwgc1MsIFtzTy5sZWZ0LCBzTy50b3BdLCBfYW5jaG9yTGlzdHMucmlnaHQsIGZhbHNlLCAxLCBbMSwgMF0pO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICB0aGlzLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX2FtRW5kcG9pbnRzID0ge307XG4gICAgICAgICAgICBjb25uZWN0aW9uc0J5RWxlbWVudElkID0ge307XG4gICAgICAgICAgICBhbmNob3JMaXN0cyA9IHt9O1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmFkZEZsb2F0aW5nQ29ubmVjdGlvbiA9IGZ1bmN0aW9uIChrZXksIGNvbm4pIHtcbiAgICAgICAgICAgIGZsb2F0aW5nQ29ubmVjdGlvbnNba2V5XSA9IGNvbm47XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucmVtb3ZlRmxvYXRpbmdDb25uZWN0aW9uID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgZGVsZXRlIGZsb2F0aW5nQ29ubmVjdGlvbnNba2V5XTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5uZXdDb25uZWN0aW9uID0gZnVuY3Rpb24gKGNvbm4pIHtcbiAgICAgICAgICAgIHZhciBzb3VyY2VJZCA9IGNvbm4uc291cmNlSWQsIHRhcmdldElkID0gY29ubi50YXJnZXRJZCxcbiAgICAgICAgICAgICAgICBlcCA9IGNvbm4uZW5kcG9pbnRzLFxuICAgICAgICAgICAgICAgIGRvUmVnaXN0ZXJUYXJnZXQgPSB0cnVlLFxuICAgICAgICAgICAgICAgIHJlZ2lzdGVyQ29ubmVjdGlvbiA9IGZ1bmN0aW9uIChvdGhlckluZGV4LCBvdGhlckVuZHBvaW50LCBvdGhlckFuY2hvciwgZWxJZCwgYykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKHNvdXJjZUlkID09PSB0YXJnZXRJZCkgJiYgb3RoZXJBbmNob3IuaXNDb250aW51b3VzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgdGhlIHRhcmdldCBlbmRwb2ludCdzIGNhbnZhcy4gIHdlIGRvbnQgbmVlZCBpdC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbm4uX2pzUGx1bWIuaW5zdGFuY2UucmVtb3ZlRWxlbWVudChlcFsxXS5jYW52YXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9SZWdpc3RlclRhcmdldCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF9qdS5hZGRUb0xpc3QoY29ubmVjdGlvbnNCeUVsZW1lbnRJZCwgZWxJZCwgW2MsIG90aGVyRW5kcG9pbnQsIG90aGVyQW5jaG9yLmNvbnN0cnVjdG9yID09PSBfanAuRHluYW1pY0FuY2hvcl0pO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJlZ2lzdGVyQ29ubmVjdGlvbigwLCBlcFswXSwgZXBbMF0uYW5jaG9yLCB0YXJnZXRJZCwgY29ubik7XG4gICAgICAgICAgICBpZiAoZG9SZWdpc3RlclRhcmdldCkge1xuICAgICAgICAgICAgICAgIHJlZ2lzdGVyQ29ubmVjdGlvbigxLCBlcFsxXSwgZXBbMV0uYW5jaG9yLCBzb3VyY2VJZCwgY29ubik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciByZW1vdmVFbmRwb2ludEZyb21BbmNob3JMaXN0cyA9IGZ1bmN0aW9uIChlbmRwb2ludCkge1xuICAgICAgICAgICAgKGZ1bmN0aW9uIChsaXN0LCBlSWQpIHtcbiAgICAgICAgICAgICAgICBpZiAobGlzdCkgeyAgLy8gdHJhbnNpZW50IGFuY2hvcnMgZG9udCBnZXQgZW50cmllcyBpbiB0aGlzIGxpc3QuXG4gICAgICAgICAgICAgICAgICAgIHZhciBmID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlWzRdID09PSBlSWQ7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIF9qdS5yZW1vdmVXaXRoRnVuY3Rpb24obGlzdC50b3AsIGYpO1xuICAgICAgICAgICAgICAgICAgICBfanUucmVtb3ZlV2l0aEZ1bmN0aW9uKGxpc3QubGVmdCwgZik7XG4gICAgICAgICAgICAgICAgICAgIF9qdS5yZW1vdmVXaXRoRnVuY3Rpb24obGlzdC5ib3R0b20sIGYpO1xuICAgICAgICAgICAgICAgICAgICBfanUucmVtb3ZlV2l0aEZ1bmN0aW9uKGxpc3QucmlnaHQsIGYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKGFuY2hvckxpc3RzW2VuZHBvaW50LmVsZW1lbnRJZF0sIGVuZHBvaW50LmlkKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uRGV0YWNoZWQgPSBmdW5jdGlvbiAoY29ubkluZm8sIGRvTm90UmVkcmF3KSB7XG4gICAgICAgICAgICB2YXIgY29ubmVjdGlvbiA9IGNvbm5JbmZvLmNvbm5lY3Rpb24gfHwgY29ubkluZm8sXG4gICAgICAgICAgICAgICAgc291cmNlSWQgPSBjb25uSW5mby5zb3VyY2VJZCxcbiAgICAgICAgICAgICAgICB0YXJnZXRJZCA9IGNvbm5JbmZvLnRhcmdldElkLFxuICAgICAgICAgICAgICAgIGVwID0gY29ubmVjdGlvbi5lbmRwb2ludHMsXG4gICAgICAgICAgICAgICAgcmVtb3ZlQ29ubmVjdGlvbiA9IGZ1bmN0aW9uIChvdGhlckluZGV4LCBvdGhlckVuZHBvaW50LCBvdGhlckFuY2hvciwgZWxJZCwgYykge1xuICAgICAgICAgICAgICAgICAgIF9qdS5yZW1vdmVXaXRoRnVuY3Rpb24oY29ubmVjdGlvbnNCeUVsZW1lbnRJZFtlbElkXSwgZnVuY3Rpb24gKF9jKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NbMF0uaWQgPT09IGMuaWQ7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJlbW92ZUNvbm5lY3Rpb24oMSwgZXBbMV0sIGVwWzFdLmFuY2hvciwgc291cmNlSWQsIGNvbm5lY3Rpb24pO1xuICAgICAgICAgICAgcmVtb3ZlQ29ubmVjdGlvbigwLCBlcFswXSwgZXBbMF0uYW5jaG9yLCB0YXJnZXRJZCwgY29ubmVjdGlvbik7XG4gICAgICAgICAgICBpZiAoY29ubmVjdGlvbi5mbG9hdGluZ0lkKSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlQ29ubmVjdGlvbihjb25uZWN0aW9uLmZsb2F0aW5nSW5kZXgsIGNvbm5lY3Rpb24uZmxvYXRpbmdFbmRwb2ludCwgY29ubmVjdGlvbi5mbG9hdGluZ0VuZHBvaW50LmFuY2hvciwgY29ubmVjdGlvbi5mbG9hdGluZ0lkLCBjb25uZWN0aW9uKTtcbiAgICAgICAgICAgICAgICByZW1vdmVFbmRwb2ludEZyb21BbmNob3JMaXN0cyhjb25uZWN0aW9uLmZsb2F0aW5nRW5kcG9pbnQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyByZW1vdmUgZnJvbSBhbmNob3JMaXN0cyAgICAgICAgICAgIFxuICAgICAgICAgICAgcmVtb3ZlRW5kcG9pbnRGcm9tQW5jaG9yTGlzdHMoY29ubmVjdGlvbi5lbmRwb2ludHNbMF0pO1xuICAgICAgICAgICAgcmVtb3ZlRW5kcG9pbnRGcm9tQW5jaG9yTGlzdHMoY29ubmVjdGlvbi5lbmRwb2ludHNbMV0pO1xuXG4gICAgICAgICAgICBpZiAoIWRvTm90UmVkcmF3KSB7XG4gICAgICAgICAgICAgICAgc2VsZi5yZWRyYXcoY29ubmVjdGlvbi5zb3VyY2VJZCk7XG4gICAgICAgICAgICAgICAgaWYgKGNvbm5lY3Rpb24udGFyZ2V0SWQgIT09IGNvbm5lY3Rpb24uc291cmNlSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5yZWRyYXcoY29ubmVjdGlvbi50YXJnZXRJZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmFkZCA9IGZ1bmN0aW9uIChlbmRwb2ludCwgZWxlbWVudElkKSB7XG4gICAgICAgICAgICBfanUuYWRkVG9MaXN0KF9hbUVuZHBvaW50cywgZWxlbWVudElkLCBlbmRwb2ludCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY2hhbmdlSWQgPSBmdW5jdGlvbiAob2xkSWQsIG5ld0lkKSB7XG4gICAgICAgICAgICBjb25uZWN0aW9uc0J5RWxlbWVudElkW25ld0lkXSA9IGNvbm5lY3Rpb25zQnlFbGVtZW50SWRbb2xkSWRdO1xuICAgICAgICAgICAgX2FtRW5kcG9pbnRzW25ld0lkXSA9IF9hbUVuZHBvaW50c1tvbGRJZF07XG4gICAgICAgICAgICBkZWxldGUgY29ubmVjdGlvbnNCeUVsZW1lbnRJZFtvbGRJZF07XG4gICAgICAgICAgICBkZWxldGUgX2FtRW5kcG9pbnRzW29sZElkXTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5nZXRDb25uZWN0aW9uc0ZvciA9IGZ1bmN0aW9uIChlbGVtZW50SWQpIHtcbiAgICAgICAgICAgIHJldHVybiBjb25uZWN0aW9uc0J5RWxlbWVudElkW2VsZW1lbnRJZF0gfHwgW107XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ2V0RW5kcG9pbnRzRm9yID0gZnVuY3Rpb24gKGVsZW1lbnRJZCkge1xuICAgICAgICAgICAgcmV0dXJuIF9hbUVuZHBvaW50c1tlbGVtZW50SWRdIHx8IFtdO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmRlbGV0ZUVuZHBvaW50ID0gZnVuY3Rpb24gKGVuZHBvaW50KSB7XG4gICAgICAgICAgICBfanUucmVtb3ZlV2l0aEZ1bmN0aW9uKF9hbUVuZHBvaW50c1tlbmRwb2ludC5lbGVtZW50SWRdLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlLmlkID09PSBlbmRwb2ludC5pZDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmVtb3ZlRW5kcG9pbnRGcm9tQW5jaG9yTGlzdHMoZW5kcG9pbnQpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNsZWFyRm9yID0gZnVuY3Rpb24gKGVsZW1lbnRJZCkge1xuICAgICAgICAgICAgZGVsZXRlIF9hbUVuZHBvaW50c1tlbGVtZW50SWRdO1xuICAgICAgICAgICAgX2FtRW5kcG9pbnRzW2VsZW1lbnRJZF0gPSBbXTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gdXBkYXRlcyB0aGUgZ2l2ZW4gYW5jaG9yIGxpc3QgYnkgZWl0aGVyIHVwZGF0aW5nIGFuIGV4aXN0aW5nIGFuY2hvcidzIGluZm8sIG9yIGFkZGluZyBpdC4gdGhpcyBmdW5jdGlvblxuICAgICAgICAvLyBhbHNvIHJlbW92ZXMgdGhlIGFuY2hvciBmcm9tIGl0cyBwcmV2aW91cyBsaXN0LCBpZiB0aGUgZWRnZSBpdCBpcyBvbiBoYXMgY2hhbmdlZC5cbiAgICAgICAgLy8gYWxsIGNvbm5lY3Rpb25zIGZvdW5kIGFsb25nIHRoZSB3YXkgKHRob3NlIHRoYXQgYXJlIGNvbm5lY3RlZCB0byBvbmUgb2YgdGhlIGZhY2VzIHRoaXMgZnVuY3Rpb25cbiAgICAgICAgLy8gb3BlcmF0ZXMgb24pIGFyZSBhZGRlZCB0byB0aGUgY29ubnNUb1BhaW50IGxpc3QsIGFzIGFyZSB0aGVpciBlbmRwb2ludHMuIGluIHRoaXMgd2F5IHdlIGtub3cgdG8gcmVwYWludFxuICAgICAgICAvLyB0aGVtIHd0aG91dCBoYXZpbmcgdG8gY2FsY3VsYXRlIGFueXRoaW5nIGVsc2UgYWJvdXQgdGhlbS5cbiAgICAgICAgdmFyIF91cGRhdGVBbmNob3JMaXN0ID0gZnVuY3Rpb24gKGxpc3RzLCB0aGV0YSwgb3JkZXIsIGNvbm4sIGFCb29sZWFuLCBvdGhlckVsSWQsIGlkeCwgcmV2ZXJzZSwgZWRnZUlkLCBlbElkLCBjb25uc1RvUGFpbnQsIGVuZHBvaW50c1RvUGFpbnQpIHtcbiAgICAgICAgICAgIC8vIGZpcnN0IHRyeSB0byBmaW5kIHRoZSBleGFjdCBtYXRjaCwgYnV0IGtlZXAgdHJhY2sgb2YgdGhlIGZpcnN0IGluZGV4IG9mIGEgbWF0Y2hpbmcgZWxlbWVudCBpZCBhbG9uZyB0aGUgd2F5LnNcbiAgICAgICAgICAgIHZhciBleGFjdElkeCA9IC0xLFxuICAgICAgICAgICAgICAgIGZpcnN0TWF0Y2hpbmdFbElkeCA9IC0xLFxuICAgICAgICAgICAgICAgIGVuZHBvaW50ID0gY29ubi5lbmRwb2ludHNbaWR4XSxcbiAgICAgICAgICAgICAgICBlbmRwb2ludElkID0gZW5kcG9pbnQuaWQsXG4gICAgICAgICAgICAgICAgb0lkeCA9IFsxLCAwXVtpZHhdLFxuICAgICAgICAgICAgICAgIHZhbHVlcyA9IFtcbiAgICAgICAgICAgICAgICAgICAgWyB0aGV0YSwgb3JkZXIgXSxcbiAgICAgICAgICAgICAgICAgICAgY29ubixcbiAgICAgICAgICAgICAgICAgICAgYUJvb2xlYW4sXG4gICAgICAgICAgICAgICAgICAgIG90aGVyRWxJZCxcbiAgICAgICAgICAgICAgICAgICAgZW5kcG9pbnRJZFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgbGlzdFRvQWRkVG8gPSBsaXN0c1tlZGdlSWRdLFxuICAgICAgICAgICAgICAgIGxpc3RUb1JlbW92ZUZyb20gPSBlbmRwb2ludC5fY29udGludW91c0FuY2hvckVkZ2UgPyBsaXN0c1tlbmRwb2ludC5fY29udGludW91c0FuY2hvckVkZ2VdIDogbnVsbCxcbiAgICAgICAgICAgICAgICBpLFxuICAgICAgICAgICAgICAgIGNhbmRpZGF0ZTtcblxuICAgICAgICAgICAgaWYgKGxpc3RUb1JlbW92ZUZyb20pIHtcbiAgICAgICAgICAgICAgICB2YXIgcklkeCA9IF9qdS5maW5kV2l0aEZ1bmN0aW9uKGxpc3RUb1JlbW92ZUZyb20sIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlWzRdID09PSBlbmRwb2ludElkO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChySWR4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBsaXN0VG9SZW1vdmVGcm9tLnNwbGljZShySWR4LCAxKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gZ2V0IGFsbCBjb25uZWN0aW9ucyBmcm9tIHRoaXMgbGlzdFxuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdFRvUmVtb3ZlRnJvbS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FuZGlkYXRlID0gbGlzdFRvUmVtb3ZlRnJvbVtpXVsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9qdS5hZGRXaXRoRnVuY3Rpb24oY29ubnNUb1BhaW50LCBjYW5kaWRhdGUsIGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGMuaWQgPT09IGNhbmRpZGF0ZS5pZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2p1LmFkZFdpdGhGdW5jdGlvbihlbmRwb2ludHNUb1BhaW50LCBsaXN0VG9SZW1vdmVGcm9tW2ldWzFdLmVuZHBvaW50c1tpZHhdLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlLmlkID09PSBjYW5kaWRhdGUuZW5kcG9pbnRzW2lkeF0uaWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9qdS5hZGRXaXRoRnVuY3Rpb24oZW5kcG9pbnRzVG9QYWludCwgbGlzdFRvUmVtb3ZlRnJvbVtpXVsxXS5lbmRwb2ludHNbb0lkeF0sIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUuaWQgPT09IGNhbmRpZGF0ZS5lbmRwb2ludHNbb0lkeF0uaWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxpc3RUb0FkZFRvLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY2FuZGlkYXRlID0gbGlzdFRvQWRkVG9baV1bMV07XG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5pZHggPT09IDEgJiYgbGlzdFRvQWRkVG9baV1bM10gPT09IG90aGVyRWxJZCAmJiBmaXJzdE1hdGNoaW5nRWxJZHggPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0TWF0Y2hpbmdFbElkeCA9IGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF9qdS5hZGRXaXRoRnVuY3Rpb24oY29ubnNUb1BhaW50LCBjYW5kaWRhdGUsIGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjLmlkID09PSBjYW5kaWRhdGUuaWQ7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgX2p1LmFkZFdpdGhGdW5jdGlvbihlbmRwb2ludHNUb1BhaW50LCBsaXN0VG9BZGRUb1tpXVsxXS5lbmRwb2ludHNbaWR4XSwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUuaWQgPT09IGNhbmRpZGF0ZS5lbmRwb2ludHNbaWR4XS5pZDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBfanUuYWRkV2l0aEZ1bmN0aW9uKGVuZHBvaW50c1RvUGFpbnQsIGxpc3RUb0FkZFRvW2ldWzFdLmVuZHBvaW50c1tvSWR4XSwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUuaWQgPT09IGNhbmRpZGF0ZS5lbmRwb2ludHNbb0lkeF0uaWQ7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXhhY3RJZHggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgbGlzdFRvQWRkVG9bZXhhY3RJZHhdID0gdmFsdWVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGluc2VydElkeCA9IHJldmVyc2UgPyBmaXJzdE1hdGNoaW5nRWxJZHggIT09IC0xID8gZmlyc3RNYXRjaGluZ0VsSWR4IDogMCA6IGxpc3RUb0FkZFRvLmxlbmd0aDsgLy8gb2YgY291cnNlIHdlIHdpbGwgZ2V0IHRoaXMgZnJvbSBoYXZpbmcgbG9va2VkIHRocm91Z2ggdGhlIGFycmF5IHNob3J0bHkuXG4gICAgICAgICAgICAgICAgbGlzdFRvQWRkVG8uc3BsaWNlKGluc2VydElkeCwgMCwgdmFsdWVzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gc3RvcmUgdGhpcyBmb3IgbmV4dCB0aW1lLlxuICAgICAgICAgICAgZW5kcG9pbnQuX2NvbnRpbnVvdXNBbmNob3JFZGdlID0gZWRnZUlkO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIGZpbmQgdGhlIGVudHJ5IGluIGFuIGVuZHBvaW50J3MgbGlzdCBmb3IgdGhpcyBjb25uZWN0aW9uIGFuZCB1cGRhdGUgaXRzIHRhcmdldCBlbmRwb2ludFxuICAgICAgICAvLyB3aXRoIHRoZSBjdXJyZW50IHRhcmdldCBpbiB0aGUgY29ubmVjdGlvbi5cbiAgICAgICAgLy8gVGhpcyBtZXRob2QgYW5kIHNvdXJjZUNoYW5nZWQgbmVlZCB0byBiZSBmb2xkZXIgaW50byBvbmUuXG4gICAgICAgIC8vXG4gICAgICAgIHRoaXMudXBkYXRlT3RoZXJFbmRwb2ludCA9IGZ1bmN0aW9uIChzb3VyY2VFbElkLCBvbGRUYXJnZXRJZCwgbmV3VGFyZ2V0SWQsIGNvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgIHZhciBzSW5kZXggPSBfanUuZmluZFdpdGhGdW5jdGlvbihjb25uZWN0aW9uc0J5RWxlbWVudElkW3NvdXJjZUVsSWRdLCBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaVswXS5pZCA9PT0gY29ubmVjdGlvbi5pZDtcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICB0SW5kZXggPSBfanUuZmluZFdpdGhGdW5jdGlvbihjb25uZWN0aW9uc0J5RWxlbWVudElkW29sZFRhcmdldElkXSwgZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlbMF0uaWQgPT09IGNvbm5lY3Rpb24uaWQ7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIHVwZGF0ZSBvciBhZGQgZGF0YSBmb3Igc291cmNlXG4gICAgICAgICAgICBpZiAoc0luZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25zQnlFbGVtZW50SWRbc291cmNlRWxJZF1bc0luZGV4XVswXSA9IGNvbm5lY3Rpb247XG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbnNCeUVsZW1lbnRJZFtzb3VyY2VFbElkXVtzSW5kZXhdWzFdID0gY29ubmVjdGlvbi5lbmRwb2ludHNbMV07XG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbnNCeUVsZW1lbnRJZFtzb3VyY2VFbElkXVtzSW5kZXhdWzJdID0gY29ubmVjdGlvbi5lbmRwb2ludHNbMV0uYW5jaG9yLmNvbnN0cnVjdG9yID09PSBfanAuRHluYW1pY0FuY2hvcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gcmVtb3ZlIGVudHJ5IGZvciBwcmV2aW91cyB0YXJnZXQgKGlmIHRoZXJlKVxuICAgICAgICAgICAgaWYgKHRJbmRleCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbnNCeUVsZW1lbnRJZFtvbGRUYXJnZXRJZF0uc3BsaWNlKHRJbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgLy8gYWRkIGVudHJ5IGZvciBuZXcgdGFyZ2V0XG4gICAgICAgICAgICAgICAgX2p1LmFkZFRvTGlzdChjb25uZWN0aW9uc0J5RWxlbWVudElkLCBuZXdUYXJnZXRJZCwgW2Nvbm5lY3Rpb24sIGNvbm5lY3Rpb24uZW5kcG9pbnRzWzBdLCBjb25uZWN0aW9uLmVuZHBvaW50c1swXS5hbmNob3IuY29uc3RydWN0b3IgPT09IF9qcC5EeW5hbWljQW5jaG9yXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbm5lY3Rpb24udXBkYXRlQ29ubmVjdGVkQ2xhc3MoKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvL1xuICAgICAgICAvLyBub3RpZmljYXRpb24gdGhhdCB0aGUgY29ubmVjdGlvbiBnaXZlbiBoYXMgY2hhbmdlZCBzb3VyY2UgZnJvbSB0aGUgb3JpZ2luYWxJZCB0byB0aGUgbmV3SWQuXG4gICAgICAgIC8vIFRoaXMgaW52b2x2ZXM6XG4gICAgICAgIC8vIDEuIHJlbW92aW5nIHRoZSBjb25uZWN0aW9uIGZyb20gdGhlIGxpc3Qgb2YgY29ubmVjdGlvbnMgc3RvcmVkIGZvciB0aGUgb3JpZ2luYWxJZFxuICAgICAgICAvLyAyLiB1cGRhdGluZyB0aGUgc291cmNlIGluZm9ybWF0aW9uIGZvciB0aGUgdGFyZ2V0IG9mIHRoZSBjb25uZWN0aW9uXG4gICAgICAgIC8vIDMuIHJlLXJlZ2lzdGVyaW5nIHRoZSBjb25uZWN0aW9uIGluIGNvbm5lY3Rpb25zQnlFbGVtZW50SWQgd2l0aCB0aGUgbmV3SWRcbiAgICAgICAgLy9cbiAgICAgICAgdGhpcy5zb3VyY2VDaGFuZ2VkID0gZnVuY3Rpb24gKG9yaWdpbmFsSWQsIG5ld0lkLCBjb25uZWN0aW9uLCBuZXdFbGVtZW50KSB7XG4gICAgICAgICAgICBpZiAob3JpZ2luYWxJZCAhPT0gbmV3SWQpIHtcblxuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb24uc291cmNlSWQgPSBuZXdJZDtcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uLnNvdXJjZSA9IG5ld0VsZW1lbnQ7XG5cbiAgICAgICAgICAgICAgICAvLyByZW1vdmUgdGhlIGVudHJ5IHRoYXQgcG9pbnRzIGZyb20gdGhlIG9sZCBzb3VyY2UgdG8gdGhlIHRhcmdldFxuICAgICAgICAgICAgICAgIF9qdS5yZW1vdmVXaXRoRnVuY3Rpb24oY29ubmVjdGlvbnNCeUVsZW1lbnRJZFtvcmlnaW5hbElkXSwgZnVuY3Rpb24gKGluZm8pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGluZm9bMF0uaWQgPT09IGNvbm5lY3Rpb24uaWQ7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gZmluZCBlbnRyeSBmb3IgdGFyZ2V0IGFuZCB1cGRhdGUgaXRcbiAgICAgICAgICAgICAgICB2YXIgdElkeCA9IF9qdS5maW5kV2l0aEZ1bmN0aW9uKGNvbm5lY3Rpb25zQnlFbGVtZW50SWRbY29ubmVjdGlvbi50YXJnZXRJZF0sIGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpWzBdLmlkID09PSBjb25uZWN0aW9uLmlkO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmICh0SWR4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbnNCeUVsZW1lbnRJZFtjb25uZWN0aW9uLnRhcmdldElkXVt0SWR4XVswXSA9IGNvbm5lY3Rpb247XG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25zQnlFbGVtZW50SWRbY29ubmVjdGlvbi50YXJnZXRJZF1bdElkeF1bMV0gPSBjb25uZWN0aW9uLmVuZHBvaW50c1swXTtcbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbnNCeUVsZW1lbnRJZFtjb25uZWN0aW9uLnRhcmdldElkXVt0SWR4XVsyXSA9IGNvbm5lY3Rpb24uZW5kcG9pbnRzWzBdLmFuY2hvci5jb25zdHJ1Y3RvciA9PT0gX2pwLkR5bmFtaWNBbmNob3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGFkZCBlbnRyeSBmb3IgbmV3IHNvdXJjZVxuICAgICAgICAgICAgICAgIF9qdS5hZGRUb0xpc3QoY29ubmVjdGlvbnNCeUVsZW1lbnRJZCwgbmV3SWQsIFtjb25uZWN0aW9uLCBjb25uZWN0aW9uLmVuZHBvaW50c1sxXSwgY29ubmVjdGlvbi5lbmRwb2ludHNbMV0uYW5jaG9yLmNvbnN0cnVjdG9yID09PSBfanAuRHluYW1pY0FuY2hvcl0pO1xuXG4gICAgICAgICAgICAgICAgLy8gVE9ETyBTUCBub3QgZmluYWwgb24gdGhpcyB5ZXQuIHdoZW4gYSB1c2VyIGRyYWdzIGFuIGV4aXN0aW5nIGNvbm5lY3Rpb24gYW5kIGl0IHR1cm5zIGludG8gYSBzZWxmXG4gICAgICAgICAgICAgICAgLy8gbG9vcCwgdGhlbiB0aGlzIGNvZGUgaGlkZXMgdGhlIHRhcmdldCBlbmRwb2ludCAoYnkgcmVtb3ZpbmcgaXQgZnJvbSB0aGUgRE9NKSBCdXQgSSB0aGluayB0aGlzIHNob3VsZFxuICAgICAgICAgICAgICAgIC8vIG9jY3VyIG9ubHkgaWYgdGhlIGFuY2hvciBpcyBDb250aW51b3VzXG4gICAgICAgICAgICAgICAgaWYgKGNvbm5lY3Rpb24uZW5kcG9pbnRzWzFdLmFuY2hvci5pc0NvbnRpbnVvdXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbm5lY3Rpb24uc291cmNlID09PSBjb25uZWN0aW9uLnRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbi5fanNQbHVtYi5pbnN0YW5jZS5yZW1vdmVFbGVtZW50KGNvbm5lY3Rpb24uZW5kcG9pbnRzWzFdLmNhbnZhcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29ubmVjdGlvbi5lbmRwb2ludHNbMV0uY2FudmFzLnBhcmVudE5vZGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb24uX2pzUGx1bWIuaW5zdGFuY2UuYXBwZW5kRWxlbWVudChjb25uZWN0aW9uLmVuZHBvaW50c1sxXS5jYW52YXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbi51cGRhdGVDb25uZWN0ZWRDbGFzcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIG1vdmVzIHRoZSBnaXZlbiBlbmRwb2ludCBmcm9tIGBjdXJyZW50SWRgIHRvIGBlbGVtZW50YC5cbiAgICAgICAgLy8gVGhpcyBpbnZvbHZlczpcbiAgICAgICAgLy9cbiAgICAgICAgLy8gMS4gY2hhbmdpbmcgdGhlIGtleSBpbiBfYW1FbmRwb2ludHMgdW5kZXIgd2hpY2ggdGhlIGVuZHBvaW50IGlzIHN0b3JlZFxuICAgICAgICAvLyAyLiBjaGFuZ2luZyB0aGUgc291cmNlIG9yIHRhcmdldCB2YWx1ZXMgaW4gYWxsIG9mIHRoZSBlbmRwb2ludCdzIGNvbm5lY3Rpb25zXG4gICAgICAgIC8vIDMuIGNoYW5naW5nIHRoZSBhcnJheSBpbiBjb25uZWN0aW9uc0J5RWxlbWVudElkIGluIHdoaWNoIHRoZSBlbmRwb2ludCdzIGNvbm5lY3Rpb25zXG4gICAgICAgIC8vICAgIGFyZSBzdG9yZWQgKGRvbmUgYnkgZWl0aGVyIHNvdXJjZUNoYW5nZWQgb3IgdXBkYXRlT3RoZXJFbmRwb2ludClcbiAgICAgICAgLy9cbiAgICAgICAgdGhpcy5yZWhvbWVFbmRwb2ludCA9IGZ1bmN0aW9uIChlcCwgY3VycmVudElkLCBlbGVtZW50KSB7XG4gICAgICAgICAgICB2YXIgZXBzID0gX2FtRW5kcG9pbnRzW2N1cnJlbnRJZF0gfHwgW10sXG4gICAgICAgICAgICAgICAgZWxlbWVudElkID0ganNQbHVtYkluc3RhbmNlLmdldElkKGVsZW1lbnQpO1xuXG4gICAgICAgICAgICBpZiAoZWxlbWVudElkICE9PSBjdXJyZW50SWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgaWR4ID0gZXBzLmluZGV4T2YoZXApO1xuICAgICAgICAgICAgICAgIGlmIChpZHggPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2VwID0gZXBzLnNwbGljZShpZHgsIDEpWzBdO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmFkZChfZXAsIGVsZW1lbnRJZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVwLmNvbm5lY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVwLmNvbm5lY3Rpb25zW2ldLnNvdXJjZUlkID09PSBjdXJyZW50SWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5zb3VyY2VDaGFuZ2VkKGN1cnJlbnRJZCwgZXAuZWxlbWVudElkLCBlcC5jb25uZWN0aW9uc1tpXSwgZXAuZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGVwLmNvbm5lY3Rpb25zW2ldLnRhcmdldElkID09PSBjdXJyZW50SWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZXAuY29ubmVjdGlvbnNbaV0udGFyZ2V0SWQgPSBlcC5lbGVtZW50SWQ7XG4gICAgICAgICAgICAgICAgICAgIGVwLmNvbm5lY3Rpb25zW2ldLnRhcmdldCA9IGVwLmVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYudXBkYXRlT3RoZXJFbmRwb2ludChlcC5jb25uZWN0aW9uc1tpXS5zb3VyY2VJZCwgY3VycmVudElkLCBlcC5lbGVtZW50SWQsIGVwLmNvbm5lY3Rpb25zW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5yZWRyYXcgPSBmdW5jdGlvbiAoZWxlbWVudElkLCB1aSwgdGltZXN0YW1wLCBvZmZzZXRUb1VJLCBjbGVhckVkaXRzLCBkb05vdFJlY2FsY0VuZHBvaW50KSB7XG5cbiAgICAgICAgICAgIGlmICghanNQbHVtYkluc3RhbmNlLmlzU3VzcGVuZERyYXdpbmcoKSkge1xuICAgICAgICAgICAgICAgIC8vIGdldCBhbGwgdGhlIGVuZHBvaW50cyBmb3IgdGhpcyBlbGVtZW50XG4gICAgICAgICAgICAgICAgdmFyIGVwID0gX2FtRW5kcG9pbnRzW2VsZW1lbnRJZF0gfHwgW10sXG4gICAgICAgICAgICAgICAgICAgIGVuZHBvaW50Q29ubmVjdGlvbnMgPSBjb25uZWN0aW9uc0J5RWxlbWVudElkW2VsZW1lbnRJZF0gfHwgW10sXG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25zVG9QYWludCA9IFtdLFxuICAgICAgICAgICAgICAgICAgICBlbmRwb2ludHNUb1BhaW50ID0gW10sXG4gICAgICAgICAgICAgICAgICAgIGFuY2hvcnNUb1VwZGF0ZSA9IFtdO1xuXG4gICAgICAgICAgICAgICAgdGltZXN0YW1wID0gdGltZXN0YW1wIHx8IGpzUGx1bWJJbnN0YW5jZS50aW1lc3RhbXAoKTtcbiAgICAgICAgICAgICAgICAvLyBvZmZzZXRUb1VJIGFyZSB2YWx1ZXMgdGhhdCB3b3VsZCBoYXZlIGJlZW4gY2FsY3VsYXRlZCBpbiB0aGUgZHJhZ01hbmFnZXIgd2hlbiByZWdpc3RlcmluZ1xuICAgICAgICAgICAgICAgIC8vIGFuIGVuZHBvaW50IGZvciBhbiBlbGVtZW50IHRoYXQgaGFkIGEgcGFyZW50IChzb21ld2hlcmUgaW4gdGhlIGhpZXJhcmNoeSkgdGhhdCBoYWQgYmVlblxuICAgICAgICAgICAgICAgIC8vIHJlZ2lzdGVyZWQgYXMgZHJhZ2dhYmxlLlxuICAgICAgICAgICAgICAgIG9mZnNldFRvVUkgPSBvZmZzZXRUb1VJIHx8IHtsZWZ0OiAwLCB0b3A6IDB9O1xuICAgICAgICAgICAgICAgIGlmICh1aSkge1xuICAgICAgICAgICAgICAgICAgICB1aSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IHVpLmxlZnQgKyBvZmZzZXRUb1VJLmxlZnQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3A6IHVpLnRvcCArIG9mZnNldFRvVUkudG9wXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gdmFsaWQgZm9yIG9uZSBwYWludCBjeWNsZS5cbiAgICAgICAgICAgICAgICB2YXIgbXlPZmZzZXQgPSBqc1BsdW1iSW5zdGFuY2UudXBkYXRlT2Zmc2V0KHsgZWxJZDogZWxlbWVudElkLCBvZmZzZXQ6IHVpLCByZWNhbGM6IGZhbHNlLCB0aW1lc3RhbXA6IHRpbWVzdGFtcCB9KSxcbiAgICAgICAgICAgICAgICAgICAgb3JpZW50YXRpb25DYWNoZSA9IHt9O1xuXG4gICAgICAgICAgICAgICAgLy8gYWN0dWFsbHksIGZpcnN0IHdlIHNob3VsZCBjb21wdXRlIHRoZSBvcmllbnRhdGlvbiBvZiB0aGlzIGVsZW1lbnQgdG8gYWxsIG90aGVyIGVsZW1lbnRzIHRvIHdoaWNoXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBlbGVtZW50IGlzIGNvbm5lY3RlZCB3aXRoIGEgY29udGludW91cyBhbmNob3IgKHdoZXRoZXIgYm90aCBlbmRzIG9mIHRoZSBjb25uZWN0aW9uIGhhdmVcbiAgICAgICAgICAgICAgICAvLyBhIGNvbnRpbnVvdXMgYW5jaG9yIG9yIGp1c3Qgb25lKVxuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbmRwb2ludENvbm5lY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb25uID0gZW5kcG9pbnRDb25uZWN0aW9uc1tpXVswXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZUlkID0gY29ubi5zb3VyY2VJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldElkID0gY29ubi50YXJnZXRJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZUNvbnRpbnVvdXMgPSBjb25uLmVuZHBvaW50c1swXS5hbmNob3IuaXNDb250aW51b3VzLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Q29udGludW91cyA9IGNvbm4uZW5kcG9pbnRzWzFdLmFuY2hvci5pc0NvbnRpbnVvdXM7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZUNvbnRpbnVvdXMgfHwgdGFyZ2V0Q29udGludW91cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9LZXkgPSBzb3VyY2VJZCArIFwiX1wiICsgdGFyZ2V0SWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbyA9IG9yaWVudGF0aW9uQ2FjaGVbb0tleV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb0lkeCA9IGNvbm4uc291cmNlSWQgPT09IGVsZW1lbnRJZCA/IDEgOiAwO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc291cmNlQ29udGludW91cyAmJiAhYW5jaG9yTGlzdHNbc291cmNlSWRdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5jaG9yTGlzdHNbc291cmNlSWRdID0geyB0b3A6IFtdLCByaWdodDogW10sIGJvdHRvbTogW10sIGxlZnQ6IFtdIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0Q29udGludW91cyAmJiAhYW5jaG9yTGlzdHNbdGFyZ2V0SWRdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5jaG9yTGlzdHNbdGFyZ2V0SWRdID0geyB0b3A6IFtdLCByaWdodDogW10sIGJvdHRvbTogW10sIGxlZnQ6IFtdIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50SWQgIT09IHRhcmdldElkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAganNQbHVtYkluc3RhbmNlLnVwZGF0ZU9mZnNldCh7IGVsSWQ6IHRhcmdldElkLCB0aW1lc3RhbXA6IHRpbWVzdGFtcCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50SWQgIT09IHNvdXJjZUlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAganNQbHVtYkluc3RhbmNlLnVwZGF0ZU9mZnNldCh7IGVsSWQ6IHNvdXJjZUlkLCB0aW1lc3RhbXA6IHRpbWVzdGFtcCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRkID0ganNQbHVtYkluc3RhbmNlLmdldENhY2hlZERhdGEodGFyZ2V0SWQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNkID0ganNQbHVtYkluc3RhbmNlLmdldENhY2hlZERhdGEoc291cmNlSWQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0SWQgPT09IHNvdXJjZUlkICYmIChzb3VyY2VDb250aW51b3VzIHx8IHRhcmdldENvbnRpbnVvdXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaGVyZSB3ZSBtYXkgd2FudCB0byBpbXByb3ZlIHRoaXMgYnkgc29tZWhvdyBkZXRlcm1pbmluZyB0aGUgZmFjZSB3ZSdkIGxpa2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0byBwdXQgdGhlIGNvbm5lY3RvciBvbi4gIGlkZWFsbHksIHdoZW4gZHJhd2luZywgdGhlIGZhY2Ugc2hvdWxkIGJlIGNhbGN1bGF0ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBieSBkZXRlcm1pbmluZyB3aGljaCBmYWNlIGlzIGNsb3Nlc3QgdG8gdGhlIHBvaW50IGF0IHdoaWNoIHRoZSBtb3VzZSBidXR0b25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3YXMgcmVsZWFzZWQuICBmb3Igbm93LCB3ZSdyZSBwdXR0aW5nIGl0IG9uIHRoZSB0b3AgZmFjZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdXBkYXRlQW5jaG9yTGlzdCggYW5jaG9yTGlzdHNbc291cmNlSWRdLCAtTWF0aC5QSSAvIDIsIDAsIGNvbm4sIGZhbHNlLCB0YXJnZXRJZCwgMCwgZmFsc2UsIFwidG9wXCIsIHNvdXJjZUlkLCBjb25uZWN0aW9uc1RvUGFpbnQsIGVuZHBvaW50c1RvUGFpbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF91cGRhdGVBbmNob3JMaXN0KCBhbmNob3JMaXN0c1t0YXJnZXRJZF0sIC1NYXRoLlBJIC8gMiwgMCwgY29ubiwgZmFsc2UsIHNvdXJjZUlkLCAxLCBmYWxzZSwgXCJ0b3BcIiwgdGFyZ2V0SWQsIGNvbm5lY3Rpb25zVG9QYWludCwgZW5kcG9pbnRzVG9QYWludCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbyA9IGNhbGN1bGF0ZU9yaWVudGF0aW9uKHNvdXJjZUlkLCB0YXJnZXRJZCwgc2QubywgdGQubywgY29ubi5lbmRwb2ludHNbMF0uYW5jaG9yLCBjb25uLmVuZHBvaW50c1sxXS5hbmNob3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmllbnRhdGlvbkNhY2hlW29LZXldID0gbztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyB3b3VsZCBiZSBhIHBlcmZvcm1hbmNlIGVuaGFuY2VtZW50LCBidXQgdGhlIGNvbXB1dGVkIGFuZ2xlcyBuZWVkIHRvIGJlIGNsYW1wZWQgdG9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy90aGUgKC1QSS8yIC0+IFBJLzIpIHJhbmdlIGluIG9yZGVyIGZvciB0aGUgc29ydGluZyB0byB3b3JrIHByb3Blcmx5LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiAgb3JpZW50YXRpb25DYWNoZVtvS2V5Ml0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmllbnRhdGlvbjpvLm9yaWVudGF0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYTpbby5hWzFdLCBvLmFbMF1dLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhldGE6by50aGV0YSArIE1hdGguUEksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGV0YTI6by50aGV0YTIgKyBNYXRoLlBJXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9OyovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2VDb250aW51b3VzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF91cGRhdGVBbmNob3JMaXN0KGFuY2hvckxpc3RzW3NvdXJjZUlkXSwgby50aGV0YSwgMCwgY29ubiwgZmFsc2UsIHRhcmdldElkLCAwLCBmYWxzZSwgby5hWzBdLCBzb3VyY2VJZCwgY29ubmVjdGlvbnNUb1BhaW50LCBlbmRwb2ludHNUb1BhaW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldENvbnRpbnVvdXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3VwZGF0ZUFuY2hvckxpc3QoYW5jaG9yTGlzdHNbdGFyZ2V0SWRdLCBvLnRoZXRhMiwgLTEsIGNvbm4sIHRydWUsIHNvdXJjZUlkLCAxLCB0cnVlLCBvLmFbMV0sIHRhcmdldElkLCBjb25uZWN0aW9uc1RvUGFpbnQsIGVuZHBvaW50c1RvUGFpbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZUNvbnRpbnVvdXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfanUuYWRkV2l0aEZ1bmN0aW9uKGFuY2hvcnNUb1VwZGF0ZSwgc291cmNlSWQsIGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhID09PSBzb3VyY2VJZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXRDb250aW51b3VzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2p1LmFkZFdpdGhGdW5jdGlvbihhbmNob3JzVG9VcGRhdGUsIHRhcmdldElkLCBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYSA9PT0gdGFyZ2V0SWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBfanUuYWRkV2l0aEZ1bmN0aW9uKGNvbm5lY3Rpb25zVG9QYWludCwgY29ubiwgZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYy5pZCA9PT0gY29ubi5pZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChzb3VyY2VDb250aW51b3VzICYmIG9JZHggPT09IDApIHx8ICh0YXJnZXRDb250aW51b3VzICYmIG9JZHggPT09IDEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2p1LmFkZFdpdGhGdW5jdGlvbihlbmRwb2ludHNUb1BhaW50LCBjb25uLmVuZHBvaW50c1tvSWR4XSwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUuaWQgPT09IGNvbm4uZW5kcG9pbnRzW29JZHhdLmlkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gcGxhY2UgRW5kcG9pbnRzIHdob3NlIGFuY2hvcnMgYXJlIGNvbnRpbnVvdXMgYnV0IGhhdmUgbm8gQ29ubmVjdGlvbnNcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZXAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVwW2ldLmNvbm5lY3Rpb25zLmxlbmd0aCA9PT0gMCAmJiBlcFtpXS5hbmNob3IuaXNDb250aW51b3VzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWFuY2hvckxpc3RzW2VsZW1lbnRJZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmNob3JMaXN0c1tlbGVtZW50SWRdID0geyB0b3A6IFtdLCByaWdodDogW10sIGJvdHRvbTogW10sIGxlZnQ6IFtdIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBfdXBkYXRlQW5jaG9yTGlzdChhbmNob3JMaXN0c1tlbGVtZW50SWRdLCAtTWF0aC5QSSAvIDIsIDAsIHtlbmRwb2ludHM6IFtlcFtpXSwgZXBbaV1dLCBwYWludDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgfX0sIGZhbHNlLCBlbGVtZW50SWQsIDAsIGZhbHNlLCBlcFtpXS5hbmNob3IuZ2V0RGVmYXVsdEZhY2UoKSwgZWxlbWVudElkLCBjb25uZWN0aW9uc1RvUGFpbnQsIGVuZHBvaW50c1RvUGFpbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2p1LmFkZFdpdGhGdW5jdGlvbihhbmNob3JzVG9VcGRhdGUsIGVsZW1lbnRJZCwgZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYSA9PT0gZWxlbWVudElkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBub3cgcGxhY2UgYWxsIHRoZSBjb250aW51b3VzIGFuY2hvcnMgd2UgbmVlZCB0bztcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYW5jaG9yc1RvVXBkYXRlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHBsYWNlQW5jaG9ycyhhbmNob3JzVG9VcGRhdGVbaV0sIGFuY2hvckxpc3RzW2FuY2hvcnNUb1VwZGF0ZVtpXV0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIG5vdyB0aGF0IGNvbnRpbnVvdXMgYW5jaG9ycyBoYXZlIGJlZW4gcGxhY2VkLCBwYWludCBhbGwgdGhlIGVuZHBvaW50cyBmb3IgdGhpcyBlbGVtZW50XG4gICAgICAgICAgICAgICAgLy8gVE9ETyBwZXJmb3JtYW5jZTogYWRkIHRoZSBlbmRwb2ludCBpZHMgdG8gYSB0ZW1wIGFycmF5LCBhbmQgdGhlbiB3aGVuIGl0ZXJhdGluZyBpbiB0aGUgbmV4dFxuICAgICAgICAgICAgICAgIC8vIGxvb3AsIGNoZWNrIHRoYXQgd2UgZGlkbid0IGp1c3QgcGFpbnQgdGhhdCBlbmRwb2ludC4gd2UgY2FuIHByb2JhYmx5IHNoYXZlIG9mZiBhIGZldyBtb3JlIG1pbGxpc2Vjb25kcyB0aGlzIHdheS5cbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZXAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZXBbaV0ucGFpbnQoeyB0aW1lc3RhbXA6IHRpbWVzdGFtcCwgb2Zmc2V0OiBteU9mZnNldCwgZGltZW5zaW9uczogbXlPZmZzZXQucywgcmVjYWxjOiBkb05vdFJlY2FsY0VuZHBvaW50ICE9PSB0cnVlIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIC4uLiBhbmQgYW55IG90aGVyIGVuZHBvaW50cyB3ZSBjYW1lIGFjcm9zcyBhcyBhIHJlc3VsdCBvZiB0aGUgY29udGludW91cyBhbmNob3JzLlxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBlbmRwb2ludHNUb1BhaW50Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjZCA9IGpzUGx1bWJJbnN0YW5jZS5nZXRDYWNoZWREYXRhKGVuZHBvaW50c1RvUGFpbnRbaV0uZWxlbWVudElkKTtcbiAgICAgICAgICAgICAgICAgICAgZW5kcG9pbnRzVG9QYWludFtpXS5wYWludCh7IHRpbWVzdGFtcDogdGltZXN0YW1wLCBvZmZzZXQ6IGNkLCBkaW1lbnNpb25zOiBjZC5zIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHBhaW50IGFsbCB0aGUgc3RhbmRhcmQgYW5kIFwiZHluYW1pYyBjb25uZWN0aW9uc1wiLCB3aGljaCBhcmUgY29ubmVjdGlvbnMgd2hvc2Ugb3RoZXIgYW5jaG9yIGlzXG4gICAgICAgICAgICAgICAgLy8gc3RhdGljIGFuZCB0aGVyZWZvcmUgZG9lcyBuZWVkIHRvIGJlIHJlY29tcHV0ZWQ7IHdlIG1ha2Ugc3VyZSB0aGF0IGhhcHBlbnMgb25seSBvbmUgdGltZS5cblxuICAgICAgICAgICAgICAgIC8vIFRPRE8gd2UgY291bGQgaGF2ZSBjb21waWxlZCBhIGxpc3Qgb2YgdGhlc2UgaW4gdGhlIGZpcnN0IHBhc3MgdGhyb3VnaCBjb25uZWN0aW9uczsgbWlnaHQgc2F2ZSBzb21lIHRpbWUuXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGVuZHBvaW50Q29ubmVjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG90aGVyRW5kcG9pbnQgPSBlbmRwb2ludENvbm5lY3Rpb25zW2ldWzFdO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3RoZXJFbmRwb2ludC5hbmNob3IuY29uc3RydWN0b3IgPT09IF9qcC5EeW5hbWljQW5jaG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdGhlckVuZHBvaW50LnBhaW50KHsgZWxlbWVudFdpdGhQcmVjZWRlbmNlOiBlbGVtZW50SWQsIHRpbWVzdGFtcDogdGltZXN0YW1wIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2p1LmFkZFdpdGhGdW5jdGlvbihjb25uZWN0aW9uc1RvUGFpbnQsIGVuZHBvaW50Q29ubmVjdGlvbnNbaV1bMF0sIGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGMuaWQgPT09IGVuZHBvaW50Q29ubmVjdGlvbnNbaV1bMF0uaWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFsbCB0aGUgY29ubmVjdGlvbnMgZm9yIHRoZSBvdGhlciBlbmRwb2ludCBub3cgbmVlZCB0byBiZSByZXBhaW50ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgb3RoZXJFbmRwb2ludC5jb25uZWN0aW9ucy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvdGhlckVuZHBvaW50LmNvbm5lY3Rpb25zW2tdICE9PSBlbmRwb2ludENvbm5lY3Rpb25zW2ldWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9qdS5hZGRXaXRoRnVuY3Rpb24oY29ubmVjdGlvbnNUb1BhaW50LCBvdGhlckVuZHBvaW50LmNvbm5lY3Rpb25zW2tdLCBmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGMuaWQgPT09IG90aGVyRW5kcG9pbnQuY29ubmVjdGlvbnNba10uaWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChvdGhlckVuZHBvaW50LmFuY2hvci5jb25zdHJ1Y3RvciA9PT0gX2pwLkFuY2hvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2p1LmFkZFdpdGhGdW5jdGlvbihjb25uZWN0aW9uc1RvUGFpbnQsIGVuZHBvaW50Q29ubmVjdGlvbnNbaV1bMF0sIGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGMuaWQgPT09IGVuZHBvaW50Q29ubmVjdGlvbnNbaV1bMF0uaWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHBhaW50IGN1cnJlbnQgZmxvYXRpbmcgY29ubmVjdGlvbiBmb3IgdGhpcyBlbGVtZW50LCBpZiB0aGVyZSBpcyBvbmUuXG4gICAgICAgICAgICAgICAgdmFyIGZjID0gZmxvYXRpbmdDb25uZWN0aW9uc1tlbGVtZW50SWRdO1xuICAgICAgICAgICAgICAgIGlmIChmYykge1xuICAgICAgICAgICAgICAgICAgICBmYy5wYWludCh7dGltZXN0YW1wOiB0aW1lc3RhbXAsIHJlY2FsYzogZmFsc2UsIGVsSWQ6IGVsZW1lbnRJZH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHBhaW50IGFsbCB0aGUgY29ubmVjdGlvbnNcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY29ubmVjdGlvbnNUb1BhaW50Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25zVG9QYWludFtpXS5wYWludCh7ZWxJZDogZWxlbWVudElkLCB0aW1lc3RhbXA6IHRpbWVzdGFtcCwgcmVjYWxjOiBmYWxzZSwgY2xlYXJFZGl0czogY2xlYXJFZGl0c30pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgQ29udGludW91c0FuY2hvciA9IGZ1bmN0aW9uIChhbmNob3JQYXJhbXMpIHtcbiAgICAgICAgICAgIF9qdS5FdmVudEdlbmVyYXRvci5hcHBseSh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFwiQ29udGludW91c1wiO1xuICAgICAgICAgICAgdGhpcy5pc0R5bmFtaWMgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5pc0NvbnRpbnVvdXMgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIGZhY2VzID0gYW5jaG9yUGFyYW1zLmZhY2VzIHx8IFtcInRvcFwiLCBcInJpZ2h0XCIsIFwiYm90dG9tXCIsIFwibGVmdFwiXSxcbiAgICAgICAgICAgICAgICBjbG9ja3dpc2UgPSAhKGFuY2hvclBhcmFtcy5jbG9ja3dpc2UgPT09IGZhbHNlKSxcbiAgICAgICAgICAgICAgICBhdmFpbGFibGVGYWNlcyA9IHsgfSxcbiAgICAgICAgICAgICAgICBvcHBvc2l0ZXMgPSB7IFwidG9wXCI6IFwiYm90dG9tXCIsIFwicmlnaHRcIjogXCJsZWZ0XCIsIFwibGVmdFwiOiBcInJpZ2h0XCIsIFwiYm90dG9tXCI6IFwidG9wXCIgfSxcbiAgICAgICAgICAgICAgICBjbG9ja3dpc2VPcHRpb25zID0geyBcInRvcFwiOiBcInJpZ2h0XCIsIFwicmlnaHRcIjogXCJib3R0b21cIiwgXCJsZWZ0XCI6IFwidG9wXCIsIFwiYm90dG9tXCI6IFwibGVmdFwiIH0sXG4gICAgICAgICAgICAgICAgYW50aUNsb2Nrd2lzZU9wdGlvbnMgPSB7IFwidG9wXCI6IFwibGVmdFwiLCBcInJpZ2h0XCI6IFwidG9wXCIsIFwibGVmdFwiOiBcImJvdHRvbVwiLCBcImJvdHRvbVwiOiBcInJpZ2h0XCIgfSxcbiAgICAgICAgICAgICAgICBzZWNvbmRCZXN0ID0gY2xvY2t3aXNlID8gY2xvY2t3aXNlT3B0aW9ucyA6IGFudGlDbG9ja3dpc2VPcHRpb25zLFxuICAgICAgICAgICAgICAgIGxhc3RDaG9pY2UgPSBjbG9ja3dpc2UgPyBhbnRpQ2xvY2t3aXNlT3B0aW9ucyA6IGNsb2Nrd2lzZU9wdGlvbnMsXG4gICAgICAgICAgICAgICAgY3NzQ2xhc3MgPSBhbmNob3JQYXJhbXMuY3NzQ2xhc3MgfHwgXCJcIjtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmYWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGF2YWlsYWJsZUZhY2VzW2ZhY2VzW2ldXSA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuZ2V0RGVmYXVsdEZhY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhY2VzLmxlbmd0aCA9PT0gMCA/IFwidG9wXCIgOiBmYWNlc1swXTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIGlmIHRoZSBnaXZlbiBlZGdlIGlzIHN1cHBvcnRlZCwgcmV0dXJucyBpdC4gb3RoZXJ3aXNlIGxvb2tzIGZvciBhIHN1YnN0aXR1dGUgdGhhdCBfaXNfXG4gICAgICAgICAgICAvLyBzdXBwb3J0ZWQuIGlmIG5vbmUgc3VwcG9ydGVkIHdlIGFsc28gcmV0dXJuIHRoZSByZXF1ZXN0IGVkZ2UuXG4gICAgICAgICAgICB0aGlzLnZlcmlmeUVkZ2UgPSBmdW5jdGlvbiAoZWRnZSkge1xuICAgICAgICAgICAgICAgIGlmIChhdmFpbGFibGVGYWNlc1tlZGdlXSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWRnZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYXZhaWxhYmxlRmFjZXNbb3Bwb3NpdGVzW2VkZ2VdXSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3Bwb3NpdGVzW2VkZ2VdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChhdmFpbGFibGVGYWNlc1tzZWNvbmRCZXN0W2VkZ2VdXSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2Vjb25kQmVzdFtlZGdlXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYXZhaWxhYmxlRmFjZXNbbGFzdENob2ljZVtlZGdlXV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxhc3RDaG9pY2VbZWRnZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBlZGdlOyAvLyB3ZSBoYXZlIHRvIGdpdmUgdGhlbSBzb21ldGhpbmcuXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB0aGlzLmlzRWRnZVN1cHBvcnRlZCA9IGZ1bmN0aW9uIChlZGdlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF2YWlsYWJsZUZhY2VzW2VkZ2VdID09PSB0cnVlO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdGhpcy5jb21wdXRlID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICAgICAgICAgIHJldHVybiB1c2VyRGVmaW5lZENvbnRpbnVvdXNBbmNob3JMb2NhdGlvbnNbcGFyYW1zLmVsZW1lbnQuaWRdIHx8IGNvbnRpbnVvdXNBbmNob3JMb2NhdGlvbnNbcGFyYW1zLmVsZW1lbnQuaWRdIHx8IFswLCAwXTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLmdldEN1cnJlbnRMb2NhdGlvbiA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdXNlckRlZmluZWRDb250aW51b3VzQW5jaG9yTG9jYXRpb25zW3BhcmFtcy5lbGVtZW50LmlkXSB8fCBjb250aW51b3VzQW5jaG9yTG9jYXRpb25zW3BhcmFtcy5lbGVtZW50LmlkXSB8fCBbMCwgMF07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5nZXRPcmllbnRhdGlvbiA9IGZ1bmN0aW9uIChlbmRwb2ludCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb250aW51b3VzQW5jaG9yT3JpZW50YXRpb25zW2VuZHBvaW50LmlkXSB8fCBbMCwgMF07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5jbGVhclVzZXJEZWZpbmVkTG9jYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHVzZXJEZWZpbmVkQ29udGludW91c0FuY2hvckxvY2F0aW9uc1thbmNob3JQYXJhbXMuZWxlbWVudElkXTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLnNldFVzZXJEZWZpbmVkTG9jYXRpb24gPSBmdW5jdGlvbiAobG9jKSB7XG4gICAgICAgICAgICAgICAgdXNlckRlZmluZWRDb250aW51b3VzQW5jaG9yTG9jYXRpb25zW2FuY2hvclBhcmFtcy5lbGVtZW50SWRdID0gbG9jO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuZ2V0Q3NzQ2xhc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNzc0NsYXNzO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBjb250aW51b3VzIGFuY2hvcnNcbiAgICAgICAganNQbHVtYkluc3RhbmNlLmNvbnRpbnVvdXNBbmNob3JGYWN0b3J5ID0ge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb250aW51b3VzQW5jaG9yKHBhcmFtcyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2xlYXI6IGZ1bmN0aW9uIChlbGVtZW50SWQpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdXNlckRlZmluZWRDb250aW51b3VzQW5jaG9yTG9jYXRpb25zW2VsZW1lbnRJZF07XG4gICAgICAgICAgICAgICAgZGVsZXRlIGNvbnRpbnVvdXNBbmNob3JMb2NhdGlvbnNbZWxlbWVudElkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQW5jaG9ycyBtb2RlbCBhIHBvc2l0aW9uIG9uIHNvbWUgZWxlbWVudCBhdCB3aGljaCBhbiBFbmRwb2ludCBtYXkgYmUgbG9jYXRlZC4gIFRoZXkgYmVnYW4gYXMgYSBmaXJzdCBjbGFzcyBjaXRpemVuIG9mIGpzUGx1bWIsIGllLiBhIHVzZXJcbiAgICAgKiB3YXMgcmVxdWlyZWQgdG8gY3JlYXRlIHRoZXNlIHRoZW1zZWx2ZXMsIGJ1dCBvdmVyIHRpbWUgdGhpcyBoYXMgYmVlbiByZXBsYWNlZCBieSB0aGUgY29uY2VwdCBvZiByZWZlcnJpbmcgdG8gdGhlbSBlaXRoZXIgYnkgbmFtZSAoZWcuIFwiVG9wTWlkZGxlXCIpLFxuICAgICAqIG9yIGJ5IGFuIGFycmF5IGRlc2NyaWJpbmcgdGhlaXIgY29vcmRpbmF0ZXMgKGVnLiBbIDAsIDAuNSwgMCwgLTEgXSwgd2hpY2ggaXMgdGhlIHNhbWUgYXMgXCJUb3BNaWRkbGVcIikuICBqc1BsdW1iIG5vdyBoYW5kbGVzIGFsbCBvZiB0aGVcbiAgICAgKiBjcmVhdGlvbiBvZiBBbmNob3JzIHdpdGhvdXQgdXNlciBpbnRlcnZlbnRpb24uXG4gICAgICovXG4gICAgX2pwLkFuY2hvciA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgdGhpcy54ID0gcGFyYW1zLnggfHwgMDtcbiAgICAgICAgdGhpcy55ID0gcGFyYW1zLnkgfHwgMDtcbiAgICAgICAgdGhpcy5lbGVtZW50SWQgPSBwYXJhbXMuZWxlbWVudElkO1xuICAgICAgICB0aGlzLmNzc0NsYXNzID0gcGFyYW1zLmNzc0NsYXNzIHx8IFwiXCI7XG4gICAgICAgIHRoaXMudXNlckRlZmluZWRMb2NhdGlvbiA9IG51bGw7XG4gICAgICAgIHRoaXMub3JpZW50YXRpb24gPSBwYXJhbXMub3JpZW50YXRpb24gfHwgWyAwLCAwIF07XG4gICAgICAgIHRoaXMubGFzdFJldHVyblZhbHVlID0gbnVsbDtcbiAgICAgICAgdGhpcy5vZmZzZXRzID0gcGFyYW1zLm9mZnNldHMgfHwgWyAwLCAwIF07XG4gICAgICAgIHRoaXMudGltZXN0YW1wID0gbnVsbDtcblxuICAgICAgICBfanUuRXZlbnRHZW5lcmF0b3IuYXBwbHkodGhpcyk7XG5cbiAgICAgICAgdGhpcy5jb21wdXRlID0gZnVuY3Rpb24gKHBhcmFtcykge1xuXG4gICAgICAgICAgICB2YXIgeHkgPSBwYXJhbXMueHksIHdoID0gcGFyYW1zLndoLCB0aW1lc3RhbXAgPSBwYXJhbXMudGltZXN0YW1wO1xuXG4gICAgICAgICAgICBpZiAocGFyYW1zLmNsZWFyVXNlckRlZmluZWRMb2NhdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMudXNlckRlZmluZWRMb2NhdGlvbiA9IG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aW1lc3RhbXAgJiYgdGltZXN0YW1wID09PSB0aGlzLnRpbWVzdGFtcCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxhc3RSZXR1cm5WYWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMudXNlckRlZmluZWRMb2NhdGlvbiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sYXN0UmV0dXJuVmFsdWUgPSB0aGlzLnVzZXJEZWZpbmVkTG9jYXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RSZXR1cm5WYWx1ZSA9IFsgeHlbMF0gKyAodGhpcy54ICogd2hbMF0pICsgdGhpcy5vZmZzZXRzWzBdLCB4eVsxXSArICh0aGlzLnkgKiB3aFsxXSkgKyB0aGlzLm9mZnNldHNbMV0gXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy50aW1lc3RhbXAgPSB0aW1lc3RhbXA7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sYXN0UmV0dXJuVmFsdWU7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5nZXRDdXJyZW50TG9jYXRpb24gPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMubGFzdFJldHVyblZhbHVlID09IG51bGwgfHwgKHBhcmFtcy50aW1lc3RhbXAgIT0gbnVsbCAmJiB0aGlzLnRpbWVzdGFtcCAhPT0gcGFyYW1zLnRpbWVzdGFtcCkpID8gdGhpcy5jb21wdXRlKHBhcmFtcykgOiB0aGlzLmxhc3RSZXR1cm5WYWx1ZTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIF9qdS5leHRlbmQoX2pwLkFuY2hvciwgX2p1LkV2ZW50R2VuZXJhdG9yLCB7XG4gICAgICAgIGVxdWFsczogZnVuY3Rpb24gKGFuY2hvcikge1xuICAgICAgICAgICAgaWYgKCFhbmNob3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgYW8gPSBhbmNob3IuZ2V0T3JpZW50YXRpb24oKSxcbiAgICAgICAgICAgICAgICBvID0gdGhpcy5nZXRPcmllbnRhdGlvbigpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMueCA9PT0gYW5jaG9yLnggJiYgdGhpcy55ID09PSBhbmNob3IueSAmJiB0aGlzLm9mZnNldHNbMF0gPT09IGFuY2hvci5vZmZzZXRzWzBdICYmIHRoaXMub2Zmc2V0c1sxXSA9PT0gYW5jaG9yLm9mZnNldHNbMV0gJiYgb1swXSA9PT0gYW9bMF0gJiYgb1sxXSA9PT0gYW9bMV07XG4gICAgICAgIH0sXG4gICAgICAgIGdldFVzZXJEZWZpbmVkTG9jYXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVzZXJEZWZpbmVkTG9jYXRpb247XG4gICAgICAgIH0sXG4gICAgICAgIHNldFVzZXJEZWZpbmVkTG9jYXRpb246IGZ1bmN0aW9uIChsKSB7XG4gICAgICAgICAgICB0aGlzLnVzZXJEZWZpbmVkTG9jYXRpb24gPSBsO1xuICAgICAgICB9LFxuICAgICAgICBjbGVhclVzZXJEZWZpbmVkTG9jYXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMudXNlckRlZmluZWRMb2NhdGlvbiA9IG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIGdldE9yaWVudGF0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcmllbnRhdGlvbjtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0Q3NzQ2xhc3M6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNzc0NsYXNzO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBBbiBBbmNob3IgdGhhdCBmbG9hdHMuIGl0cyBvcmllbnRhdGlvbiBpcyBjb21wdXRlZCBkeW5hbWljYWxseSBmcm9tXG4gICAgICogaXRzIHBvc2l0aW9uIHJlbGF0aXZlIHRvIHRoZSBhbmNob3IgaXQgaXMgZmxvYXRpbmcgcmVsYXRpdmUgdG8uICBJdCBpcyB1c2VkIHdoZW4gY3JlYXRpbmdcbiAgICAgKiBhIGNvbm5lY3Rpb24gdGhyb3VnaCBkcmFnIGFuZCBkcm9wLlxuICAgICAqXG4gICAgICogVE9ETyBGbG9hdGluZ0FuY2hvciBjb3VsZCB0b3RhbGx5IGJlIHJlZmFjdG9yZWQgdG8gZXh0ZW5kIEFuY2hvciBqdXN0IHNsaWdodGx5LlxuICAgICAqL1xuICAgIF9qcC5GbG9hdGluZ0FuY2hvciA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcblxuICAgICAgICBfanAuQW5jaG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgLy8gdGhpcyBpcyB0aGUgYW5jaG9yIHRoYXQgdGhpcyBmbG9hdGluZyBhbmNob3IgaXMgcmVmZXJlbmNlZCB0byBmb3JcbiAgICAgICAgLy8gcHVycG9zZXMgb2YgY2FsY3VsYXRpbmcgdGhlIG9yaWVudGF0aW9uLlxuICAgICAgICB2YXIgcmVmID0gcGFyYW1zLnJlZmVyZW5jZSxcbiAgICAgICAgICAgIC8vIHRoZSBjYW52YXMgdGhpcyByZWZlcnMgdG8uXG4gICAgICAgICAgICByZWZDYW52YXMgPSBwYXJhbXMucmVmZXJlbmNlQ2FudmFzLFxuICAgICAgICAgICAgc2l6ZSA9IF9qcC5nZXRTaXplKHJlZkNhbnZhcyksXG4gICAgICAgICAgICAvLyB0aGVzZSBhcmUgdXNlZCB0byBzdG9yZSB0aGUgY3VycmVudCByZWxhdGl2ZSBwb3NpdGlvbiBvZiBvdXJcbiAgICAgICAgICAgIC8vIGFuY2hvciB3cnQgdGhlIHJlZmVyZW5jZSBhbmNob3IuIHRoZXkgb25seSBpbmRpY2F0ZVxuICAgICAgICAgICAgLy8gZGlyZWN0aW9uLCBzbyBoYXZlIGEgdmFsdWUgb2YgMSBvciAtMSAob3IsIHZlcnkgcmFyZWx5LCAwKS4gdGhlc2VcbiAgICAgICAgICAgIC8vIHZhbHVlcyBhcmUgd3JpdHRlbiBieSB0aGUgY29tcHV0ZSBtZXRob2QsIGFuZCByZWFkXG4gICAgICAgICAgICAvLyBieSB0aGUgZ2V0T3JpZW50YXRpb24gbWV0aG9kLlxuICAgICAgICAgICAgeERpciA9IDAsIHlEaXIgPSAwLFxuICAgICAgICAgICAgLy8gdGVtcG9yYXJ5IG1lbWJlciB1c2VkIHRvIHN0b3JlIGFuIG9yaWVudGF0aW9uIHdoZW4gdGhlIGZsb2F0aW5nXG4gICAgICAgICAgICAvLyBhbmNob3IgaXMgaG92ZXJpbmcgb3ZlciBhbm90aGVyIGFuY2hvci5cbiAgICAgICAgICAgIG9yaWVudGF0aW9uID0gbnVsbCxcbiAgICAgICAgICAgIF9sYXN0UmVzdWx0ID0gbnVsbDtcblxuICAgICAgICAvLyBjbGVhciBmcm9tIHBhcmVudC4gd2Ugd2FudCBmbG9hdGluZyBhbmNob3Igb3JpZW50YXRpb24gdG8gYWx3YXlzIGJlIGNvbXB1dGVkLlxuICAgICAgICB0aGlzLm9yaWVudGF0aW9uID0gbnVsbDtcblxuICAgICAgICAvLyBzZXQgdGhlc2UgdG8gMCBlYWNoOyB0aGV5IGFyZSB1c2VkIGJ5IGNlcnRhaW4gdHlwZXMgb2YgY29ubmVjdG9ycyBpbiB0aGUgbG9vcGJhY2sgY2FzZSxcbiAgICAgICAgLy8gd2hlbiB0aGUgY29ubmVjdG9yIGlzIHRyeWluZyB0byBjbGVhciB0aGUgZWxlbWVudCBpdCBpcyBvbi4gYnV0IGZvciBmbG9hdGluZyBhbmNob3IgaXQncyBub3RcbiAgICAgICAgLy8gdmVyeSBpbXBvcnRhbnQuXG4gICAgICAgIHRoaXMueCA9IDA7XG4gICAgICAgIHRoaXMueSA9IDA7XG5cbiAgICAgICAgdGhpcy5pc0Zsb2F0aW5nID0gdHJ1ZTtcblxuICAgICAgICB0aGlzLmNvbXB1dGUgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgICAgICB2YXIgeHkgPSBwYXJhbXMueHksXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gWyB4eVswXSArIChzaXplWzBdIC8gMiksIHh5WzFdICsgKHNpemVbMV0gLyAyKSBdOyAvLyByZXR1cm4gb3JpZ2luIG9mIHRoZSBlbGVtZW50LiB3ZSBtYXkgd2lzaCB0byBpbXByb3ZlIHRoaXMgc28gdGhhdCBhbnkgb2JqZWN0IGNhbiBiZSB0aGUgZHJhZyBwcm94eS5cbiAgICAgICAgICAgIF9sYXN0UmVzdWx0ID0gcmVzdWx0O1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmdldE9yaWVudGF0aW9uID0gZnVuY3Rpb24gKF9lbmRwb2ludCkge1xuICAgICAgICAgICAgaWYgKG9yaWVudGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9yaWVudGF0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIG8gPSByZWYuZ2V0T3JpZW50YXRpb24oX2VuZHBvaW50KTtcbiAgICAgICAgICAgICAgICAvLyBoZXJlIHdlIHRha2UgaW50byBhY2NvdW50IHRoZSBvcmllbnRhdGlvbiBvZiB0aGUgb3RoZXJcbiAgICAgICAgICAgICAgICAvLyBhbmNob3I6IGlmIGl0IGRlY2xhcmVzIHplcm8gZm9yIHNvbWUgZGlyZWN0aW9uLCB3ZSBkZWNsYXJlIHplcm8gdG9vLiB0aGlzIG1pZ2h0IG5vdCBiZSB0aGUgbW9zdCBhd2Vzb21lLiBwZXJoYXBzIHdlIGNhbiBjb21lXG4gICAgICAgICAgICAgICAgLy8gdXAgd2l0aCBhIGJldHRlciB3YXkuIGl0J3MganVzdCBzbyB0aGF0IHRoZSBsaW5lIHdlIGRyYXcgbG9va3MgbGlrZSBpdCBtYWtlcyBzZW5zZS4gbWF5YmUgdGhpcyB3b250IG1ha2Ugc2Vuc2UuXG4gICAgICAgICAgICAgICAgcmV0dXJuIFsgTWF0aC5hYnMob1swXSkgKiB4RGlyICogLTEsXG4gICAgICAgICAgICAgICAgICAgICAgICBNYXRoLmFicyhvWzFdKSAqIHlEaXIgKiAtMSBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBub3RpZmljYXRpb24gdGhlIGVuZHBvaW50IGFzc29jaWF0ZWQgd2l0aCB0aGlzIGFuY2hvciBpcyBob3ZlcmluZ1xuICAgICAgICAgKiBvdmVyIGFub3RoZXIgYW5jaG9yOyB3ZSB3YW50IHRvIGFzc3VtZSB0aGF0IGFuY2hvcidzIG9yaWVudGF0aW9uXG4gICAgICAgICAqIGZvciB0aGUgZHVyYXRpb24gb2YgdGhlIGhvdmVyLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vdmVyID0gZnVuY3Rpb24gKGFuY2hvciwgZW5kcG9pbnQpIHtcbiAgICAgICAgICAgIG9yaWVudGF0aW9uID0gYW5jaG9yLmdldE9yaWVudGF0aW9uKGVuZHBvaW50KTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogbm90aWZpY2F0aW9uIHRoZSBlbmRwb2ludCBhc3NvY2lhdGVkIHdpdGggdGhpcyBhbmNob3IgaXMgbm9cbiAgICAgICAgICogbG9uZ2VyIGhvdmVyaW5nIG92ZXIgYW5vdGhlciBhbmNob3I7IHdlIHNob3VsZCByZXN1bWUgY2FsY3VsYXRpbmdcbiAgICAgICAgICogb3JpZW50YXRpb24gYXMgd2Ugbm9ybWFsbHkgZG8uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIG9yaWVudGF0aW9uID0gbnVsbDtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmdldEN1cnJlbnRMb2NhdGlvbiA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgICAgIHJldHVybiBfbGFzdFJlc3VsdCA9PSBudWxsID8gdGhpcy5jb21wdXRlKHBhcmFtcykgOiBfbGFzdFJlc3VsdDtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIF9qdS5leHRlbmQoX2pwLkZsb2F0aW5nQW5jaG9yLCBfanAuQW5jaG9yKTtcblxuICAgIHZhciBfY29udmVydEFuY2hvciA9IGZ1bmN0aW9uIChhbmNob3IsIGpzUGx1bWJJbnN0YW5jZSwgZWxlbWVudElkKSB7XG4gICAgICAgIHJldHVybiBhbmNob3IuY29uc3RydWN0b3IgPT09IF9qcC5BbmNob3IgPyBhbmNob3IgOiBqc1BsdW1iSW5zdGFuY2UubWFrZUFuY2hvcihhbmNob3IsIGVsZW1lbnRJZCwganNQbHVtYkluc3RhbmNlKTtcbiAgICB9O1xuXG4gICAgLyogXG4gICAgICogQSBEeW5hbWljQW5jaG9yIGlzIGFuIEFuY2hvciB0aGF0IGNvbnRhaW5zIGEgbGlzdCBvZiBvdGhlciBBbmNob3JzLCB3aGljaCBpdCBjeWNsZXNcbiAgICAgKiB0aHJvdWdoIGF0IGNvbXB1dGUgdGltZSB0byBmaW5kIHRoZSBvbmUgdGhhdCBpcyBsb2NhdGVkIGNsb3Nlc3QgdG9cbiAgICAgKiB0aGUgY2VudGVyIG9mIHRoZSB0YXJnZXQgZWxlbWVudCwgYW5kIHJldHVybnMgdGhhdCBBbmNob3IncyBjb21wdXRlXG4gICAgICogbWV0aG9kIHJlc3VsdC4gdGhpcyBjYXVzZXMgZW5kcG9pbnRzIHRvIGZvbGxvdyBlYWNoIG90aGVyIHdpdGhcbiAgICAgKiByZXNwZWN0IHRvIHRoZSBvcmllbnRhdGlvbiBvZiB0aGVpciB0YXJnZXQgZWxlbWVudHMsIHdoaWNoIGlzIGEgdXNlZnVsXG4gICAgICogZmVhdHVyZSBmb3Igc29tZSBhcHBsaWNhdGlvbnMuXG4gICAgICogXG4gICAgICovXG4gICAgX2pwLkR5bmFtaWNBbmNob3IgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgIF9qcC5BbmNob3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgICAgICB0aGlzLmlzRHluYW1pYyA9IHRydWU7XG4gICAgICAgIHRoaXMuYW5jaG9ycyA9IFtdO1xuICAgICAgICB0aGlzLmVsZW1lbnRJZCA9IHBhcmFtcy5lbGVtZW50SWQ7XG4gICAgICAgIHRoaXMuanNQbHVtYkluc3RhbmNlID0gcGFyYW1zLmpzUGx1bWJJbnN0YW5jZTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmFtcy5hbmNob3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmFuY2hvcnNbaV0gPSBfY29udmVydEFuY2hvcihwYXJhbXMuYW5jaG9yc1tpXSwgdGhpcy5qc1BsdW1iSW5zdGFuY2UsIHRoaXMuZWxlbWVudElkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZ2V0QW5jaG9ycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFuY2hvcnM7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubG9ja2VkID0gZmFsc2U7XG4gICAgICAgIHZhciBfY3VyQW5jaG9yID0gdGhpcy5hbmNob3JzLmxlbmd0aCA+IDAgPyB0aGlzLmFuY2hvcnNbMF0gOiBudWxsLFxuICAgICAgICAgICAgX2xhc3RBbmNob3IgPSBfY3VyQW5jaG9yLFxuICAgICAgICAgICAgc2VsZiA9IHRoaXMsXG5cbiAgICAgICAgLy8gaGVscGVyIG1ldGhvZCB0byBjYWxjdWxhdGUgdGhlIGRpc3RhbmNlIGJldHdlZW4gdGhlIGNlbnRlcnMgb2YgdGhlIHR3byBlbGVtZW50cy5cbiAgICAgICAgICAgIF9kaXN0YW5jZSA9IGZ1bmN0aW9uIChhbmNob3IsIGN4LCBjeSwgeHksIHdoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGF4ID0geHlbMF0gKyAoYW5jaG9yLnggKiB3aFswXSksIGF5ID0geHlbMV0gKyAoYW5jaG9yLnkgKiB3aFsxXSksXG4gICAgICAgICAgICAgICAgICAgIGFjeCA9IHh5WzBdICsgKHdoWzBdIC8gMiksIGFjeSA9IHh5WzFdICsgKHdoWzFdIC8gMik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChNYXRoLnNxcnQoTWF0aC5wb3coY3ggLSBheCwgMikgKyBNYXRoLnBvdyhjeSAtIGF5LCAyKSkgK1xuICAgICAgICAgICAgICAgICAgICBNYXRoLnNxcnQoTWF0aC5wb3coYWN4IC0gYXgsIDIpICsgTWF0aC5wb3coYWN5IC0gYXksIDIpKSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAvLyBkZWZhdWx0IG1ldGhvZCB1c2VzIGRpc3RhbmNlIGJldHdlZW4gZWxlbWVudCBjZW50ZXJzLiAgeW91IGNhbiBwcm92aWRlIHlvdXIgb3duIG1ldGhvZCBpbiB0aGUgZHluYW1pYyBhbmNob3JcbiAgICAgICAgLy8gY29uc3RydWN0b3IgKGFuZCBhbHNvIHRvIGpzUGx1bWIubWFrZUR5bmFtaWNBbmNob3IpLiB0aGUgYXJndW1lbnRzIHRvIGl0IGFyZSBmb3VyIGFycmF5czpcbiAgICAgICAgLy8geHkgLSB4eSBsb2Mgb2YgdGhlIGFuY2hvcidzIGVsZW1lbnRcbiAgICAgICAgLy8gd2ggLSBhbmNob3IncyBlbGVtZW50J3MgZGltZW5zaW9uc1xuICAgICAgICAvLyB0eHkgLSB4eSBsb2Mgb2YgdGhlIGVsZW1lbnQgb2YgdGhlIG90aGVyIGFuY2hvciBpbiB0aGUgY29ubmVjdGlvblxuICAgICAgICAvLyB0d2ggLSBkaW1lbnNpb25zIG9mIHRoZSBlbGVtZW50IG9mIHRoZSBvdGhlciBhbmNob3IgaW4gdGhlIGNvbm5lY3Rpb24uXG4gICAgICAgIC8vIGFuY2hvcnMgLSB0aGUgbGlzdCBvZiBzZWxlY3RhYmxlIGFuY2hvcnNcbiAgICAgICAgICAgIF9hbmNob3JTZWxlY3RvciA9IHBhcmFtcy5zZWxlY3RvciB8fCBmdW5jdGlvbiAoeHksIHdoLCB0eHksIHR3aCwgYW5jaG9ycykge1xuICAgICAgICAgICAgICAgIHZhciBjeCA9IHR4eVswXSArICh0d2hbMF0gLyAyKSwgY3kgPSB0eHlbMV0gKyAodHdoWzFdIC8gMik7XG4gICAgICAgICAgICAgICAgdmFyIG1pbklkeCA9IC0xLCBtaW5EaXN0ID0gSW5maW5pdHk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbmNob3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkID0gX2Rpc3RhbmNlKGFuY2hvcnNbaV0sIGN4LCBjeSwgeHksIHdoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGQgPCBtaW5EaXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5JZHggPSBpICsgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbkRpc3QgPSBkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBhbmNob3JzW21pbklkeF07XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuY29tcHV0ZSA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgICAgIHZhciB4eSA9IHBhcmFtcy54eSwgd2ggPSBwYXJhbXMud2gsIHR4eSA9IHBhcmFtcy50eHksIHR3aCA9IHBhcmFtcy50d2g7XG5cbiAgICAgICAgICAgIHRoaXMudGltZXN0YW1wID0gcGFyYW1zLnRpbWVzdGFtcDtcblxuICAgICAgICAgICAgdmFyIHVkbCA9IHNlbGYuZ2V0VXNlckRlZmluZWRMb2NhdGlvbigpO1xuICAgICAgICAgICAgaWYgKHVkbCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVkbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaWYgYW5jaG9yIGlzIGxvY2tlZCBvciBhbiBvcHBvc2l0ZSBlbGVtZW50IHdhcyBub3QgZ2l2ZW4sIHdlXG4gICAgICAgICAgICAvLyBtYWludGFpbiBvdXIgc3RhdGUuIGFuY2hvciB3aWxsIGJlIGxvY2tlZFxuICAgICAgICAgICAgLy8gaWYgaXQgaXMgdGhlIHNvdXJjZSBvZiBhIGRyYWcgYW5kIGRyb3AuXG4gICAgICAgICAgICBpZiAodGhpcy5sb2NrZWQgfHwgdHh5ID09IG51bGwgfHwgdHdoID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2N1ckFuY2hvci5jb21wdXRlKHBhcmFtcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMudGltZXN0YW1wID0gbnVsbDsgLy8gb3RoZXJ3aXNlIGNsZWFyIHRoaXMsIGkgdGhpbmsuIHdlIHdhbnQgdGhlIGFuY2hvciB0byBjb21wdXRlLlxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY3VyQW5jaG9yID0gX2FuY2hvclNlbGVjdG9yKHh5LCB3aCwgdHh5LCB0d2gsIHRoaXMuYW5jaG9ycyk7XG4gICAgICAgICAgICB0aGlzLnggPSBfY3VyQW5jaG9yLng7XG4gICAgICAgICAgICB0aGlzLnkgPSBfY3VyQW5jaG9yLnk7XG5cbiAgICAgICAgICAgIGlmIChfY3VyQW5jaG9yICE9PSBfbGFzdEFuY2hvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuZmlyZShcImFuY2hvckNoYW5nZWRcIiwgX2N1ckFuY2hvcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9sYXN0QW5jaG9yID0gX2N1ckFuY2hvcjtcblxuICAgICAgICAgICAgcmV0dXJuIF9jdXJBbmNob3IuY29tcHV0ZShwYXJhbXMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuZ2V0Q3VycmVudExvY2F0aW9uID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VXNlckRlZmluZWRMb2NhdGlvbigpIHx8IChfY3VyQW5jaG9yICE9IG51bGwgPyBfY3VyQW5jaG9yLmdldEN1cnJlbnRMb2NhdGlvbihwYXJhbXMpIDogbnVsbCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5nZXRPcmllbnRhdGlvbiA9IGZ1bmN0aW9uIChfZW5kcG9pbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBfY3VyQW5jaG9yICE9IG51bGwgPyBfY3VyQW5jaG9yLmdldE9yaWVudGF0aW9uKF9lbmRwb2ludCkgOiBbIDAsIDAgXTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vdmVyID0gZnVuY3Rpb24gKGFuY2hvciwgZW5kcG9pbnQpIHtcbiAgICAgICAgICAgIGlmIChfY3VyQW5jaG9yICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBfY3VyQW5jaG9yLm92ZXIoYW5jaG9yLCBlbmRwb2ludCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKF9jdXJBbmNob3IgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIF9jdXJBbmNob3Iub3V0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5nZXRDc3NDbGFzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAoX2N1ckFuY2hvciAmJiBfY3VyQW5jaG9yLmdldENzc0NsYXNzKCkpIHx8IFwiXCI7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBfanUuZXh0ZW5kKF9qcC5EeW5hbWljQW5jaG9yLCBfanAuQW5jaG9yKTtcblxuLy8gLS0tLS0tLS0gYmFzaWMgYW5jaG9ycyAtLS0tLS0tLS0tLS0tLS0tLS0gICAgXG4gICAgdmFyIF9jdXJyeUFuY2hvciA9IGZ1bmN0aW9uICh4LCB5LCBveCwgb3ksIHR5cGUsIGZuSW5pdCkge1xuICAgICAgICBfanAuQW5jaG9yc1t0eXBlXSA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgICAgIHZhciBhID0gcGFyYW1zLmpzUGx1bWJJbnN0YW5jZS5tYWtlQW5jaG9yKFsgeCwgeSwgb3gsIG95LCAwLCAwIF0sIHBhcmFtcy5lbGVtZW50SWQsIHBhcmFtcy5qc1BsdW1iSW5zdGFuY2UpO1xuICAgICAgICAgICAgYS50eXBlID0gdHlwZTtcbiAgICAgICAgICAgIGlmIChmbkluaXQpIHtcbiAgICAgICAgICAgICAgICBmbkluaXQoYSwgcGFyYW1zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICBfY3VycnlBbmNob3IoMC41LCAwLCAwLCAtMSwgXCJUb3BDZW50ZXJcIik7XG4gICAgX2N1cnJ5QW5jaG9yKDAuNSwgMSwgMCwgMSwgXCJCb3R0b21DZW50ZXJcIik7XG4gICAgX2N1cnJ5QW5jaG9yKDAsIDAuNSwgLTEsIDAsIFwiTGVmdE1pZGRsZVwiKTtcbiAgICBfY3VycnlBbmNob3IoMSwgMC41LCAxLCAwLCBcIlJpZ2h0TWlkZGxlXCIpO1xuXG4gICAgX2N1cnJ5QW5jaG9yKDAuNSwgMCwgMCwgLTEsIFwiVG9wXCIpO1xuICAgIF9jdXJyeUFuY2hvcigwLjUsIDEsIDAsIDEsIFwiQm90dG9tXCIpO1xuICAgIF9jdXJyeUFuY2hvcigwLCAwLjUsIC0xLCAwLCBcIkxlZnRcIik7XG4gICAgX2N1cnJ5QW5jaG9yKDEsIDAuNSwgMSwgMCwgXCJSaWdodFwiKTtcbiAgICBfY3VycnlBbmNob3IoMC41LCAwLjUsIDAsIDAsIFwiQ2VudGVyXCIpO1xuICAgIF9jdXJyeUFuY2hvcigxLCAwLCAwLCAtMSwgXCJUb3BSaWdodFwiKTtcbiAgICBfY3VycnlBbmNob3IoMSwgMSwgMCwgMSwgXCJCb3R0b21SaWdodFwiKTtcbiAgICBfY3VycnlBbmNob3IoMCwgMCwgMCwgLTEsIFwiVG9wTGVmdFwiKTtcbiAgICBfY3VycnlBbmNob3IoMCwgMSwgMCwgMSwgXCJCb3R0b21MZWZ0XCIpO1xuXG4vLyAtLS0tLS0tIGR5bmFtaWMgYW5jaG9ycyAtLS0tLS0tLS0tLS0tLS0tLS0tICAgIFxuXG4gICAgLy8gZGVmYXVsdCBkeW5hbWljIGFuY2hvcnMgY2hvb3NlcyBmcm9tIFRvcCwgUmlnaHQsIEJvdHRvbSwgTGVmdFxuICAgIF9qcC5EZWZhdWx0cy5EeW5hbWljQW5jaG9ycyA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtcy5qc1BsdW1iSW5zdGFuY2UubWFrZUFuY2hvcnMoW1wiVG9wQ2VudGVyXCIsIFwiUmlnaHRNaWRkbGVcIiwgXCJCb3R0b21DZW50ZXJcIiwgXCJMZWZ0TWlkZGxlXCJdLCBwYXJhbXMuZWxlbWVudElkLCBwYXJhbXMuanNQbHVtYkluc3RhbmNlKTtcbiAgICB9O1xuXG4gICAgLy8gZGVmYXVsdCBkeW5hbWljIGFuY2hvcnMgYm91bmQgdG8gbmFtZSAnQXV0b0RlZmF1bHQnXG4gICAgX2pwLkFuY2hvcnMuQXV0b0RlZmF1bHQgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgIHZhciBhID0gcGFyYW1zLmpzUGx1bWJJbnN0YW5jZS5tYWtlRHluYW1pY0FuY2hvcihfanAuRGVmYXVsdHMuRHluYW1pY0FuY2hvcnMocGFyYW1zKSk7XG4gICAgICAgIGEudHlwZSA9IFwiQXV0b0RlZmF1bHRcIjtcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgfTtcblxuLy8gLS0tLS0tLSBjb250aW51b3VzIGFuY2hvcnMgLS0tLS0tLS0tLS0tLS0tLS0tLSAgICBcblxuICAgIHZhciBfY3VycnlDb250aW51b3VzQW5jaG9yID0gZnVuY3Rpb24gKHR5cGUsIGZhY2VzKSB7XG4gICAgICAgIF9qcC5BbmNob3JzW3R5cGVdID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICAgICAgdmFyIGEgPSBwYXJhbXMuanNQbHVtYkluc3RhbmNlLm1ha2VBbmNob3IoW1wiQ29udGludW91c1wiLCB7IGZhY2VzOiBmYWNlcyB9XSwgcGFyYW1zLmVsZW1lbnRJZCwgcGFyYW1zLmpzUGx1bWJJbnN0YW5jZSk7XG4gICAgICAgICAgICBhLnR5cGUgPSB0eXBlO1xuICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIF9qcC5BbmNob3JzLkNvbnRpbnVvdXMgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBwYXJhbXMuanNQbHVtYkluc3RhbmNlLmNvbnRpbnVvdXNBbmNob3JGYWN0b3J5LmdldChwYXJhbXMpO1xuICAgIH07XG5cbiAgICBfY3VycnlDb250aW51b3VzQW5jaG9yKFwiQ29udGludW91c0xlZnRcIiwgW1wibGVmdFwiXSk7XG4gICAgX2N1cnJ5Q29udGludW91c0FuY2hvcihcIkNvbnRpbnVvdXNUb3BcIiwgW1widG9wXCJdKTtcbiAgICBfY3VycnlDb250aW51b3VzQW5jaG9yKFwiQ29udGludW91c0JvdHRvbVwiLCBbXCJib3R0b21cIl0pO1xuICAgIF9jdXJyeUNvbnRpbnVvdXNBbmNob3IoXCJDb250aW51b3VzUmlnaHRcIiwgW1wicmlnaHRcIl0pO1xuXG4vLyAtLS0tLS0tIHBvc2l0aW9uIGFzc2lnbiBhbmNob3JzIC0tLS0tLS0tLS0tLS0tLS0tLS0gICAgXG5cbiAgICAvLyB0aGlzIGFuY2hvciB0eXBlIGxldHMgeW91IGFzc2lnbiB0aGUgcG9zaXRpb24gYXQgY29ubmVjdGlvbiB0aW1lLlxuICAgIF9jdXJyeUFuY2hvcigwLCAwLCAwLCAwLCBcIkFzc2lnblwiLCBmdW5jdGlvbiAoYW5jaG9yLCBwYXJhbXMpIHtcbiAgICAgICAgLy8gZmluZCB3aGF0IHRvIHVzZSBhcyB0aGUgXCJwb3NpdGlvbiBmaW5kZXJcIi4gdGhlIHVzZXIgbWF5IGhhdmUgc3VwcGxpZWQgYSBTdHJpbmcgd2hpY2ggcmVwcmVzZW50c1xuICAgICAgICAvLyB0aGUgaWQgb2YgYSBwb3NpdGlvbiBmaW5kZXIgaW4ganNQbHVtYi5BbmNob3JQb3NpdGlvbkZpbmRlcnMsIG9yIHRoZSB1c2VyIG1heSBoYXZlIHN1cHBsaWVkIHRoZVxuICAgICAgICAvLyBwb3NpdGlvbiBmaW5kZXIgYXMgYSBmdW5jdGlvbi4gIHdlIGZpbmQgb3V0IHdoYXQgdG8gdXNlIGFuZCB0aGVuIHNldCBpdCBvbiB0aGUgYW5jaG9yLlxuICAgICAgICB2YXIgcGYgPSBwYXJhbXMucG9zaXRpb24gfHwgXCJGaXhlZFwiO1xuICAgICAgICBhbmNob3IucG9zaXRpb25GaW5kZXIgPSBwZi5jb25zdHJ1Y3RvciA9PT0gU3RyaW5nID8gcGFyYW1zLmpzUGx1bWJJbnN0YW5jZS5BbmNob3JQb3NpdGlvbkZpbmRlcnNbcGZdIDogcGY7XG4gICAgICAgIC8vIGFsd2F5cyBzZXQgdGhlIGNvbnN0cnVjdG9yIHBhcmFtczsgdGhlIHBvc2l0aW9uIGZpbmRlciBtaWdodCBuZWVkIHRoZW0gbGF0ZXIgKHRoZSBHcmlkIG9uZSBkb2VzLFxuICAgICAgICAvLyBmb3IgZXhhbXBsZSlcbiAgICAgICAgYW5jaG9yLmNvbnN0cnVjdG9yUGFyYW1zID0gcGFyYW1zO1xuICAgIH0pO1xuXG4gICAgLy8gdGhlc2UgYXJlIHRoZSBkZWZhdWx0IGFuY2hvciBwb3NpdGlvbnMgZmluZGVycywgd2hpY2ggYXJlIHVzZWQgYnkgdGhlIG1ha2VUYXJnZXQgZnVuY3Rpb24uICBzdXBwbHlpbmdcbiAgICAvLyBhIHBvc2l0aW9uIGZpbmRlciBhcmd1bWVudCB0byB0aGF0IGZ1bmN0aW9uIGFsbG93cyB5b3UgdG8gc3BlY2lmeSB3aGVyZSB0aGUgcmVzdWx0aW5nIGFuY2hvciB3aWxsXG4gICAgLy8gYmUgbG9jYXRlZFxuICAgIHJvb3QuanNQbHVtYkluc3RhbmNlLnByb3RvdHlwZS5BbmNob3JQb3NpdGlvbkZpbmRlcnMgPSB7XG4gICAgICAgIFwiRml4ZWRcIjogZnVuY3Rpb24gKGRwLCBlcCwgZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBbIChkcC5sZWZ0IC0gZXAubGVmdCkgLyBlc1swXSwgKGRwLnRvcCAtIGVwLnRvcCkgLyBlc1sxXSBdO1xuICAgICAgICB9LFxuICAgICAgICBcIkdyaWRcIjogZnVuY3Rpb24gKGRwLCBlcCwgZXMsIHBhcmFtcykge1xuICAgICAgICAgICAgdmFyIGR4ID0gZHAubGVmdCAtIGVwLmxlZnQsIGR5ID0gZHAudG9wIC0gZXAudG9wLFxuICAgICAgICAgICAgICAgIGd4ID0gZXNbMF0gLyAocGFyYW1zLmdyaWRbMF0pLCBneSA9IGVzWzFdIC8gKHBhcmFtcy5ncmlkWzFdKSxcbiAgICAgICAgICAgICAgICBteCA9IE1hdGguZmxvb3IoZHggLyBneCksIG15ID0gTWF0aC5mbG9vcihkeSAvIGd5KTtcbiAgICAgICAgICAgIHJldHVybiBbICgobXggKiBneCkgKyAoZ3ggLyAyKSkgLyBlc1swXSwgKChteSAqIGd5KSArIChneSAvIDIpKSAvIGVzWzFdIF07XG4gICAgICAgIH1cbiAgICB9O1xuXG4vLyAtLS0tLS0tIHBlcmltZXRlciBhbmNob3JzIC0tLS0tLS0tLS0tLS0tLS0tLS0gICAgXG5cbiAgICBfanAuQW5jaG9ycy5QZXJpbWV0ZXIgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgICAgICAgdmFyIGFuY2hvckNvdW50ID0gcGFyYW1zLmFuY2hvckNvdW50IHx8IDYwLFxuICAgICAgICAgICAgc2hhcGUgPSBwYXJhbXMuc2hhcGU7XG5cbiAgICAgICAgaWYgKCFzaGFwZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm8gc2hhcGUgc3VwcGxpZWQgdG8gUGVyaW1ldGVyIEFuY2hvciB0eXBlXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIF9jaXJjbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHIgPSAwLjUsIHN0ZXAgPSBNYXRoLlBJICogMiAvIGFuY2hvckNvdW50LCBjdXJyZW50ID0gMCwgYSA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYW5jaG9yQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgeCA9IHIgKyAociAqIE1hdGguc2luKGN1cnJlbnQpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgPSByICsgKHIgKiBNYXRoLmNvcyhjdXJyZW50KSk7XG4gICAgICAgICAgICAgICAgICAgIGEucHVzaChbIHgsIHksIDAsIDAgXSk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgKz0gc3RlcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3BhdGggPSBmdW5jdGlvbiAoc2VnbWVudHMpIHtcbiAgICAgICAgICAgICAgICB2YXIgYW5jaG9yc1BlckZhY2UgPSBhbmNob3JDb3VudCAvIHNlZ21lbnRzLmxlbmd0aCwgYSA9IFtdLFxuICAgICAgICAgICAgICAgICAgICBfY29tcHV0ZUZhY2UgPSBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIsIGZyYWN0aW9uYWxMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuY2hvcnNQZXJGYWNlID0gYW5jaG9yQ291bnQgKiBmcmFjdGlvbmFsTGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGR4ID0gKHgyIC0geDEpIC8gYW5jaG9yc1BlckZhY2UsIGR5ID0gKHkyIC0geTEpIC8gYW5jaG9yc1BlckZhY2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFuY2hvcnNQZXJGYWNlOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhLnB1c2goW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDEgKyAoZHggKiBpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkxICsgKGR5ICogaSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgX2NvbXB1dGVGYWNlLmFwcGx5KG51bGwsIHNlZ21lbnRzW2ldKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfc2hhcGUgPSBmdW5jdGlvbiAoZmFjZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgcyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmFjZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcy5wdXNoKFtmYWNlc1tpXVswXSwgZmFjZXNbaV1bMV0sIGZhY2VzW2ldWzJdLCBmYWNlc1tpXVszXSwgMSAvIGZhY2VzLmxlbmd0aF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gX3BhdGgocyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3JlY3RhbmdsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3NoYXBlKFtcbiAgICAgICAgICAgICAgICAgICAgWyAwLCAwLCAxLCAwIF0sXG4gICAgICAgICAgICAgICAgICAgIFsgMSwgMCwgMSwgMSBdLFxuICAgICAgICAgICAgICAgICAgICBbIDEsIDEsIDAsIDEgXSxcbiAgICAgICAgICAgICAgICAgICAgWyAwLCAxLCAwLCAwIF1cbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgdmFyIF9zaGFwZXMgPSB7XG4gICAgICAgICAgICAgICAgXCJDaXJjbGVcIjogX2NpcmNsZSxcbiAgICAgICAgICAgICAgICBcIkVsbGlwc2VcIjogX2NpcmNsZSxcbiAgICAgICAgICAgICAgICBcIkRpYW1vbmRcIjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3NoYXBlKFtcbiAgICAgICAgICAgICAgICAgICAgICAgIFsgMC41LCAwLCAxLCAwLjUgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFsgMSwgMC41LCAwLjUsIDEgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFsgMC41LCAxLCAwLCAwLjUgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFsgMCwgMC41LCAwLjUsIDAgXVxuICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwiUmVjdGFuZ2xlXCI6IF9yZWN0YW5nbGUsXG4gICAgICAgICAgICAgICAgXCJTcXVhcmVcIjogX3JlY3RhbmdsZSxcbiAgICAgICAgICAgICAgICBcIlRyaWFuZ2xlXCI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9zaGFwZShbXG4gICAgICAgICAgICAgICAgICAgICAgICBbIDAuNSwgMCwgMSwgMSBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgWyAxLCAxLCAwLCAxIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBbIDAsIDEsIDAuNSwgMF1cbiAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcIlBhdGhcIjogZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcG9pbnRzID0gcGFyYW1zLnBvaW50cywgcCA9IFtdLCB0bCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGwgPSBNYXRoLnNxcnQoTWF0aC5wb3cocG9pbnRzW2ldWzJdIC0gcG9pbnRzW2ldWzBdKSArIE1hdGgucG93KHBvaW50c1tpXVszXSAtIHBvaW50c1tpXVsxXSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGwgKz0gbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHAucHVzaChbcG9pbnRzW2ldWzBdLCBwb2ludHNbaV1bMV0sIHBvaW50c1tpICsgMV1bMF0sIHBvaW50c1tpICsgMV1bMV0sIGxdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHAubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBbal1bNF0gPSBwW2pdWzRdIC8gdGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9wYXRoKHApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfcm90YXRlID0gZnVuY3Rpb24gKHBvaW50cywgYW1vdW50SW5EZWdyZWVzKSB7XG4gICAgICAgICAgICAgICAgdmFyIG8gPSBbXSwgdGhldGEgPSBhbW91bnRJbkRlZ3JlZXMgLyAxODAgKiBNYXRoLlBJO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfeCA9IHBvaW50c1tpXVswXSAtIDAuNSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF95ID0gcG9pbnRzW2ldWzFdIC0gMC41O1xuXG4gICAgICAgICAgICAgICAgICAgIG8ucHVzaChbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMC41ICsgKChfeCAqIE1hdGguY29zKHRoZXRhKSkgLSAoX3kgKiBNYXRoLnNpbih0aGV0YSkpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAwLjUgKyAoKF94ICogTWF0aC5zaW4odGhldGEpKSArIChfeSAqIE1hdGguY29zKHRoZXRhKSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzW2ldWzJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzW2ldWzNdXG4gICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbztcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgaWYgKCFfc2hhcGVzW3NoYXBlXSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2hhcGUgW1wiICsgc2hhcGUgKyBcIl0gaXMgdW5rbm93biBieSBQZXJpbWV0ZXIgQW5jaG9yIHR5cGVcIik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGEgPSBfc2hhcGVzW3NoYXBlXShwYXJhbXMpO1xuICAgICAgICBpZiAocGFyYW1zLnJvdGF0aW9uKSB7XG4gICAgICAgICAgICBkYSA9IF9yb3RhdGUoZGEsIHBhcmFtcy5yb3RhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGEgPSBwYXJhbXMuanNQbHVtYkluc3RhbmNlLm1ha2VEeW5hbWljQW5jaG9yKGRhKTtcbiAgICAgICAgYS50eXBlID0gXCJQZXJpbWV0ZXJcIjtcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgfTtcbn0pLmNhbGwodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB0aGlzKTtcbi8qXG4gKiBqc1BsdW1iIENvbW11bml0eSBFZGl0aW9uXG4gKiBcbiAqIFByb3ZpZGVzIGEgd2F5IHRvIHZpc3VhbGx5IGNvbm5lY3QgZWxlbWVudHMgb24gYW4gSFRNTCBwYWdlLCB1c2luZyBTVkcuXG4gKiBcbiAqIFRoaXMgZmlsZSBjb250YWlucyB0aGUgZGVmYXVsdCBDb25uZWN0b3JzLCBFbmRwb2ludCBhbmQgT3ZlcmxheSBkZWZpbml0aW9ucy5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTAgLSAyMDE3IGpzUGx1bWIgKGhlbGxvQGpzcGx1bWJ0b29sa2l0LmNvbSlcbiAqIFxuICogaHR0cHM6Ly9qc3BsdW1idG9vbGtpdC5jb21cbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9qc3BsdW1iL2pzcGx1bWJcbiAqIFxuICogRHVhbCBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGFuZCBHUEwyIGxpY2Vuc2VzLlxuICovXG47XG4oZnVuY3Rpb24gKCkge1xuXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIHJvb3QgPSB0aGlzLCBfanAgPSByb290LmpzUGx1bWIsIF9qdSA9IHJvb3QuanNQbHVtYlV0aWwsIF9qZyA9IHJvb3QuQmlsdG9uZztcblxuICAgIF9qcC5TZWdtZW50cyA9IHtcblxuICAgICAgICAvKlxuICAgICAgICAgKiBDbGFzczogQWJzdHJhY3RTZWdtZW50XG4gICAgICAgICAqIEEgQ29ubmVjdG9yIGlzIG1hZGUgdXAgb2YgMS4uTiBTZWdtZW50cywgZWFjaCBvZiB3aGljaCBoYXMgYSBUeXBlLCBzdWNoIGFzICdTdHJhaWdodCcsICdBcmMnLFxuICAgICAgICAgKiAnQmV6aWVyJy4gVGhpcyBpcyBuZXcgZnJvbSAxLjQuMiwgYW5kIGdpdmVzIHVzIGEgbG90IG1vcmUgZmxleGliaWxpdHkgd2hlbiBkcmF3aW5nIGNvbm5lY3Rpb25zOiB0aGluZ3Mgc3VjaFxuICAgICAgICAgKiBhcyByb3VuZGVkIGNvcm5lcnMgZm9yIGZsb3djaGFydCBjb25uZWN0b3JzLCBmb3IgZXhhbXBsZSwgb3IgYSBzdHJhaWdodCBsaW5lIHN0dWIgZm9yIEJlemllciBjb25uZWN0aW9ucywgYXJlXG4gICAgICAgICAqIG11Y2ggZWFzaWVyIHRvIGRvIG5vdy5cbiAgICAgICAgICpcbiAgICAgICAgICogQSBTZWdtZW50IGlzIHJlc3BvbnNpYmxlIGZvciBwcm92aWRpbmcgY29vcmRpbmF0ZXMgZm9yIHBhaW50aW5nIGl0LCBhbmQgYWxzbyBtdXN0IGJlIGFibGUgdG8gcmVwb3J0IGl0cyBsZW5ndGguXG4gICAgICAgICAqIFxuICAgICAgICAgKi9cbiAgICAgICAgQWJzdHJhY3RTZWdtZW50OiBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgICAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcztcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBGdW5jdGlvbjogZmluZENsb3Nlc3RQb2ludE9uUGF0aFxuICAgICAgICAgICAgICogRmluZHMgdGhlIGNsb3Nlc3QgcG9pbnQgb24gdGhpcyBzZWdtZW50IHRvIHRoZSBnaXZlbiBbeCwgeV0sXG4gICAgICAgICAgICAgKiByZXR1cm5pbmcgYm90aCB0aGUgeCBhbmQgeSBvZiB0aGUgcG9pbnQgcGx1cyBpdHMgZGlzdGFuY2UgZnJvbVxuICAgICAgICAgICAgICogdGhlIHN1cHBsaWVkIHBvaW50LCBhbmQgaXRzIGxvY2F0aW9uIGFsb25nIHRoZSBsZW5ndGggb2YgdGhlXG4gICAgICAgICAgICAgKiBwYXRoIGluc2NyaWJlZCBieSB0aGUgc2VnbWVudC4gIFRoaXMgaW1wbGVtZW50YXRpb24gcmV0dXJuc1xuICAgICAgICAgICAgICogSW5maW5pdHkgZm9yIGRpc3RhbmNlIGFuZCBudWxsIHZhbHVlcyBmb3IgZXZlcnl0aGluZyBlbHNlO1xuICAgICAgICAgICAgICogc3ViY2xhc3NlcyBhcmUgZXhwZWN0ZWQgdG8gb3ZlcnJpZGUuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuZmluZENsb3Nlc3RQb2ludE9uUGF0aCA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZDogSW5maW5pdHksXG4gICAgICAgICAgICAgICAgICAgIHg6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHk6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGw6IG51bGxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdGhpcy5nZXRCb3VuZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbWluWDogTWF0aC5taW4ocGFyYW1zLngxLCBwYXJhbXMueDIpLFxuICAgICAgICAgICAgICAgICAgICBtaW5ZOiBNYXRoLm1pbihwYXJhbXMueTEsIHBhcmFtcy55MiksXG4gICAgICAgICAgICAgICAgICAgIG1heFg6IE1hdGgubWF4KHBhcmFtcy54MSwgcGFyYW1zLngyKSxcbiAgICAgICAgICAgICAgICAgICAgbWF4WTogTWF0aC5tYXgocGFyYW1zLnkxLCBwYXJhbXMueTIpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIFN0cmFpZ2h0OiBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgICAgICB2YXIgX3N1cGVyID0gX2pwLlNlZ21lbnRzLkFic3RyYWN0U2VnbWVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpLFxuICAgICAgICAgICAgICAgIGxlbmd0aCwgbSwgbTIsIHgxLCB4MiwgeTEsIHkyLFxuICAgICAgICAgICAgICAgIF9yZWNhbGMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aCA9IE1hdGguc3FydChNYXRoLnBvdyh4MiAtIHgxLCAyKSArIE1hdGgucG93KHkyIC0geTEsIDIpKTtcbiAgICAgICAgICAgICAgICAgICAgbSA9IF9qZy5ncmFkaWVudCh7eDogeDEsIHk6IHkxfSwge3g6IHgyLCB5OiB5Mn0pO1xuICAgICAgICAgICAgICAgICAgICBtMiA9IC0xIC8gbTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBcIlN0cmFpZ2h0XCI7XG5cbiAgICAgICAgICAgIHRoaXMuZ2V0TGVuZ3RoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5nZXRHcmFkaWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHRoaXMuZ2V0Q29vcmRpbmF0ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgeDE6IHgxLCB5MTogeTEsIHgyOiB4MiwgeTI6IHkyIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5zZXRDb29yZGluYXRlcyA9IGZ1bmN0aW9uIChjb29yZHMpIHtcbiAgICAgICAgICAgICAgICB4MSA9IGNvb3Jkcy54MTtcbiAgICAgICAgICAgICAgICB5MSA9IGNvb3Jkcy55MTtcbiAgICAgICAgICAgICAgICB4MiA9IGNvb3Jkcy54MjtcbiAgICAgICAgICAgICAgICB5MiA9IGNvb3Jkcy55MjtcbiAgICAgICAgICAgICAgICBfcmVjYWxjKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5zZXRDb29yZGluYXRlcyh7eDE6IHBhcmFtcy54MSwgeTE6IHBhcmFtcy55MSwgeDI6IHBhcmFtcy54MiwgeTI6IHBhcmFtcy55Mn0pO1xuXG4gICAgICAgICAgICB0aGlzLmdldEJvdW5kcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBtaW5YOiBNYXRoLm1pbih4MSwgeDIpLFxuICAgICAgICAgICAgICAgICAgICBtaW5ZOiBNYXRoLm1pbih5MSwgeTIpLFxuICAgICAgICAgICAgICAgICAgICBtYXhYOiBNYXRoLm1heCh4MSwgeDIpLFxuICAgICAgICAgICAgICAgICAgICBtYXhZOiBNYXRoLm1heCh5MSwgeTIpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogcmV0dXJucyB0aGUgcG9pbnQgb24gdGhlIHNlZ21lbnQncyBwYXRoIHRoYXQgaXMgJ2xvY2F0aW9uJyBhbG9uZyB0aGUgbGVuZ3RoIG9mIHRoZSBwYXRoLCB3aGVyZSAnbG9jYXRpb24nIGlzIGEgZGVjaW1hbCBmcm9tXG4gICAgICAgICAgICAgKiAwIHRvIDEgaW5jbHVzaXZlLiBmb3IgdGhlIHN0cmFpZ2h0IGxpbmUgc2VnbWVudCB0aGlzIGlzIHNpbXBsZSBtYXRocy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5wb2ludE9uUGF0aCA9IGZ1bmN0aW9uIChsb2NhdGlvbiwgYWJzb2x1dGUpIHtcbiAgICAgICAgICAgICAgICBpZiAobG9jYXRpb24gPT09IDAgJiYgIWFic29sdXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHg6IHgxLCB5OiB5MSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChsb2NhdGlvbiA9PT0gMSAmJiAhYWJzb2x1dGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgeDogeDIsIHk6IHkyIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbCA9IGFic29sdXRlID8gbG9jYXRpb24gPiAwID8gbG9jYXRpb24gOiBsZW5ndGggKyBsb2NhdGlvbiA6IGxvY2F0aW9uICogbGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2pnLnBvaW50T25MaW5lKHt4OiB4MSwgeTogeTF9LCB7eDogeDIsIHk6IHkyfSwgbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiByZXR1cm5zIHRoZSBncmFkaWVudCBvZiB0aGUgc2VnbWVudCBhdCB0aGUgZ2l2ZW4gcG9pbnQgLSB3aGljaCBmb3IgdXMgaXMgY29uc3RhbnQuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuZ3JhZGllbnRBdFBvaW50ID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogcmV0dXJucyB0aGUgcG9pbnQgb24gdGhlIHNlZ21lbnQncyBwYXRoIHRoYXQgaXMgJ2Rpc3RhbmNlJyBhbG9uZyB0aGUgbGVuZ3RoIG9mIHRoZSBwYXRoIGZyb20gJ2xvY2F0aW9uJywgd2hlcmVcbiAgICAgICAgICAgICAqICdsb2NhdGlvbicgaXMgYSBkZWNpbWFsIGZyb20gMCB0byAxIGluY2x1c2l2ZSwgYW5kICdkaXN0YW5jZScgaXMgYSBudW1iZXIgb2YgcGl4ZWxzLlxuICAgICAgICAgICAgICogdGhpcyBoYW5kcyBvZmYgdG8ganNQbHVtYlV0aWwgdG8gZG8gdGhlIG1hdGhzLCBzdXBwbHlpbmcgdHdvIHBvaW50cyBhbmQgdGhlIGRpc3RhbmNlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLnBvaW50QWxvbmdQYXRoRnJvbSA9IGZ1bmN0aW9uIChsb2NhdGlvbiwgZGlzdGFuY2UsIGFic29sdXRlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHAgPSB0aGlzLnBvaW50T25QYXRoKGxvY2F0aW9uLCBhYnNvbHV0ZSksXG4gICAgICAgICAgICAgICAgICAgIGZhckF3YXlQb2ludCA9IGRpc3RhbmNlIDw9IDAgPyB7eDogeDEsIHk6IHkxfSA6IHt4OiB4MiwgeTogeTIgfTtcblxuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgIGxvY2F0aW9uID09IDEgPyB7XG4gICAgICAgICAgICAgICAgIHg6eDEgKyAoKHgyIC0geDEpICogMTApLFxuICAgICAgICAgICAgICAgICB5OnkxICsgKCh5MSAtIHkyKSAqIDEwKVxuICAgICAgICAgICAgICAgICB9IDpcbiAgICAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgICAgIGlmIChkaXN0YW5jZSA8PSAwICYmIE1hdGguYWJzKGRpc3RhbmNlKSA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzdGFuY2UgKj0gLTE7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9qZy5wb2ludE9uTGluZShwLCBmYXJBd2F5UG9pbnQsIGRpc3RhbmNlKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIGlzIGMgYmV0d2VlbiBhIGFuZCBiP1xuICAgICAgICAgICAgdmFyIHdpdGhpbiA9IGZ1bmN0aW9uIChhLCBiLCBjKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGMgPj0gTWF0aC5taW4oYSwgYikgJiYgYyA8PSBNYXRoLm1heChhLCBiKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBmaW5kIHdoaWNoIG9mIGEgYW5kIGIgaXMgY2xvc2VzdCB0byBjXG4gICAgICAgICAgICB2YXIgY2xvc2VzdCA9IGZ1bmN0aW9uIChhLCBiLCBjKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGguYWJzKGMgLSBhKSA8IE1hdGguYWJzKGMgLSBiKSA/IGEgOiBiO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgRnVuY3Rpb246IGZpbmRDbG9zZXN0UG9pbnRPblBhdGhcbiAgICAgICAgICAgICBGaW5kcyB0aGUgY2xvc2VzdCBwb2ludCBvbiB0aGlzIHNlZ21lbnQgdG8gW3gseV0uIFNlZVxuICAgICAgICAgICAgIG5vdGVzIG9uIHRoaXMgbWV0aG9kIGluIEFic3RyYWN0U2VnbWVudC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5maW5kQ2xvc2VzdFBvaW50T25QYXRoID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgICAgICB2YXIgb3V0ID0ge1xuICAgICAgICAgICAgICAgICAgICBkOiBJbmZpbml0eSxcbiAgICAgICAgICAgICAgICAgICAgeDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgeTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgbDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgeDE6IHgxLFxuICAgICAgICAgICAgICAgICAgICB4MjogeDIsXG4gICAgICAgICAgICAgICAgICAgIHkxOiB5MSxcbiAgICAgICAgICAgICAgICAgICAgeTI6IHkyXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGlmIChtID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dC55ID0geTE7XG4gICAgICAgICAgICAgICAgICAgIG91dC54ID0gd2l0aGluKHgxLCB4MiwgeCkgPyB4IDogY2xvc2VzdCh4MSwgeDIsIHgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChtID09PSBJbmZpbml0eSB8fCBtID09PSAtSW5maW5pdHkpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0LnggPSB4MTtcbiAgICAgICAgICAgICAgICAgICAgb3V0LnkgPSB3aXRoaW4oeTEsIHkyLCB5KSA/IHkgOiBjbG9zZXN0KHkxLCB5MiwgeSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBjbG9zZXN0IHBvaW50IGxpZXMgb24gbm9ybWFsIGZyb20gZ2l2ZW4gcG9pbnQgdG8gdGhpcyBsaW5lLiAgXG4gICAgICAgICAgICAgICAgICAgIHZhciBiID0geTEgLSAobSAqIHgxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGIyID0geSAtIChtMiAqIHgpLFxuICAgICAgICAgICAgICAgICAgICAvLyB5MSA9IG0ueDEgKyBiIGFuZCB5MSA9IG0yLngxICsgYjJcbiAgICAgICAgICAgICAgICAgICAgLy8gc28gbS54MSArIGIgPSBtMi54MSArIGIyXG4gICAgICAgICAgICAgICAgICAgIC8vIHgxKG0gLSBtMikgPSBiMiAtIGJcbiAgICAgICAgICAgICAgICAgICAgLy8geDEgPSAoYjIgLSBiKSAvIChtIC0gbTIpXG4gICAgICAgICAgICAgICAgICAgICAgICBfeDEgPSAoYjIgLSBiKSAvIChtIC0gbTIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgX3kxID0gKG0gKiBfeDEpICsgYjtcblxuICAgICAgICAgICAgICAgICAgICBvdXQueCA9IHdpdGhpbih4MSwgeDIsIF94MSkgPyBfeDEgOiBjbG9zZXN0KHgxLCB4MiwgX3gxKTsvL194MTtcbiAgICAgICAgICAgICAgICAgICAgb3V0LnkgPSB3aXRoaW4oeTEsIHkyLCBfeTEpID8gX3kxIDogY2xvc2VzdCh5MSwgeTIsIF95MSk7Ly9feTE7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGZyYWN0aW9uSW5TZWdtZW50ID0gX2pnLmxpbmVMZW5ndGgoWyBvdXQueCwgb3V0LnkgXSwgWyB4MSwgeTEgXSk7XG4gICAgICAgICAgICAgICAgb3V0LmQgPSBfamcubGluZUxlbmd0aChbeCwgeV0sIFtvdXQueCwgb3V0LnldKTtcbiAgICAgICAgICAgICAgICBvdXQubCA9IGZyYWN0aW9uSW5TZWdtZW50IC8gbGVuZ3RoO1xuICAgICAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qXG4gICAgICAgICBBcmMgU2VnbWVudC4gWW91IG5lZWQgdG8gc3VwcGx5OlxuXG4gICAgICAgICByICAgLSAgIHJhZGl1c1xuICAgICAgICAgY3ggIC0gICBjZW50ZXIgeCBmb3IgdGhlIGFyY1xuICAgICAgICAgY3kgIC0gICBjZW50ZXIgeSBmb3IgdGhlIGFyY1xuICAgICAgICAgYWMgIC0gICB3aGV0aGVyIHRoZSBhcmMgaXMgYW50aWNsb2Nrd2lzZSBvciBub3QuIGRlZmF1bHQgaXMgY2xvY2t3aXNlLlxuXG4gICAgICAgICBhbmQgdGhlbiBlaXRoZXI6XG5cbiAgICAgICAgIHN0YXJ0QW5nbGUgIC0gICBzdGFydEFuZ2xlIGZvciB0aGUgYXJjLlxuICAgICAgICAgZW5kQW5nbGUgICAgLSAgIGVuZEFuZ2xlIGZvciB0aGUgYXJjLlxuXG4gICAgICAgICBvcjpcblxuICAgICAgICAgeDEgICAgICAgICAgLSAgIHggZm9yIHN0YXJ0IHBvaW50XG4gICAgICAgICB5MSAgICAgICAgICAtICAgeSBmb3Igc3RhcnQgcG9pbnRcbiAgICAgICAgIHgyICAgICAgICAgIC0gICB4IGZvciBlbmQgcG9pbnRcbiAgICAgICAgIHkyICAgICAgICAgIC0gICB5IGZvciBlbmQgcG9pbnRcblxuICAgICAgICAgKi9cbiAgICAgICAgQXJjOiBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgICAgICB2YXIgX3N1cGVyID0gX2pwLlNlZ21lbnRzLkFic3RyYWN0U2VnbWVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpLFxuICAgICAgICAgICAgICAgIF9jYWxjQW5nbGUgPSBmdW5jdGlvbiAoX3gsIF95KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfamcudGhldGEoW3BhcmFtcy5jeCwgcGFyYW1zLmN5XSwgW194LCBfeV0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgX2NhbGNBbmdsZUZvckxvY2F0aW9uID0gZnVuY3Rpb24gKHNlZ21lbnQsIGxvY2F0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWdtZW50LmFudGljbG9ja3dpc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzYSA9IHNlZ21lbnQuc3RhcnRBbmdsZSA8IHNlZ21lbnQuZW5kQW5nbGUgPyBzZWdtZW50LnN0YXJ0QW5nbGUgKyBUV09fUEkgOiBzZWdtZW50LnN0YXJ0QW5nbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcyA9IE1hdGguYWJzKHNhIC0gc2VnbWVudC5lbmRBbmdsZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2EgLSAocyAqIGxvY2F0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlYSA9IHNlZ21lbnQuZW5kQW5nbGUgPCBzZWdtZW50LnN0YXJ0QW5nbGUgPyBzZWdtZW50LmVuZEFuZ2xlICsgVFdPX1BJIDogc2VnbWVudC5lbmRBbmdsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcyA9IE1hdGguYWJzKGVhIC0gc2VnbWVudC5zdGFydEFuZ2xlKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlZ21lbnQuc3RhcnRBbmdsZSArIChzcyAqIGxvY2F0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgVFdPX1BJID0gMiAqIE1hdGguUEk7XG5cbiAgICAgICAgICAgIHRoaXMucmFkaXVzID0gcGFyYW1zLnI7XG4gICAgICAgICAgICB0aGlzLmFudGljbG9ja3dpc2UgPSBwYXJhbXMuYWM7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBcIkFyY1wiO1xuXG4gICAgICAgICAgICBpZiAocGFyYW1zLnN0YXJ0QW5nbGUgJiYgcGFyYW1zLmVuZEFuZ2xlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydEFuZ2xlID0gcGFyYW1zLnN0YXJ0QW5nbGU7XG4gICAgICAgICAgICAgICAgdGhpcy5lbmRBbmdsZSA9IHBhcmFtcy5lbmRBbmdsZTtcbiAgICAgICAgICAgICAgICB0aGlzLngxID0gcGFyYW1zLmN4ICsgKHRoaXMucmFkaXVzICogTWF0aC5jb3MocGFyYW1zLnN0YXJ0QW5nbGUpKTtcbiAgICAgICAgICAgICAgICB0aGlzLnkxID0gcGFyYW1zLmN5ICsgKHRoaXMucmFkaXVzICogTWF0aC5zaW4ocGFyYW1zLnN0YXJ0QW5nbGUpKTtcbiAgICAgICAgICAgICAgICB0aGlzLngyID0gcGFyYW1zLmN4ICsgKHRoaXMucmFkaXVzICogTWF0aC5jb3MocGFyYW1zLmVuZEFuZ2xlKSk7XG4gICAgICAgICAgICAgICAgdGhpcy55MiA9IHBhcmFtcy5jeSArICh0aGlzLnJhZGl1cyAqIE1hdGguc2luKHBhcmFtcy5lbmRBbmdsZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydEFuZ2xlID0gX2NhbGNBbmdsZShwYXJhbXMueDEsIHBhcmFtcy55MSk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbmRBbmdsZSA9IF9jYWxjQW5nbGUocGFyYW1zLngyLCBwYXJhbXMueTIpO1xuICAgICAgICAgICAgICAgIHRoaXMueDEgPSBwYXJhbXMueDE7XG4gICAgICAgICAgICAgICAgdGhpcy55MSA9IHBhcmFtcy55MTtcbiAgICAgICAgICAgICAgICB0aGlzLngyID0gcGFyYW1zLngyO1xuICAgICAgICAgICAgICAgIHRoaXMueTIgPSBwYXJhbXMueTI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmVuZEFuZ2xlIDwgMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZW5kQW5nbGUgKz0gVFdPX1BJO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuc3RhcnRBbmdsZSA8IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0QW5nbGUgKz0gVFdPX1BJO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBzZWdtZW50IGlzIHVzZWQgYnkgdm1sICAgICBcbiAgICAgICAgICAgIC8vdGhpcy5zZWdtZW50ID0gX2pnLnF1YWRyYW50KFt0aGlzLngxLCB0aGlzLnkxXSwgW3RoaXMueDIsIHRoaXMueTJdKTtcblxuICAgICAgICAgICAgLy8gd2Ugbm93IGhhdmUgc3RhcnRBbmdsZSBhbmQgZW5kQW5nbGUgYXMgcG9zaXRpdmUgbnVtYmVycywgbWVhbmluZyB0aGVcbiAgICAgICAgICAgIC8vIGFic29sdXRlIGRpZmZlcmVuY2UgKHxkfCkgYmV0d2VlbiB0aGVtIGlzIHRoZSBzd2VlcCAocykgb2YgdGhpcyBhcmMsIHVubGVzcyB0aGVcbiAgICAgICAgICAgIC8vIGFyYyBpcyAnYW50aWNsb2Nrd2lzZScgaW4gd2hpY2ggY2FzZSAncycgaXMgZ2l2ZW4gYnkgMlBJIC0gfGR8LlxuXG4gICAgICAgICAgICB2YXIgZWEgPSB0aGlzLmVuZEFuZ2xlIDwgdGhpcy5zdGFydEFuZ2xlID8gdGhpcy5lbmRBbmdsZSArIFRXT19QSSA6IHRoaXMuZW5kQW5nbGU7XG4gICAgICAgICAgICB0aGlzLnN3ZWVwID0gTWF0aC5hYnMoZWEgLSB0aGlzLnN0YXJ0QW5nbGUpO1xuICAgICAgICAgICAgaWYgKHRoaXMuYW50aWNsb2Nrd2lzZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3dlZXAgPSBUV09fUEkgLSB0aGlzLnN3ZWVwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNpcmN1bWZlcmVuY2UgPSAyICogTWF0aC5QSSAqIHRoaXMucmFkaXVzLFxuICAgICAgICAgICAgICAgIGZyYWMgPSB0aGlzLnN3ZWVwIC8gVFdPX1BJLFxuICAgICAgICAgICAgICAgIGxlbmd0aCA9IGNpcmN1bWZlcmVuY2UgKiBmcmFjO1xuXG4gICAgICAgICAgICB0aGlzLmdldExlbmd0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGVuZ3RoO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdGhpcy5nZXRCb3VuZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbWluWDogcGFyYW1zLmN4IC0gcGFyYW1zLnIsXG4gICAgICAgICAgICAgICAgICAgIG1heFg6IHBhcmFtcy5jeCArIHBhcmFtcy5yLFxuICAgICAgICAgICAgICAgICAgICBtaW5ZOiBwYXJhbXMuY3kgLSBwYXJhbXMucixcbiAgICAgICAgICAgICAgICAgICAgbWF4WTogcGFyYW1zLmN5ICsgcGFyYW1zLnJcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIFZFUllfU01BTExfVkFMVUUgPSAwLjAwMDAwMDAwMDEsXG4gICAgICAgICAgICAgICAgZ2VudGxlUm91bmQgPSBmdW5jdGlvbiAobikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZiA9IE1hdGguZmxvb3IobiksIHIgPSBNYXRoLmNlaWwobik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuIC0gZiA8IFZFUllfU01BTExfVkFMVUUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHIgLSBuIDwgVkVSWV9TTUFMTF9WQUxVRSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiByZXR1cm5zIHRoZSBwb2ludCBvbiB0aGUgc2VnbWVudCdzIHBhdGggdGhhdCBpcyAnbG9jYXRpb24nIGFsb25nIHRoZSBsZW5ndGggb2YgdGhlIHBhdGgsIHdoZXJlICdsb2NhdGlvbicgaXMgYSBkZWNpbWFsIGZyb21cbiAgICAgICAgICAgICAqIDAgdG8gMSBpbmNsdXNpdmUuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMucG9pbnRPblBhdGggPSBmdW5jdGlvbiAobG9jYXRpb24sIGFic29sdXRlKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAobG9jYXRpb24gPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgeDogdGhpcy54MSwgeTogdGhpcy55MSwgdGhldGE6IHRoaXMuc3RhcnRBbmdsZSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChsb2NhdGlvbiA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB4OiB0aGlzLngyLCB5OiB0aGlzLnkyLCB0aGV0YTogdGhpcy5lbmRBbmdsZSB9O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChhYnNvbHV0ZSkge1xuICAgICAgICAgICAgICAgICAgICBsb2NhdGlvbiA9IGxvY2F0aW9uIC8gbGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBhbmdsZSA9IF9jYWxjQW5nbGVGb3JMb2NhdGlvbih0aGlzLCBsb2NhdGlvbiksXG4gICAgICAgICAgICAgICAgICAgIF94ID0gcGFyYW1zLmN4ICsgKHBhcmFtcy5yICogTWF0aC5jb3MoYW5nbGUpKSxcbiAgICAgICAgICAgICAgICAgICAgX3kgPSBwYXJhbXMuY3kgKyAocGFyYW1zLnIgKiBNYXRoLnNpbihhbmdsZSkpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgeDogZ2VudGxlUm91bmQoX3gpLCB5OiBnZW50bGVSb3VuZChfeSksIHRoZXRhOiBhbmdsZSB9O1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiByZXR1cm5zIHRoZSBncmFkaWVudCBvZiB0aGUgc2VnbWVudCBhdCB0aGUgZ2l2ZW4gcG9pbnQuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuZ3JhZGllbnRBdFBvaW50ID0gZnVuY3Rpb24gKGxvY2F0aW9uLCBhYnNvbHV0ZSkge1xuICAgICAgICAgICAgICAgIHZhciBwID0gdGhpcy5wb2ludE9uUGF0aChsb2NhdGlvbiwgYWJzb2x1dGUpO1xuICAgICAgICAgICAgICAgIHZhciBtID0gX2pnLm5vcm1hbChbIHBhcmFtcy5jeCwgcGFyYW1zLmN5IF0sIFtwLngsIHAueSBdKTtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuYW50aWNsb2Nrd2lzZSAmJiAobSA9PT0gSW5maW5pdHkgfHwgbSA9PT0gLUluZmluaXR5KSkge1xuICAgICAgICAgICAgICAgICAgICBtICo9IC0xO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHRoaXMucG9pbnRBbG9uZ1BhdGhGcm9tID0gZnVuY3Rpb24gKGxvY2F0aW9uLCBkaXN0YW5jZSwgYWJzb2x1dGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgcCA9IHRoaXMucG9pbnRPblBhdGgobG9jYXRpb24sIGFic29sdXRlKSxcbiAgICAgICAgICAgICAgICAgICAgYXJjU3BhbiA9IGRpc3RhbmNlIC8gY2lyY3VtZmVyZW5jZSAqIDIgKiBNYXRoLlBJLFxuICAgICAgICAgICAgICAgICAgICBkaXIgPSB0aGlzLmFudGljbG9ja3dpc2UgPyAtMSA6IDEsXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0QW5nbGUgPSBwLnRoZXRhICsgKGRpciAqIGFyY1NwYW4pLFxuICAgICAgICAgICAgICAgICAgICBzdGFydFggPSBwYXJhbXMuY3ggKyAodGhpcy5yYWRpdXMgKiBNYXRoLmNvcyhzdGFydEFuZ2xlKSksXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0WSA9IHBhcmFtcy5jeSArICh0aGlzLnJhZGl1cyAqIE1hdGguc2luKHN0YXJ0QW5nbGUpKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB7eDogc3RhcnRYLCB5OiBzdGFydFl9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICBCZXppZXI6IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgICAgIHRoaXMuY3VydmUgPSBbXG4gICAgICAgICAgICAgICAgeyB4OiBwYXJhbXMueDEsIHk6IHBhcmFtcy55MX0sXG4gICAgICAgICAgICAgICAgeyB4OiBwYXJhbXMuY3AxeCwgeTogcGFyYW1zLmNwMXkgfSxcbiAgICAgICAgICAgICAgICB7IHg6IHBhcmFtcy5jcDJ4LCB5OiBwYXJhbXMuY3AyeSB9LFxuICAgICAgICAgICAgICAgIHsgeDogcGFyYW1zLngyLCB5OiBwYXJhbXMueTIgfVxuICAgICAgICAgICAgXTtcblxuICAgICAgICAgICAgdmFyIF9zdXBlciA9IF9qcC5TZWdtZW50cy5BYnN0cmFjdFNlZ21lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIC8vIGFsdGhvdWdoIHRoaXMgaXMgbm90IGEgc3RyaWN0bHkgcmlnb3JvdXMgZGV0ZXJtaW5hdGlvbiBvZiBib3VuZHNcbiAgICAgICAgICAgIC8vIG9mIGEgYmV6aWVyIGN1cnZlLCBpdCB3b3JrcyBmb3IgdGhlIHR5cGVzIG9mIGN1cnZlcyB0aGF0IHRoaXMgc2VnbWVudFxuICAgICAgICAgICAgLy8gdHlwZSBwcm9kdWNlcy5cbiAgICAgICAgICAgIHRoaXMuYm91bmRzID0ge1xuICAgICAgICAgICAgICAgIG1pblg6IE1hdGgubWluKHBhcmFtcy54MSwgcGFyYW1zLngyLCBwYXJhbXMuY3AxeCwgcGFyYW1zLmNwMngpLFxuICAgICAgICAgICAgICAgIG1pblk6IE1hdGgubWluKHBhcmFtcy55MSwgcGFyYW1zLnkyLCBwYXJhbXMuY3AxeSwgcGFyYW1zLmNwMnkpLFxuICAgICAgICAgICAgICAgIG1heFg6IE1hdGgubWF4KHBhcmFtcy54MSwgcGFyYW1zLngyLCBwYXJhbXMuY3AxeCwgcGFyYW1zLmNwMngpLFxuICAgICAgICAgICAgICAgIG1heFk6IE1hdGgubWF4KHBhcmFtcy55MSwgcGFyYW1zLnkyLCBwYXJhbXMuY3AxeSwgcGFyYW1zLmNwMnkpXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBcIkJlemllclwiO1xuXG4gICAgICAgICAgICB2YXIgX3RyYW5zbGF0ZUxvY2F0aW9uID0gZnVuY3Rpb24gKF9jdXJ2ZSwgbG9jYXRpb24sIGFic29sdXRlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFic29sdXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uID0gcm9vdC5qc0Jlemllci5sb2NhdGlvbkFsb25nQ3VydmVGcm9tKF9jdXJ2ZSwgbG9jYXRpb24gPiAwID8gMCA6IDEsIGxvY2F0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gbG9jYXRpb247XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIHJldHVybnMgdGhlIHBvaW50IG9uIHRoZSBzZWdtZW50J3MgcGF0aCB0aGF0IGlzICdsb2NhdGlvbicgYWxvbmcgdGhlIGxlbmd0aCBvZiB0aGUgcGF0aCwgd2hlcmUgJ2xvY2F0aW9uJyBpcyBhIGRlY2ltYWwgZnJvbVxuICAgICAgICAgICAgICogMCB0byAxIGluY2x1c2l2ZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5wb2ludE9uUGF0aCA9IGZ1bmN0aW9uIChsb2NhdGlvbiwgYWJzb2x1dGUpIHtcbiAgICAgICAgICAgICAgICBsb2NhdGlvbiA9IF90cmFuc2xhdGVMb2NhdGlvbih0aGlzLmN1cnZlLCBsb2NhdGlvbiwgYWJzb2x1dGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiByb290LmpzQmV6aWVyLnBvaW50T25DdXJ2ZSh0aGlzLmN1cnZlLCBsb2NhdGlvbik7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIHJldHVybnMgdGhlIGdyYWRpZW50IG9mIHRoZSBzZWdtZW50IGF0IHRoZSBnaXZlbiBwb2ludC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5ncmFkaWVudEF0UG9pbnQgPSBmdW5jdGlvbiAobG9jYXRpb24sIGFic29sdXRlKSB7XG4gICAgICAgICAgICAgICAgbG9jYXRpb24gPSBfdHJhbnNsYXRlTG9jYXRpb24odGhpcy5jdXJ2ZSwgbG9jYXRpb24sIGFic29sdXRlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcm9vdC5qc0Jlemllci5ncmFkaWVudEF0UG9pbnQodGhpcy5jdXJ2ZSwgbG9jYXRpb24pO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdGhpcy5wb2ludEFsb25nUGF0aEZyb20gPSBmdW5jdGlvbiAobG9jYXRpb24sIGRpc3RhbmNlLCBhYnNvbHV0ZSkge1xuICAgICAgICAgICAgICAgIGxvY2F0aW9uID0gX3RyYW5zbGF0ZUxvY2F0aW9uKHRoaXMuY3VydmUsIGxvY2F0aW9uLCBhYnNvbHV0ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJvb3QuanNCZXppZXIucG9pbnRBbG9uZ0N1cnZlRnJvbSh0aGlzLmN1cnZlLCBsb2NhdGlvbiwgZGlzdGFuY2UpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdGhpcy5nZXRMZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJvb3QuanNCZXppZXIuZ2V0TGVuZ3RoKHRoaXMuY3VydmUpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdGhpcy5nZXRCb3VuZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYm91bmRzO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBfanAuU2VnbWVudFJlbmRlcmVyID0ge1xuICAgICAgICBnZXRQYXRoOiBmdW5jdGlvbiAoc2VnbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuICh7XG4gICAgICAgICAgICAgICAgXCJTdHJhaWdodFwiOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkID0gc2VnbWVudC5nZXRDb29yZGluYXRlcygpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJNIFwiICsgZC54MSArIFwiIFwiICsgZC55MSArIFwiIEwgXCIgKyBkLngyICsgXCIgXCIgKyBkLnkyO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJCZXppZXJcIjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZCA9IHNlZ21lbnQucGFyYW1zO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJNIFwiICsgZC54MSArIFwiIFwiICsgZC55MSArXG4gICAgICAgICAgICAgICAgICAgICAgICBcIiBDIFwiICsgZC5jcDF4ICsgXCIgXCIgKyBkLmNwMXkgKyBcIiBcIiArIGQuY3AyeCArIFwiIFwiICsgZC5jcDJ5ICsgXCIgXCIgKyBkLngyICsgXCIgXCIgKyBkLnkyO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJBcmNcIjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZCA9IHNlZ21lbnQucGFyYW1zLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGFmID0gc2VnbWVudC5zd2VlcCA+IE1hdGguUEkgPyAxIDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNmID0gc2VnbWVudC5hbnRpY2xvY2t3aXNlID8gMCA6IDE7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiTVwiICsgc2VnbWVudC54MSArIFwiIFwiICsgc2VnbWVudC55MSArIFwiIEEgXCIgKyBzZWdtZW50LnJhZGl1cyArIFwiIFwiICsgZC5yICsgXCIgMCBcIiArIGxhZiArIFwiLFwiICsgc2YgKyBcIiBcIiArIHNlZ21lbnQueDIgKyBcIiBcIiArIHNlZ21lbnQueTI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlbc2VnbWVudC50eXBlXSgpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qXG4gICAgIENsYXNzOiBBYnN0cmFjdENvbXBvbmVudFxuICAgICBTdXBlcmNsYXNzIGZvciBBYnN0cmFjdENvbm5lY3RvciBhbmQgQWJzdHJhY3RFbmRwb2ludC5cbiAgICAgKi9cbiAgICB2YXIgQWJzdHJhY3RDb21wb25lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucmVzZXRCb3VuZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmJvdW5kcyA9IHsgbWluWDogSW5maW5pdHksIG1pblk6IEluZmluaXR5LCBtYXhYOiAtSW5maW5pdHksIG1heFk6IC1JbmZpbml0eSB9O1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnJlc2V0Qm91bmRzKCk7XG4gICAgfTtcblxuICAgIC8qXG4gICAgICogQ2xhc3M6IEFic3RyYWN0Q29ubmVjdG9yXG4gICAgICogU3VwZXJjbGFzcyBmb3IgYWxsIENvbm5lY3RvcnM7IGhlcmUgaXMgd2hlcmUgU2VnbWVudHMgYXJlIG1hbmFnZWQuICBUaGlzIGlzIGV4cG9zZWQgb24ganNQbHVtYiBqdXN0IHNvIGl0XG4gICAgICogY2FuIGJlIGFjY2Vzc2VkIGZyb20gb3RoZXIgZmlsZXMuIFlvdSBzaG91bGQgbm90IHRyeSB0byBpbnN0YW50aWF0ZSBvbmUgb2YgdGhlc2UgZGlyZWN0bHkuXG4gICAgICpcbiAgICAgKiBXaGVuIHRoaXMgY2xhc3MgaXMgYXNrZWQgZm9yIGEgcG9pbnRPblBhdGgsIG9yIGdyYWRpZW50IGV0YywgaXQgbXVzdCBmaXJzdCBmaWd1cmUgb3V0IHdoaWNoIHNlZ21lbnQgdG8gZGlzcGF0Y2hcbiAgICAgKiB0aGF0IHJlcXVlc3QgdG8uIFRoaXMgaXMgZG9uZSBieSBrZWVwaW5nIHRyYWNrIG9mIHRoZSB0b3RhbCBjb25uZWN0b3IgbGVuZ3RoIGFzIHNlZ21lbnRzIGFyZSBhZGRlZCwgYW5kIGFsc29cbiAgICAgKiB0aGVpciBjdW11bGF0aXZlIHJhdGlvcyB0byB0aGUgdG90YWwgbGVuZ3RoLiAgVGhlbiB3aGVuIHRoZSByaWdodCBzZWdtZW50IGlzIGZvdW5kIGl0IGlzIGEgc2ltcGxlIGNhc2Ugb2YgZGlzcGF0Y2hpbmdcbiAgICAgKiB0aGUgcmVxdWVzdCB0byBpdCAoYW5kIGFkanVzdGluZyAnbG9jYXRpb24nIHNvIHRoYXQgaXQgaXMgcmVsYXRpdmUgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGF0IHNlZ21lbnQuKVxuICAgICAqL1xuICAgIF9qcC5Db25uZWN0b3JzLkFic3RyYWN0Q29ubmVjdG9yID0gZnVuY3Rpb24gKHBhcmFtcykge1xuXG4gICAgICAgIEFic3RyYWN0Q29tcG9uZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgdmFyIHNlZ21lbnRzID0gW10sXG4gICAgICAgICAgICB0b3RhbExlbmd0aCA9IDAsXG4gICAgICAgICAgICBzZWdtZW50UHJvcG9ydGlvbnMgPSBbXSxcbiAgICAgICAgICAgIHNlZ21lbnRQcm9wb3J0aW9uYWxMZW5ndGhzID0gW10sXG4gICAgICAgICAgICBzdHViID0gcGFyYW1zLnN0dWIgfHwgMCxcbiAgICAgICAgICAgIHNvdXJjZVN0dWIgPSBfanUuaXNBcnJheShzdHViKSA/IHN0dWJbMF0gOiBzdHViLFxuICAgICAgICAgICAgdGFyZ2V0U3R1YiA9IF9qdS5pc0FycmF5KHN0dWIpID8gc3R1YlsxXSA6IHN0dWIsXG4gICAgICAgICAgICBnYXAgPSBwYXJhbXMuZ2FwIHx8IDAsXG4gICAgICAgICAgICBzb3VyY2VHYXAgPSBfanUuaXNBcnJheShnYXApID8gZ2FwWzBdIDogZ2FwLFxuICAgICAgICAgICAgdGFyZ2V0R2FwID0gX2p1LmlzQXJyYXkoZ2FwKSA/IGdhcFsxXSA6IGdhcCxcbiAgICAgICAgICAgIHVzZXJQcm92aWRlZFNlZ21lbnRzID0gbnVsbCxcbiAgICAgICAgICAgIGVkaXRlZCA9IGZhbHNlLFxuICAgICAgICAgICAgcGFpbnRJbmZvID0gbnVsbCxcbiAgICAgICAgICAgIGdlb21ldHJ5ID0gbnVsbCxcbiAgICAgICAgICAgIGVkaXRhYmxlID0gcGFyYW1zLmVkaXRhYmxlICE9PSBmYWxzZSAmJiBfanAuQ29ubmVjdG9yRWRpdG9ycyAhPSBudWxsICYmIF9qcC5Db25uZWN0b3JFZGl0b3JzW3RoaXMudHlwZV0gIT0gbnVsbDtcblxuICAgICAgICB2YXIgX3NldEdlb21ldHJ5ID0gdGhpcy5zZXRHZW9tZXRyeSA9IGZ1bmN0aW9uKGcsIGludGVybmFsbHlDb21wdXRlZCkge1xuICAgICAgICAgICAgZWRpdGVkID0gKCFpbnRlcm5hbGx5Q29tcHV0ZWQpO1xuICAgICAgICAgICAgZ2VvbWV0cnkgPSBnO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgX2dldEdlb21ldHJ5ID0gdGhpcy5nZXRHZW9tZXRyeSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGdlb21ldHJ5O1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuZ2V0UGF0aERhdGEgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBwID0gXCJcIjtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBwICs9IF9qcC5TZWdtZW50UmVuZGVyZXIuZ2V0UGF0aChzZWdtZW50c1tpXSk7XG4gICAgICAgICAgICAgICAgcCArPSBcIiBcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuaGFzQmVlbkVkaXRlZCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gZWRpdGVkOyB9O1xuICAgICAgICB0aGlzLmlzRWRpdGluZyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5lZGl0b3IgIT0gbnVsbCAmJiB0aGlzLmVkaXRvci5pc0FjdGl2ZSgpOyB9O1xuICAgICAgICB0aGlzLnNldEVkaXRhYmxlID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgLy8gaWYgdGhpcyBjb25uZWN0b3IgaGFzIGFuIGVkaXRvciBhbHJlYWR5LCBvclxuICAgICAgICAgICAgLy8gaWYgYW4gZWRpdG9yIGZvciB0aGlzIGNvbm5lY3RvcidzIHR5cGUgaXMgYXZhaWxhYmxlLCBvclxuICAgICAgICAgICAgLy8gaWYgdGhlIGNoaWxkIGRlY2xhcmVzIGFuIG92ZXJyaWRlU2V0RWRpdGFibGUgYW5kIGl0IGRvZXMgbm90IHJldHVybiBmYWxzZSwgZWRpdGFibGUgaXMgdHJ1ZS5cbiAgICAgICAgICAgIGlmIChlICYmIF9qcC5Db25uZWN0b3JFZGl0b3JzICE9IG51bGwgJiYgX2pwLkNvbm5lY3RvckVkaXRvcnNbdGhpcy50eXBlXSAhPSBudWxsICYmICh0aGlzLm92ZXJyaWRlU2V0RWRpdGFibGUgPT0gbnVsbCB8fCB0aGlzLm92ZXJyaWRlU2V0RWRpdGFibGUoKSkpIHtcbiAgICAgICAgICAgICAgICBlZGl0YWJsZSA9IGU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVkaXRhYmxlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZWRpdGFibGU7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaXNFZGl0YWJsZSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gZWRpdGFibGU7IH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZ1bmN0aW9uOiBmaW5kU2VnbWVudEZvclBvaW50XG4gICAgICAgICAqIFJldHVybnMgdGhlIHNlZ21lbnQgdGhhdCBpcyBjbG9zZXN0IHRvIHRoZSBnaXZlbiBbeCx5XSxcbiAgICAgICAgICogbnVsbCBpZiBub3RoaW5nIGZvdW5kLiAgVGhpcyBmdW5jdGlvbiByZXR1cm5zIGEgSlNcbiAgICAgICAgICogb2JqZWN0IHdpdGg6XG4gICAgICAgICAqXG4gICAgICAgICAqICAgZCAgIC0gICBkaXN0YW5jZSBmcm9tIHNlZ21lbnRcbiAgICAgICAgICogICBsICAgLSAgIHByb3BvcnRpb25hbCBsb2NhdGlvbiBpbiBzZWdtZW50XG4gICAgICAgICAqICAgeCAgIC0gICB4IHBvaW50IG9uIHRoZSBzZWdtZW50XG4gICAgICAgICAqICAgeSAgIC0gICB5IHBvaW50IG9uIHRoZSBzZWdtZW50XG4gICAgICAgICAqICAgcyAgIC0gICB0aGUgc2VnbWVudCBpdHNlbGYuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmZpbmRTZWdtZW50Rm9yUG9pbnQgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgdmFyIG91dCA9IHsgZDogSW5maW5pdHksIHM6IG51bGwsIHg6IG51bGwsIHk6IG51bGwsIGw6IG51bGwgfTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgX3MgPSBzZWdtZW50c1tpXS5maW5kQ2xvc2VzdFBvaW50T25QYXRoKHgsIHkpO1xuICAgICAgICAgICAgICAgIGlmIChfcy5kIDwgb3V0LmQpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0LmQgPSBfcy5kO1xuICAgICAgICAgICAgICAgICAgICBvdXQubCA9IF9zLmw7XG4gICAgICAgICAgICAgICAgICAgIG91dC54ID0gX3MueDtcbiAgICAgICAgICAgICAgICAgICAgb3V0LnkgPSBfcy55O1xuICAgICAgICAgICAgICAgICAgICBvdXQucyA9IHNlZ21lbnRzW2ldO1xuICAgICAgICAgICAgICAgICAgICBvdXQueDEgPSBfcy54MTtcbiAgICAgICAgICAgICAgICAgICAgb3V0LngyID0gX3MueDI7XG4gICAgICAgICAgICAgICAgICAgIG91dC55MSA9IF9zLnkxO1xuICAgICAgICAgICAgICAgICAgICBvdXQueTIgPSBfcy55MjtcbiAgICAgICAgICAgICAgICAgICAgb3V0LmluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIF91cGRhdGVTZWdtZW50UHJvcG9ydGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGN1ckxvYyA9IDA7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2wgPSBzZWdtZW50c1tpXS5nZXRMZW5ndGgoKTtcbiAgICAgICAgICAgICAgICAgICAgc2VnbWVudFByb3BvcnRpb25hbExlbmd0aHNbaV0gPSBzbCAvIHRvdGFsTGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBzZWdtZW50UHJvcG9ydGlvbnNbaV0gPSBbY3VyTG9jLCAoY3VyTG9jICs9IChzbCAvIHRvdGFsTGVuZ3RoKSkgXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIHJldHVybnMgW3NlZ21lbnQsIHByb3BvcnRpb24gb2YgdHJhdmVsIGluIHNlZ21lbnQsIHNlZ21lbnQgaW5kZXhdIGZvciB0aGUgc2VnbWVudFxuICAgICAgICAgICAgICogdGhhdCBjb250YWlucyB0aGUgcG9pbnQgd2hpY2ggaXMgJ2xvY2F0aW9uJyBkaXN0YW5jZSBhbG9uZyB0aGUgZW50aXJlIHBhdGgsIHdoZXJlXG4gICAgICAgICAgICAgKiAnbG9jYXRpb24nIGlzIGEgZGVjaW1hbCBiZXR3ZWVuIDAgYW5kIDEgaW5jbHVzaXZlLiBpbiB0aGlzIGNvbm5lY3RvciB0eXBlLCBwYXRoc1xuICAgICAgICAgICAgICogYXJlIG1hZGUgdXAgb2YgYSBsaXN0IG9mIHNlZ21lbnRzLCBlYWNoIG9mIHdoaWNoIGNvbnRyaWJ1dGVzIHNvbWUgZnJhY3Rpb24gdG9cbiAgICAgICAgICAgICAqIHRoZSB0b3RhbCBsZW5ndGguXG4gICAgICAgICAgICAgKiBGcm9tIDEuMy4xMCB0aGlzIGFsc28gc3VwcG9ydHMgdGhlICdhYnNvbHV0ZScgcHJvcGVydHksIHdoaWNoIGxldHMgdXMgc3BlY2lmeSBhIGxvY2F0aW9uXG4gICAgICAgICAgICAgKiBhcyB0aGUgYWJzb2x1dGUgZGlzdGFuY2UgaW4gcGl4ZWxzLCByYXRoZXIgdGhhbiBhIHByb3BvcnRpb24gb2YgdGhlIHRvdGFsIHBhdGguXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIF9maW5kU2VnbWVudEZvckxvY2F0aW9uID0gZnVuY3Rpb24gKGxvY2F0aW9uLCBhYnNvbHV0ZSkge1xuICAgICAgICAgICAgICAgIGlmIChhYnNvbHV0ZSkge1xuICAgICAgICAgICAgICAgICAgICBsb2NhdGlvbiA9IGxvY2F0aW9uID4gMCA/IGxvY2F0aW9uIC8gdG90YWxMZW5ndGggOiAodG90YWxMZW5ndGggKyBsb2NhdGlvbikgLyB0b3RhbExlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGlkeCA9IHNlZ21lbnRQcm9wb3J0aW9ucy5sZW5ndGggLSAxLCBpblNlZ21lbnRQcm9wb3J0aW9uID0gMTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlZ21lbnRQcm9wb3J0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VnbWVudFByb3BvcnRpb25zW2ldWzFdID49IGxvY2F0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZHggPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdG9kbyBpcyB0aGlzIGNvcnJlY3QgZm9yIGFsbCBjb25uZWN0b3IgcGF0aCB0eXBlcz9cbiAgICAgICAgICAgICAgICAgICAgICAgIGluU2VnbWVudFByb3BvcnRpb24gPSBsb2NhdGlvbiA9PT0gMSA/IDEgOiBsb2NhdGlvbiA9PT0gMCA/IDAgOiAobG9jYXRpb24gLSBzZWdtZW50UHJvcG9ydGlvbnNbaV1bMF0pIC8gc2VnbWVudFByb3BvcnRpb25hbExlbmd0aHNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4geyBzZWdtZW50OiBzZWdtZW50c1tpZHhdLCBwcm9wb3J0aW9uOiBpblNlZ21lbnRQcm9wb3J0aW9uLCBpbmRleDogaWR4IH07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2FkZFNlZ21lbnQgPSBmdW5jdGlvbiAoY29ubiwgdHlwZSwgcGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtcy54MSA9PT0gcGFyYW1zLngyICYmIHBhcmFtcy55MSA9PT0gcGFyYW1zLnkyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHMgPSBuZXcgX2pwLlNlZ21lbnRzW3R5cGVdKHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgc2VnbWVudHMucHVzaChzKTtcbiAgICAgICAgICAgICAgICB0b3RhbExlbmd0aCArPSBzLmdldExlbmd0aCgpO1xuICAgICAgICAgICAgICAgIGNvbm4udXBkYXRlQm91bmRzKHMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9jbGVhclNlZ21lbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRvdGFsTGVuZ3RoID0gc2VnbWVudHMubGVuZ3RoID0gc2VnbWVudFByb3BvcnRpb25zLmxlbmd0aCA9IHNlZ21lbnRQcm9wb3J0aW9uYWxMZW5ndGhzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuc2V0U2VnbWVudHMgPSBmdW5jdGlvbiAoX3NlZ3MpIHtcbiAgICAgICAgICAgIHVzZXJQcm92aWRlZFNlZ21lbnRzID0gW107XG4gICAgICAgICAgICB0b3RhbExlbmd0aCA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF9zZWdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdXNlclByb3ZpZGVkU2VnbWVudHMucHVzaChfc2Vnc1tpXSk7XG4gICAgICAgICAgICAgICAgdG90YWxMZW5ndGggKz0gX3NlZ3NbaV0uZ2V0TGVuZ3RoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5nZXRMZW5ndGggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0b3RhbExlbmd0aDtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgX3ByZXBhcmVDb21wdXRlID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICAgICAgdGhpcy5zdHJva2VXaWR0aCA9IHBhcmFtcy5zdHJva2VXaWR0aDtcbiAgICAgICAgICAgIHZhciBzZWdtZW50ID0gX2pnLnF1YWRyYW50KHBhcmFtcy5zb3VyY2VQb3MsIHBhcmFtcy50YXJnZXRQb3MpLFxuICAgICAgICAgICAgICAgIHN3YXBYID0gcGFyYW1zLnRhcmdldFBvc1swXSA8IHBhcmFtcy5zb3VyY2VQb3NbMF0sXG4gICAgICAgICAgICAgICAgc3dhcFkgPSBwYXJhbXMudGFyZ2V0UG9zWzFdIDwgcGFyYW1zLnNvdXJjZVBvc1sxXSxcbiAgICAgICAgICAgICAgICBsdyA9IHBhcmFtcy5zdHJva2VXaWR0aCB8fCAxLFxuICAgICAgICAgICAgICAgIHNvID0gcGFyYW1zLnNvdXJjZUVuZHBvaW50LmFuY2hvci5nZXRPcmllbnRhdGlvbihwYXJhbXMuc291cmNlRW5kcG9pbnQpLFxuICAgICAgICAgICAgICAgIHRvID0gcGFyYW1zLnRhcmdldEVuZHBvaW50LmFuY2hvci5nZXRPcmllbnRhdGlvbihwYXJhbXMudGFyZ2V0RW5kcG9pbnQpLFxuICAgICAgICAgICAgICAgIHggPSBzd2FwWCA/IHBhcmFtcy50YXJnZXRQb3NbMF0gOiBwYXJhbXMuc291cmNlUG9zWzBdLFxuICAgICAgICAgICAgICAgIHkgPSBzd2FwWSA/IHBhcmFtcy50YXJnZXRQb3NbMV0gOiBwYXJhbXMuc291cmNlUG9zWzFdLFxuICAgICAgICAgICAgICAgIHcgPSBNYXRoLmFicyhwYXJhbXMudGFyZ2V0UG9zWzBdIC0gcGFyYW1zLnNvdXJjZVBvc1swXSksXG4gICAgICAgICAgICAgICAgaCA9IE1hdGguYWJzKHBhcmFtcy50YXJnZXRQb3NbMV0gLSBwYXJhbXMuc291cmNlUG9zWzFdKTtcblxuICAgICAgICAgICAgLy8gaWYgZWl0aGVyIGFuY2hvciBkb2VzIG5vdCBoYXZlIGFuIG9yaWVudGF0aW9uIHNldCwgd2UgZGVyaXZlIG9uZSBmcm9tIHRoZWlyIHJlbGF0aXZlXG4gICAgICAgICAgICAvLyBwb3NpdGlvbnMuICB3ZSBmaXggdGhlIGF4aXMgdG8gYmUgdGhlIG9uZSBpbiB3aGljaCB0aGUgdHdvIGVsZW1lbnRzIGFyZSBmdXJ0aGVyIGFwYXJ0LCBhbmRcbiAgICAgICAgICAgIC8vIHBvaW50IGVhY2ggYW5jaG9yIGF0IHRoZSBvdGhlciBlbGVtZW50LiAgdGhpcyBpcyBhbHNvIHVzZWQgd2hlbiBkcmFnZ2luZyBhIG5ldyBjb25uZWN0aW9uLlxuICAgICAgICAgICAgaWYgKHNvWzBdID09PSAwICYmIHNvWzFdID09PSAwIHx8IHRvWzBdID09PSAwICYmIHRvWzFdID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gdyA+IGggPyAwIDogMSwgb0luZGV4ID0gWzEsIDBdW2luZGV4XTtcbiAgICAgICAgICAgICAgICBzbyA9IFtdO1xuICAgICAgICAgICAgICAgIHRvID0gW107XG4gICAgICAgICAgICAgICAgc29baW5kZXhdID0gcGFyYW1zLnNvdXJjZVBvc1tpbmRleF0gPiBwYXJhbXMudGFyZ2V0UG9zW2luZGV4XSA/IC0xIDogMTtcbiAgICAgICAgICAgICAgICB0b1tpbmRleF0gPSBwYXJhbXMuc291cmNlUG9zW2luZGV4XSA+IHBhcmFtcy50YXJnZXRQb3NbaW5kZXhdID8gMSA6IC0xO1xuICAgICAgICAgICAgICAgIHNvW29JbmRleF0gPSAwO1xuICAgICAgICAgICAgICAgIHRvW29JbmRleF0gPSAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgc3ggPSBzd2FwWCA/IHcgKyAoc291cmNlR2FwICogc29bMF0pIDogc291cmNlR2FwICogc29bMF0sXG4gICAgICAgICAgICAgICAgc3kgPSBzd2FwWSA/IGggKyAoc291cmNlR2FwICogc29bMV0pIDogc291cmNlR2FwICogc29bMV0sXG4gICAgICAgICAgICAgICAgdHggPSBzd2FwWCA/IHRhcmdldEdhcCAqIHRvWzBdIDogdyArICh0YXJnZXRHYXAgKiB0b1swXSksXG4gICAgICAgICAgICAgICAgdHkgPSBzd2FwWSA/IHRhcmdldEdhcCAqIHRvWzFdIDogaCArICh0YXJnZXRHYXAgKiB0b1sxXSksXG4gICAgICAgICAgICAgICAgb1Byb2R1Y3QgPSAoKHNvWzBdICogdG9bMF0pICsgKHNvWzFdICogdG9bMV0pKTtcblxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgICBzeDogc3gsIHN5OiBzeSwgdHg6IHR4LCB0eTogdHksIGx3OiBsdyxcbiAgICAgICAgICAgICAgICB4U3BhbjogTWF0aC5hYnModHggLSBzeCksXG4gICAgICAgICAgICAgICAgeVNwYW46IE1hdGguYWJzKHR5IC0gc3kpLFxuICAgICAgICAgICAgICAgIG14OiAoc3ggKyB0eCkgLyAyLFxuICAgICAgICAgICAgICAgIG15OiAoc3kgKyB0eSkgLyAyLFxuICAgICAgICAgICAgICAgIHNvOiBzbywgdG86IHRvLCB4OiB4LCB5OiB5LCB3OiB3LCBoOiBoLFxuICAgICAgICAgICAgICAgIHNlZ21lbnQ6IHNlZ21lbnQsXG4gICAgICAgICAgICAgICAgc3RhcnRTdHViWDogc3ggKyAoc29bMF0gKiBzb3VyY2VTdHViKSxcbiAgICAgICAgICAgICAgICBzdGFydFN0dWJZOiBzeSArIChzb1sxXSAqIHNvdXJjZVN0dWIpLFxuICAgICAgICAgICAgICAgIGVuZFN0dWJYOiB0eCArICh0b1swXSAqIHRhcmdldFN0dWIpLFxuICAgICAgICAgICAgICAgIGVuZFN0dWJZOiB0eSArICh0b1sxXSAqIHRhcmdldFN0dWIpLFxuICAgICAgICAgICAgICAgIGlzWEdyZWF0ZXJUaGFuU3R1YlRpbWVzMjogTWF0aC5hYnMoc3ggLSB0eCkgPiAoc291cmNlU3R1YiArIHRhcmdldFN0dWIpLFxuICAgICAgICAgICAgICAgIGlzWUdyZWF0ZXJUaGFuU3R1YlRpbWVzMjogTWF0aC5hYnMoc3kgLSB0eSkgPiAoc291cmNlU3R1YiArIHRhcmdldFN0dWIpLFxuICAgICAgICAgICAgICAgIG9wcG9zaXRlOiBvUHJvZHVjdCA9PT0gLTEsXG4gICAgICAgICAgICAgICAgcGVycGVuZGljdWxhcjogb1Byb2R1Y3QgPT09IDAsXG4gICAgICAgICAgICAgICAgb3J0aG9nb25hbDogb1Byb2R1Y3QgPT09IDEsXG4gICAgICAgICAgICAgICAgc291cmNlQXhpczogc29bMF0gPT09IDAgPyBcInlcIiA6IFwieFwiLFxuICAgICAgICAgICAgICAgIHBvaW50czogW3gsIHksIHcsIGgsIHN4LCBzeSwgdHgsIHR5IF1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXN1bHQuYW5jaG9yT3JpZW50YXRpb24gPSByZXN1bHQub3Bwb3NpdGUgPyBcIm9wcG9zaXRlXCIgOiByZXN1bHQub3J0aG9nb25hbCA/IFwib3J0aG9nb25hbFwiIDogXCJwZXJwZW5kaWN1bGFyXCI7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuZ2V0U2VnbWVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VnbWVudHM7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy51cGRhdGVCb3VuZHMgPSBmdW5jdGlvbiAoc2VnbWVudCkge1xuICAgICAgICAgICAgdmFyIHNlZ0JvdW5kcyA9IHNlZ21lbnQuZ2V0Qm91bmRzKCk7XG4gICAgICAgICAgICB0aGlzLmJvdW5kcy5taW5YID0gTWF0aC5taW4odGhpcy5ib3VuZHMubWluWCwgc2VnQm91bmRzLm1pblgpO1xuICAgICAgICAgICAgdGhpcy5ib3VuZHMubWF4WCA9IE1hdGgubWF4KHRoaXMuYm91bmRzLm1heFgsIHNlZ0JvdW5kcy5tYXhYKTtcbiAgICAgICAgICAgIHRoaXMuYm91bmRzLm1pblkgPSBNYXRoLm1pbih0aGlzLmJvdW5kcy5taW5ZLCBzZWdCb3VuZHMubWluWSk7XG4gICAgICAgICAgICB0aGlzLmJvdW5kcy5tYXhZID0gTWF0aC5tYXgodGhpcy5ib3VuZHMubWF4WSwgc2VnQm91bmRzLm1heFkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBkdW1wU2VnbWVudHNUb0NvbnNvbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIlNFR01FTlRTOlwiKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhzZWdtZW50c1tpXS50eXBlLCBzZWdtZW50c1tpXS5nZXRMZW5ndGgoKSwgc2VnbWVudFByb3BvcnRpb25zW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLnBvaW50T25QYXRoID0gZnVuY3Rpb24gKGxvY2F0aW9uLCBhYnNvbHV0ZSkge1xuICAgICAgICAgICAgdmFyIHNlZyA9IF9maW5kU2VnbWVudEZvckxvY2F0aW9uKGxvY2F0aW9uLCBhYnNvbHV0ZSk7XG4gICAgICAgICAgICByZXR1cm4gc2VnLnNlZ21lbnQgJiYgc2VnLnNlZ21lbnQucG9pbnRPblBhdGgoc2VnLnByb3BvcnRpb24sIGZhbHNlKSB8fCBbMCwgMF07XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5ncmFkaWVudEF0UG9pbnQgPSBmdW5jdGlvbiAobG9jYXRpb24sIGFic29sdXRlKSB7XG4gICAgICAgICAgICB2YXIgc2VnID0gX2ZpbmRTZWdtZW50Rm9yTG9jYXRpb24obG9jYXRpb24sIGFic29sdXRlKTtcbiAgICAgICAgICAgIHJldHVybiBzZWcuc2VnbWVudCAmJiBzZWcuc2VnbWVudC5ncmFkaWVudEF0UG9pbnQoc2VnLnByb3BvcnRpb24sIGZhbHNlKSB8fCAwO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMucG9pbnRBbG9uZ1BhdGhGcm9tID0gZnVuY3Rpb24gKGxvY2F0aW9uLCBkaXN0YW5jZSwgYWJzb2x1dGUpIHtcbiAgICAgICAgICAgIHZhciBzZWcgPSBfZmluZFNlZ21lbnRGb3JMb2NhdGlvbihsb2NhdGlvbiwgYWJzb2x1dGUpO1xuICAgICAgICAgICAgLy8gVE9ETyB3aGF0IGhhcHBlbnMgaWYgdGhpcyBjcm9zc2VzIHRvIHRoZSBuZXh0IHNlZ21lbnQ/XG4gICAgICAgICAgICByZXR1cm4gc2VnLnNlZ21lbnQgJiYgc2VnLnNlZ21lbnQucG9pbnRBbG9uZ1BhdGhGcm9tKHNlZy5wcm9wb3J0aW9uLCBkaXN0YW5jZSwgZmFsc2UpIHx8IFswLCAwXTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmNvbXB1dGUgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgICAgICBwYWludEluZm8gPSBfcHJlcGFyZUNvbXB1dGUuY2FsbCh0aGlzLCBwYXJhbXMpO1xuXG4gICAgICAgICAgICBfY2xlYXJTZWdtZW50cygpO1xuICAgICAgICAgICAgdGhpcy5fY29tcHV0ZShwYWludEluZm8sIHBhcmFtcyk7XG4gICAgICAgICAgICB0aGlzLnggPSBwYWludEluZm8ucG9pbnRzWzBdO1xuICAgICAgICAgICAgdGhpcy55ID0gcGFpbnRJbmZvLnBvaW50c1sxXTtcbiAgICAgICAgICAgIHRoaXMudyA9IHBhaW50SW5mby5wb2ludHNbMl07XG4gICAgICAgICAgICB0aGlzLmggPSBwYWludEluZm8ucG9pbnRzWzNdO1xuICAgICAgICAgICAgdGhpcy5zZWdtZW50ID0gcGFpbnRJbmZvLnNlZ21lbnQ7XG4gICAgICAgICAgICBfdXBkYXRlU2VnbWVudFByb3BvcnRpb25zKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFkZFNlZ21lbnQ6IF9hZGRTZWdtZW50LFxuICAgICAgICAgICAgcHJlcGFyZUNvbXB1dGU6IF9wcmVwYXJlQ29tcHV0ZSxcbiAgICAgICAgICAgIHNvdXJjZVN0dWI6IHNvdXJjZVN0dWIsXG4gICAgICAgICAgICB0YXJnZXRTdHViOiB0YXJnZXRTdHViLFxuICAgICAgICAgICAgbWF4U3R1YjogTWF0aC5tYXgoc291cmNlU3R1YiwgdGFyZ2V0U3R1YiksXG4gICAgICAgICAgICBzb3VyY2VHYXA6IHNvdXJjZUdhcCxcbiAgICAgICAgICAgIHRhcmdldEdhcDogdGFyZ2V0R2FwLFxuICAgICAgICAgICAgbWF4R2FwOiBNYXRoLm1heChzb3VyY2VHYXAsIHRhcmdldEdhcCksXG4gICAgICAgICAgICBzZXRHZW9tZXRyeTpfc2V0R2VvbWV0cnksXG4gICAgICAgICAgICBnZXRHZW9tZXRyeTpfZ2V0R2VvbWV0cnlcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIF9qdS5leHRlbmQoX2pwLkNvbm5lY3RvcnMuQWJzdHJhY3RDb25uZWN0b3IsIEFic3RyYWN0Q29tcG9uZW50KTtcblxuXG4gICAgLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqIEVORCBPRiBDT05ORUNUT1IgVFlQRVMgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXG4gICAgLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqIEVORFBPSU5UIFRZUEVTICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblxuICAgIF9qcC5FbmRwb2ludHMuQWJzdHJhY3RFbmRwb2ludCA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgQWJzdHJhY3RDb21wb25lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgdmFyIGNvbXB1dGUgPSB0aGlzLmNvbXB1dGUgPSBmdW5jdGlvbiAoYW5jaG9yUG9pbnQsIG9yaWVudGF0aW9uLCBlbmRwb2ludFN0eWxlLCBjb25uZWN0b3JQYWludFN0eWxlKSB7XG4gICAgICAgICAgICB2YXIgb3V0ID0gdGhpcy5fY29tcHV0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgdGhpcy54ID0gb3V0WzBdO1xuICAgICAgICAgICAgdGhpcy55ID0gb3V0WzFdO1xuICAgICAgICAgICAgdGhpcy53ID0gb3V0WzJdO1xuICAgICAgICAgICAgdGhpcy5oID0gb3V0WzNdO1xuICAgICAgICAgICAgdGhpcy5ib3VuZHMubWluWCA9IHRoaXMueDtcbiAgICAgICAgICAgIHRoaXMuYm91bmRzLm1pblkgPSB0aGlzLnk7XG4gICAgICAgICAgICB0aGlzLmJvdW5kcy5tYXhYID0gdGhpcy54ICsgdGhpcy53O1xuICAgICAgICAgICAgdGhpcy5ib3VuZHMubWF4WSA9IHRoaXMueSArIHRoaXMuaDtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb21wdXRlOiBjb21wdXRlLFxuICAgICAgICAgICAgY3NzQ2xhc3M6IHBhcmFtcy5jc3NDbGFzc1xuICAgICAgICB9O1xuICAgIH07XG4gICAgX2p1LmV4dGVuZChfanAuRW5kcG9pbnRzLkFic3RyYWN0RW5kcG9pbnQsIEFic3RyYWN0Q29tcG9uZW50KTtcblxuICAgIC8qKlxuICAgICAqIENsYXNzOiBFbmRwb2ludHMuRG90XG4gICAgICogQSByb3VuZCBlbmRwb2ludCwgd2l0aCBkZWZhdWx0IHJhZGl1cyAxMCBwaXhlbHMuXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbjogQ29uc3RydWN0b3JcbiAgICAgKlxuICAgICAqIFBhcmFtZXRlcnM6XG4gICAgICpcbiAgICAgKiAgICByYWRpdXMgICAgLSAgICByYWRpdXMgb2YgdGhlIGVuZHBvaW50LiAgZGVmYXVsdHMgdG8gMTAgcGl4ZWxzLlxuICAgICAqL1xuICAgIF9qcC5FbmRwb2ludHMuRG90ID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICB0aGlzLnR5cGUgPSBcIkRvdFwiO1xuICAgICAgICB2YXIgX3N1cGVyID0gX2pwLkVuZHBvaW50cy5BYnN0cmFjdEVuZHBvaW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgICAgICAgdGhpcy5yYWRpdXMgPSBwYXJhbXMucmFkaXVzIHx8IDEwO1xuICAgICAgICB0aGlzLmRlZmF1bHRPZmZzZXQgPSAwLjUgKiB0aGlzLnJhZGl1cztcbiAgICAgICAgdGhpcy5kZWZhdWx0SW5uZXJSYWRpdXMgPSB0aGlzLnJhZGl1cyAvIDM7XG5cbiAgICAgICAgdGhpcy5fY29tcHV0ZSA9IGZ1bmN0aW9uIChhbmNob3JQb2ludCwgb3JpZW50YXRpb24sIGVuZHBvaW50U3R5bGUsIGNvbm5lY3RvclBhaW50U3R5bGUpIHtcbiAgICAgICAgICAgIHRoaXMucmFkaXVzID0gZW5kcG9pbnRTdHlsZS5yYWRpdXMgfHwgdGhpcy5yYWRpdXM7XG4gICAgICAgICAgICB2YXIgeCA9IGFuY2hvclBvaW50WzBdIC0gdGhpcy5yYWRpdXMsXG4gICAgICAgICAgICAgICAgeSA9IGFuY2hvclBvaW50WzFdIC0gdGhpcy5yYWRpdXMsXG4gICAgICAgICAgICAgICAgdyA9IHRoaXMucmFkaXVzICogMixcbiAgICAgICAgICAgICAgICBoID0gdGhpcy5yYWRpdXMgKiAyO1xuXG4gICAgICAgICAgICBpZiAoZW5kcG9pbnRTdHlsZS5zdHJva2UpIHtcbiAgICAgICAgICAgICAgICB2YXIgbHcgPSBlbmRwb2ludFN0eWxlLnN0cm9rZVdpZHRoIHx8IDE7XG4gICAgICAgICAgICAgICAgeCAtPSBsdztcbiAgICAgICAgICAgICAgICB5IC09IGx3O1xuICAgICAgICAgICAgICAgIHcgKz0gKGx3ICogMik7XG4gICAgICAgICAgICAgICAgaCArPSAobHcgKiAyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbIHgsIHksIHcsIGgsIHRoaXMucmFkaXVzIF07XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBfanUuZXh0ZW5kKF9qcC5FbmRwb2ludHMuRG90LCBfanAuRW5kcG9pbnRzLkFic3RyYWN0RW5kcG9pbnQpO1xuXG4gICAgX2pwLkVuZHBvaW50cy5SZWN0YW5nbGUgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgIHRoaXMudHlwZSA9IFwiUmVjdGFuZ2xlXCI7XG4gICAgICAgIHZhciBfc3VwZXIgPSBfanAuRW5kcG9pbnRzLkFic3RyYWN0RW5kcG9pbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICAgICAgICB0aGlzLndpZHRoID0gcGFyYW1zLndpZHRoIHx8IDIwO1xuICAgICAgICB0aGlzLmhlaWdodCA9IHBhcmFtcy5oZWlnaHQgfHwgMjA7XG5cbiAgICAgICAgdGhpcy5fY29tcHV0ZSA9IGZ1bmN0aW9uIChhbmNob3JQb2ludCwgb3JpZW50YXRpb24sIGVuZHBvaW50U3R5bGUsIGNvbm5lY3RvclBhaW50U3R5bGUpIHtcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IGVuZHBvaW50U3R5bGUud2lkdGggfHwgdGhpcy53aWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQgPSBlbmRwb2ludFN0eWxlLmhlaWdodCB8fCB0aGlzLmhlaWdodCxcbiAgICAgICAgICAgICAgICB4ID0gYW5jaG9yUG9pbnRbMF0gLSAod2lkdGggLyAyKSxcbiAgICAgICAgICAgICAgICB5ID0gYW5jaG9yUG9pbnRbMV0gLSAoaGVpZ2h0IC8gMik7XG5cbiAgICAgICAgICAgIHJldHVybiBbIHgsIHksIHdpZHRoLCBoZWlnaHRdO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgX2p1LmV4dGVuZChfanAuRW5kcG9pbnRzLlJlY3RhbmdsZSwgX2pwLkVuZHBvaW50cy5BYnN0cmFjdEVuZHBvaW50KTtcblxuICAgIHZhciBET01FbGVtZW50RW5kcG9pbnQgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgIF9qcC5qc1BsdW1iVUlDb21wb25lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5fanNQbHVtYi5kaXNwbGF5RWxlbWVudHMgPSBbXTtcbiAgICB9O1xuICAgIF9qdS5leHRlbmQoRE9NRWxlbWVudEVuZHBvaW50LCBfanAuanNQbHVtYlVJQ29tcG9uZW50LCB7XG4gICAgICAgIGdldERpc3BsYXlFbGVtZW50czogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2pzUGx1bWIuZGlzcGxheUVsZW1lbnRzO1xuICAgICAgICB9LFxuICAgICAgICBhcHBlbmREaXNwbGF5RWxlbWVudDogZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICB0aGlzLl9qc1BsdW1iLmRpc3BsYXlFbGVtZW50cy5wdXNoKGVsKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ2xhc3M6IEVuZHBvaW50cy5JbWFnZVxuICAgICAqIERyYXdzIGFuIGltYWdlIGFzIHRoZSBFbmRwb2ludC5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbjogQ29uc3RydWN0b3JcbiAgICAgKlxuICAgICAqIFBhcmFtZXRlcnM6XG4gICAgICpcbiAgICAgKiAgICBzcmMgICAgLSAgICBsb2NhdGlvbiBvZiB0aGUgaW1hZ2UgdG8gdXNlLlxuXG4gICAgIFRPRE86IG11bHRpcGxlIHJlZmVyZW5jZXMgdG8gc2VsZi4gbm90IHN1cmUgcXVpdGUgaG93IHRvIGdldCByaWQgb2YgdGhlbSBlbnRpcmVseS4gcGVyaGFwcyBzZWxmID0gbnVsbCBpbiB0aGUgY2xlYW51cFxuICAgICBmdW5jdGlvbiB3aWxsIHN1ZmZpY2VcblxuICAgICBUT0RPIHRoaXMgY2xhc3Mgc3RpbGwgbWlnaHQgbGVhayBtZW1vcnkuXG5cbiAgICAgKi9cbiAgICBfanAuRW5kcG9pbnRzLkltYWdlID0gZnVuY3Rpb24gKHBhcmFtcykge1xuXG4gICAgICAgIHRoaXMudHlwZSA9IFwiSW1hZ2VcIjtcbiAgICAgICAgRE9NRWxlbWVudEVuZHBvaW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIF9qcC5FbmRwb2ludHMuQWJzdHJhY3RFbmRwb2ludC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgICAgIHZhciBfb25sb2FkID0gcGFyYW1zLm9ubG9hZCxcbiAgICAgICAgICAgIHNyYyA9IHBhcmFtcy5zcmMgfHwgcGFyYW1zLnVybCxcbiAgICAgICAgICAgIGNsYXp6ID0gcGFyYW1zLmNzc0NsYXNzID8gXCIgXCIgKyBwYXJhbXMuY3NzQ2xhc3MgOiBcIlwiO1xuXG4gICAgICAgIHRoaXMuX2pzUGx1bWIuaW1nID0gbmV3IEltYWdlKCk7XG4gICAgICAgIHRoaXMuX2pzUGx1bWIucmVhZHkgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fanNQbHVtYi5pbml0aWFsaXplZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9qc1BsdW1iLmRlbGV0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fanNQbHVtYi53aWR0aFRvVXNlID0gcGFyYW1zLndpZHRoO1xuICAgICAgICB0aGlzLl9qc1BsdW1iLmhlaWdodFRvVXNlID0gcGFyYW1zLmhlaWdodDtcbiAgICAgICAgdGhpcy5fanNQbHVtYi5lbmRwb2ludCA9IHBhcmFtcy5lbmRwb2ludDtcblxuICAgICAgICB0aGlzLl9qc1BsdW1iLmltZy5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fanNQbHVtYiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fanNQbHVtYi5yZWFkeSA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5fanNQbHVtYi53aWR0aFRvVXNlID0gdGhpcy5fanNQbHVtYi53aWR0aFRvVXNlIHx8IHRoaXMuX2pzUGx1bWIuaW1nLndpZHRoO1xuICAgICAgICAgICAgICAgIHRoaXMuX2pzUGx1bWIuaGVpZ2h0VG9Vc2UgPSB0aGlzLl9qc1BsdW1iLmhlaWdodFRvVXNlIHx8IHRoaXMuX2pzUGx1bWIuaW1nLmhlaWdodDtcbiAgICAgICAgICAgICAgICBpZiAoX29ubG9hZCkge1xuICAgICAgICAgICAgICAgICAgICBfb25sb2FkKHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfS5iaW5kKHRoaXMpO1xuXG4gICAgICAgIC8qXG4gICAgICAgICBGdW5jdGlvbjogc2V0SW1hZ2VcbiAgICAgICAgIFNldHMgdGhlIEltYWdlIHRvIHVzZSBpbiB0aGlzIEVuZHBvaW50LlxuXG4gICAgICAgICBQYXJhbWV0ZXJzOlxuICAgICAgICAgaW1nICAgICAgICAgLSAgIG1heSBiZSBhIFVSTCBvciBhbiBJbWFnZSBvYmplY3RcbiAgICAgICAgIG9ubG9hZCAgICAgIC0gICBvcHRpb25hbDsgYSBjYWxsYmFjayB0byBleGVjdXRlIG9uY2UgdGhlIGltYWdlIGhhcyBsb2FkZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9qc1BsdW1iLmVuZHBvaW50LnNldEltYWdlID0gZnVuY3Rpb24gKF9pbWcsIG9ubG9hZCkge1xuICAgICAgICAgICAgdmFyIHMgPSBfaW1nLmNvbnN0cnVjdG9yID09PSBTdHJpbmcgPyBfaW1nIDogX2ltZy5zcmM7XG4gICAgICAgICAgICBfb25sb2FkID0gb25sb2FkO1xuICAgICAgICAgICAgdGhpcy5fanNQbHVtYi5pbWcuc3JjID0gcztcblxuICAgICAgICAgICAgaWYgKHRoaXMuY2FudmFzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbnZhcy5zZXRBdHRyaWJ1dGUoXCJzcmNcIiwgdGhpcy5fanNQbHVtYi5pbWcuc3JjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfS5iaW5kKHRoaXMpO1xuXG4gICAgICAgIHRoaXMuX2pzUGx1bWIuZW5kcG9pbnQuc2V0SW1hZ2Uoc3JjLCBfb25sb2FkKTtcbiAgICAgICAgdGhpcy5fY29tcHV0ZSA9IGZ1bmN0aW9uIChhbmNob3JQb2ludCwgb3JpZW50YXRpb24sIGVuZHBvaW50U3R5bGUsIGNvbm5lY3RvclBhaW50U3R5bGUpIHtcbiAgICAgICAgICAgIHRoaXMuYW5jaG9yUG9pbnQgPSBhbmNob3JQb2ludDtcbiAgICAgICAgICAgIGlmICh0aGlzLl9qc1BsdW1iLnJlYWR5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFthbmNob3JQb2ludFswXSAtIHRoaXMuX2pzUGx1bWIud2lkdGhUb1VzZSAvIDIsIGFuY2hvclBvaW50WzFdIC0gdGhpcy5fanNQbHVtYi5oZWlnaHRUb1VzZSAvIDIsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2pzUGx1bWIud2lkdGhUb1VzZSwgdGhpcy5fanNQbHVtYi5oZWlnaHRUb1VzZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzAsIDAsIDAsIDBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuY2FudmFzID0gX2pwLmNyZWF0ZUVsZW1lbnQoXCJpbWdcIiwge1xuICAgICAgICAgICAgcG9zaXRpb246XCJhYnNvbHV0ZVwiLFxuICAgICAgICAgICAgbWFyZ2luOjAsXG4gICAgICAgICAgICBwYWRkaW5nOjAsXG4gICAgICAgICAgICBvdXRsaW5lOjBcbiAgICAgICAgfSwgdGhpcy5fanNQbHVtYi5pbnN0YW5jZS5lbmRwb2ludENsYXNzICsgY2xhenopO1xuXG4gICAgICAgIGlmICh0aGlzLl9qc1BsdW1iLndpZHRoVG9Vc2UpIHtcbiAgICAgICAgICAgIHRoaXMuY2FudmFzLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIHRoaXMuX2pzUGx1bWIud2lkdGhUb1VzZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2pzUGx1bWIuaGVpZ2h0VG9Vc2UpIHtcbiAgICAgICAgICAgIHRoaXMuY2FudmFzLnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCB0aGlzLl9qc1BsdW1iLmhlaWdodFRvVXNlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9qc1BsdW1iLmluc3RhbmNlLmFwcGVuZEVsZW1lbnQodGhpcy5jYW52YXMpO1xuXG4gICAgICAgIHRoaXMuYWN0dWFsbHlQYWludCA9IGZ1bmN0aW9uIChkLCBzdHlsZSwgYW5jaG9yKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2pzUGx1bWIuZGVsZXRlZCkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fanNQbHVtYi5pbml0aWFsaXplZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbnZhcy5zZXRBdHRyaWJ1dGUoXCJzcmNcIiwgdGhpcy5fanNQbHVtYi5pbWcuc3JjKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHBlbmREaXNwbGF5RWxlbWVudCh0aGlzLmNhbnZhcyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2pzUGx1bWIuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgeCA9IHRoaXMuYW5jaG9yUG9pbnRbMF0gLSAodGhpcy5fanNQbHVtYi53aWR0aFRvVXNlIC8gMiksXG4gICAgICAgICAgICAgICAgICAgIHkgPSB0aGlzLmFuY2hvclBvaW50WzFdIC0gKHRoaXMuX2pzUGx1bWIuaGVpZ2h0VG9Vc2UgLyAyKTtcbiAgICAgICAgICAgICAgICBfanUuc2l6ZUVsZW1lbnQodGhpcy5jYW52YXMsIHgsIHksIHRoaXMuX2pzUGx1bWIud2lkdGhUb1VzZSwgdGhpcy5fanNQbHVtYi5oZWlnaHRUb1VzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5wYWludCA9IGZ1bmN0aW9uIChzdHlsZSwgYW5jaG9yKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fanNQbHVtYiAhPSBudWxsKSB7ICAvLyBtYXkgaGF2ZSBiZWVuIGRlbGV0ZWRcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fanNQbHVtYi5yZWFkeSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdHVhbGx5UGFpbnQoc3R5bGUsIGFuY2hvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByb290LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYWludChzdHlsZSwgYW5jaG9yKTtcbiAgICAgICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpLCAyMDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIF9qdS5leHRlbmQoX2pwLkVuZHBvaW50cy5JbWFnZSwgWyBET01FbGVtZW50RW5kcG9pbnQsIF9qcC5FbmRwb2ludHMuQWJzdHJhY3RFbmRwb2ludCBdLCB7XG4gICAgICAgIGNsZWFudXA6IGZ1bmN0aW9uIChmb3JjZSkge1xuICAgICAgICAgICAgaWYgKGZvcmNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fanNQbHVtYi5kZWxldGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jYW52YXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYW52YXMucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmNhbnZhcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLypcbiAgICAgKiBDbGFzczogRW5kcG9pbnRzLkJsYW5rXG4gICAgICogQW4gRW5kcG9pbnQgdGhhdCBwYWludHMgbm90aGluZyAodmlzaWJsZSkgb24gdGhlIHNjcmVlbi4gIFN1cHBvcnRzIGNzc0NsYXNzIGFuZCBob3ZlckNsYXNzIHBhcmFtZXRlcnMgbGlrZSBhbGwgRW5kcG9pbnRzLlxuICAgICAqL1xuICAgIF9qcC5FbmRwb2ludHMuQmxhbmsgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgIHZhciBfc3VwZXIgPSBfanAuRW5kcG9pbnRzLkFic3RyYWN0RW5kcG9pbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy50eXBlID0gXCJCbGFua1wiO1xuICAgICAgICBET01FbGVtZW50RW5kcG9pbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5fY29tcHV0ZSA9IGZ1bmN0aW9uIChhbmNob3JQb2ludCwgb3JpZW50YXRpb24sIGVuZHBvaW50U3R5bGUsIGNvbm5lY3RvclBhaW50U3R5bGUpIHtcbiAgICAgICAgICAgIHJldHVybiBbYW5jaG9yUG9pbnRbMF0sIGFuY2hvclBvaW50WzFdLCAxMCwgMF07XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGNsYXp6ID0gcGFyYW1zLmNzc0NsYXNzID8gXCIgXCIgKyBwYXJhbXMuY3NzQ2xhc3MgOiBcIlwiO1xuXG4gICAgICAgIHRoaXMuY2FudmFzID0gX2pwLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgICAgICAgZGlzcGxheTogXCJibG9ja1wiLFxuICAgICAgICAgICAgd2lkdGg6IFwiMXB4XCIsXG4gICAgICAgICAgICBoZWlnaHQ6IFwiMXB4XCIsXG4gICAgICAgICAgICBiYWNrZ3JvdW5kOiBcInRyYW5zcGFyZW50XCIsXG4gICAgICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiXG4gICAgICAgIH0sIHRoaXMuX2pzUGx1bWIuaW5zdGFuY2UuZW5kcG9pbnRDbGFzcyArIGNsYXp6KTtcblxuICAgICAgICB0aGlzLl9qc1BsdW1iLmluc3RhbmNlLmFwcGVuZEVsZW1lbnQodGhpcy5jYW52YXMpO1xuXG4gICAgICAgIHRoaXMucGFpbnQgPSBmdW5jdGlvbiAoc3R5bGUsIGFuY2hvcikge1xuICAgICAgICAgICAgX2p1LnNpemVFbGVtZW50KHRoaXMuY2FudmFzLCB0aGlzLngsIHRoaXMueSwgdGhpcy53LCB0aGlzLmgpO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgX2p1LmV4dGVuZChfanAuRW5kcG9pbnRzLkJsYW5rLCBbX2pwLkVuZHBvaW50cy5BYnN0cmFjdEVuZHBvaW50LCBET01FbGVtZW50RW5kcG9pbnRdLCB7XG4gICAgICAgIGNsZWFudXA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNhbnZhcyAmJiB0aGlzLmNhbnZhcy5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYW52YXMucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmNhbnZhcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qXG4gICAgICogQ2xhc3M6IEVuZHBvaW50cy5UcmlhbmdsZVxuICAgICAqIEEgdHJpYW5ndWxhciBFbmRwb2ludC5cbiAgICAgKi9cbiAgICAvKlxuICAgICAqIEZ1bmN0aW9uOiBDb25zdHJ1Y3RvclxuICAgICAqXG4gICAgICogUGFyYW1ldGVyczpcbiAgICAgKlxuICAgICAqIHdpZHRoICAgd2lkdGggb2YgdGhlIHRyaWFuZ2xlJ3MgYmFzZS4gIGRlZmF1bHRzIHRvIDU1IHBpeGVscy5cbiAgICAgKiBoZWlnaHQgIGhlaWdodCBvZiB0aGUgdHJpYW5nbGUgZnJvbSBiYXNlIHRvIGFwZXguICBkZWZhdWx0cyB0byA1NSBwaXhlbHMuXG4gICAgICovXG4gICAgX2pwLkVuZHBvaW50cy5UcmlhbmdsZSA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgdGhpcy50eXBlID0gXCJUcmlhbmdsZVwiO1xuICAgICAgICBfanAuRW5kcG9pbnRzLkFic3RyYWN0RW5kcG9pbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBwYXJhbXMgPSBwYXJhbXMgfHwgeyAgfTtcbiAgICAgICAgcGFyYW1zLndpZHRoID0gcGFyYW1zLndpZHRoIHx8IDU1O1xuICAgICAgICBwYXJhbXMuaGVpZ2h0ID0gcGFyYW1zLmhlaWdodCB8fCA1NTtcbiAgICAgICAgdGhpcy53aWR0aCA9IHBhcmFtcy53aWR0aDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBwYXJhbXMuaGVpZ2h0O1xuICAgICAgICB0aGlzLl9jb21wdXRlID0gZnVuY3Rpb24gKGFuY2hvclBvaW50LCBvcmllbnRhdGlvbiwgZW5kcG9pbnRTdHlsZSwgY29ubmVjdG9yUGFpbnRTdHlsZSkge1xuICAgICAgICAgICAgdmFyIHdpZHRoID0gZW5kcG9pbnRTdHlsZS53aWR0aCB8fCBzZWxmLndpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodCA9IGVuZHBvaW50U3R5bGUuaGVpZ2h0IHx8IHNlbGYuaGVpZ2h0LFxuICAgICAgICAgICAgICAgIHggPSBhbmNob3JQb2ludFswXSAtICh3aWR0aCAvIDIpLFxuICAgICAgICAgICAgICAgIHkgPSBhbmNob3JQb2ludFsxXSAtIChoZWlnaHQgLyAyKTtcbiAgICAgICAgICAgIHJldHVybiBbIHgsIHksIHdpZHRoLCBoZWlnaHQgXTtcbiAgICAgICAgfTtcbiAgICB9O1xuLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqIEVORCBPRiBFTkRQT0lOVCBUWVBFUyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cblxuLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqIE9WRVJMQVkgREVGSU5JVElPTlMgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogICAgXG5cbiAgICB2YXIgQWJzdHJhY3RPdmVybGF5ID0gX2pwLk92ZXJsYXlzLkFic3RyYWN0T3ZlcmxheSA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgdGhpcy52aXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5pc0FwcGVuZGVkQXRUb3BMZXZlbCA9IHRydWU7XG4gICAgICAgIHRoaXMuY29tcG9uZW50ID0gcGFyYW1zLmNvbXBvbmVudDtcbiAgICAgICAgdGhpcy5sb2MgPSBwYXJhbXMubG9jYXRpb24gPT0gbnVsbCA/IDAuNSA6IHBhcmFtcy5sb2NhdGlvbjtcbiAgICAgICAgdGhpcy5lbmRwb2ludExvYyA9IHBhcmFtcy5lbmRwb2ludExvY2F0aW9uID09IG51bGwgPyBbIDAuNSwgMC41XSA6IHBhcmFtcy5lbmRwb2ludExvY2F0aW9uO1xuICAgICAgICB0aGlzLnZpc2libGUgPSBwYXJhbXMudmlzaWJsZSAhPT0gZmFsc2U7XG4gICAgfTtcbiAgICBBYnN0cmFjdE92ZXJsYXkucHJvdG90eXBlID0ge1xuICAgICAgICBjbGVhbnVwOiBmdW5jdGlvbiAoZm9yY2UpIHtcbiAgICAgICAgICAgIGlmIChmb3JjZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29tcG9uZW50ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbnZhcyA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5lbmRwb2ludExvYyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHJlYXR0YWNoOmZ1bmN0aW9uKGluc3RhbmNlLCBjb21wb25lbnQpIHsgfSxcbiAgICAgICAgc2V0VmlzaWJsZTogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgdGhpcy52aXNpYmxlID0gdmFsO1xuICAgICAgICAgICAgdGhpcy5jb21wb25lbnQucmVwYWludCgpO1xuICAgICAgICB9LFxuICAgICAgICBpc1Zpc2libGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZpc2libGU7XG4gICAgICAgIH0sXG4gICAgICAgIGhpZGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0VmlzaWJsZShmYWxzZSk7XG4gICAgICAgIH0sXG4gICAgICAgIHNob3c6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0VmlzaWJsZSh0cnVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgaW5jcmVtZW50TG9jYXRpb246IGZ1bmN0aW9uIChhbW91bnQpIHtcbiAgICAgICAgICAgIHRoaXMubG9jICs9IGFtb3VudDtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50LnJlcGFpbnQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0TG9jYXRpb246IGZ1bmN0aW9uIChsKSB7XG4gICAgICAgICAgICB0aGlzLmxvYyA9IGw7XG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudC5yZXBhaW50KCk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldExvY2F0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2M7XG4gICAgICAgIH0sXG4gICAgICAgIHVwZGF0ZUZyb206ZnVuY3Rpb24oKSB7IH1cbiAgICB9O1xuXG5cbiAgICAvKlxuICAgICAqIENsYXNzOiBPdmVybGF5cy5BcnJvd1xuICAgICAqXG4gICAgICogQW4gYXJyb3cgb3ZlcmxheSwgZGVmaW5lZCBieSBmb3VyIHBvaW50czogdGhlIGhlYWQsIHRoZSB0d28gc2lkZXMgb2YgdGhlIHRhaWwsIGFuZCBhICdmb2xkYmFjaycgcG9pbnQgYXQgc29tZSBkaXN0YW5jZSBhbG9uZyB0aGUgbGVuZ3RoXG4gICAgICogb2YgdGhlIGFycm93IHRoYXQgbGluZXMgZnJvbSBlYWNoIHRhaWwgcG9pbnQgY29udmVyZ2UgaW50by4gIFRoZSBmb2xkYmFjayBwb2ludCBpcyBkZWZpbmVkIHVzaW5nIGEgZGVjaW1hbCB0aGF0IGluZGljYXRlcyBzb21lIGZyYWN0aW9uXG4gICAgICogb2YgdGhlIGxlbmd0aCBvZiB0aGUgYXJyb3cgYW5kIGhhcyBhIGRlZmF1bHQgdmFsdWUgb2YgMC42MjMuICBBIGZvbGRiYWNrIHBvaW50IHZhbHVlIG9mIDEgd291bGQgbWVhbiB0aGF0IHRoZSBhcnJvdyBoYWQgYSBzdHJhaWdodCBsaW5lXG4gICAgICogYWNyb3NzIHRoZSB0YWlsLlxuICAgICAqL1xuICAgIC8qXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIENvbnN0cnVjdG9yIHBhcmFtcy5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3BhcmFtcy5sZW5ndGhdIERpc3RhbmNlIGluIHBpeGVscyBmcm9tIGhlYWQgdG8gdGFpbCBiYXNlbGluZS4gZGVmYXVsdCAyMC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3BhcmFtcy53aWR0aF0gV2lkdGggaW4gcGl4ZWxzIG9mIHRoZSB0YWlsIGJhc2VsaW5lLiBkZWZhdWx0IDIwLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbcGFyYW1zLmZpbGxdIFN0eWxlIHRvIHVzZSB3aGVuIGZpbGxpbmcgdGhlIGFycm93LiAgZGVmYXVsdHMgdG8gXCJibGFja1wiLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbcGFyYW1zLnN0cm9rZV0gU3R5bGUgdG8gdXNlIHdoZW4gc3Ryb2tpbmcgdGhlIGFycm93LiBkZWZhdWx0cyB0byBudWxsLCB3aGljaCBtZWFucyB0aGUgYXJyb3cgaXMgbm90IHN0cm9rZWQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtwYXJhbXMuc3Ryb2tlLXdpZHRoXSBMaW5lIHdpZHRoIHRvIHVzZSB3aGVuIHN0cm9raW5nIHRoZSBhcnJvdy4gZGVmYXVsdHMgdG8gMSwgYnV0IG9ubHkgdXNlZCBpZiBzdHJva2UgaXMgbm90IG51bGwuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtwYXJhbXMuZm9sZGJhY2tdIERpc3RhbmNlIChhcyBhIGRlY2ltYWwgZnJvbSAwIHRvIDEgaW5jbHVzaXZlKSBhbG9uZyB0aGUgbGVuZ3RoIG9mIHRoZSBhcnJvdyBtYXJraW5nIHRoZSBwb2ludCB0aGUgdGFpbCBwb2ludHMgc2hvdWxkIGZvbGQgYmFjayB0by4gIGRlZmF1bHRzIHRvIDAuNjIzLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbcGFyYW1zLmxvY2F0aW9uXSBEaXN0YW5jZSAoYXMgYSBkZWNpbWFsIGZyb20gMCB0byAxIGluY2x1c2l2ZSkgbWFya2luZyB3aGVyZSB0aGUgYXJyb3cgc2hvdWxkIHNpdCBvbiB0aGUgY29ubmVjdG9yLiBkZWZhdWx0cyB0byAwLjUuXG4gICAgICogQHBhcmFtIHtOVW1iZXJ9IFtwYXJhbXMuZGlyZWN0aW9uXSBJbmRpY2F0ZXMgdGhlIGRpcmVjdGlvbiB0aGUgYXJyb3cgcG9pbnRzIGluLiB2YWxpZCB2YWx1ZXMgYXJlIC0xIGFuZCAxOyAxIGlzIGRlZmF1bHQuXG4gICAgICovXG4gICAgX2pwLk92ZXJsYXlzLkFycm93ID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICB0aGlzLnR5cGUgPSBcIkFycm93XCI7XG4gICAgICAgIEFic3RyYWN0T3ZlcmxheS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmlzQXBwZW5kZWRBdFRvcExldmVsID0gZmFsc2U7XG4gICAgICAgIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIHRoaXMubGVuZ3RoID0gcGFyYW1zLmxlbmd0aCB8fCAyMDtcbiAgICAgICAgdGhpcy53aWR0aCA9IHBhcmFtcy53aWR0aCB8fCAyMDtcbiAgICAgICAgdGhpcy5pZCA9IHBhcmFtcy5pZDtcbiAgICAgICAgdmFyIGRpcmVjdGlvbiA9IChwYXJhbXMuZGlyZWN0aW9uIHx8IDEpIDwgMCA/IC0xIDogMSxcbiAgICAgICAgICAgIHBhaW50U3R5bGUgPSBwYXJhbXMucGFpbnRTdHlsZSB8fCB7IFwic3Ryb2tlLXdpZHRoXCI6IDEgfSxcbiAgICAgICAgLy8gaG93IGZhciBhbG9uZyB0aGUgYXJyb3cgdGhlIGxpbmVzIGZvbGRpbmcgYmFjayBpbiBjb21lIHRvLiBkZWZhdWx0IGlzIDYyLjMlLlxuICAgICAgICAgICAgZm9sZGJhY2sgPSBwYXJhbXMuZm9sZGJhY2sgfHwgMC42MjM7XG5cbiAgICAgICAgdGhpcy5jb21wdXRlTWF4U2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBzZWxmLndpZHRoICogMS41O1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuZWxlbWVudENyZWF0ZWQgPSBmdW5jdGlvbihwLCBjb21wb25lbnQpIHtcbiAgICAgICAgICAgIHRoaXMucGF0aCA9IHA7XG4gICAgICAgICAgICBpZiAocGFyYW1zLmV2ZW50cykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgaW4gcGFyYW1zLmV2ZW50cykge1xuICAgICAgICAgICAgICAgICAgICBfanAub24ocCwgaSwgcGFyYW1zLmV2ZW50c1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuZHJhdyA9IGZ1bmN0aW9uIChjb21wb25lbnQsIGN1cnJlbnRDb25uZWN0aW9uUGFpbnRTdHlsZSkge1xuXG4gICAgICAgICAgICB2YXIgaHh5LCBtaWQsIHR4eSwgdGFpbCwgY3h5O1xuICAgICAgICAgICAgaWYgKGNvbXBvbmVudC5wb2ludEFsb25nUGF0aEZyb20pIHtcblxuICAgICAgICAgICAgICAgIGlmIChfanUuaXNTdHJpbmcodGhpcy5sb2MpIHx8IHRoaXMubG9jID4gMSB8fCB0aGlzLmxvYyA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGwgPSBwYXJzZUludCh0aGlzLmxvYywgMTApLFxuICAgICAgICAgICAgICAgICAgICAgICAgZnJvbUxvYyA9IHRoaXMubG9jIDwgMCA/IDEgOiAwO1xuICAgICAgICAgICAgICAgICAgICBoeHkgPSBjb21wb25lbnQucG9pbnRBbG9uZ1BhdGhGcm9tKGZyb21Mb2MsIGwsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgbWlkID0gY29tcG9uZW50LnBvaW50QWxvbmdQYXRoRnJvbShmcm9tTG9jLCBsIC0gKGRpcmVjdGlvbiAqIHRoaXMubGVuZ3RoIC8gMiksIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgdHh5ID0gX2pnLnBvaW50T25MaW5lKGh4eSwgbWlkLCB0aGlzLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubG9jID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGh4eSA9IGNvbXBvbmVudC5wb2ludE9uUGF0aCh0aGlzLmxvYyk7XG4gICAgICAgICAgICAgICAgICAgIG1pZCA9IGNvbXBvbmVudC5wb2ludEFsb25nUGF0aEZyb20odGhpcy5sb2MsIC0odGhpcy5sZW5ndGgpKTtcbiAgICAgICAgICAgICAgICAgICAgdHh5ID0gX2pnLnBvaW50T25MaW5lKGh4eSwgbWlkLCB0aGlzLmxlbmd0aCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfID0gdHh5O1xuICAgICAgICAgICAgICAgICAgICAgICAgdHh5ID0gaHh5O1xuICAgICAgICAgICAgICAgICAgICAgICAgaHh5ID0gXztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLmxvYyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0eHkgPSBjb21wb25lbnQucG9pbnRPblBhdGgodGhpcy5sb2MpO1xuICAgICAgICAgICAgICAgICAgICBtaWQgPSBjb21wb25lbnQucG9pbnRBbG9uZ1BhdGhGcm9tKHRoaXMubG9jLCB0aGlzLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIGh4eSA9IF9qZy5wb2ludE9uTGluZSh0eHksIG1pZCwgdGhpcy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGlyZWN0aW9uID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9fID0gdHh5O1xuICAgICAgICAgICAgICAgICAgICAgICAgdHh5ID0gaHh5O1xuICAgICAgICAgICAgICAgICAgICAgICAgaHh5ID0gX187XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGh4eSA9IGNvbXBvbmVudC5wb2ludEFsb25nUGF0aEZyb20odGhpcy5sb2MsIGRpcmVjdGlvbiAqIHRoaXMubGVuZ3RoIC8gMik7XG4gICAgICAgICAgICAgICAgICAgIG1pZCA9IGNvbXBvbmVudC5wb2ludE9uUGF0aCh0aGlzLmxvYyk7XG4gICAgICAgICAgICAgICAgICAgIHR4eSA9IF9qZy5wb2ludE9uTGluZShoeHksIG1pZCwgdGhpcy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRhaWwgPSBfamcucGVycGVuZGljdWxhckxpbmVUbyhoeHksIHR4eSwgdGhpcy53aWR0aCk7XG4gICAgICAgICAgICAgICAgY3h5ID0gX2pnLnBvaW50T25MaW5lKGh4eSwgdHh5LCBmb2xkYmFjayAqIHRoaXMubGVuZ3RoKTtcblxuICAgICAgICAgICAgICAgIHZhciBkID0geyBoeHk6IGh4eSwgdGFpbDogdGFpbCwgY3h5OiBjeHkgfSxcbiAgICAgICAgICAgICAgICAgICAgc3Ryb2tlID0gcGFpbnRTdHlsZS5zdHJva2UgfHwgY3VycmVudENvbm5lY3Rpb25QYWludFN0eWxlLnN0cm9rZSxcbiAgICAgICAgICAgICAgICAgICAgZmlsbCA9IHBhaW50U3R5bGUuZmlsbCB8fCBjdXJyZW50Q29ubmVjdGlvblBhaW50U3R5bGUuc3Ryb2tlLFxuICAgICAgICAgICAgICAgICAgICBsaW5lV2lkdGggPSBwYWludFN0eWxlLnN0cm9rZVdpZHRoIHx8IGN1cnJlbnRDb25uZWN0aW9uUGFpbnRTdHlsZS5zdHJva2VXaWR0aDtcblxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudDogY29tcG9uZW50LFxuICAgICAgICAgICAgICAgICAgICBkOiBkLFxuICAgICAgICAgICAgICAgICAgICBcInN0cm9rZS13aWR0aFwiOiBsaW5lV2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIHN0cm9rZTogc3Ryb2tlLFxuICAgICAgICAgICAgICAgICAgICBmaWxsOiBmaWxsLFxuICAgICAgICAgICAgICAgICAgICBtaW5YOiBNYXRoLm1pbihoeHkueCwgdGFpbFswXS54LCB0YWlsWzFdLngpLFxuICAgICAgICAgICAgICAgICAgICBtYXhYOiBNYXRoLm1heChoeHkueCwgdGFpbFswXS54LCB0YWlsWzFdLngpLFxuICAgICAgICAgICAgICAgICAgICBtaW5ZOiBNYXRoLm1pbihoeHkueSwgdGFpbFswXS55LCB0YWlsWzFdLnkpLFxuICAgICAgICAgICAgICAgICAgICBtYXhZOiBNYXRoLm1heChoeHkueSwgdGFpbFswXS55LCB0YWlsWzFdLnkpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB7Y29tcG9uZW50OiBjb21wb25lbnQsIG1pblg6IDAsIG1heFg6IDAsIG1pblk6IDAsIG1heFk6IDB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG4gICAgX2p1LmV4dGVuZChfanAuT3ZlcmxheXMuQXJyb3csIEFic3RyYWN0T3ZlcmxheSwge1xuICAgICAgICB1cGRhdGVGcm9tOmZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIHRoaXMubGVuZ3RoID0gZC5sZW5ndGggfHwgdGhpcy5sZW5ndGg7XG4gICAgICAgICAgICB0aGlzLndpZHRoID0gZC53aWR0aHx8IHRoaXMud2lkdGg7XG4gICAgICAgICAgICB0aGlzLmRpcmVjdGlvbiA9IGQuZGlyZWN0aW9uICE9IG51bGwgPyBkLmRpcmVjdGlvbiA6IHRoaXMuZGlyZWN0aW9uO1xuICAgICAgICAgICAgdGhpcy5mb2xkYmFjayA9IGQuZm9sZGJhY2t8fCB0aGlzLmZvbGRiYWNrO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvKlxuICAgICAqIENsYXNzOiBPdmVybGF5cy5QbGFpbkFycm93XG4gICAgICpcbiAgICAgKiBBIGJhc2ljIGFycm93LiAgVGhpcyBpcyBpbiBmYWN0IGp1c3Qgb25lIGluc3RhbmNlIG9mIHRoZSBtb3JlIGdlbmVyaWMgY2FzZSBpbiB3aGljaCB0aGUgdGFpbCBmb2xkcyBiYWNrIG9uIGl0c2VsZiB0byBzb21lXG4gICAgICogcG9pbnQgYWxvbmcgdGhlIGxlbmd0aCBvZiB0aGUgYXJyb3c6IGluIHRoaXMgY2FzZSwgdGhhdCBmb2xkYmFjayBwb2ludCBpcyB0aGUgZnVsbCBsZW5ndGggb2YgdGhlIGFycm93LiAgc28gaXQganVzdCBkb2VzXG4gICAgICogYSAnY2FsbCcgdG8gQXJyb3cgd2l0aCBmb2xkYmFjayBzZXQgYXBwcm9wcmlhdGVseS5cbiAgICAgKi9cbiAgICAvKlxuICAgICAqIEZ1bmN0aW9uOiBDb25zdHJ1Y3RvclxuICAgICAqIFNlZSA8T3ZlcmxheXMuQXJyb3c+IGZvciBhbGxvd2VkIHBhcmFtZXRlcnMgZm9yIHRoaXMgb3ZlcmxheS5cbiAgICAgKi9cbiAgICBfanAuT3ZlcmxheXMuUGxhaW5BcnJvdyA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICAgICAgICB2YXIgcCA9IF9qcC5leHRlbmQocGFyYW1zLCB7Zm9sZGJhY2s6IDF9KTtcbiAgICAgICAgX2pwLk92ZXJsYXlzLkFycm93LmNhbGwodGhpcywgcCk7XG4gICAgICAgIHRoaXMudHlwZSA9IFwiUGxhaW5BcnJvd1wiO1xuICAgIH07XG4gICAgX2p1LmV4dGVuZChfanAuT3ZlcmxheXMuUGxhaW5BcnJvdywgX2pwLk92ZXJsYXlzLkFycm93KTtcblxuICAgIC8qXG4gICAgICogQ2xhc3M6IE92ZXJsYXlzLkRpYW1vbmRcbiAgICAgKiBcbiAgICAgKiBBIGRpYW1vbmQuIExpa2UgUGxhaW5BcnJvdywgdGhpcyBpcyBhIGNvbmNyZXRlIGNhc2Ugb2YgdGhlIG1vcmUgZ2VuZXJpYyBjYXNlIG9mIHRoZSB0YWlsIHBvaW50cyBjb252ZXJnaW5nIG9uIHNvbWUgcG9pbnQuLi5pdCBqdXN0XG4gICAgICogaGFwcGVucyB0aGF0IGluIHRoaXMgY2FzZSwgdGhhdCBwb2ludCBpcyBncmVhdGVyIHRoYW4gdGhlIGxlbmd0aCBvZiB0aGUgdGhlIGFycm93LlxuICAgICAqXG4gICAgICogICAgICB0aGlzIGNvdWxkIHByb2JhYmx5IGRvIHdpdGggc29tZSBoZWxwIHdpdGggcG9zaXRpb25pbmcuLi5kdWUgdG8gdGhlIHdheSBpdCByZXVzZXMgdGhlIEFycm93IHBhaW50IGNvZGUsIHdoYXQgQXJyb3cgdGhpbmtzIGlzIHRoZVxuICAgICAqICAgICAgY2VudGVyIGlzIGFjdHVhbGx5IDEvNCBvZiB0aGUgd2F5IGFsb25nIGZvciB0aGlzIGd1eS4gIGJ1dCB3ZSBkb24ndCBoYXZlIGFueSBrbm93bGVkZ2Ugb2YgcGl4ZWxzIGF0IHRoaXMgcG9pbnQsIHNvIHdlJ3JlIGtpbmQgb2ZcbiAgICAgKiAgICAgIHN0dWNrIHdoZW4gaXQgY29tZXMgdG8gaGVscGluZyBvdXQgdGhlIEFycm93IGNsYXNzLiBwb3NzaWJseSB3ZSBjb3VsZCBwYXNzIGluIGEgJ3RyYW5zcG9zZScgcGFyYW1ldGVyIG9yIHNvbWV0aGluZy4gdGhlIHZhbHVlXG4gICAgICogICAgICB3b3VsZCBiZSAtbC80IGluIHRoaXMgY2FzZSAtIG1vdmUgYWxvbmcgb25lIHF1YXJ0ZXIgb2YgdGhlIHRvdGFsIGxlbmd0aC5cbiAgICAgKi9cbiAgICAvKlxuICAgICAqIEZ1bmN0aW9uOiBDb25zdHJ1Y3RvclxuICAgICAqIFNlZSA8T3ZlcmxheXMuQXJyb3c+IGZvciBhbGxvd2VkIHBhcmFtZXRlcnMgZm9yIHRoaXMgb3ZlcmxheS5cbiAgICAgKi9cbiAgICBfanAuT3ZlcmxheXMuRGlhbW9uZCA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICAgICAgICB2YXIgbCA9IHBhcmFtcy5sZW5ndGggfHwgNDAsXG4gICAgICAgICAgICBwID0gX2pwLmV4dGVuZChwYXJhbXMsIHtsZW5ndGg6IGwgLyAyLCBmb2xkYmFjazogMn0pO1xuICAgICAgICBfanAuT3ZlcmxheXMuQXJyb3cuY2FsbCh0aGlzLCBwKTtcbiAgICAgICAgdGhpcy50eXBlID0gXCJEaWFtb25kXCI7XG4gICAgfTtcbiAgICBfanUuZXh0ZW5kKF9qcC5PdmVybGF5cy5EaWFtb25kLCBfanAuT3ZlcmxheXMuQXJyb3cpO1xuXG4gICAgdmFyIF9nZXREaW1lbnNpb25zID0gZnVuY3Rpb24gKGNvbXBvbmVudCwgZm9yY2VSZWZyZXNoKSB7XG4gICAgICAgIGlmIChjb21wb25lbnQuX2pzUGx1bWIuY2FjaGVkRGltZW5zaW9ucyA9PSBudWxsIHx8IGZvcmNlUmVmcmVzaCkge1xuICAgICAgICAgICAgY29tcG9uZW50Ll9qc1BsdW1iLmNhY2hlZERpbWVuc2lvbnMgPSBjb21wb25lbnQuZ2V0RGltZW5zaW9ucygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb21wb25lbnQuX2pzUGx1bWIuY2FjaGVkRGltZW5zaW9ucztcbiAgICB9O1xuXG4gICAgLy8gYWJzdHJhY3Qgc3VwZXJjbGFzcyBmb3Igb3ZlcmxheXMgdGhhdCBhZGQgYW4gZWxlbWVudCB0byB0aGUgRE9NLlxuICAgIHZhciBBYnN0cmFjdERPTU92ZXJsYXkgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgIF9qcC5qc1BsdW1iVUlDb21wb25lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgQWJzdHJhY3RPdmVybGF5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgLy8gaGFuZCBvZmYgZmlyZWQgZXZlbnRzIHRvIGFzc29jaWF0ZWQgY29tcG9uZW50LlxuICAgICAgICB2YXIgX2YgPSB0aGlzLmZpcmU7XG4gICAgICAgIHRoaXMuZmlyZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF9mLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBpZiAodGhpcy5jb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbXBvbmVudC5maXJlLmFwcGx5KHRoaXMuY29tcG9uZW50LCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuZGV0YWNoZWQ9ZmFsc2U7XG4gICAgICAgIHRoaXMuaWQgPSBwYXJhbXMuaWQ7XG4gICAgICAgIHRoaXMuX2pzUGx1bWIuZGl2ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fanNQbHVtYi5pbml0aWFsaXNlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9qc1BsdW1iLmNvbXBvbmVudCA9IHBhcmFtcy5jb21wb25lbnQ7XG4gICAgICAgIHRoaXMuX2pzUGx1bWIuY2FjaGVkRGltZW5zaW9ucyA9IG51bGw7XG4gICAgICAgIHRoaXMuX2pzUGx1bWIuY3JlYXRlID0gcGFyYW1zLmNyZWF0ZTtcbiAgICAgICAgdGhpcy5fanNQbHVtYi5pbml0aWFsbHlJbnZpc2libGUgPSBwYXJhbXMudmlzaWJsZSA9PT0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5nZXRFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2pzUGx1bWIuZGl2ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGl2ID0gdGhpcy5fanNQbHVtYi5kaXYgPSBfanAuZ2V0RWxlbWVudCh0aGlzLl9qc1BsdW1iLmNyZWF0ZSh0aGlzLl9qc1BsdW1iLmNvbXBvbmVudCkpO1xuICAgICAgICAgICAgICAgIGRpdi5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcbiAgICAgICAgICAgICAgICBkaXYuY2xhc3NOYW1lID0gdGhpcy5fanNQbHVtYi5pbnN0YW5jZS5vdmVybGF5Q2xhc3MgKyBcIiBcIiArXG4gICAgICAgICAgICAgICAgICAgICh0aGlzLmNzc0NsYXNzID8gdGhpcy5jc3NDbGFzcyA6XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMuY3NzQ2xhc3MgPyBwYXJhbXMuY3NzQ2xhc3MgOiBcIlwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9qc1BsdW1iLmluc3RhbmNlLmFwcGVuZEVsZW1lbnQoZGl2KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9qc1BsdW1iLmluc3RhbmNlLmdldElkKGRpdik7XG4gICAgICAgICAgICAgICAgdGhpcy5jYW52YXMgPSBkaXY7XG5cbiAgICAgICAgICAgICAgICAvLyBpbiBJRSB0aGUgdG9wIGxlZnQgY29ybmVyIGlzIHdoYXQgaXQgcGxhY2VkIGF0IHRoZSBkZXNpcmVkIGxvY2F0aW9uLiAgVGhpcyB3aWxsIG5vdFxuICAgICAgICAgICAgICAgIC8vIGJlIGZpeGVkLiBJRTggaXMgbm90IGdvaW5nIHRvIGJlIHN1cHBvcnRlZCBmb3IgbXVjaCBsb25nZXIuXG4gICAgICAgICAgICAgICAgdmFyIHRzID0gXCJ0cmFuc2xhdGUoLTUwJSwgLTUwJSlcIjtcbiAgICAgICAgICAgICAgICBkaXYuc3R5bGUud2Via2l0VHJhbnNmb3JtID0gdHM7XG4gICAgICAgICAgICAgICAgZGl2LnN0eWxlLm1velRyYW5zZm9ybSA9IHRzO1xuICAgICAgICAgICAgICAgIGRpdi5zdHlsZS5tc1RyYW5zZm9ybSA9IHRzO1xuICAgICAgICAgICAgICAgIGRpdi5zdHlsZS5vVHJhbnNmb3JtID0gdHM7XG4gICAgICAgICAgICAgICAgZGl2LnN0eWxlLnRyYW5zZm9ybSA9IHRzO1xuXG4gICAgICAgICAgICAgICAgLy8gd3JpdGUgdGhlIHJlbGF0ZWQgY29tcG9uZW50IGludG8gdGhlIGNyZWF0ZWQgZWxlbWVudFxuICAgICAgICAgICAgICAgIGRpdi5fanNQbHVtYiA9IHRoaXM7XG5cbiAgICAgICAgICAgICAgICBpZiAocGFyYW1zLnZpc2libGUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpdi5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2pzUGx1bWIuZGl2O1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuZHJhdyA9IGZ1bmN0aW9uIChjb21wb25lbnQsIGN1cnJlbnRDb25uZWN0aW9uUGFpbnRTdHlsZSwgYWJzb2x1dGVQb3NpdGlvbikge1xuICAgICAgICAgICAgdmFyIHRkID0gX2dldERpbWVuc2lvbnModGhpcyk7XG4gICAgICAgICAgICBpZiAodGQgIT0gbnVsbCAmJiB0ZC5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgICAgICB2YXIgY3h5ID0geyB4OiAwLCB5OiAwIH07XG5cbiAgICAgICAgICAgICAgICAvLyBhYnNvbHV0ZVBvc2l0aW9uIHdvdWxkIGhhdmUgYmVlbiBzZXQgYnkgYSBjYWxsIHRvIGNvbm5lY3Rpb24uc2V0QWJzb2x1dGVPdmVybGF5UG9zaXRpb24uXG4gICAgICAgICAgICAgICAgaWYgKGFic29sdXRlUG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgY3h5ID0geyB4OiBhYnNvbHV0ZVBvc2l0aW9uWzBdLCB5OiBhYnNvbHV0ZVBvc2l0aW9uWzFdIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNvbXBvbmVudC5wb2ludE9uUGF0aCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbG9jID0gdGhpcy5sb2MsIGFic29sdXRlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfanUuaXNTdHJpbmcodGhpcy5sb2MpIHx8IHRoaXMubG9jIDwgMCB8fCB0aGlzLmxvYyA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvYyA9IHBhcnNlSW50KHRoaXMubG9jLCAxMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhYnNvbHV0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY3h5ID0gY29tcG9uZW50LnBvaW50T25QYXRoKGxvYywgYWJzb2x1dGUpOyAgLy8gYSBjb25uZWN0aW9uXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbG9jVG9Vc2UgPSB0aGlzLmxvYy5jb25zdHJ1Y3RvciA9PT0gQXJyYXkgPyB0aGlzLmxvYyA6IHRoaXMuZW5kcG9pbnRMb2M7XG4gICAgICAgICAgICAgICAgICAgIGN4eSA9IHsgeDogbG9jVG9Vc2VbMF0gKiBjb21wb25lbnQudyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IGxvY1RvVXNlWzFdICogY29tcG9uZW50LmggfTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgbWlueCA9IGN4eS54IC0gKHRkWzBdIC8gMiksXG4gICAgICAgICAgICAgICAgICAgIG1pbnkgPSBjeHkueSAtICh0ZFsxXSAvIDIpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50OiBjb21wb25lbnQsXG4gICAgICAgICAgICAgICAgICAgIGQ6IHsgbWlueDogbWlueCwgbWlueTogbWlueSwgdGQ6IHRkLCBjeHk6IGN4eSB9LFxuICAgICAgICAgICAgICAgICAgICBtaW5YOiBtaW54LFxuICAgICAgICAgICAgICAgICAgICBtYXhYOiBtaW54ICsgdGRbMF0sXG4gICAgICAgICAgICAgICAgICAgIG1pblk6IG1pbnksXG4gICAgICAgICAgICAgICAgICAgIG1heFk6IG1pbnkgKyB0ZFsxXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge21pblg6IDAsIG1heFg6IDAsIG1pblk6IDAsIG1heFk6IDB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG4gICAgX2p1LmV4dGVuZChBYnN0cmFjdERPTU92ZXJsYXksIFtfanAuanNQbHVtYlVJQ29tcG9uZW50LCBBYnN0cmFjdE92ZXJsYXldLCB7XG4gICAgICAgIGdldERpbWVuc2lvbnM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBbMSwxXTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0VmlzaWJsZTogZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fanNQbHVtYi5kaXYpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9qc1BsdW1iLmRpdi5zdHlsZS5kaXNwbGF5ID0gc3RhdGUgPyBcImJsb2NrXCIgOiBcIm5vbmVcIjtcbiAgICAgICAgICAgICAgICAvLyBpZiBpbml0aWFsbHkgaW52aXNpYmxlLCBkaW1lbnNpb25zIGFyZSAwLDAgYW5kIG5ldmVyIGdldCB1cGRhdGVkXG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlICYmIHRoaXMuX2pzUGx1bWIuaW5pdGlhbGx5SW52aXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIF9nZXREaW1lbnNpb25zKHRoaXMsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbXBvbmVudC5yZXBhaW50KCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2pzUGx1bWIuaW5pdGlhbGx5SW52aXNpYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvKlxuICAgICAgICAgKiBGdW5jdGlvbjogY2xlYXJDYWNoZWREaW1lbnNpb25zXG4gICAgICAgICAqIENsZWFycyB0aGUgY2FjaGVkIGRpbWVuc2lvbnMgZm9yIHRoZSBsYWJlbC4gQXMgYSBwZXJmb3JtYW5jZSBlbmhhbmNlbWVudCwgbGFiZWwgZGltZW5zaW9ucyBhcmVcbiAgICAgICAgICogY2FjaGVkIGZyb20gMS4zLjEyIG9ud2FyZHMuIFRoZSBjYWNoZSBpcyBjbGVhcmVkIHdoZW4geW91IGNoYW5nZSB0aGUgbGFiZWwgdGV4dCwgb2YgY291cnNlLCBidXRcbiAgICAgICAgICogdGhlcmUgYXJlIG90aGVyIHJlYXNvbnMgd2h5IHRoZSB0ZXh0IGRpbWVuc2lvbnMgbWlnaHQgY2hhbmdlIC0gaWYgeW91IG1ha2UgYSBjaGFuZ2UgdGhyb3VnaCBDU1MsIGZvclxuICAgICAgICAgKiBleGFtcGxlLCB5b3UgbWlnaHQgY2hhbmdlIHRoZSBmb250IHNpemUuICBpbiB0aGF0IGNhc2UgeW91IHNob3VsZCBleHBsaWNpdGx5IGNhbGwgdGhpcyBtZXRob2QuXG4gICAgICAgICAqL1xuICAgICAgICBjbGVhckNhY2hlZERpbWVuc2lvbnM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX2pzUGx1bWIuY2FjaGVkRGltZW5zaW9ucyA9IG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIGNsZWFudXA6IGZ1bmN0aW9uIChmb3JjZSkge1xuICAgICAgICAgICAgaWYgKGZvcmNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2pzUGx1bWIuZGl2ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fanNQbHVtYi5kaXYuX2pzUGx1bWIgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9qc1BsdW1iLmluc3RhbmNlLnJlbW92ZUVsZW1lbnQodGhpcy5fanNQbHVtYi5kaXYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGlmIG5vdCBhIGZvcmNlZCBjbGVhbnVwLCBqdXN0IGRldGFjaCBjaGlsZCBmcm9tIHBhcmVudCBmb3Igbm93LlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9qc1BsdW1iICYmIHRoaXMuX2pzUGx1bWIuZGl2ICYmIHRoaXMuX2pzUGx1bWIuZGl2LnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fanNQbHVtYi5kaXYucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLl9qc1BsdW1iLmRpdik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuZGV0YWNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0sXG4gICAgICAgIHJlYXR0YWNoOmZ1bmN0aW9uKGluc3RhbmNlLCBjb21wb25lbnQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9qc1BsdW1iLmRpdiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaW5zdGFuY2UuZ2V0Q29udGFpbmVyKCkuYXBwZW5kQ2hpbGQodGhpcy5fanNQbHVtYi5kaXYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5kZXRhY2hlZCA9IGZhbHNlO1xuICAgICAgICB9LFxuICAgICAgICBjb21wdXRlTWF4U2l6ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHRkID0gX2dldERpbWVuc2lvbnModGhpcyk7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgodGRbMF0sIHRkWzFdKTtcbiAgICAgICAgfSxcbiAgICAgICAgcGFpbnQ6IGZ1bmN0aW9uIChwLCBjb250YWluZXJFeHRlbnRzKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2pzUGx1bWIuaW5pdGlhbGlzZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdldEVsZW1lbnQoKTtcbiAgICAgICAgICAgICAgICBwLmNvbXBvbmVudC5hcHBlbmREaXNwbGF5RWxlbWVudCh0aGlzLl9qc1BsdW1iLmRpdik7XG4gICAgICAgICAgICAgICAgdGhpcy5fanNQbHVtYi5pbml0aWFsaXNlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZGV0YWNoZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fanNQbHVtYi5kaXYucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLl9qc1BsdW1iLmRpdik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fanNQbHVtYi5kaXYuc3R5bGUubGVmdCA9IChwLmNvbXBvbmVudC54ICsgcC5kLm1pbngpICsgXCJweFwiO1xuICAgICAgICAgICAgdGhpcy5fanNQbHVtYi5kaXYuc3R5bGUudG9wID0gKHAuY29tcG9uZW50LnkgKyBwLmQubWlueSkgKyBcInB4XCI7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qXG4gICAgICogQ2xhc3M6IE92ZXJsYXlzLkN1c3RvbVxuICAgICAqIEEgQ3VzdG9tIG92ZXJsYXkuIFlvdSBzdXBwbHkgYSAnY3JlYXRlJyBmdW5jdGlvbiB3aGljaCByZXR1cm5zIHNvbWUgRE9NIGVsZW1lbnQsIGFuZCBqc1BsdW1iIHBvc2l0aW9ucyBpdC5cbiAgICAgKiBUaGUgJ2NyZWF0ZScgZnVuY3Rpb24gaXMgcGFzc2VkIGEgQ29ubmVjdGlvbiBvciBFbmRwb2ludC5cbiAgICAgKi9cbiAgICAvKlxuICAgICAqIEZ1bmN0aW9uOiBDb25zdHJ1Y3RvclxuICAgICAqIFxuICAgICAqIFBhcmFtZXRlcnM6XG4gICAgICogY3JlYXRlIC0gZnVuY3Rpb24gZm9yIGpzUGx1bWIgdG8gY2FsbCB0aGF0IHJldHVybnMgYSBET00gZWxlbWVudC5cbiAgICAgKiBsb2NhdGlvbiAtIGRpc3RhbmNlIChhcyBhIGRlY2ltYWwgZnJvbSAwIHRvIDEgaW5jbHVzaXZlKSBtYXJraW5nIHdoZXJlIHRoZSBsYWJlbCBzaG91bGQgc2l0IG9uIHRoZSBjb25uZWN0b3IuIGRlZmF1bHRzIHRvIDAuNS5cbiAgICAgKiBpZCAtIG9wdGlvbmFsIGlkIHRvIHVzZSBmb3IgbGF0ZXIgcmV0cmlldmFsIG9mIHRoaXMgb3ZlcmxheS5cbiAgICAgKlxuICAgICAqL1xuICAgIF9qcC5PdmVybGF5cy5DdXN0b20gPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgIHRoaXMudHlwZSA9IFwiQ3VzdG9tXCI7XG4gICAgICAgIEFic3RyYWN0RE9NT3ZlcmxheS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gICAgX2p1LmV4dGVuZChfanAuT3ZlcmxheXMuQ3VzdG9tLCBBYnN0cmFjdERPTU92ZXJsYXkpO1xuXG4gICAgX2pwLk92ZXJsYXlzLkd1aWRlTGluZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgc2VsZi5sZW5ndGggPSA1MDtcbiAgICAgICAgc2VsZi5zdHJva2VXaWR0aCA9IDU7XG4gICAgICAgIHRoaXMudHlwZSA9IFwiR3VpZGVMaW5lc1wiO1xuICAgICAgICBBYnN0cmFjdE92ZXJsYXkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgX2pwLmpzUGx1bWJVSUNvbXBvbmVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmRyYXcgPSBmdW5jdGlvbiAoY29ubmVjdG9yLCBjdXJyZW50Q29ubmVjdGlvblBhaW50U3R5bGUpIHtcblxuICAgICAgICAgICAgdmFyIGhlYWQgPSBjb25uZWN0b3IucG9pbnRBbG9uZ1BhdGhGcm9tKHNlbGYubG9jLCBzZWxmLmxlbmd0aCAvIDIpLFxuICAgICAgICAgICAgICAgIG1pZCA9IGNvbm5lY3Rvci5wb2ludE9uUGF0aChzZWxmLmxvYyksXG4gICAgICAgICAgICAgICAgdGFpbCA9IF9qZy5wb2ludE9uTGluZShoZWFkLCBtaWQsIHNlbGYubGVuZ3RoKSxcbiAgICAgICAgICAgICAgICB0YWlsTGluZSA9IF9qZy5wZXJwZW5kaWN1bGFyTGluZVRvKGhlYWQsIHRhaWwsIDQwKSxcbiAgICAgICAgICAgICAgICBoZWFkTGluZSA9IF9qZy5wZXJwZW5kaWN1bGFyTGluZVRvKHRhaWwsIGhlYWQsIDIwKTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBjb25uZWN0b3I6IGNvbm5lY3RvcixcbiAgICAgICAgICAgICAgICBoZWFkOiBoZWFkLFxuICAgICAgICAgICAgICAgIHRhaWw6IHRhaWwsXG4gICAgICAgICAgICAgICAgaGVhZExpbmU6IGhlYWRMaW5lLFxuICAgICAgICAgICAgICAgIHRhaWxMaW5lOiB0YWlsTGluZSxcbiAgICAgICAgICAgICAgICBtaW5YOiBNYXRoLm1pbihoZWFkLngsIHRhaWwueCwgaGVhZExpbmVbMF0ueCwgaGVhZExpbmVbMV0ueCksXG4gICAgICAgICAgICAgICAgbWluWTogTWF0aC5taW4oaGVhZC55LCB0YWlsLnksIGhlYWRMaW5lWzBdLnksIGhlYWRMaW5lWzFdLnkpLFxuICAgICAgICAgICAgICAgIG1heFg6IE1hdGgubWF4KGhlYWQueCwgdGFpbC54LCBoZWFkTGluZVswXS54LCBoZWFkTGluZVsxXS54KSxcbiAgICAgICAgICAgICAgICBtYXhZOiBNYXRoLm1heChoZWFkLnksIHRhaWwueSwgaGVhZExpbmVbMF0ueSwgaGVhZExpbmVbMV0ueSlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gdGhpcy5jbGVhbnVwID0gZnVuY3Rpb24oKSB7IH07ICAvLyBub3RoaW5nIHRvIGNsZWFuIHVwIGZvciBHdWlkZUxpbmVzXG4gICAgfTtcblxuICAgIC8qXG4gICAgICogQ2xhc3M6IE92ZXJsYXlzLkxhYmVsXG5cbiAgICAgKi9cbiAgICAvKlxuICAgICAqIEZ1bmN0aW9uOiBDb25zdHJ1Y3RvclxuICAgICAqIFxuICAgICAqIFBhcmFtZXRlcnM6XG4gICAgICogY3NzQ2xhc3MgLSBvcHRpb25hbCBjc3MgY2xhc3Mgc3RyaW5nIHRvIGFwcGVuZCB0byBjc3MgY2xhc3MuIFRoaXMgc3RyaW5nIGlzIGFwcGVuZGVkIFwiYXMtaXNcIiwgc28geW91IGNhbiBvZiBjb3Vyc2UgaGF2ZSBtdWx0aXBsZSBjbGFzc2VzXG4gICAgICogICAgICAgICAgICAgZGVmaW5lZC4gIFRoaXMgcGFyYW1ldGVyIGlzIHByZWZlcnJlZCB0byB1c2luZyBsYWJlbFN0eWxlLCBib3JkZXJXaWR0aCBhbmQgYm9yZGVyU3R5bGUuXG4gICAgICogbGFiZWwgLSB0aGUgbGFiZWwgdG8gcGFpbnQuICBNYXkgYmUgYSBzdHJpbmcgb3IgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBzdHJpbmcuICBOb3RoaW5nIHdpbGwgYmUgcGFpbnRlZCBpZiB5b3VyIGxhYmVsIGlzIG51bGwgb3IgeW91clxuICAgICAqICAgICAgICAgbGFiZWwgZnVuY3Rpb24gcmV0dXJucyBudWxsLiAgZW1wdHkgc3RyaW5ncyBfd2lsbF8gYmUgcGFpbnRlZC5cbiAgICAgKiBsb2NhdGlvbiAtIGRpc3RhbmNlIChhcyBhIGRlY2ltYWwgZnJvbSAwIHRvIDEgaW5jbHVzaXZlKSBtYXJraW5nIHdoZXJlIHRoZSBsYWJlbCBzaG91bGQgc2l0IG9uIHRoZSBjb25uZWN0b3IuIGRlZmF1bHRzIHRvIDAuNS5cbiAgICAgKiBpZCAtIG9wdGlvbmFsIGlkIHRvIHVzZSBmb3IgbGF0ZXIgcmV0cmlldmFsIG9mIHRoaXMgb3ZlcmxheS5cbiAgICAgKiBcbiAgICAgKlxuICAgICAqL1xuICAgIF9qcC5PdmVybGF5cy5MYWJlbCA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgdGhpcy5sYWJlbFN0eWxlID0gcGFyYW1zLmxhYmVsU3R5bGU7XG5cbiAgICAgICAgdmFyIGxhYmVsV2lkdGggPSBudWxsLCBsYWJlbEhlaWdodCA9IG51bGwsIGxhYmVsVGV4dCA9IG51bGwsIGxhYmVsUGFkZGluZyA9IG51bGw7XG4gICAgICAgIHRoaXMuY3NzQ2xhc3MgPSB0aGlzLmxhYmVsU3R5bGUgIT0gbnVsbCA/IHRoaXMubGFiZWxTdHlsZS5jc3NDbGFzcyA6IG51bGw7XG4gICAgICAgIHZhciBwID0gX2pwLmV4dGVuZCh7XG4gICAgICAgICAgICBjcmVhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2pwLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICB9fSwgcGFyYW1zKTtcbiAgICAgICAgX2pwLk92ZXJsYXlzLkN1c3RvbS5jYWxsKHRoaXMsIHApO1xuICAgICAgICB0aGlzLnR5cGUgPSBcIkxhYmVsXCI7XG4gICAgICAgIHRoaXMubGFiZWwgPSBwYXJhbXMubGFiZWwgfHwgXCJcIjtcbiAgICAgICAgdGhpcy5sYWJlbFRleHQgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5sYWJlbFN0eWxlKSB7XG4gICAgICAgICAgICB2YXIgZWwgPSB0aGlzLmdldEVsZW1lbnQoKTtcbiAgICAgICAgICAgIHRoaXMubGFiZWxTdHlsZS5mb250ID0gdGhpcy5sYWJlbFN0eWxlLmZvbnQgfHwgXCIxMnB4IHNhbnMtc2VyaWZcIjtcbiAgICAgICAgICAgIGVsLnN0eWxlLmZvbnQgPSB0aGlzLmxhYmVsU3R5bGUuZm9udDtcbiAgICAgICAgICAgIGVsLnN0eWxlLmNvbG9yID0gdGhpcy5sYWJlbFN0eWxlLmNvbG9yIHx8IFwiYmxhY2tcIjtcbiAgICAgICAgICAgIGlmICh0aGlzLmxhYmVsU3R5bGUuZmlsbCkge1xuICAgICAgICAgICAgICAgIGVsLnN0eWxlLmJhY2tncm91bmQgPSB0aGlzLmxhYmVsU3R5bGUuZmlsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmxhYmVsU3R5bGUuYm9yZGVyV2lkdGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRTdHlsZSA9IHRoaXMubGFiZWxTdHlsZS5ib3JkZXJTdHlsZSA/IHRoaXMubGFiZWxTdHlsZS5ib3JkZXJTdHlsZSA6IFwiYmxhY2tcIjtcbiAgICAgICAgICAgICAgICBlbC5zdHlsZS5ib3JkZXIgPSB0aGlzLmxhYmVsU3R5bGUuYm9yZGVyV2lkdGggKyBcInB4IHNvbGlkIFwiICsgZFN0eWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMubGFiZWxTdHlsZS5wYWRkaW5nKSB7XG4gICAgICAgICAgICAgICAgZWwuc3R5bGUucGFkZGluZyA9IHRoaXMubGFiZWxTdHlsZS5wYWRkaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9O1xuICAgIF9qdS5leHRlbmQoX2pwLk92ZXJsYXlzLkxhYmVsLCBfanAuT3ZlcmxheXMuQ3VzdG9tLCB7XG4gICAgICAgIGNsZWFudXA6IGZ1bmN0aW9uIChmb3JjZSkge1xuICAgICAgICAgICAgaWYgKGZvcmNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXYgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMubGFiZWwgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMubGFiZWxUZXh0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLmNzc0NsYXNzID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLmxhYmVsU3R5bGUgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBnZXRMYWJlbDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGFiZWw7XG4gICAgICAgIH0sXG4gICAgICAgIC8qXG4gICAgICAgICAqIEZ1bmN0aW9uOiBzZXRMYWJlbFxuICAgICAgICAgKiBzZXRzIHRoZSBsYWJlbCdzLCB1bSwgbGFiZWwuICB5b3Ugd291bGQgdGhpbmsgaSdkIGNhbGwgdGhpcyBmdW5jdGlvblxuICAgICAgICAgKiAnc2V0VGV4dCcsIGJ1dCB5b3UgY2FuIHBhc3MgZWl0aGVyIGEgRnVuY3Rpb24gb3IgYSBTdHJpbmcgdG8gdGhpcywgc29cbiAgICAgICAgICogaXQgbWFrZXMgbW9yZSBzZW5zZSBhcyAnc2V0TGFiZWwnLiBUaGlzIHVzZXMgaW5uZXJIVE1MIG9uIHRoZSBsYWJlbCBkaXYsIHNvIGtlZXBcbiAgICAgICAgICogdGhhdCBpbiBtaW5kIGlmIHlvdSBuZWVkIGVzY2FwZWQgSFRNTC5cbiAgICAgICAgICovXG4gICAgICAgIHNldExhYmVsOiBmdW5jdGlvbiAobCkge1xuICAgICAgICAgICAgdGhpcy5sYWJlbCA9IGw7XG4gICAgICAgICAgICB0aGlzLmxhYmVsVGV4dCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmNsZWFyQ2FjaGVkRGltZW5zaW9ucygpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50LnJlcGFpbnQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0RGltZW5zaW9uczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgICAgICAgIHJldHVybiBBYnN0cmFjdERPTU92ZXJsYXkucHJvdG90eXBlLmdldERpbWVuc2lvbnMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfSxcbiAgICAgICAgdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMubGFiZWwgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHZhciBsdCA9IHRoaXMubGFiZWwodGhpcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5nZXRFbGVtZW50KCkuaW5uZXJIVE1MID0gbHQucmVwbGFjZSgvXFxyXFxuL2csIFwiPGJyLz5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5sYWJlbFRleHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxhYmVsVGV4dCA9IHRoaXMubGFiZWw7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0RWxlbWVudCgpLmlubmVySFRNTCA9IHRoaXMubGFiZWxUZXh0LnJlcGxhY2UoL1xcclxcbi9nLCBcIjxici8+XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdXBkYXRlRnJvbTpmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICBpZihkLmxhYmVsICE9IG51bGwpe1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0TGFiZWwoZC5sYWJlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiBFTkQgT0YgT1ZFUkxBWSBERUZJTklUSU9OUyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXG59KS5jYWxsKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdGhpcyk7XG5cbi8qXG4gKiBqc1BsdW1iIENvbW11bml0eSBFZGl0aW9uXG4gKlxuICogUHJvdmlkZXMgYSB3YXkgdG8gdmlzdWFsbHkgY29ubmVjdCBlbGVtZW50cyBvbiBhbiBIVE1MIHBhZ2UsIHVzaW5nIFNWRy5cbiAqXG4gKiBUaGlzIGZpbGUgY29udGFpbnMgdGhlIGJhc2UgY2xhc3MgZm9yIGxpYnJhcnkgYWRhcHRlcnMuXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEwIC0gMjAxNyBqc1BsdW1iIChoZWxsb0Bqc3BsdW1idG9vbGtpdC5jb20pXG4gKlxuICogaHR0cHM6Ly9qc3BsdW1idG9vbGtpdC5jb21cbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9qc3BsdW1iL2pzcGx1bWJcbiAqXG4gKiBEdWFsIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgYW5kIEdQTDIgbGljZW5zZXMuXG4gKi9cbjsoZnVuY3Rpb24oKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIHJvb3QgPSB0aGlzLFxuICAgICAgICBfanAgPSByb290LmpzUGx1bWI7XG5cbiAgICB2YXIgX2dldEV2ZW50TWFuYWdlciA9IGZ1bmN0aW9uKGluc3RhbmNlKSB7XG4gICAgICAgIHZhciBlID0gaW5zdGFuY2UuX21vdHRsZTtcbiAgICAgICAgaWYgKCFlKSB7XG4gICAgICAgICAgICBlID0gaW5zdGFuY2UuX21vdHRsZSA9IG5ldyByb290Lk1vdHRsZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlO1xuICAgIH07XG5cbiAgICBfanAuZXh0ZW5kKHJvb3QuanNQbHVtYkluc3RhbmNlLnByb3RvdHlwZSwge1xuICAgICAgICBnZXRFdmVudE1hbmFnZXI6ZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gX2dldEV2ZW50TWFuYWdlcih0aGlzKTtcbiAgICAgICAgfSxcbiAgICAgICAgb24gOiBmdW5jdGlvbihlbCwgZXZlbnQsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBoZXJlIHdlIHdvdWxkIGxpa2UgdG8gbWFwIHRoZSB0YXAgZXZlbnQgaWYgd2Uga25vdyBpdHNcbiAgICAgICAgICAgIC8vIGFuIGludGVybmFsIGJpbmQgdG8gYSBjbGljay4gd2UgaGF2ZSB0byBrbm93IGl0cyBpbnRlcm5hbCBiZWNhdXNlIG9ubHlcbiAgICAgICAgICAgIC8vIHRoZW4gY2FuIHdlIGJlIHN1cmUgdGhhdCB0aGUgVVAgZXZlbnQgd29udCBiZSBjb25zdW1lZCAodGFwIGlzIGEgc3ludGhlc2l6ZWRcbiAgICAgICAgICAgIC8vIGV2ZW50IGZyb20gYSBtb3VzZWRvd24gZm9sbG93ZWQgYnkgYSBtb3VzZXVwKS5cbiAgICAgICAgICAgIC8vZXZlbnQgPSB7IFwiY2xpY2tcIjpcInRhcFwiLCBcImRibGNsaWNrXCI6XCJkYmx0YXBcIn1bZXZlbnRdIHx8IGV2ZW50O1xuICAgICAgICAgICAgdGhpcy5nZXRFdmVudE1hbmFnZXIoKS5vbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIG9mZiA6IGZ1bmN0aW9uKGVsLCBldmVudCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0RXZlbnRNYW5hZ2VyKCkub2ZmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgIH0pO1xuXG5cbn0pLmNhbGwodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB0aGlzKTtcbi8qXG4gKiBqc1BsdW1iIENvbW11bml0eSBFZGl0aW9uXG4gKlxuICogUHJvdmlkZXMgYSB3YXkgdG8gdmlzdWFsbHkgY29ubmVjdCBlbGVtZW50cyBvbiBhbiBIVE1MIHBhZ2UsIHVzaW5nIFNWRy5cbiAqXG4gKiBUaGlzIGZpbGUgY29udGFpbnMgdGhlIGNvZGUgZm9yIHdvcmtpbmcgd2l0aCBHcm91cHMuXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEwIC0gMjAxNyBqc1BsdW1iIChoZWxsb0Bqc3BsdW1idG9vbGtpdC5jb20pXG4gKlxuICogaHR0cHM6Ly9qc3BsdW1idG9vbGtpdC5jb21cbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9qc3BsdW1iL2pzcGx1bWJcbiAqXG4gKiBEdWFsIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgYW5kIEdQTDIgbGljZW5zZXMuXG4gKi9cbjsoZnVuY3Rpb24oKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICB2YXIgcm9vdCA9IHRoaXMsXG4gICAgICAgIF9qdSA9IHJvb3QuanNQbHVtYlV0aWwsXG4gICAgICAgIF9qcGkgPSByb290LmpzUGx1bWJJbnN0YW5jZTtcblxuICAgIHZhciBHUk9VUF9DT0xMQVBTRURfQ0xBU1MgPSBcImp0ay1ncm91cC1jb2xsYXBzZWRcIjtcbiAgICB2YXIgR1JPVVBfRVhQQU5ERURfQ0xBU1MgPSBcImp0ay1ncm91cC1leHBhbmRlZFwiO1xuICAgIHZhciBHUk9VUF9DT05UQUlORVJfU0VMRUNUT1IgPSBcIltqdGstZ3JvdXAtY29udGVudF1cIjtcbiAgICB2YXIgRUxFTUVOVF9EUkFHR0FCTEVfRVZFTlQgPSBcImVsZW1lbnREcmFnZ2FibGVcIjtcbiAgICB2YXIgU1RPUCA9IFwic3RvcFwiO1xuICAgIHZhciBSRVZFUlQgPSBcInJldmVydFwiO1xuICAgIHZhciBHUk9VUF9NQU5BR0VSID0gXCJfZ3JvdXBNYW5hZ2VyXCI7XG4gICAgdmFyIEdST1VQID0gXCJfanNQbHVtYkdyb3VwXCI7XG4gICAgdmFyIEdST1VQX0RSQUdfU0NPUEUgPSBcIl9qc1BsdW1iR3JvdXBEcmFnXCI7XG4gICAgdmFyIEVWVF9DSElMRF9BRERFRCA9IFwiZ3JvdXA6YWRkTWVtYmVyXCI7XG4gICAgdmFyIEVWVF9DSElMRF9SRU1PVkVEID0gXCJncm91cDpyZW1vdmVNZW1iZXJcIjtcbiAgICB2YXIgRVZUX0dST1VQX0FEREVEID0gXCJncm91cDphZGRcIjtcbiAgICB2YXIgRVZUX0dST1VQX1JFTU9WRUQgPSBcImdyb3VwOnJlbW92ZVwiO1xuICAgIHZhciBFVlRfRVhQQU5EID0gXCJncm91cDpleHBhbmRcIjtcbiAgICB2YXIgRVZUX0NPTExBUFNFID0gXCJncm91cDpjb2xsYXBzZVwiO1xuICAgIHZhciBFVlRfR1JPVVBfRFJBR19TVE9QID0gXCJncm91cERyYWdTdG9wXCI7XG4gICAgdmFyIEVWVF9DT05ORUNUSU9OX01PVkVEID0gXCJjb25uZWN0aW9uTW92ZWRcIjtcbiAgICB2YXIgRVZUX0lOVEVSTkFMX0NPTk5FQ1RJT05fREVUQUNIRUQgPSBcImludGVybmFsLmNvbm5lY3Rpb25EZXRhY2hlZFwiO1xuXG4gICAgdmFyIENNRF9SRU1PVkVfQUxMID0gXCJyZW1vdmVBbGxcIjtcbiAgICB2YXIgQ01EX09SUEhBTl9BTEwgPSBcIm9ycGhhbkFsbFwiO1xuICAgIHZhciBDTURfU0hPVyA9IFwic2hvd1wiO1xuICAgIHZhciBDTURfSElERSA9IFwiaGlkZVwiO1xuXG4gICAgdmFyIEdyb3VwTWFuYWdlciA9IGZ1bmN0aW9uKF9qc1BsdW1iKSB7XG4gICAgICAgIHZhciBfbWFuYWdlZEdyb3VwcyA9IHt9LCBfY29ubmVjdGlvblNvdXJjZU1hcCA9IHt9LCBfY29ubmVjdGlvblRhcmdldE1hcCA9IHt9LCBzZWxmID0gdGhpcztcblxuICAgICAgICBfanNQbHVtYi5iaW5kKFwiY29ubmVjdGlvblwiLCBmdW5jdGlvbihwKSB7XG4gICAgICAgICAgICBpZiAocC5zb3VyY2VbR1JPVVBdICE9IG51bGwgJiYgcC50YXJnZXRbR1JPVVBdICE9IG51bGwgJiYgcC5zb3VyY2VbR1JPVVBdID09PSBwLnRhcmdldFtHUk9VUF0pIHtcbiAgICAgICAgICAgICAgICBfY29ubmVjdGlvblNvdXJjZU1hcFtwLmNvbm5lY3Rpb24uaWRdID0gcC5zb3VyY2VbR1JPVVBdO1xuICAgICAgICAgICAgICAgIF9jb25uZWN0aW9uVGFyZ2V0TWFwW3AuY29ubmVjdGlvbi5pZF0gPSBwLnNvdXJjZVtHUk9VUF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAocC5zb3VyY2VbR1JPVVBdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgX2p1LnN1Z2dlc3QocC5zb3VyY2VbR1JPVVBdLmNvbm5lY3Rpb25zLnNvdXJjZSwgcC5jb25uZWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgX2Nvbm5lY3Rpb25Tb3VyY2VNYXBbcC5jb25uZWN0aW9uLmlkXSA9IHAuc291cmNlW0dST1VQXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHAudGFyZ2V0W0dST1VQXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIF9qdS5zdWdnZXN0KHAudGFyZ2V0W0dST1VQXS5jb25uZWN0aW9ucy50YXJnZXQsIHAuY29ubmVjdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIF9jb25uZWN0aW9uVGFyZ2V0TWFwW3AuY29ubmVjdGlvbi5pZF0gPSBwLnRhcmdldFtHUk9VUF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBmdW5jdGlvbiBfY2xlYW51cERldGFjaGVkQ29ubmVjdGlvbihjb25uKSB7XG4gICAgICAgICAgICBkZWxldGUgY29ubi5wcm94aWVzO1xuICAgICAgICAgICAgdmFyIGdyb3VwID0gX2Nvbm5lY3Rpb25Tb3VyY2VNYXBbY29ubi5pZF0sIGY7XG4gICAgICAgICAgICBpZiAoZ3JvdXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGYgPSBmdW5jdGlvbihjKSB7IHJldHVybiBjLmlkID09PSBjb25uLmlkOyB9O1xuICAgICAgICAgICAgICAgIF9qdS5yZW1vdmVXaXRoRnVuY3Rpb24oZ3JvdXAuY29ubmVjdGlvbnMuc291cmNlLCBmKTtcbiAgICAgICAgICAgICAgICBfanUucmVtb3ZlV2l0aEZ1bmN0aW9uKGdyb3VwLmNvbm5lY3Rpb25zLnRhcmdldCwgZik7XG4gICAgICAgICAgICAgICAgZGVsZXRlIF9jb25uZWN0aW9uU291cmNlTWFwW2Nvbm4uaWRdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBncm91cCA9IF9jb25uZWN0aW9uVGFyZ2V0TWFwW2Nvbm4uaWRdO1xuICAgICAgICAgICAgaWYgKGdyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBmID0gZnVuY3Rpb24oYykgeyByZXR1cm4gYy5pZCA9PT0gY29ubi5pZDsgfTtcbiAgICAgICAgICAgICAgICBfanUucmVtb3ZlV2l0aEZ1bmN0aW9uKGdyb3VwLmNvbm5lY3Rpb25zLnNvdXJjZSwgZik7XG4gICAgICAgICAgICAgICAgX2p1LnJlbW92ZVdpdGhGdW5jdGlvbihncm91cC5jb25uZWN0aW9ucy50YXJnZXQsIGYpO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBfY29ubmVjdGlvblRhcmdldE1hcFtjb25uLmlkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIF9qc1BsdW1iLmJpbmQoRVZUX0lOVEVSTkFMX0NPTk5FQ1RJT05fREVUQUNIRUQsIGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICAgIF9jbGVhbnVwRGV0YWNoZWRDb25uZWN0aW9uKHAuY29ubmVjdGlvbik7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIF9qc1BsdW1iLmJpbmQoRVZUX0NPTk5FQ1RJT05fTU9WRUQsIGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICAgIHZhciBjb25uTWFwID0gcC5pbmRleCA9PT0gMCA/IF9jb25uZWN0aW9uU291cmNlTWFwIDogX2Nvbm5lY3Rpb25UYXJnZXRNYXA7XG4gICAgICAgICAgICB2YXIgZ3JvdXAgPSBjb25uTWFwW3AuY29ubmVjdGlvbi5pZF07XG4gICAgICAgICAgICBpZiAoZ3JvdXApIHtcbiAgICAgICAgICAgICAgICB2YXIgbGlzdCA9IGdyb3VwLmNvbm5lY3Rpb25zW3AuaW5kZXggPT09IDAgPyBcInNvdXJjZVwiIDogXCJ0YXJnZXRcIl07XG4gICAgICAgICAgICAgICAgdmFyIGlkeCA9IGxpc3QuaW5kZXhPZihwLmNvbm5lY3Rpb24pO1xuICAgICAgICAgICAgICAgIGlmIChpZHggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3Quc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmFkZEdyb3VwID0gZnVuY3Rpb24oZ3JvdXApIHtcbiAgICAgICAgICAgIF9qc1BsdW1iLmFkZENsYXNzKGdyb3VwLmdldEVsKCksIEdST1VQX0VYUEFOREVEX0NMQVNTKTtcbiAgICAgICAgICAgIF9tYW5hZ2VkR3JvdXBzW2dyb3VwLmlkXSA9IGdyb3VwO1xuICAgICAgICAgICAgZ3JvdXAubWFuYWdlciA9IHRoaXM7XG4gICAgICAgICAgICBfdXBkYXRlQ29ubmVjdGlvbnNGb3JHcm91cChncm91cCk7XG4gICAgICAgICAgICBfanNQbHVtYi5maXJlKEVWVF9HUk9VUF9BRERFRCwgeyBncm91cDpncm91cCB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmFkZFRvR3JvdXAgPSBmdW5jdGlvbihncm91cCwgZWwsIGRvTm90RmlyZUV2ZW50KSB7XG4gICAgICAgICAgICBncm91cCA9IHRoaXMuZ2V0R3JvdXAoZ3JvdXApO1xuICAgICAgICAgICAgaWYgKGdyb3VwKSB7XG4gICAgICAgICAgICAgICAgLy9ncm91cC5hZGQoZWwsIGRvTm90RmlyZUV2ZW50KTtcbiAgICAgICAgICAgICAgICB2YXIgZ3JvdXBFbCA9IGdyb3VwLmdldEVsKCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoZWwuX2lzSnNQbHVtYkdyb3VwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRHcm91cCA9IGVsLl9qc1BsdW1iR3JvdXA7XG4gICAgICAgICAgICAgICAgLy8gaWYgYWxyZWFkeSBhIG1lbWJlciBvZiB0aGlzIGdyb3VwLCBkbyBub3RoaW5nXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRHcm91cCAhPT0gZ3JvdXApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVscG9zID0gX2pzUGx1bWIuZ2V0T2Zmc2V0KGVsLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNwb3MgPSBncm91cC5jb2xsYXBzZWQgPyBfanNQbHVtYi5nZXRPZmZzZXQoZ3JvdXBFbCwgdHJ1ZSkgOiBfanNQbHVtYi5nZXRPZmZzZXQoZ3JvdXAuZ2V0RHJhZ0FyZWEoKSwgdHJ1ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gb3RoZXJ3aXNlLCB0cmFuc2ZlciB0byB0aGlzIGdyb3VwLlxuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudEdyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRHcm91cC5yZW1vdmUoZWwsIGRvTm90RmlyZUV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYudXBkYXRlQ29ubmVjdGlvbnNGb3JHcm91cChjdXJyZW50R3JvdXApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGdyb3VwLmFkZChlbCwgZG9Ob3RGaXJlRXZlbnQpO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBoYW5kbGVEcm9wcGVkQ29ubmVjdGlvbnMgPSBmdW5jdGlvbiAobGlzdCwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvaWR4ID0gaW5kZXggPT09IDAgPyAxIDogMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3QuZWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuc2V0VmlzaWJsZShmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGMuZW5kcG9pbnRzW29pZHhdLmVsZW1lbnQuX2pzUGx1bWJHcm91cCA9PT0gZ3JvdXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5lbmRwb2ludHNbb2lkeF0uc2V0VmlzaWJsZShmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZXhwYW5kQ29ubmVjdGlvbihjLCBvaWR4LCBncm91cCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmVuZHBvaW50c1tpbmRleF0uc2V0VmlzaWJsZShmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY29sbGFwc2VDb25uZWN0aW9uKGMsIGluZGV4LCBncm91cCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGdyb3VwLmNvbGxhcHNlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlRHJvcHBlZENvbm5lY3Rpb25zKF9qc1BsdW1iLnNlbGVjdCh7c291cmNlOiBlbH0pLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZURyb3BwZWRDb25uZWN0aW9ucyhfanNQbHVtYi5zZWxlY3Qoe3RhcmdldDogZWx9KSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB2YXIgZWxJZCA9IF9qc1BsdW1iLmdldElkKGVsKTtcbiAgICAgICAgICAgICAgICAgICAgX2pzUGx1bWIuZHJhZ01hbmFnZXIuc2V0UGFyZW50KGVsLCBlbElkLCBncm91cEVsLCBfanNQbHVtYi5nZXRJZChncm91cEVsKSwgZWxwb3MpO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdQb3NpdGlvbiA9IHsgbGVmdDogZWxwb3MubGVmdCAtIGNwb3MubGVmdCwgdG9wOiBlbHBvcy50b3AgLSBjcG9zLnRvcCB9O1xuXG4gICAgICAgICAgICAgICAgICAgIF9qc1BsdW1iLnNldFBvc2l0aW9uKGVsLCBuZXdQb3NpdGlvbik7XG5cbiAgICAgICAgICAgICAgICAgICAgX2pzUGx1bWIuZHJhZ01hbmFnZXIucmV2YWxpZGF0ZVBhcmVudChlbCwgZWxJZCwgZWxwb3MpO1xuXG4gICAgICAgICAgICAgICAgICAgIHNlbGYudXBkYXRlQ29ubmVjdGlvbnNGb3JHcm91cChncm91cCk7XG5cbiAgICAgICAgICAgICAgICAgICAgX2pzUGx1bWIucmV2YWxpZGF0ZShlbElkKTtcblxuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9qc1BsdW1iLmZpcmUoRVZUX0NISUxEX0FEREVELCB7Z3JvdXA6IGdyb3VwLCBlbDogZWx9KTtcbiAgICAgICAgICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMucmVtb3ZlRnJvbUdyb3VwID0gZnVuY3Rpb24oZ3JvdXAsIGVsLCBkb05vdEZpcmVFdmVudCkge1xuICAgICAgICAgICAgZ3JvdXAgPSB0aGlzLmdldEdyb3VwKGdyb3VwKTtcbiAgICAgICAgICAgIGlmIChncm91cCkge1xuICAgICAgICAgICAgICAgIGdyb3VwLnJlbW92ZShlbCwgbnVsbCwgZG9Ob3RGaXJlRXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuZ2V0R3JvdXAgPSBmdW5jdGlvbihncm91cElkKSB7XG4gICAgICAgICAgICB2YXIgZ3JvdXAgPSBncm91cElkO1xuICAgICAgICAgICAgaWYgKF9qdS5pc1N0cmluZyhncm91cElkKSkge1xuICAgICAgICAgICAgICAgIGdyb3VwID0gX21hbmFnZWRHcm91cHNbZ3JvdXBJZF07XG4gICAgICAgICAgICAgICAgaWYgKGdyb3VwID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk5vIHN1Y2ggZ3JvdXAgW1wiICsgZ3JvdXBJZCArIFwiXVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZ3JvdXA7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5nZXRHcm91cHMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBvID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBnIGluIF9tYW5hZ2VkR3JvdXBzKSB7XG4gICAgICAgICAgICAgICAgby5wdXNoKF9tYW5hZ2VkR3JvdXBzW2ddKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMucmVtb3ZlR3JvdXAgPSBmdW5jdGlvbihncm91cCwgZGVsZXRlTWVtYmVycywgbWFuaXB1bGF0ZURPTSwgZG9Ob3RGaXJlRXZlbnQpIHtcbiAgICAgICAgICAgIGdyb3VwID0gdGhpcy5nZXRHcm91cChncm91cCk7XG4gICAgICAgICAgICB0aGlzLmV4cGFuZEdyb3VwKGdyb3VwLCB0cnVlKTsgLy8gdGhpcyByZWluc3RhdGVzIGFueSBvcmlnaW5hbCBjb25uZWN0aW9ucyBhbmQgcmVtb3ZlcyBhbGwgcHJveGllcywgYnV0IGRvZXMgbm90IGZpcmUgYW4gZXZlbnQuXG4gICAgICAgICAgICBncm91cFtkZWxldGVNZW1iZXJzID8gQ01EX1JFTU9WRV9BTEwgOiBDTURfT1JQSEFOX0FMTF0obWFuaXB1bGF0ZURPTSwgZG9Ob3RGaXJlRXZlbnQpO1xuICAgICAgICAgICAgX2pzUGx1bWIucmVtb3ZlKGdyb3VwLmdldEVsKCkpO1xuICAgICAgICAgICAgZGVsZXRlIF9tYW5hZ2VkR3JvdXBzW2dyb3VwLmlkXTtcbiAgICAgICAgICAgIGRlbGV0ZSBfanNQbHVtYi5fZ3JvdXBzW2dyb3VwLmlkXTtcbiAgICAgICAgICAgIF9qc1BsdW1iLmZpcmUoRVZUX0dST1VQX1JFTU9WRUQsIHsgZ3JvdXA6Z3JvdXAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5yZW1vdmVBbGxHcm91cHMgPSBmdW5jdGlvbihkZWxldGVNZW1iZXJzLCBtYW5pcHVsYXRlRE9NLCBkb05vdEZpcmVFdmVudCkge1xuICAgICAgICAgICAgZm9yICh2YXIgZyBpbiBfbWFuYWdlZEdyb3Vwcykge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlR3JvdXAoX21hbmFnZWRHcm91cHNbZ10sIGRlbGV0ZU1lbWJlcnMsIG1hbmlwdWxhdGVET00sIGRvTm90RmlyZUV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBfc2V0VmlzaWJsZShncm91cCwgc3RhdGUpIHtcbiAgICAgICAgICAgIHZhciBtID0gZ3JvdXAuZ2V0TWVtYmVycygpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgX2pzUGx1bWJbc3RhdGUgPyBDTURfU0hPVyA6IENNRF9ISURFXShtW2ldLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBfY29sbGFwc2VDb25uZWN0aW9uID0gdGhpcy5jb2xsYXBzZUNvbm5lY3Rpb24gPSBmdW5jdGlvbihjLCBpbmRleCwgZ3JvdXApIHtcblxuICAgICAgICAgICAgdmFyIHByb3h5RXAsIGdyb3VwRWwgPSBncm91cC5nZXRFbCgpLCBncm91cEVsSWQgPSBfanNQbHVtYi5nZXRJZChncm91cEVsKSxcbiAgICAgICAgICAgICAgICBvcmlnaW5hbEVsZW1lbnRJZCA9IGMuZW5kcG9pbnRzW2luZGV4XS5lbGVtZW50SWQ7XG5cbiAgICAgICAgICAgIHZhciBvdGhlckVsID0gYy5lbmRwb2ludHNbaW5kZXggPT09IDAgPyAxIDogMF0uZWxlbWVudDtcbiAgICAgICAgICAgIGlmIChvdGhlckVsW0dST1VQXSAmJiAoIW90aGVyRWxbR1JPVVBdLnNob3VsZFByb3h5KCkgJiYgb3RoZXJFbFtHUk9VUF0uY29sbGFwc2VkKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYy5wcm94aWVzID0gYy5wcm94aWVzIHx8IFtdO1xuICAgICAgICAgICAgaWYoYy5wcm94aWVzW2luZGV4XSkge1xuICAgICAgICAgICAgICAgIHByb3h5RXAgPSBjLnByb3hpZXNbaW5kZXhdLmVwO1xuICAgICAgICAgICAgfWVsc2Uge1xuICAgICAgICAgICAgICAgIHByb3h5RXAgPSBfanNQbHVtYi5hZGRFbmRwb2ludChncm91cEVsLCB7XG4gICAgICAgICAgICAgICAgICAgIGVuZHBvaW50Omdyb3VwLmdldEVuZHBvaW50KGMsIGluZGV4KSxcbiAgICAgICAgICAgICAgICAgICAgYW5jaG9yOmdyb3VwLmdldEFuY2hvcihjLCBpbmRleCksXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtZXRlcnM6e1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNQcm94eUVuZHBvaW50OnRydWVcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJveHlFcC5zZXREZWxldGVPbkVtcHR5KHRydWUpO1xuXG4gICAgICAgICAgICAvLyBmb3IgdGhpcyBpbmRleCwgc3Rhc2ggcHJveHkgaW5mbzogdGhlIG5ldyBFUCwgdGhlIG9yaWdpbmFsIEVQLlxuICAgICAgICAgICAgYy5wcm94aWVzW2luZGV4XSA9IHsgZXA6cHJveHlFcCwgb3JpZ2luYWxFcDogYy5lbmRwb2ludHNbaW5kZXhdIH07XG5cbiAgICAgICAgICAgIC8vIGFuZCBhZHZpc2UgdGhlIGFuY2hvciBtYW5hZ2VyXG4gICAgICAgICAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPIHdoeSBhcmUgdGhlcmUgdHdvIGRpZmZlcmVudGx5IG5hbWVkIG1ldGhvZHM/IFdoeSBpcyB0aGVyZSBub3Qgb25lIG1ldGhvZCB0aGF0IHNheXMgXCJzb21lIGVuZCBvZiB0aGlzXG4gICAgICAgICAgICAgICAgLy8gY29ubmVjdGlvbiBjaGFuZ2VkICh5b3UgZ2l2ZSB0aGUgaW5kZXgpLCBhbmQgaGVyZSdzIHRoZSBuZXcgZWxlbWVudCBhbmQgZWxlbWVudCBpZC5cIlxuICAgICAgICAgICAgICAgIF9qc1BsdW1iLmFuY2hvck1hbmFnZXIuc291cmNlQ2hhbmdlZChvcmlnaW5hbEVsZW1lbnRJZCwgZ3JvdXBFbElkLCBjLCBncm91cEVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIF9qc1BsdW1iLmFuY2hvck1hbmFnZXIudXBkYXRlT3RoZXJFbmRwb2ludChjLmVuZHBvaW50c1swXS5lbGVtZW50SWQsIG9yaWdpbmFsRWxlbWVudElkLCBncm91cEVsSWQsIGMpO1xuICAgICAgICAgICAgICAgIGMudGFyZ2V0ID0gZ3JvdXBFbDtcbiAgICAgICAgICAgICAgICBjLnRhcmdldElkID0gZ3JvdXBFbElkO1xuICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgIC8vIGRldGFjaCB0aGUgb3JpZ2luYWwgRVAgZnJvbSB0aGUgY29ubmVjdGlvbi5cbiAgICAgICAgICAgIGMucHJveGllc1tpbmRleF0ub3JpZ2luYWxFcC5kZXRhY2hGcm9tQ29ubmVjdGlvbihjLCBudWxsLCB0cnVlKTtcblxuICAgICAgICAgICAgLy8gc2V0IHRoZSBwcm94eSBhcyB0aGUgbmV3IGVwXG4gICAgICAgICAgICBwcm94eUVwLmNvbm5lY3Rpb25zID0gWyBjIF07XG4gICAgICAgICAgICBjLmVuZHBvaW50c1tpbmRleF0gPSBwcm94eUVwO1xuXG4gICAgICAgICAgICBjLnNldFZpc2libGUodHJ1ZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5jb2xsYXBzZUdyb3VwID0gZnVuY3Rpb24oZ3JvdXApIHtcbiAgICAgICAgICAgIGdyb3VwID0gdGhpcy5nZXRHcm91cChncm91cCk7XG4gICAgICAgICAgICBpZiAoZ3JvdXAgPT0gbnVsbCB8fCBncm91cC5jb2xsYXBzZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZ3JvdXBFbCA9IGdyb3VwLmdldEVsKCk7XG5cbiAgICAgICAgICAgIC8vIHRvZG8gcmVtb3ZlIG9sZCBwcm94eSBlbmRwb2ludHMgZmlyc3QsIGp1c3QgaW4gY2FzZT9cbiAgICAgICAgICAgIC8vZ3JvdXAucHJveGllcy5sZW5ndGggPSAwO1xuXG4gICAgICAgICAgICAvLyBoaWRlIGFsbCBjb25uZWN0aW9uc1xuICAgICAgICAgICAgX3NldFZpc2libGUoZ3JvdXAsIGZhbHNlKTtcblxuICAgICAgICAgICAgaWYgKGdyb3VwLnNob3VsZFByb3h5KCkpIHtcbiAgICAgICAgICAgICAgICAvLyBjb2xsYXBzZXMgYWxsIGNvbm5lY3Rpb25zIGluIGEgZ3JvdXAuXG4gICAgICAgICAgICAgICAgdmFyIF9jb2xsYXBzZVNldCA9IGZ1bmN0aW9uIChjb25ucywgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb25ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGMgPSBjb25uc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jb2xsYXBzZUNvbm5lY3Rpb24oYywgaW5kZXgsIGdyb3VwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAvLyBzZXR1cCBwcm94aWVzIGZvciBzb3VyY2VzIGFuZCB0YXJnZXRzXG4gICAgICAgICAgICAgICAgX2NvbGxhcHNlU2V0KGdyb3VwLmNvbm5lY3Rpb25zLnNvdXJjZSwgMCk7XG4gICAgICAgICAgICAgICAgX2NvbGxhcHNlU2V0KGdyb3VwLmNvbm5lY3Rpb25zLnRhcmdldCwgMSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGdyb3VwLmNvbGxhcHNlZCA9IHRydWU7XG4gICAgICAgICAgICBfanNQbHVtYi5yZW1vdmVDbGFzcyhncm91cEVsLCBHUk9VUF9FWFBBTkRFRF9DTEFTUyk7XG4gICAgICAgICAgICBfanNQbHVtYi5hZGRDbGFzcyhncm91cEVsLCBHUk9VUF9DT0xMQVBTRURfQ0xBU1MpO1xuICAgICAgICAgICAgX2pzUGx1bWIucmV2YWxpZGF0ZShncm91cEVsKTtcbiAgICAgICAgICAgIF9qc1BsdW1iLmZpcmUoRVZUX0NPTExBUFNFLCB7IGdyb3VwOmdyb3VwICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgX2V4cGFuZENvbm5lY3Rpb24gPSB0aGlzLmV4cGFuZENvbm5lY3Rpb24gPSBmdW5jdGlvbihjLCBpbmRleCwgZ3JvdXApIHtcblxuICAgICAgICAgICAgLy8gaWYgbm8gcHJveGllcyBvciBub25lIGZvciB0aGlzIGVuZCBvZiB0aGUgY29ubmVjdGlvbiwgYWJvcnQuXG4gICAgICAgICAgICBpZiAoYy5wcm94aWVzID09IG51bGwgfHwgYy5wcm94aWVzW2luZGV4XSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZ3JvdXBFbElkID0gX2pzUGx1bWIuZ2V0SWQoZ3JvdXAuZ2V0RWwoKSksXG4gICAgICAgICAgICAgICAgb3JpZ2luYWxFbGVtZW50ID0gYy5wcm94aWVzW2luZGV4XS5vcmlnaW5hbEVwLmVsZW1lbnQsXG4gICAgICAgICAgICAgICAgb3JpZ2luYWxFbGVtZW50SWQgPSBjLnByb3hpZXNbaW5kZXhdLm9yaWdpbmFsRXAuZWxlbWVudElkO1xuXG4gICAgICAgICAgICBjLmVuZHBvaW50c1tpbmRleF0gPSBjLnByb3hpZXNbaW5kZXhdLm9yaWdpbmFsRXA7XG4gICAgICAgICAgICAvLyBhbmQgYWR2aXNlIHRoZSBhbmNob3IgbWFuYWdlclxuICAgICAgICAgICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETyB3aHkgYXJlIHRoZXJlIHR3byBkaWZmZXJlbnRseSBuYW1lZCBtZXRob2RzPyBXaHkgaXMgdGhlcmUgbm90IG9uZSBtZXRob2QgdGhhdCBzYXlzIFwic29tZSBlbmQgb2YgdGhpc1xuICAgICAgICAgICAgICAgIC8vIGNvbm5lY3Rpb24gY2hhbmdlZCAoeW91IGdpdmUgdGhlIGluZGV4KSwgYW5kIGhlcmUncyB0aGUgbmV3IGVsZW1lbnQgYW5kIGVsZW1lbnQgaWQuXCJcbiAgICAgICAgICAgICAgICBfanNQbHVtYi5hbmNob3JNYW5hZ2VyLnNvdXJjZUNoYW5nZWQoZ3JvdXBFbElkLCBvcmlnaW5hbEVsZW1lbnRJZCwgYywgb3JpZ2luYWxFbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIF9qc1BsdW1iLmFuY2hvck1hbmFnZXIudXBkYXRlT3RoZXJFbmRwb2ludChjLmVuZHBvaW50c1swXS5lbGVtZW50SWQsIGdyb3VwRWxJZCwgb3JpZ2luYWxFbGVtZW50SWQsIGMpO1xuICAgICAgICAgICAgICAgIGMudGFyZ2V0ID0gb3JpZ2luYWxFbGVtZW50O1xuICAgICAgICAgICAgICAgIGMudGFyZ2V0SWQgPSBvcmlnaW5hbEVsZW1lbnRJZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZGV0YWNoIHRoZSBwcm94eSBFUCBmcm9tIHRoZSBjb25uZWN0aW9uICh3aGljaCB3aWxsIGNhdXNlIGl0IHRvIGJlIHJlbW92ZWQgYXMgd2Ugbm8gbG9uZ2VyIG5lZWQgaXQpXG4gICAgICAgICAgICBjLnByb3hpZXNbaW5kZXhdLmVwLmRldGFjaEZyb21Db25uZWN0aW9uKGMsIG51bGwpO1xuXG4gICAgICAgICAgICBjLnByb3hpZXNbaW5kZXhdLm9yaWdpbmFsRXAuYWRkQ29ubmVjdGlvbihjKTtcblxuICAgICAgICAgICAgLy8gY2xlYW51cFxuICAgICAgICAgICAgZGVsZXRlIGMucHJveGllc1tpbmRleF07XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5leHBhbmRHcm91cCA9IGZ1bmN0aW9uKGdyb3VwLCBkb05vdEZpcmVFdmVudCkge1xuXG4gICAgICAgICAgICBncm91cCA9IHRoaXMuZ2V0R3JvdXAoZ3JvdXApO1xuXG4gICAgICAgICAgICBpZiAoZ3JvdXAgPT0gbnVsbCB8fCAhZ3JvdXAuY29sbGFwc2VkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGdyb3VwRWwgPSBncm91cC5nZXRFbCgpO1xuXG4gICAgICAgICAgICBfc2V0VmlzaWJsZShncm91cCwgdHJ1ZSk7XG5cbiAgICAgICAgICAgIGlmIChncm91cC5zaG91bGRQcm94eSgpKSB7XG4gICAgICAgICAgICAgICAgLy8gY29sbGFwc2VzIGFsbCBjb25uZWN0aW9ucyBpbiBhIGdyb3VwLlxuICAgICAgICAgICAgICAgIHZhciBfZXhwYW5kU2V0ID0gZnVuY3Rpb24gKGNvbm5zLCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbm5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYyA9IGNvbm5zW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2V4cGFuZENvbm5lY3Rpb24oYywgaW5kZXgsIGdyb3VwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAvLyBzZXR1cCBwcm94aWVzIGZvciBzb3VyY2VzIGFuZCB0YXJnZXRzXG4gICAgICAgICAgICAgICAgX2V4cGFuZFNldChncm91cC5jb25uZWN0aW9ucy5zb3VyY2UsIDApO1xuICAgICAgICAgICAgICAgIF9leHBhbmRTZXQoZ3JvdXAuY29ubmVjdGlvbnMudGFyZ2V0LCAxKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZ3JvdXAuY29sbGFwc2VkID0gZmFsc2U7XG4gICAgICAgICAgICBfanNQbHVtYi5hZGRDbGFzcyhncm91cEVsLCBHUk9VUF9FWFBBTkRFRF9DTEFTUyk7XG4gICAgICAgICAgICBfanNQbHVtYi5yZW1vdmVDbGFzcyhncm91cEVsLCBHUk9VUF9DT0xMQVBTRURfQ0xBU1MpO1xuICAgICAgICAgICAgX2pzUGx1bWIucmV2YWxpZGF0ZShncm91cEVsKTtcbiAgICAgICAgICAgIHRoaXMucmVwYWludEdyb3VwKGdyb3VwKTtcbiAgICAgICAgICAgIGlmICghZG9Ob3RGaXJlRXZlbnQpIHtcbiAgICAgICAgICAgICAgICBfanNQbHVtYi5maXJlKEVWVF9FWFBBTkQsIHsgZ3JvdXA6IGdyb3VwfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5yZXBhaW50R3JvdXAgPSBmdW5jdGlvbihncm91cCkge1xuICAgICAgICAgICAgZ3JvdXAgPSB0aGlzLmdldEdyb3VwKGdyb3VwKTtcbiAgICAgICAgICAgIHZhciBtID0gZ3JvdXAuZ2V0TWVtYmVycygpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgX2pzUGx1bWIucmV2YWxpZGF0ZShtW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBUT0RPIHJlZmFjdG9yIHRoaXMgd2l0aCB0aGUgY29kZSB0aGF0IHJlc3BvbmRzIHRvIGBjb25uZWN0aW9uYCBldmVudHMuXG4gICAgICAgIGZ1bmN0aW9uIF91cGRhdGVDb25uZWN0aW9uc0Zvckdyb3VwKGdyb3VwKSB7XG4gICAgICAgICAgICB2YXIgbWVtYmVycyA9IGdyb3VwLmdldE1lbWJlcnMoKTtcbiAgICAgICAgICAgIHZhciBjMSA9IF9qc1BsdW1iLmdldENvbm5lY3Rpb25zKHtzb3VyY2U6bWVtYmVyc30sIHRydWUpO1xuICAgICAgICAgICAgdmFyIGMyID0gX2pzUGx1bWIuZ2V0Q29ubmVjdGlvbnMoe3RhcmdldDptZW1iZXJzfSwgdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgcHJvY2Vzc2VkID0ge307XG4gICAgICAgICAgICBncm91cC5jb25uZWN0aW9ucy5zb3VyY2UubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIGdyb3VwLmNvbm5lY3Rpb25zLnRhcmdldC5sZW5ndGggPSAwO1xuICAgICAgICAgICAgdmFyIG9uZVNldCA9IGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb2Nlc3NlZFtjW2ldLmlkXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc2VkW2NbaV0uaWRdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNbaV0uc291cmNlLl9qc1BsdW1iR3JvdXAgPT09IGdyb3VwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY1tpXS50YXJnZXQuX2pzUGx1bWJHcm91cCAhPT0gZ3JvdXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBncm91cC5jb25uZWN0aW9ucy5zb3VyY2UucHVzaChjW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIF9jb25uZWN0aW9uU291cmNlTWFwW2NbaV0uaWRdID0gZ3JvdXA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY1tpXS50YXJnZXQuX2pzUGx1bWJHcm91cCA9PT0gZ3JvdXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwLmNvbm5lY3Rpb25zLnRhcmdldC5wdXNoKGNbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2Nvbm5lY3Rpb25UYXJnZXRNYXBbY1tpXS5pZF0gPSBncm91cDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBvbmVTZXQoYzEpOyBvbmVTZXQoYzIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy51cGRhdGVDb25uZWN0aW9uc0Zvckdyb3VwID0gX3VwZGF0ZUNvbm5lY3Rpb25zRm9yR3JvdXA7XG4gICAgICAgIHRoaXMucmVmcmVzaEFsbEdyb3VwcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZm9yICh2YXIgZyBpbiBfbWFuYWdlZEdyb3Vwcykge1xuICAgICAgICAgICAgICAgIF91cGRhdGVDb25uZWN0aW9uc0Zvckdyb3VwKF9tYW5hZ2VkR3JvdXBzW2ddKTtcbiAgICAgICAgICAgICAgICBfanNQbHVtYi5kcmFnTWFuYWdlci51cGRhdGVPZmZzZXRzKF9qc1BsdW1iLmdldElkKF9tYW5hZ2VkR3JvdXBzW2ddLmdldEVsKCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2pzUGx1bWJJbnN0YW5jZX0gX2pzUGx1bWIgQXNzb2NpYXRlZCBqc1BsdW1iIGluc3RhbmNlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXNcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IHBhcmFtcy5lbCBUaGUgRE9NIGVsZW1lbnQgcmVwcmVzZW50aW5nIHRoZSBHcm91cC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW3BhcmFtcy5pZF0gT3B0aW9uYWwgSUQgZm9yIHRoZSBHcm91cC4gQSBVVUlEIHdpbGwgYmUgYXNzaWduZWQgYXMgdGhlIEdyb3VwJ3MgSUQgaWYgeW91IGRvIG5vdCBwcm92aWRlIG9uZS5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtwYXJhbXMuY29uc3RyYWluPWZhbHNlXSBJZiB0cnVlLCBjaGlsZCBlbGVtZW50cyB3aWxsIG5vdCBiZSBhYmxlIHRvIGJlIGRyYWdnZWQgb3V0c2lkZSBvZiB0aGUgR3JvdXAgY29udGFpbmVyLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3BhcmFtcy5yZXZlcnQ9dHJ1ZV0gQnkgZGVmYXVsdCwgY2hpbGQgZWxlbWVudHMgcmV2ZXJ0IHRvIHRoZSBjb250YWluZXIgaWYgZHJhZ2dlZCBvdXRzaWRlLiBZb3UgY2FuIGNoYW5nZSB0aGlzIGJ5IHNldHRpbmcgYHJldmVydDpmYWxzZWAuIFRoaXMgYmVoYXZpb3VyIGlzIGFsc28gb3ZlcnJpZGRlbiBpZiB5b3Ugc2V0IGBvcnBoYW5gIG9yIGBwcnVuZWAuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbcGFyYW1zLm9ycGhhbj1mYWxzZV0gSWYgdHJ1ZSwgY2hpbGQgZWxlbWVudHMgZHJvcHBlZCBvdXRzaWRlIG9mIHRoZSBHcm91cCBjb250YWluZXIgd2lsbCBiZSByZW1vdmVkIGZyb20gdGhlIEdyb3VwIChidXQgbm90IGZyb20gdGhlIERPTSkuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbcGFyYW1zLnBydW5lPWZhbHNlXSBJZiB0cnVlLCBjaGlsZCBlbGVtZW50cyBkcm9wcGVkIG91dHNpZGUgb2YgdGhlIEdyb3VwIGNvbnRhaW5lciB3aWxsIGJlIHJlbW92ZWQgZnJvbSB0aGUgR3JvdXAgYW5kIGFsc28gZnJvbSB0aGUgRE9NLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3BhcmFtcy5kcm9wT3ZlcnJpZGU9ZmFsc2VdIElmIHRydWUsIGEgY2hpbGQgZWxlbWVudCB0aGF0IGhhcyBiZWVuIGRyb3BwZWQgb250byBzb21lIG90aGVyIEdyb3VwIHdpbGwgbm90IGJlIHN1YmplY3QgdG8gdGhlIGNvbnRyb2xzIGltcG9zZWQgYnkgYHBydW5lYCwgYHJldmVydGAgb3IgYG9ycGhhbmAuXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgdmFyIEdyb3VwID0gZnVuY3Rpb24oX2pzUGx1bWIsIHBhcmFtcykge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBlbCA9IHBhcmFtcy5lbDtcbiAgICAgICAgdGhpcy5nZXRFbCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gZWw7IH07XG4gICAgICAgIHRoaXMuaWQgPSBwYXJhbXMuaWQgfHwgX2p1LnV1aWQoKTtcbiAgICAgICAgZWwuX2lzSnNQbHVtYkdyb3VwID0gdHJ1ZTtcblxuICAgICAgICB2YXIgZ2V0RHJhZ0FyZWEgPSB0aGlzLmdldERyYWdBcmVhID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgZGEgPSBfanNQbHVtYi5nZXRTZWxlY3RvcihlbCwgR1JPVVBfQ09OVEFJTkVSX1NFTEVDVE9SKTtcbiAgICAgICAgICAgIHJldHVybiBkYSAmJiBkYS5sZW5ndGggPiAwID8gZGFbMF0gOiBlbDtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgZ2hvc3QgPSBwYXJhbXMuZ2hvc3QgPT09IHRydWU7XG4gICAgICAgIHZhciBjb25zdHJhaW4gPSBnaG9zdCB8fCAocGFyYW1zLmNvbnN0cmFpbiA9PT0gdHJ1ZSk7XG4gICAgICAgIHZhciByZXZlcnQgPSBwYXJhbXMucmV2ZXJ0ICE9PSBmYWxzZTtcbiAgICAgICAgdmFyIG9ycGhhbiA9IHBhcmFtcy5vcnBoYW4gPT09IHRydWU7XG4gICAgICAgIHZhciBwcnVuZSA9IHBhcmFtcy5wcnVuZSA9PT0gdHJ1ZTtcbiAgICAgICAgdmFyIGRyb3BPdmVycmlkZSA9IHBhcmFtcy5kcm9wT3ZlcnJpZGUgPT09IHRydWU7XG4gICAgICAgIHZhciBwcm94aWVkID0gcGFyYW1zLnByb3hpZWQgIT09IGZhbHNlO1xuICAgICAgICB2YXIgZWxlbWVudHMgPSBbXTtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9ucyA9IHsgc291cmNlOltdLCB0YXJnZXQ6W10sIGludGVybmFsOltdIH07XG5cbiAgICAgICAgLy8gdGhpcyBmdW5jdGlvbiwgYW5kIGdldEVuZHBvaW50IGJlbG93LCBhcmUgc3R1YnMgZm9yIGEgZnV0dXJlIHNldHVwIGluIHdoaWNoIHdlIGNhbiBjaG9vc2UgZW5kcG9pbnRcbiAgICAgICAgLy8gYW5kIGFuY2hvciBiYXNlZCB1cG9uIHRoZSBjb25uZWN0aW9uIGFuZCB0aGUgaW5kZXggKHNvdXJjZS90YXJnZXQpIG9mIHRoZSBlbmRwb2ludCB0byBiZSBwcm94aWVkLlxuICAgICAgICB0aGlzLmdldEFuY2hvciA9IGZ1bmN0aW9uKGNvbm4sIGVuZHBvaW50SW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJhbXMuYW5jaG9yIHx8IFwiQ29udGludW91c1wiO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuZ2V0RW5kcG9pbnQgPSBmdW5jdGlvbihjb25uLCBlbmRwb2ludEluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyYW1zLmVuZHBvaW50IHx8IFsgXCJEb3RcIiwgeyByYWRpdXM6MTAgfV07XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5jb2xsYXBzZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHBhcmFtcy5kcmFnZ2FibGUgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICB2YXIgb3B0cyA9IHtcbiAgICAgICAgICAgICAgICBzdG9wOmZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgICAgICAgICAgICAgICBfanNQbHVtYi5maXJlKEVWVF9HUk9VUF9EUkFHX1NUT1AsIGpzUGx1bWIuZXh0ZW5kKHBhcmFtcywge2dyb3VwOnNlbGZ9KSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzY29wZTpHUk9VUF9EUkFHX1NDT1BFXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHBhcmFtcy5kcmFnT3B0aW9ucykge1xuICAgICAgICAgICAgICAgIHJvb3QuanNQbHVtYi5leHRlbmQob3B0cywgcGFyYW1zLmRyYWdPcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9qc1BsdW1iLmRyYWdnYWJsZShwYXJhbXMuZWwsIG9wdHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJhbXMuZHJvcHBhYmxlICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgX2pzUGx1bWIuZHJvcHBhYmxlKHBhcmFtcy5lbCwge1xuICAgICAgICAgICAgICAgIGRyb3A6ZnVuY3Rpb24ocCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZWwgPSBwLmRyYWcuZWw7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbC5faXNKc1BsdW1iR3JvdXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgY3VycmVudEdyb3VwID0gZWwuX2pzUGx1bWJHcm91cDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRHcm91cCAhPT0gc2VsZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRHcm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRHcm91cC5vdmVycmlkZURyb3AoZWwsIHNlbGYpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBfanNQbHVtYi5nZXRHcm91cE1hbmFnZXIoKS5hZGRUb0dyb3VwKHNlbGYsIGVsLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBfZWFjaCA9IGZ1bmN0aW9uKF9lbCwgZm4pIHtcbiAgICAgICAgICAgIHZhciBlbHMgPSBfZWwubm9kZVR5cGUgPT0gbnVsbCA/ICBfZWwgOiBbIF9lbCBdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBmbihlbHNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMub3ZlcnJpZGVEcm9wID0gZnVuY3Rpb24oX2VsLCB0YXJnZXRHcm91cCkge1xuICAgICAgICAgICAgcmV0dXJuIGRyb3BPdmVycmlkZSAmJiAocmV2ZXJ0IHx8IHBydW5lIHx8IG9ycGhhbik7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5hZGQgPSBmdW5jdGlvbihfZWwsIGRvTm90RmlyZUV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgZHJhZ0FyZWEgPSBnZXREcmFnQXJlYSgpO1xuICAgICAgICAgICAgX2VhY2goX2VsLCBmdW5jdGlvbihfX2VsKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoX19lbC5fanNQbHVtYkdyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9fZWwuX2pzUGx1bWJHcm91cCA9PT0gc2VsZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgX19lbC5fanNQbHVtYkdyb3VwLnJlbW92ZShfX2VsLCB0cnVlLCBkb05vdEZpcmVFdmVudCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgX19lbC5fanNQbHVtYkdyb3VwID0gc2VsZjtcbiAgICAgICAgICAgICAgICBlbGVtZW50cy5wdXNoKF9fZWwpO1xuICAgICAgICAgICAgICAgIC8vIHRlc3QgaWYgZHJhZ2dhYmxlIGFuZCBhZGQgaGFuZGxlcnMgaWYgc28uXG4gICAgICAgICAgICAgICAgaWYgKF9qc1BsdW1iLmlzQWxyZWFkeURyYWdnYWJsZShfX2VsKSkge1xuICAgICAgICAgICAgICAgICAgICBfYmluZERyYWdIYW5kbGVycyhfX2VsKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoX19lbC5wYXJlbnROb2RlICE9PSBkcmFnQXJlYSkge1xuICAgICAgICAgICAgICAgICAgICBkcmFnQXJlYS5hcHBlbmRDaGlsZChfX2VsKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIWRvTm90RmlyZUV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIF9qc1BsdW1iLmZpcmUoRVZUX0NISUxEX0FEREVELCB7Z3JvdXA6IHNlbGYsIGVsOiBfX2VsfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIF9qc1BsdW1iLmdldEdyb3VwTWFuYWdlcigpLnVwZGF0ZUNvbm5lY3Rpb25zRm9yR3JvdXAoc2VsZik7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5yZW1vdmUgPSBmdW5jdGlvbihlbCwgbWFuaXB1bGF0ZURPTSwgZG9Ob3RGaXJlRXZlbnQsIGRvTm90VXBkYXRlQ29ubmVjdGlvbnMpIHtcblxuICAgICAgICAgICAgX2VhY2goZWwsIGZ1bmN0aW9uKF9fZWwpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgX19lbC5fanNQbHVtYkdyb3VwO1xuICAgICAgICAgICAgICAgIF9qdS5yZW1vdmVXaXRoRnVuY3Rpb24oZWxlbWVudHMsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUgPT09IF9fZWw7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBpZiAobWFuaXB1bGF0ZURPTSkge1xuICAgICAgICAgICAgICAgICAgICB0cnkgeyBzZWxmLmdldERyYWdBcmVhKCkucmVtb3ZlQ2hpbGQoX19lbCk7IH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGpzUGx1bWJVdGlsLmxvZyhcIkNvdWxkIG5vdCByZW1vdmUgZWxlbWVudCBmcm9tIEdyb3VwIFwiICsgZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3VuYmluZERyYWdIYW5kbGVycyhfX2VsKTtcbiAgICAgICAgICAgICAgICBpZiAoIWRvTm90RmlyZUV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIF9qc1BsdW1iLmZpcmUoRVZUX0NISUxEX1JFTU9WRUQsIHtncm91cDogc2VsZiwgZWw6IF9fZWx9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICghZG9Ob3RVcGRhdGVDb25uZWN0aW9ucykge1xuICAgICAgICAgICAgICAgIF9qc1BsdW1iLmdldEdyb3VwTWFuYWdlcigpLnVwZGF0ZUNvbm5lY3Rpb25zRm9yR3JvdXAoc2VsZik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucmVtb3ZlQWxsID0gZnVuY3Rpb24obWFuaXB1bGF0ZURPTSwgZG9Ob3RGaXJlRXZlbnQpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gZWxlbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5yZW1vdmUoZWxlbWVudHNbMF0sIG1hbmlwdWxhdGVET00sIGRvTm90RmlyZUV2ZW50LCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsZW1lbnRzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICBfanNQbHVtYi5nZXRHcm91cE1hbmFnZXIoKS51cGRhdGVDb25uZWN0aW9uc0Zvckdyb3VwKHNlbGYpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9ycGhhbkFsbCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIF9vcnBoYW4oZWxlbWVudHNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxlbWVudHMubGVuZ3RoID0gMDtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5nZXRNZW1iZXJzID0gZnVuY3Rpb24oKSB7IHJldHVybiBlbGVtZW50czsgfTtcblxuICAgICAgICBlbFtHUk9VUF0gPSB0aGlzO1xuXG4gICAgICAgIF9qc1BsdW1iLmJpbmQoRUxFTUVOVF9EUkFHR0FCTEVfRVZFTlQsIGZ1bmN0aW9uKGRyYWdQYXJhbXMpIHtcbiAgICAgICAgICAgIC8vIGlmIGl0cyBmb3IgdGhlIGN1cnJlbnQgZ3JvdXAsXG4gICAgICAgICAgICBpZiAoZHJhZ1BhcmFtcy5lbC5fanNQbHVtYkdyb3VwID09PSB0aGlzKSB7XG4gICAgICAgICAgICAgICAgX2JpbmREcmFnSGFuZGxlcnMoZHJhZ1BhcmFtcy5lbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICAgICAgZnVuY3Rpb24gX2ZpbmRQYXJlbnQoX2VsKSB7XG4gICAgICAgICAgICByZXR1cm4gX2VsLm9mZnNldFBhcmVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIF9pc0luc2lkZVBhcmVudChfZWwsIHBvcykge1xuICAgICAgICAgICAgdmFyIHAgPSBfZmluZFBhcmVudChfZWwpLFxuICAgICAgICAgICAgICAgIHMgPSBfanNQbHVtYi5nZXRTaXplKHApLFxuICAgICAgICAgICAgICAgIHNzID0gX2pzUGx1bWIuZ2V0U2l6ZShfZWwpLFxuICAgICAgICAgICAgICAgIGxlZnRFZGdlID0gcG9zWzBdLFxuICAgICAgICAgICAgICAgIHJpZ2h0RWRnZSA9IGxlZnRFZGdlICsgc3NbMF0sXG4gICAgICAgICAgICAgICAgdG9wRWRnZSA9IHBvc1sxXSxcbiAgICAgICAgICAgICAgICBib3R0b21FZGdlID0gdG9wRWRnZSArIHNzWzFdO1xuXG4gICAgICAgICAgICByZXR1cm4gcmlnaHRFZGdlID4gMCAmJiBsZWZ0RWRnZSA8IHNbMF0gJiYgYm90dG9tRWRnZSA+IDAgJiYgdG9wRWRnZSA8IHNbMV07XG4gICAgICAgIH1cblxuICAgICAgICAvL1xuICAgICAgICAvLyBvcnBoYW5pbmcgYW4gZWxlbWVudCBtZWFucyB0YWtpbmcgaXQgb3V0IG9mIHRoZSBncm91cCBhbmQgYWRkaW5nIGl0IHRvIHRoZSBtYWluIGpzcGx1bWIgY29udGFpbmVyLlxuICAgICAgICAvL1xuICAgICAgICBmdW5jdGlvbiBfb3JwaGFuKF9lbCkge1xuICAgICAgICAgICAgdmFyIGlkID0gX2pzUGx1bWIuZ2V0SWQoX2VsKTtcbiAgICAgICAgICAgIHZhciBwb3MgPSBfanNQbHVtYi5nZXRPZmZzZXQoX2VsKTtcbiAgICAgICAgICAgIF9lbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKF9lbCk7XG4gICAgICAgICAgICBfanNQbHVtYi5nZXRDb250YWluZXIoKS5hcHBlbmRDaGlsZChfZWwpO1xuICAgICAgICAgICAgX2pzUGx1bWIuc2V0UG9zaXRpb24oX2VsLCBwb3MpO1xuICAgICAgICAgICAgZGVsZXRlIF9lbC5fanNQbHVtYkdyb3VwO1xuICAgICAgICAgICAgX3VuYmluZERyYWdIYW5kbGVycyhfZWwpO1xuICAgICAgICAgICAgX2pzUGx1bWIuZHJhZ01hbmFnZXIuY2xlYXJQYXJlbnQoX2VsLCBpZCk7XG4gICAgICAgIH1cblxuICAgICAgICAvL1xuICAgICAgICAvLyByZW1vdmUgYW4gZWxlbWVudCBmcm9tIHRoZSBncm91cCwgdGhlbiBlaXRoZXIgcHJ1bmUgaXQgZnJvbSB0aGUganNwbHVtYiBpbnN0YW5jZSwgb3IganVzdCBvcnBoYW4gaXQuXG4gICAgICAgIC8vXG4gICAgICAgIGZ1bmN0aW9uIF9wcnVuZU9yT3JwaGFuKHApIHtcbiAgICAgICAgICAgIGlmICghX2lzSW5zaWRlUGFyZW50KHAuZWwsIHAucG9zKSkge1xuICAgICAgICAgICAgICAgIHZhciBncm91cCA9IHAuZWwuX2pzUGx1bWJHcm91cDtcbiAgICAgICAgICAgICAgICBpZiAocHJ1bmUpIHtcbiAgICAgICAgICAgICAgICAgICAgX2pzUGx1bWIucmVtb3ZlKHAuZWwpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIF9vcnBoYW4ocC5lbCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZ3JvdXAucmVtb3ZlKHAuZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gcmVkcmF3cyB0aGUgZWxlbWVudFxuICAgICAgICAvL1xuICAgICAgICBmdW5jdGlvbiBfcmV2YWxpZGF0ZShfZWwpIHtcbiAgICAgICAgICAgIHZhciBpZCA9IF9qc1BsdW1iLmdldElkKF9lbCk7XG4gICAgICAgICAgICBfanNQbHVtYi5yZXZhbGlkYXRlKF9lbCk7XG4gICAgICAgICAgICBfanNQbHVtYi5kcmFnTWFuYWdlci5yZXZhbGlkYXRlUGFyZW50KF9lbCwgaWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gdW5iaW5kIHRoZSBncm91cCBzcGVjaWZpYyBkcmFnL3JldmVydCBoYW5kbGVycy5cbiAgICAgICAgLy9cbiAgICAgICAgZnVuY3Rpb24gX3VuYmluZERyYWdIYW5kbGVycyhfZWwpIHtcbiAgICAgICAgICAgIGlmICghX2VsLl9rYXRhdm9yaW9EcmFnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBydW5lIHx8IG9ycGhhbikge1xuICAgICAgICAgICAgICAgIF9lbC5fa2F0YXZvcmlvRHJhZy5vZmYoU1RPUCwgX3BydW5lT3JPcnBoYW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFwcnVuZSAmJiAhb3JwaGFuICYmIHJldmVydCkge1xuICAgICAgICAgICAgICAgIF9lbC5fa2F0YXZvcmlvRHJhZy5vZmYoUkVWRVJULCBfcmV2YWxpZGF0ZSk7XG4gICAgICAgICAgICAgICAgX2VsLl9rYXRhdm9yaW9EcmFnLnNldFJldmVydChudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIF9iaW5kRHJhZ0hhbmRsZXJzKF9lbCkge1xuICAgICAgICAgICAgaWYgKCFfZWwuX2thdGF2b3Jpb0RyYWcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJ1bmUgfHwgb3JwaGFuKSB7XG4gICAgICAgICAgICAgICAgX2VsLl9rYXRhdm9yaW9EcmFnLm9uKFNUT1AsIF9wcnVuZU9yT3JwaGFuKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNvbnN0cmFpbikge1xuICAgICAgICAgICAgICAgIF9lbC5fa2F0YXZvcmlvRHJhZy5zZXRDb25zdHJhaW4odHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChnaG9zdCkge1xuICAgICAgICAgICAgICAgIF9lbC5fa2F0YXZvcmlvRHJhZy5zZXRVc2VHaG9zdFByb3h5KHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXBydW5lICYmICFvcnBoYW4gJiYgcmV2ZXJ0KSB7XG4gICAgICAgICAgICAgICAgX2VsLl9rYXRhdm9yaW9EcmFnLm9uKFJFVkVSVCwgX3JldmFsaWRhdGUpO1xuICAgICAgICAgICAgICAgIF9lbC5fa2F0YXZvcmlvRHJhZy5zZXRSZXZlcnQoZnVuY3Rpb24oX19lbCwgcG9zKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhX2lzSW5zaWRlUGFyZW50KF9fZWwsIHBvcyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNob3VsZFByb3h5ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJveGllZDtcbiAgICAgICAgfTtcblxuICAgICAgICBfanNQbHVtYi5nZXRHcm91cE1hbmFnZXIoKS5hZGRHcm91cCh0aGlzKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIGdyb3VwIHRvIHRoZSBqc1BsdW1iIGluc3RhbmNlLlxuICAgICAqIEBtZXRob2QgYWRkR3JvdXBcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zXG4gICAgICogQHJldHVybiB7R3JvdXB9IFRoZSBuZXdseSBjcmVhdGVkIEdyb3VwLlxuICAgICAqL1xuICAgIF9qcGkucHJvdG90eXBlLmFkZEdyb3VwID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgIHZhciBqID0gdGhpcztcbiAgICAgICAgai5fZ3JvdXBzID0gai5fZ3JvdXBzIHx8IHt9O1xuICAgICAgICBpZiAoai5fZ3JvdXBzW3BhcmFtcy5pZF0gIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImNhbm5vdCBjcmVhdGUgR3JvdXAgW1wiICsgcGFyYW1zLmlkICsgXCJdOyBhIEdyb3VwIHdpdGggdGhhdCBJRCBleGlzdHNcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcmFtcy5lbFtHUk9VUF0gIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImNhbm5vdCBjcmVhdGUgR3JvdXAgW1wiICsgcGFyYW1zLmlkICsgXCJdOyB0aGUgZ2l2ZW4gZWxlbWVudCBpcyBhbHJlYWR5IGEgR3JvdXBcIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGdyb3VwID0gbmV3IEdyb3VwKGosIHBhcmFtcyk7XG4gICAgICAgIGouX2dyb3Vwc1tncm91cC5pZF0gPSBncm91cDtcbiAgICAgICAgaWYgKHBhcmFtcy5jb2xsYXBzZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY29sbGFwc2VHcm91cChncm91cCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdyb3VwO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBZGQgYW4gZWxlbWVudCB0byBhIGdyb3VwLlxuICAgICAqIEBtZXRob2QgYWRkVG9Hcm91cFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBncm91cCBHcm91cCwgb3IgSUQgb2YgdGhlIGdyb3VwLCB0byBhZGQgdGhlIGVsZW1lbnQgdG8uXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBlbCBFbGVtZW50IHRvIGFkZCB0byB0aGUgZ3JvdXAuXG4gICAgICovXG4gICAgX2pwaS5wcm90b3R5cGUuYWRkVG9Hcm91cCA9IGZ1bmN0aW9uKGdyb3VwLCBlbCwgZG9Ob3RGaXJlRXZlbnQpIHtcblxuICAgICAgICB2YXIgX29uZSA9IGZ1bmN0aW9uKF9lbCkge1xuICAgICAgICAgICAgdmFyIGlkID0gdGhpcy5nZXRJZChfZWwpO1xuICAgICAgICAgICAgdGhpcy5tYW5hZ2UoaWQsIF9lbCk7XG4gICAgICAgICAgICB0aGlzLmdldEdyb3VwTWFuYWdlcigpLmFkZFRvR3JvdXAoZ3JvdXAsIF9lbCwgZG9Ob3RGaXJlRXZlbnQpO1xuICAgICAgICB9LmJpbmQodGhpcyk7XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZWwpKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgX29uZShlbFtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfb25lKGVsKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYW4gZWxlbWVudCBmcm9tIGEgZ3JvdXAuXG4gICAgICogQG1ldGhvZCByZW1vdmVGcm9tR3JvdXBcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZ3JvdXAgR3JvdXAsIG9yIElEIG9mIHRoZSBncm91cCwgdG8gcmVtb3ZlIHRoZSBlbGVtZW50IGZyb20uXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBlbCBFbGVtZW50IHRvIGFkZCB0byB0aGUgZ3JvdXAuXG4gICAgICovXG4gICAgX2pwaS5wcm90b3R5cGUucmVtb3ZlRnJvbUdyb3VwID0gZnVuY3Rpb24oZ3JvdXAsIGVsLCBkb05vdEZpcmVFdmVudCkge1xuICAgICAgICB0aGlzLmdldEdyb3VwTWFuYWdlcigpLnJlbW92ZUZyb21Hcm91cChncm91cCwgZWwsIGRvTm90RmlyZUV2ZW50KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGEgZ3JvdXAsIGFuZCBvcHRpb25hbGx5IHJlbW92ZSBpdHMgbWVtYmVycyBmcm9tIHRoZSBqc1BsdW1iIGluc3RhbmNlLlxuICAgICAqIEBtZXRob2QgcmVtb3ZlR3JvdXBcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xHcm91cH0gZ3JvdXAgR3JvdXAgdG8gZGVsZXRlLCBvciBJRCBvZiBHcm91cCB0byBkZWxldGUuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbZGVsZXRlTWVtYmVycz1mYWxzZV0gSWYgdHJ1ZSwgZ3JvdXAgbWVtYmVycyB3aWxsIGJlIHJlbW92ZWQgYWxvbmcgd2l0aCB0aGUgZ3JvdXAuIE90aGVyd2lzZSB0aGV5IHdpbGxcbiAgICAgKiBqdXN0IGJlICdvcnBoYW5lZCcgKHJldHVybmVkIHRvIHRoZSBtYWluIGNvbnRhaW5lcikuXG4gICAgICovXG4gICAgX2pwaS5wcm90b3R5cGUucmVtb3ZlR3JvdXAgPSBmdW5jdGlvbihncm91cCwgZGVsZXRlTWVtYmVycywgbWFuaXB1bGF0ZURPTSwgZG9Ob3RGaXJlRXZlbnQpIHtcbiAgICAgICAgdGhpcy5nZXRHcm91cE1hbmFnZXIoKS5yZW1vdmVHcm91cChncm91cCwgZGVsZXRlTWVtYmVycywgbWFuaXB1bGF0ZURPTSwgZG9Ob3RGaXJlRXZlbnQpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYWxsIGdyb3VwcywgYW5kIG9wdGlvbmFsbHkgcmVtb3ZlIHRoZWlyIG1lbWJlcnMgZnJvbSB0aGUganNQbHVtYiBpbnN0YW5jZS5cbiAgICAgKiBAbWV0aG9kIHJlbW92ZUFsbEdyb3VwXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbZGVsZXRlTWVtYmVycz1mYWxzZV0gSWYgdHJ1ZSwgZ3JvdXAgbWVtYmVycyB3aWxsIGJlIHJlbW92ZWQgYWxvbmcgd2l0aCB0aGUgZ3JvdXBzLiBPdGhlcndpc2UgdGhleSB3aWxsXG4gICAgICoganVzdCBiZSAnb3JwaGFuZWQnIChyZXR1cm5lZCB0byB0aGUgbWFpbiBjb250YWluZXIpLlxuICAgICAqL1xuICAgIF9qcGkucHJvdG90eXBlLnJlbW92ZUFsbEdyb3VwcyA9IGZ1bmN0aW9uKGRlbGV0ZU1lbWJlcnMsIG1hbmlwdWxhdGVET00sIGRvTm90RmlyZUV2ZW50KSB7XG4gICAgICAgIHRoaXMuZ2V0R3JvdXBNYW5hZ2VyKCkucmVtb3ZlQWxsR3JvdXBzKGRlbGV0ZU1lbWJlcnMsIG1hbmlwdWxhdGVET00sIGRvTm90RmlyZUV2ZW50KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IGEgR3JvdXBcbiAgICAgKiBAbWV0aG9kIGdldEdyb3VwXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGdyb3VwSWQgSUQgb2YgdGhlIGdyb3VwIHRvIGdldFxuICAgICAqIEByZXR1cm4ge0dyb3VwfSBHcm91cCB3aXRoIHRoZSBnaXZlbiBJRCwgbnVsbCBpZiBub3QgZm91bmQuXG4gICAgICovXG4gICAgX2pwaS5wcm90b3R5cGUuZ2V0R3JvdXAgPSBmdW5jdGlvbihncm91cElkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEdyb3VwTWFuYWdlcigpLmdldEdyb3VwKGdyb3VwSWQpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGFsbCB0aGUgR3JvdXBzIG1hbmFnZWQgYnkgdGhlIGpzUGx1bWIgaW5zdGFuY2UuXG4gICAgICogQHJldHVybnMge0dyb3VwW119IExpc3Qgb2YgR3JvdXBzLiBFbXB0eSBpZiBub25lLlxuICAgICAqL1xuICAgIF9qcGkucHJvdG90eXBlLmdldEdyb3VwcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRHcm91cE1hbmFnZXIoKS5nZXRHcm91cHMoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRXhwYW5kcyBhIGdyb3VwIGVsZW1lbnQuIGpzUGx1bWIgZG9lc24ndCBkbyBcImV2ZXJ5dGhpbmdcIiBmb3IgeW91IGhlcmUsIGJlY2F1c2Ugd2hhdCBpdCBtZWFucyB0byBleHBhbmQgYSBHcm91cFxuICAgICAqIHdpbGwgdmFyeSBmcm9tIGFwcGxpY2F0aW9uIHRvIGFwcGxpY2F0aW9uLiBqc1BsdW1iIGRvZXMgdGhlc2UgdGhpbmdzOlxuICAgICAqXG4gICAgICogLSBIaWRlcyBhbnkgY29ubmVjdGlvbnMgdGhhdCBhcmUgaW50ZXJuYWwgdG8gdGhlIGdyb3VwIChjb25uZWN0aW9ucyBiZXR3ZWVuIG1lbWJlcnMsIGFuZCBjb25uZWN0aW9ucyBmcm9tIG1lbWJlciBvZlxuICAgICAqIHRoZSBncm91cCB0byB0aGUgZ3JvdXAgaXRzZWxmKVxuICAgICAqIC0gUHJveGllcyBhbGwgY29ubmVjdGlvbnMgZm9yIHdoaWNoIHRoZSBzb3VyY2Ugb3IgdGFyZ2V0IGlzIGEgbWVtYmVyIG9mIHRoZSBncm91cC5cbiAgICAgKiAtIEhpZGVzIHRoZSBwcm94aWVkIGNvbm5lY3Rpb25zLlxuICAgICAqIC0gQWRkcyB0aGUganRrLWdyb3VwLWV4cGFuZGVkIGNsYXNzIHRvIHRoZSBncm91cCdzIGVsZW1lbnRcbiAgICAgKiAtIFJlbW92ZXMgdGhlIGp0ay1ncm91cC1jb2xsYXBzZWQgY2xhc3MgZnJvbSB0aGUgZ3JvdXAncyBlbGVtZW50LlxuICAgICAqXG4gICAgICogQG1ldGhvZCBleHBhbmRHcm91cFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfEdyb3VwfSBncm91cCBHcm91cCB0byBleHBhbmQsIG9yIElEIG9mIEdyb3VwIHRvIGV4cGFuZC5cbiAgICAgKi9cbiAgICBfanBpLnByb3RvdHlwZS5leHBhbmRHcm91cCA9IGZ1bmN0aW9uKGdyb3VwKSB7XG4gICAgICAgIHRoaXMuZ2V0R3JvdXBNYW5hZ2VyKCkuZXhwYW5kR3JvdXAoZ3JvdXApO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDb2xsYXBzZXMgYSBncm91cCBlbGVtZW50LiBqc1BsdW1iIGRvZXNuJ3QgZG8gXCJldmVyeXRoaW5nXCIgZm9yIHlvdSBoZXJlLCBiZWNhdXNlIHdoYXQgaXQgbWVhbnMgdG8gY29sbGFwc2UgYSBHcm91cFxuICAgICAqIHdpbGwgdmFyeSBmcm9tIGFwcGxpY2F0aW9uIHRvIGFwcGxpY2F0aW9uLiBqc1BsdW1iIGRvZXMgdGhlc2UgdGhpbmdzOlxuICAgICAqXG4gICAgICogLSBTaG93cyBhbnkgY29ubmVjdGlvbnMgdGhhdCBhcmUgaW50ZXJuYWwgdG8gdGhlIGdyb3VwIChjb25uZWN0aW9ucyBiZXR3ZWVuIG1lbWJlcnMsIGFuZCBjb25uZWN0aW9ucyBmcm9tIG1lbWJlciBvZlxuICAgICAqIHRoZSBncm91cCB0byB0aGUgZ3JvdXAgaXRzZWxmKVxuICAgICAqIC0gUmVtb3ZlcyBwcm94aWVzIGZvciBhbGwgY29ubmVjdGlvbnMgZm9yIHdoaWNoIHRoZSBzb3VyY2Ugb3IgdGFyZ2V0IGlzIGEgbWVtYmVyIG9mIHRoZSBncm91cC5cbiAgICAgKiAtIFNob3dzIHRoZSBwcmV2aW91c2x5IHByb3hpZWQgY29ubmVjdGlvbnMuXG4gICAgICogLSBBZGRzIHRoZSBqdGstZ3JvdXAtY29sbGFwc2VkIGNsYXNzIHRvIHRoZSBncm91cCdzIGVsZW1lbnRcbiAgICAgKiAtIFJlbW92ZXMgdGhlIGp0ay1ncm91cC1leHBhbmRlZCBjbGFzcyBmcm9tIHRoZSBncm91cCdzIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGV4cGFuZEdyb3VwXG4gICAgICogQHBhcmFtIHtTdHJpbmd8R3JvdXB9IGdyb3VwIEdyb3VwIHRvIGV4cGFuZCwgb3IgSUQgb2YgR3JvdXAgdG8gZXhwYW5kLlxuICAgICAqL1xuICAgIF9qcGkucHJvdG90eXBlLmNvbGxhcHNlR3JvdXAgPSBmdW5jdGlvbihncm91cElkKSB7XG4gICAgICAgIHRoaXMuZ2V0R3JvdXBNYW5hZ2VyKCkuY29sbGFwc2VHcm91cChncm91cElkKTtcbiAgICB9O1xuXG5cbiAgICBfanBpLnByb3RvdHlwZS5yZXBhaW50R3JvdXAgPSBmdW5jdGlvbihncm91cCkge1xuICAgICAgICB0aGlzLmdldEdyb3VwTWFuYWdlcigpLnJlcGFpbnRHcm91cChncm91cCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENvbGxhcHNlcyBvciBleHBhbmRzIGEgZ3JvdXAgZWxlbWVudCBkZXBlbmRpbmcgb24gaXRzIGN1cnJlbnQgc3RhdGUuIFNlZSBub3RlcyBpbiB0aGUgY29sbGFwc2VHcm91cCBhbmQgZXhwYW5kR3JvdXAgbWV0aG9kLlxuICAgICAqXG4gICAgICogQG1ldGhvZCB0b2dnbGVHcm91cFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfEdyb3VwfSBncm91cCBHcm91cCB0byBleHBhbmQvY29sbGFwc2UsIG9yIElEIG9mIEdyb3VwIHRvIGV4cGFuZC9jb2xsYXBzZS5cbiAgICAgKi9cbiAgICBfanBpLnByb3RvdHlwZS50b2dnbGVHcm91cCA9IGZ1bmN0aW9uKGdyb3VwKSB7XG4gICAgICAgIGdyb3VwID0gdGhpcy5nZXRHcm91cE1hbmFnZXIoKS5nZXRHcm91cChncm91cCk7XG4gICAgICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmdldEdyb3VwTWFuYWdlcigpW2dyb3VwLmNvbGxhcHNlZCA/IFwiZXhwYW5kR3JvdXBcIiA6IFwiY29sbGFwc2VHcm91cFwiXShncm91cCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy9cbiAgICAvLyBsYXp5IGluaXQgYSBncm91cCBtYW5hZ2VyIGZvciB0aGUgZ2l2ZW4ganNwbHVtYiBpbnN0YW5jZS5cbiAgICAvL1xuICAgIF9qcGkucHJvdG90eXBlLmdldEdyb3VwTWFuYWdlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbWdyID0gdGhpc1tHUk9VUF9NQU5BR0VSXTtcbiAgICAgICAgaWYgKG1nciA9PSBudWxsKSB7XG4gICAgICAgICAgICBtZ3IgPSB0aGlzW0dST1VQX01BTkFHRVJdID0gbmV3IEdyb3VwTWFuYWdlcih0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWdyO1xuICAgIH07XG5cbiAgICBfanBpLnByb3RvdHlwZS5yZW1vdmVHcm91cE1hbmFnZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZGVsZXRlIHRoaXNbR1JPVVBfTUFOQUdFUl07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIEdyb3VwIHRoYXQgdGhlIGdpdmVuIGVsZW1lbnQgYmVsb25ncyB0bywgbnVsbCBpZiBub25lLlxuICAgICAqIEBtZXRob2QgZ2V0R3JvdXBGb3JcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xFbGVtZW50fSBlbCBFbGVtZW50LCBvciBlbGVtZW50IElELlxuICAgICAqIEByZXR1cm5zIHtHcm91cH0gQSBHcm91cCwgaWYgZm91bmQsIG9yIG51bGwuXG4gICAgICovXG4gICAgX2pwaS5wcm90b3R5cGUuZ2V0R3JvdXBGb3IgPSBmdW5jdGlvbihlbCkge1xuICAgICAgICBlbCA9IHRoaXMuZ2V0RWxlbWVudChlbCk7XG4gICAgICAgIGlmIChlbCkge1xuICAgICAgICAgICAgcmV0dXJuIGVsW0dST1VQXTtcbiAgICAgICAgfVxuICAgIH07XG5cbn0pLmNhbGwodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB0aGlzKTtcblxuXG4vKlxuICoganNQbHVtYiBDb21tdW5pdHkgRWRpdGlvblxuICogXG4gKiBQcm92aWRlcyBhIHdheSB0byB2aXN1YWxseSBjb25uZWN0IGVsZW1lbnRzIG9uIGFuIEhUTUwgcGFnZSwgdXNpbmcgU1ZHLlxuICogXG4gKiBUaGlzIGZpbGUgY29udGFpbnMgdGhlICdmbG93Y2hhcnQnIGNvbm5lY3RvcnMsIGNvbnNpc3Rpbmcgb2YgdmVydGljYWwgYW5kIGhvcml6b250YWwgbGluZSBzZWdtZW50cy5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTAgLSAyMDE3IGpzUGx1bWIgKGhlbGxvQGpzcGx1bWJ0b29sa2l0LmNvbSlcbiAqIFxuICogaHR0cHM6Ly9qc3BsdW1idG9vbGtpdC5jb21cbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9qc3BsdW1iL2pzcGx1bWJcbiAqIFxuICogRHVhbCBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGFuZCBHUEwyIGxpY2Vuc2VzLlxuICovXG47XG4oZnVuY3Rpb24gKCkge1xuXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIHJvb3QgPSB0aGlzLCBfanAgPSByb290LmpzUGx1bWIsIF9qdSA9IHJvb3QuanNQbHVtYlV0aWw7XG5cbiAgICB2YXIgRmxvd2NoYXJ0ID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICB0aGlzLnR5cGUgPSBcIkZsb3djaGFydFwiO1xuICAgICAgICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG4gICAgICAgIHBhcmFtcy5zdHViID0gcGFyYW1zLnN0dWIgPT0gbnVsbCA/IDMwIDogcGFyYW1zLnN0dWI7XG4gICAgICAgIHZhciBzZWdtZW50cyxcbiAgICAgICAgICAgIF9zdXBlciA9IF9qcC5Db25uZWN0b3JzLkFic3RyYWN0Q29ubmVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksXG4gICAgICAgICAgICBtaWRwb2ludCA9IHBhcmFtcy5taWRwb2ludCA9PSBudWxsID8gMC41IDogcGFyYW1zLm1pZHBvaW50LFxuICAgICAgICAgICAgYWx3YXlzUmVzcGVjdFN0dWJzID0gcGFyYW1zLmFsd2F5c1Jlc3BlY3RTdHVicyA9PT0gdHJ1ZSxcbiAgICAgICAgICAgIGxhc3R4ID0gbnVsbCwgbGFzdHkgPSBudWxsLCBsYXN0T3JpZW50YXRpb24sXG4gICAgICAgICAgICBjb3JuZXJSYWRpdXMgPSBwYXJhbXMuY29ybmVyUmFkaXVzICE9IG51bGwgPyBwYXJhbXMuY29ybmVyUmFkaXVzIDogMCxcblxuICAgICAgICAgICAgLy8gVE9ETyBub3cgY29tbW9uIGJldHdlZW4gdGhpcyBhbmQgQWJzdHJhY3RCZXppZXJFZGl0b3I7IHJlZmFjdG9yIGludG8gc3VwZXJjbGFzcz9cbiAgICAgICAgICAgIGxvb3BiYWNrUmFkaXVzID0gcGFyYW1zLmxvb3BiYWNrUmFkaXVzIHx8IDI1LFxuICAgICAgICAgICAgaXNMb29wYmFja0N1cnJlbnRseSA9IGZhbHNlLFxuXG4gICAgICAgICAgICBzZ24gPSBmdW5jdGlvbiAobikge1xuICAgICAgICAgICAgICAgIHJldHVybiBuIDwgMCA/IC0xIDogbiA9PT0gMCA/IDAgOiAxO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogaGVscGVyIG1ldGhvZCB0byBhZGQgYSBzZWdtZW50LlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBhZGRTZWdtZW50ID0gZnVuY3Rpb24gKHNlZ21lbnRzLCB4LCB5LCBwYWludEluZm8pIHtcbiAgICAgICAgICAgICAgICBpZiAobGFzdHggPT09IHggJiYgbGFzdHkgPT09IHkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgbHggPSBsYXN0eCA9PSBudWxsID8gcGFpbnRJbmZvLnN4IDogbGFzdHgsXG4gICAgICAgICAgICAgICAgICAgIGx5ID0gbGFzdHkgPT0gbnVsbCA/IHBhaW50SW5mby5zeSA6IGxhc3R5LFxuICAgICAgICAgICAgICAgICAgICBvID0gbHggPT09IHggPyBcInZcIiA6IFwiaFwiLFxuICAgICAgICAgICAgICAgICAgICBzZ254ID0gc2duKHggLSBseCksXG4gICAgICAgICAgICAgICAgICAgIHNnbnkgPSBzZ24oeSAtIGx5KTtcblxuICAgICAgICAgICAgICAgIGxhc3R4ID0geDtcbiAgICAgICAgICAgICAgICBsYXN0eSA9IHk7XG4gICAgICAgICAgICAgICAgc2VnbWVudHMucHVzaChbbHgsIGx5LCB4LCB5LCBvLCBzZ254LCBzZ255XSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2VnTGVuZ3RoID0gZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KHNbMF0gLSBzWzJdLCAyKSArIE1hdGgucG93KHNbMV0gLSBzWzNdLCAyKSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2Nsb25lQXJyYXkgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgICAgIHZhciBfYSA9IFtdO1xuICAgICAgICAgICAgICAgIF9hLnB1c2guYXBwbHkoX2EsIGEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBfYTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB3cml0ZVNlZ21lbnRzID0gZnVuY3Rpb24gKGNvbm4sIHNlZ21lbnRzLCBwYWludEluZm8pIHtcbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudCA9IG51bGwsIG5leHQ7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGggLSAxOyBpKyspIHtcblxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudCB8fCBfY2xvbmVBcnJheShzZWdtZW50c1tpXSk7XG4gICAgICAgICAgICAgICAgICAgIG5leHQgPSBfY2xvbmVBcnJheShzZWdtZW50c1tpICsgMV0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29ybmVyUmFkaXVzID4gMCAmJiBjdXJyZW50WzRdICE9PSBuZXh0WzRdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmFkaXVzVG9Vc2UgPSBNYXRoLm1pbihjb3JuZXJSYWRpdXMsIHNlZ0xlbmd0aChjdXJyZW50KSwgc2VnTGVuZ3RoKG5leHQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJpZ2h0IGFuZ2xlLiBhZGp1c3QgY3VycmVudCBzZWdtZW50J3MgZW5kIHBvaW50LCBhbmQgbmV4dCBzZWdtZW50J3Mgc3RhcnQgcG9pbnQuXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50WzJdIC09IGN1cnJlbnRbNV0gKiByYWRpdXNUb1VzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRbM10gLT0gY3VycmVudFs2XSAqIHJhZGl1c1RvVXNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFswXSArPSBuZXh0WzVdICogcmFkaXVzVG9Vc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0WzFdICs9IG5leHRbNl0gKiByYWRpdXNUb1VzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhYyA9IChjdXJyZW50WzZdID09PSBuZXh0WzVdICYmIG5leHRbNV0gPT09IDEpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgoY3VycmVudFs2XSA9PT0gbmV4dFs1XSAmJiBuZXh0WzVdID09PSAwKSAmJiBjdXJyZW50WzVdICE9PSBuZXh0WzZdKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoY3VycmVudFs2XSA9PT0gbmV4dFs1XSAmJiBuZXh0WzVdID09PSAtMSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2dueSA9IG5leHRbMV0gPiBjdXJyZW50WzNdID8gMSA6IC0xLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNnbnggPSBuZXh0WzBdID4gY3VycmVudFsyXSA/IDEgOiAtMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZ25FcXVhbCA9IHNnbnkgPT09IHNnbngsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3ggPSAoc2duRXF1YWwgJiYgYWMgfHwgKCFzZ25FcXVhbCAmJiAhYWMpKSA/IG5leHRbMF0gOiBjdXJyZW50WzJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN5ID0gKHNnbkVxdWFsICYmIGFjIHx8ICghc2duRXF1YWwgJiYgIWFjKSkgPyBjdXJyZW50WzNdIDogbmV4dFsxXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgX3N1cGVyLmFkZFNlZ21lbnQoY29ubiwgXCJTdHJhaWdodFwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeDE6IGN1cnJlbnRbMF0sIHkxOiBjdXJyZW50WzFdLCB4MjogY3VycmVudFsyXSwgeTI6IGN1cnJlbnRbM11cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBfc3VwZXIuYWRkU2VnbWVudChjb25uLCBcIkFyY1wiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcjogcmFkaXVzVG9Vc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeDE6IGN1cnJlbnRbMl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeTE6IGN1cnJlbnRbM10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeDI6IG5leHRbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeTI6IG5leHRbMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3g6IGN4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN5OiBjeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhYzogYWNcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZHggKyBkeSBhcmUgdXNlZCB0byBhZGp1c3QgZm9yIGxpbmUgd2lkdGguXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZHggPSAoY3VycmVudFsyXSA9PT0gY3VycmVudFswXSkgPyAwIDogKGN1cnJlbnRbMl0gPiBjdXJyZW50WzBdKSA/IChwYWludEluZm8ubHcgLyAyKSA6IC0ocGFpbnRJbmZvLmx3IC8gMiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZHkgPSAoY3VycmVudFszXSA9PT0gY3VycmVudFsxXSkgPyAwIDogKGN1cnJlbnRbM10gPiBjdXJyZW50WzFdKSA/IChwYWludEluZm8ubHcgLyAyKSA6IC0ocGFpbnRJbmZvLmx3IC8gMik7XG4gICAgICAgICAgICAgICAgICAgICAgICBfc3VwZXIuYWRkU2VnbWVudChjb25uLCBcIlN0cmFpZ2h0XCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4MTogY3VycmVudFswXSAtIGR4LCB5MTogY3VycmVudFsxXSAtIGR5LCB4MjogY3VycmVudFsyXSArIGR4LCB5MjogY3VycmVudFszXSArIGR5XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gbmV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5leHQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBsYXN0IHNlZ21lbnRcbiAgICAgICAgICAgICAgICAgICAgX3N1cGVyLmFkZFNlZ21lbnQoY29ubiwgXCJTdHJhaWdodFwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4MTogbmV4dFswXSwgeTE6IG5leHRbMV0sIHgyOiBuZXh0WzJdLCB5MjogbmV4dFszXVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuX2NvbXB1dGUgPSBmdW5jdGlvbiAocGFpbnRJbmZvLCBwYXJhbXMpIHtcblxuICAgICAgICAgICAgc2VnbWVudHMgPSBbXTtcbiAgICAgICAgICAgIGxhc3R4ID0gbnVsbDtcbiAgICAgICAgICAgIGxhc3R5ID0gbnVsbDtcbiAgICAgICAgICAgIGxhc3RPcmllbnRhdGlvbiA9IG51bGw7XG5cbiAgICAgICAgICAgIHZhciBjb21tb25TdHViQ2FsY3VsYXRvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWyBwYWludEluZm8uc3RhcnRTdHViWCwgcGFpbnRJbmZvLnN0YXJ0U3R1YlksIHBhaW50SW5mby5lbmRTdHViWCwgcGFpbnRJbmZvLmVuZFN0dWJZIF07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHN0dWJDYWxjdWxhdG9ycyA9IHtcbiAgICAgICAgICAgICAgICAgICAgcGVycGVuZGljdWxhcjogY29tbW9uU3R1YkNhbGN1bGF0b3IsXG4gICAgICAgICAgICAgICAgICAgIG9ydGhvZ29uYWw6IGNvbW1vblN0dWJDYWxjdWxhdG9yLFxuICAgICAgICAgICAgICAgICAgICBvcHBvc2l0ZTogZnVuY3Rpb24gKGF4aXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwaSA9IHBhaW50SW5mbyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZHggPSBheGlzID09PSBcInhcIiA/IDAgOiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZUluUHJveGltaXR5ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInhcIjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICggKHBpLnNvW2lkeF0gPT09IDEgJiYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggKHBpLnN0YXJ0U3R1YlggPiBwaS5lbmRTdHViWCkgJiYgKHBpLnR4ID4gcGkuc3RhcnRTdHViWCkgKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggKHBpLnN4ID4gcGkuZW5kU3R1YlgpICYmIChwaS50eCA+IHBpLnN4KSkpKSkgfHxcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggKHBpLnNvW2lkeF0gPT09IC0xICYmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCAocGkuc3RhcnRTdHViWCA8IHBpLmVuZFN0dWJYKSAmJiAocGkudHggPCBwaS5zdGFydFN0dWJYKSApIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggKHBpLnN4IDwgcGkuZW5kU3R1YlgpICYmIChwaS50eCA8IHBpLnN4KSkpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwieVwiOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCAocGkuc29baWR4XSA9PT0gMSAmJiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCAocGkuc3RhcnRTdHViWSA+IHBpLmVuZFN0dWJZKSAmJiAocGkudHkgPiBwaS5zdGFydFN0dWJZKSApIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCAocGkuc3kgPiBwaS5lbmRTdHViWSkgJiYgKHBpLnR5ID4gcGkuc3kpKSkpKSB8fFxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCAocGkuc29baWR4XSA9PT0gLTEgJiYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIChwaS5zdGFydFN0dWJZIDwgcGkuZW5kU3R1YlkpICYmIChwaS50eSA8IHBpLnN0YXJ0U3R1YlkpICkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCAocGkuc3kgPCBwaS5lbmRTdHViWSkgJiYgKHBpLnR5IDwgcGkuc3kpKSkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYWx3YXlzUmVzcGVjdFN0dWJzICYmIGFyZUluUHJveGltaXR5W2F4aXNdKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInhcIjogWyhwYWludEluZm8uc3ggKyBwYWludEluZm8udHgpIC8gMiwgcGFpbnRJbmZvLnN0YXJ0U3R1YlksIChwYWludEluZm8uc3ggKyBwYWludEluZm8udHgpIC8gMiwgcGFpbnRJbmZvLmVuZFN0dWJZXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ5XCI6IFtwYWludEluZm8uc3RhcnRTdHViWCwgKHBhaW50SW5mby5zeSArIHBhaW50SW5mby50eSkgLyAyLCBwYWludEluZm8uZW5kU3R1YlgsIChwYWludEluZm8uc3kgKyBwYWludEluZm8udHkpIC8gMl1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9W2F4aXNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsgcGFpbnRJbmZvLnN0YXJ0U3R1YlgsIHBhaW50SW5mby5zdGFydFN0dWJZLCBwYWludEluZm8uZW5kU3R1YlgsIHBhaW50SW5mby5lbmRTdHViWSBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gY2FsY3VsYXRlIFN0dWJzLlxuICAgICAgICAgICAgdmFyIHN0dWJzID0gc3R1YkNhbGN1bGF0b3JzW3BhaW50SW5mby5hbmNob3JPcmllbnRhdGlvbl0ocGFpbnRJbmZvLnNvdXJjZUF4aXMpLFxuICAgICAgICAgICAgICAgIGlkeCA9IHBhaW50SW5mby5zb3VyY2VBeGlzID09PSBcInhcIiA/IDAgOiAxLFxuICAgICAgICAgICAgICAgIG9pZHggPSBwYWludEluZm8uc291cmNlQXhpcyA9PT0gXCJ4XCIgPyAxIDogMCxcbiAgICAgICAgICAgICAgICBzcyA9IHN0dWJzW2lkeF0sXG4gICAgICAgICAgICAgICAgb3NzID0gc3R1YnNbb2lkeF0sXG4gICAgICAgICAgICAgICAgZXMgPSBzdHVic1tpZHggKyAyXSxcbiAgICAgICAgICAgICAgICBvZXMgPSBzdHVic1tvaWR4ICsgMl07XG5cbiAgICAgICAgICAgIC8vIGFkZCB0aGUgc3RhcnQgc3R1YiBzZWdtZW50LiB1c2Ugc3R1YnMgZm9yIGxvb3BiYWNrIGFzIGl0IHdpbGwgbG9vayBiZXR0ZXIsIHdpdGggdGhlIGxvb3Agc3BhY2VkXG4gICAgICAgICAgICAvLyBhd2F5IGZyb20gdGhlIGVsZW1lbnQuXG4gICAgICAgICAgICBhZGRTZWdtZW50KHNlZ21lbnRzLCBzdHVic1swXSwgc3R1YnNbMV0sIHBhaW50SW5mbyk7XG5cbiAgICAgICAgICAgIC8vIGlmIGl0cyBhIGxvb3BiYWNrIGFuZCB3ZSBzaG91bGQgdHJlYXQgaXQgZGlmZmVyZW50bHkuXG4gICAgICAgICAgICBpZiAoZmFsc2UgJiZwYXJhbXMuc291cmNlUG9zWzBdID09PSBwYXJhbXMudGFyZ2V0UG9zWzBdICYmIHBhcmFtcy5zb3VyY2VQb3NbMV0gPT09IHBhcmFtcy50YXJnZXRQb3NbMV0pIHtcblxuICAgICAgICAgICAgICAgIC8vIHdlIHVzZSBsb29wYmFja1JhZGl1cyBoZXJlLCBhcyBzdGF0ZW1hY2hpbmUgY29ubmVjdG9ycyBkby5cbiAgICAgICAgICAgICAgICAvLyBzbyB3ZSBnbyByYWRpdXMgdG8gdGhlIGxlZnQgZnJvbSBzdHVic1swXSwgdGhlbiB1cHdhcmRzIGJ5IDIqcmFkaXVzLCB0byB0aGUgcmlnaHQgYnkgMipyYWRpdXMsXG4gICAgICAgICAgICAgICAgLy8gZG93biBieSAyKnJhZGl1cywgbGVmdCBieSByYWRpdXMuXG4gICAgICAgICAgICAgICAgYWRkU2VnbWVudChzZWdtZW50cywgc3R1YnNbMF0gLSBsb29wYmFja1JhZGl1cywgc3R1YnNbMV0sIHBhaW50SW5mbyk7XG4gICAgICAgICAgICAgICAgYWRkU2VnbWVudChzZWdtZW50cywgc3R1YnNbMF0gLSBsb29wYmFja1JhZGl1cywgc3R1YnNbMV0gLSAoMiAqIGxvb3BiYWNrUmFkaXVzKSwgcGFpbnRJbmZvKTtcbiAgICAgICAgICAgICAgICBhZGRTZWdtZW50KHNlZ21lbnRzLCBzdHVic1swXSArIGxvb3BiYWNrUmFkaXVzLCBzdHVic1sxXSAtICgyICogbG9vcGJhY2tSYWRpdXMpLCBwYWludEluZm8pO1xuICAgICAgICAgICAgICAgIGFkZFNlZ21lbnQoc2VnbWVudHMsIHN0dWJzWzBdICsgbG9vcGJhY2tSYWRpdXMsIHN0dWJzWzFdLCBwYWludEluZm8pO1xuICAgICAgICAgICAgICAgIGFkZFNlZ21lbnQoc2VnbWVudHMsIHN0dWJzWzBdLCBzdHVic1sxXSwgcGFpbnRJbmZvKTtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG5cblxuICAgICAgICAgICAgICAgIHZhciBtaWR4ID0gcGFpbnRJbmZvLnN0YXJ0U3R1YlggKyAoKHBhaW50SW5mby5lbmRTdHViWCAtIHBhaW50SW5mby5zdGFydFN0dWJYKSAqIG1pZHBvaW50KSxcbiAgICAgICAgICAgICAgICAgICAgbWlkeSA9IHBhaW50SW5mby5zdGFydFN0dWJZICsgKChwYWludEluZm8uZW5kU3R1YlkgLSBwYWludEluZm8uc3RhcnRTdHViWSkgKiBtaWRwb2ludCk7XG5cbiAgICAgICAgICAgICAgICB2YXIgb3JpZW50YXRpb25zID0geyB4OiBbIDAsIDEgXSwgeTogWyAxLCAwIF0gfSxcbiAgICAgICAgICAgICAgICAgICAgbGluZUNhbGN1bGF0b3JzID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGVycGVuZGljdWxhcjogZnVuY3Rpb24gKGF4aXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGkgPSBwYWludEluZm8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbIFsgMSwgMiwgMywgNCBdLCBudWxsLCBbIDIsIDEsIDQsIDMgXSBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgWyBbIDQsIDMsIDIsIDEgXSwgbnVsbCwgWyAzLCA0LCAxLCAyIF0gXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbIFsgMywgMiwgMSwgNCBdLCBudWxsLCBbIDIsIDMsIDQsIDEgXSBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgWyBbIDQsIDEsIDIsIDMgXSwgbnVsbCwgWyAxLCA0LCAzLCAyIF0gXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHVicyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IFsgWyBwaS5zdGFydFN0dWJYLCBwaS5lbmRTdHViWCBdLCBudWxsLCBbIHBpLmVuZFN0dWJYLCBwaS5zdGFydFN0dWJYIF0gXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IFsgWyBwaS5zdGFydFN0dWJZLCBwaS5lbmRTdHViWSBdLCBudWxsLCBbIHBpLmVuZFN0dWJZLCBwaS5zdGFydFN0dWJZIF0gXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaWRMaW5lcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IFsgWyBtaWR4LCBwaS5zdGFydFN0dWJZIF0sIFsgbWlkeCwgcGkuZW5kU3R1YlkgXSBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogWyBbIHBpLnN0YXJ0U3R1YlgsIG1pZHkgXSwgWyBwaS5lbmRTdHViWCwgbWlkeSBdIF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZXNUb0VuZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IFsgWyBwaS5lbmRTdHViWCwgcGkuc3RhcnRTdHViWSBdIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiBbIFsgcGkuc3RhcnRTdHViWCwgcGkuZW5kU3R1YlkgXSBdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0VG9FbmQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiBbIFsgcGkuc3RhcnRTdHViWCwgcGkuZW5kU3R1YlkgXSwgWyBwaS5lbmRTdHViWCwgcGkuZW5kU3R1YlkgXSBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogWyBbIHBpLmVuZFN0dWJYLCBwaS5zdGFydFN0dWJZIF0sIFsgcGkuZW5kU3R1YlgsIHBpLmVuZFN0dWJZIF0gXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydFRvTWlkVG9FbmQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiBbIFsgcGkuc3RhcnRTdHViWCwgbWlkeSBdLCBbIHBpLmVuZFN0dWJYLCBtaWR5IF0sIFsgcGkuZW5kU3R1YlgsIHBpLmVuZFN0dWJZIF0gXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IFsgWyBtaWR4LCBwaS5zdGFydFN0dWJZIF0sIFsgbWlkeCwgcGkuZW5kU3R1YlkgXSwgWyBwaS5lbmRTdHViWCwgcGkuZW5kU3R1YlkgXSBdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG90aGVyU3R1YnMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiBbIHBpLnN0YXJ0U3R1YlksIHBpLmVuZFN0dWJZIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiBbIHBpLnN0YXJ0U3R1YlgsIHBpLmVuZFN0dWJYIF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc29JZHggPSBvcmllbnRhdGlvbnNbYXhpc11bMF0sIHRvSWR4ID0gb3JpZW50YXRpb25zW2F4aXNdWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfc28gPSBwaS5zb1tzb0lkeF0gKyAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdG8gPSBwaS50b1t0b0lkeF0gKyAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdGhlckZsaXBwZWQgPSAocGkudG9bdG9JZHhdID09PSAtMSAmJiAob3RoZXJTdHVic1theGlzXVsxXSA8IG90aGVyU3R1YnNbYXhpc11bMF0pKSB8fCAocGkudG9bdG9JZHhdID09PSAxICYmIChvdGhlclN0dWJzW2F4aXNdWzFdID4gb3RoZXJTdHVic1theGlzXVswXSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHViMSA9IHN0dWJzW2F4aXNdW19zb11bMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0dWIyID0gc3R1YnNbYXhpc11bX3NvXVsxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VnbWVudEluZGV4ZXMgPSBzaXNbYXhpc11bX3NvXVtfdG9dO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBpLnNlZ21lbnQgPT09IHNlZ21lbnRJbmRleGVzWzNdIHx8IChwaS5zZWdtZW50ID09PSBzZWdtZW50SW5kZXhlc1syXSAmJiBvdGhlckZsaXBwZWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtaWRMaW5lc1theGlzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocGkuc2VnbWVudCA9PT0gc2VnbWVudEluZGV4ZXNbMl0gJiYgc3R1YjIgPCBzdHViMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGluZXNUb0VuZFtheGlzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoKHBpLnNlZ21lbnQgPT09IHNlZ21lbnRJbmRleGVzWzJdICYmIHN0dWIyID49IHN0dWIxKSB8fCAocGkuc2VnbWVudCA9PT0gc2VnbWVudEluZGV4ZXNbMV0gJiYgIW90aGVyRmxpcHBlZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0YXJ0VG9NaWRUb0VuZFtheGlzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocGkuc2VnbWVudCA9PT0gc2VnbWVudEluZGV4ZXNbMF0gfHwgKHBpLnNlZ21lbnQgPT09IHNlZ21lbnRJbmRleGVzWzFdICYmIG90aGVyRmxpcHBlZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0YXJ0VG9FbmRbYXhpc107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ydGhvZ29uYWw6IGZ1bmN0aW9uIChheGlzLCBzdGFydFN0dWIsIG90aGVyU3RhcnRTdHViLCBlbmRTdHViLCBvdGhlckVuZFN0dWIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGkgPSBwYWludEluZm8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVudCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwieFwiOiBwaS5zb1swXSA9PT0gLTEgPyBNYXRoLm1pbihzdGFydFN0dWIsIGVuZFN0dWIpIDogTWF0aC5tYXgoc3RhcnRTdHViLCBlbmRTdHViKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwieVwiOiBwaS5zb1sxXSA9PT0gLTEgPyBNYXRoLm1pbihzdGFydFN0dWIsIGVuZFN0dWIpIDogTWF0aC5tYXgoc3RhcnRTdHViLCBlbmRTdHViKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9W2F4aXNdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ4XCI6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFsgZXh0ZW50LCBvdGhlclN0YXJ0U3R1YiBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgWyBleHRlbnQsIG90aGVyRW5kU3R1YiBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgWyBlbmRTdHViLCBvdGhlckVuZFN0dWIgXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInlcIjogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgWyBvdGhlclN0YXJ0U3R1YiwgZXh0ZW50IF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbIG90aGVyRW5kU3R1YiwgZXh0ZW50IF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbIG90aGVyRW5kU3R1YiwgZW5kU3R1YiBdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9W2F4aXNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wcG9zaXRlOiBmdW5jdGlvbiAoYXhpcywgc3MsIG9zcywgZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGkgPSBwYWludEluZm8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG90aGVyQXhpcyA9IHtcInhcIjogXCJ5XCIsIFwieVwiOiBcInhcIn1bYXhpc10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpbSA9IHtcInhcIjogXCJoZWlnaHRcIiwgXCJ5XCI6IFwid2lkdGhcIn1bYXhpc10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBhcmF0b3IgPSBwaVtcImlzXCIgKyBheGlzLnRvVXBwZXJDYXNlKCkgKyBcIkdyZWF0ZXJUaGFuU3R1YlRpbWVzMlwiXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuc291cmNlRW5kcG9pbnQuZWxlbWVudElkID09PSBwYXJhbXMudGFyZ2V0RW5kcG9pbnQuZWxlbWVudElkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfdmFsID0gb3NzICsgKCgxIC0gcGFyYW1zLnNvdXJjZUVuZHBvaW50LmFuY2hvcltvdGhlckF4aXNdKSAqIHBhcmFtcy5zb3VyY2VJbmZvW2RpbV0pICsgX3N1cGVyLm1heFN0dWI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInhcIjogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFsgc3MsIF92YWwgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbIGVzLCBfdmFsIF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInlcIjogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFsgX3ZhbCwgc3MgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbIF92YWwsIGVzIF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVtheGlzXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghY29tcGFyYXRvciB8fCAocGkuc29baWR4XSA9PT0gMSAmJiBzcyA+IGVzKSB8fCAocGkuc29baWR4XSA9PT0gLTEgJiYgc3MgPCBlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwieFwiOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgWyBzcywgbWlkeSBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFsgZXMsIG1pZHkgXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwieVwiOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgWyBtaWR4LCBzcyBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFsgbWlkeCwgZXMgXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9W2F4aXNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICgocGkuc29baWR4XSA9PT0gMSAmJiBzcyA8IGVzKSB8fCAocGkuc29baWR4XSA9PT0gLTEgJiYgc3MgPiBlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwieFwiOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgWyBtaWR4LCBwaS5zeSBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFsgbWlkeCwgcGkudHkgXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwieVwiOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgWyBwaS5zeCwgbWlkeSBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFsgcGkudHgsIG1pZHkgXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9W2F4aXNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIC8vIGNvbXB1dGUgdGhlIHJlc3Qgb2YgdGhlIGxpbmVcbiAgICAgICAgICAgICAgICB2YXIgcCA9IGxpbmVDYWxjdWxhdG9yc1twYWludEluZm8uYW5jaG9yT3JpZW50YXRpb25dKHBhaW50SW5mby5zb3VyY2VBeGlzLCBzcywgb3NzLCBlcywgb2VzKTtcbiAgICAgICAgICAgICAgICBpZiAocCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZFNlZ21lbnQoc2VnbWVudHMsIHBbaV1bMF0sIHBbaV1bMV0sIHBhaW50SW5mbyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBsaW5lIHRvIGVuZCBzdHViXG4gICAgICAgICAgICAgICAgYWRkU2VnbWVudChzZWdtZW50cywgc3R1YnNbMl0sIHN0dWJzWzNdLCBwYWludEluZm8pO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGVuZCBzdHViIHRvIGVuZCAoY29tbW9uKVxuICAgICAgICAgICAgYWRkU2VnbWVudChzZWdtZW50cywgcGFpbnRJbmZvLnR4LCBwYWludEluZm8udHksIHBhaW50SW5mbyk7XG5cbiAgICAgICAgICAgIC8vIHdyaXRlIG91dCB0aGUgc2VnbWVudHMuXG4gICAgICAgICAgICB3cml0ZVNlZ21lbnRzKHRoaXMsIHNlZ21lbnRzLCBwYWludEluZm8pO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qdGhpcy5nZXRQYXRoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9sYXN0ID0gbnVsbCwgX2xhc3RBeGlzID0gbnVsbCwgcyA9IFtdLCBzZWdzID0gc2VnbWVudHM7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VnID0gc2Vnc1tpXSwgYXhpcyA9IHNlZ1s0XSwgYXhpc0luZGV4ID0gKGF4aXMgPT0gXCJ2XCIgPyAzIDogMik7XG4gICAgICAgICAgICAgICAgaWYgKF9sYXN0ICE9IG51bGwgJiYgX2xhc3RBeGlzID09PSBheGlzKSB7XG4gICAgICAgICAgICAgICAgICAgIF9sYXN0W2F4aXNJbmRleF0gPSBzZWdbYXhpc0luZGV4XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWdbMF0gIT0gc2VnWzJdIHx8IHNlZ1sxXSAhPSBzZWdbM10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IFsgc2VnWzBdLCBzZWdbMV0gXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IFsgc2VnWzJdLCBzZWdbM10gXVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfbGFzdCA9IHNlZztcbiAgICAgICAgICAgICAgICAgICAgICAgIF9sYXN0QXhpcyA9IHNlZ1s0XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzO1xuICAgICAgICB9OyovXG4gICAgfTtcblxuICAgIF9qdS5leHRlbmQoRmxvd2NoYXJ0LCBfanAuQ29ubmVjdG9ycy5BYnN0cmFjdENvbm5lY3Rvcik7XG4gICAgX2pwLnJlZ2lzdGVyQ29ubmVjdG9yVHlwZShGbG93Y2hhcnQsIFwiRmxvd2NoYXJ0XCIpO1xufSkuY2FsbCh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHRoaXMpO1xuLypcbiAqIGpzUGx1bWIgQ29tbXVuaXR5IEVkaXRpb25cbiAqXG4gKiBQcm92aWRlcyBhIHdheSB0byB2aXN1YWxseSBjb25uZWN0IGVsZW1lbnRzIG9uIGFuIEhUTUwgcGFnZSwgdXNpbmcgU1ZHLlxuICpcbiAqIFRoaXMgZmlsZSBjb250YWlucyB0aGUgY29kZSBmb3IgdGhlIEJlemllciBjb25uZWN0b3IgdHlwZS5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTAgLSAyMDE3IGpzUGx1bWIgKGhlbGxvQGpzcGx1bWJ0b29sa2l0LmNvbSlcbiAqXG4gKiBodHRwczovL2pzcGx1bWJ0b29sa2l0LmNvbVxuICogaHR0cHM6Ly9naXRodWIuY29tL2pzcGx1bWIvanNwbHVtYlxuICogXG4gKiBEdWFsIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgYW5kIEdQTDIgbGljZW5zZXMuXG4gKi9cbjtcbihmdW5jdGlvbiAoKSB7XG5cbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgcm9vdCA9IHRoaXMsIF9qcCA9IHJvb3QuanNQbHVtYiwgX2p1ID0gcm9vdC5qc1BsdW1iVXRpbDtcblxuICAgIF9qcC5Db25uZWN0b3JzLkFic3RyYWN0QmV6aWVyQ29ubmVjdG9yID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgICAgICAgdmFyIHNob3dMb29wYmFjayA9IHBhcmFtcy5zaG93TG9vcGJhY2sgIT09IGZhbHNlLFxuICAgICAgICAgICAgY3VydmluZXNzID0gcGFyYW1zLmN1cnZpbmVzcyB8fCAxMCxcbiAgICAgICAgICAgIG1hcmdpbiA9IHBhcmFtcy5tYXJnaW4gfHwgNSxcbiAgICAgICAgICAgIHByb3hpbWl0eUxpbWl0ID0gcGFyYW1zLnByb3hpbWl0eUxpbWl0IHx8IDgwLFxuICAgICAgICAgICAgY2xvY2t3aXNlID0gcGFyYW1zLm9yaWVudGF0aW9uICYmIHBhcmFtcy5vcmllbnRhdGlvbiA9PT0gXCJjbG9ja3dpc2VcIixcbiAgICAgICAgICAgIGxvb3BiYWNrUmFkaXVzID0gcGFyYW1zLmxvb3BiYWNrUmFkaXVzIHx8IDI1LFxuICAgICAgICAgICAgaXNMb29wYmFja0N1cnJlbnRseSA9IGZhbHNlLFxuICAgICAgICAgICAgX3N1cGVyO1xuXG4gICAgICAgIHRoaXMub3ZlcnJpZGVTZXRFZGl0YWJsZSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gIWlzTG9vcGJhY2tDdXJyZW50bHk7IH07XG5cbiAgICAgICAgdGhpcy5fY29tcHV0ZSA9IGZ1bmN0aW9uIChwYWludEluZm8sIHApIHtcblxuICAgICAgICAgICAgdmFyIHNwID0gcC5zb3VyY2VQb3MsXG4gICAgICAgICAgICAgICAgdHAgPSBwLnRhcmdldFBvcyxcbiAgICAgICAgICAgICAgICBfdyA9IE1hdGguYWJzKHNwWzBdIC0gdHBbMF0pLFxuICAgICAgICAgICAgICAgIF9oID0gTWF0aC5hYnMoc3BbMV0gLSB0cFsxXSk7XG5cbiAgICAgICAgICAgIGlmICghc2hvd0xvb3BiYWNrIHx8IChwLnNvdXJjZUVuZHBvaW50LmVsZW1lbnRJZCAhPT0gcC50YXJnZXRFbmRwb2ludC5lbGVtZW50SWQpKSB7XG4gICAgICAgICAgICAgICAgaXNMb29wYmFja0N1cnJlbnRseSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbXB1dGVCZXppZXIocGFpbnRJbmZvLCBwLCBzcCwgdHAsIF93LCBfaCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlzTG9vcGJhY2tDdXJyZW50bHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgIC8vIGEgbG9vcGJhY2sgY29ubmVjdG9yLiAgZHJhdyBhbiBhcmMgZnJvbSBvbmUgYW5jaG9yIHRvIHRoZSBvdGhlci5cbiAgICAgICAgICAgICAgICB2YXIgeDEgPSBwLnNvdXJjZVBvc1swXSwgeTEgPSBwLnNvdXJjZVBvc1sxXSAtIG1hcmdpbixcbiAgICAgICAgICAgICAgICAgICAgY3ggPSB4MSwgY3kgPSB5MSAtIGxvb3BiYWNrUmFkaXVzLFxuICAgICAgICAgICAgICAgIC8vIGNhbnZhcyBzaXppbmcgc3R1ZmYsIHRvIGVuc3VyZSB0aGUgd2hvbGUgcGFpbnRlZCBhcmVhIGlzIHZpc2libGUuXG4gICAgICAgICAgICAgICAgICAgIF94ID0gY3ggLSBsb29wYmFja1JhZGl1cyxcbiAgICAgICAgICAgICAgICAgICAgX3kgPSBjeSAtIGxvb3BiYWNrUmFkaXVzO1xuXG4gICAgICAgICAgICAgICAgX3cgPSAyICogbG9vcGJhY2tSYWRpdXM7XG4gICAgICAgICAgICAgICAgX2ggPSAyICogbG9vcGJhY2tSYWRpdXM7XG5cbiAgICAgICAgICAgICAgICBwYWludEluZm8ucG9pbnRzWzBdID0gX3g7XG4gICAgICAgICAgICAgICAgcGFpbnRJbmZvLnBvaW50c1sxXSA9IF95O1xuICAgICAgICAgICAgICAgIHBhaW50SW5mby5wb2ludHNbMl0gPSBfdztcbiAgICAgICAgICAgICAgICBwYWludEluZm8ucG9pbnRzWzNdID0gX2g7XG5cbiAgICAgICAgICAgICAgICAvLyBBREQgQU4gQVJDIFNFR01FTlQuXG4gICAgICAgICAgICAgICAgX3N1cGVyLmFkZFNlZ21lbnQodGhpcywgXCJBcmNcIiwge1xuICAgICAgICAgICAgICAgICAgICBsb29wYmFjazogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgeDE6ICh4MSAtIF94KSArIDQsXG4gICAgICAgICAgICAgICAgICAgIHkxOiB5MSAtIF95LFxuICAgICAgICAgICAgICAgICAgICBzdGFydEFuZ2xlOiAwLFxuICAgICAgICAgICAgICAgICAgICBlbmRBbmdsZTogMiAqIE1hdGguUEksXG4gICAgICAgICAgICAgICAgICAgIHI6IGxvb3BiYWNrUmFkaXVzLFxuICAgICAgICAgICAgICAgICAgICBhYzogIWNsb2Nrd2lzZSxcbiAgICAgICAgICAgICAgICAgICAgeDI6ICh4MSAtIF94KSAtIDQsXG4gICAgICAgICAgICAgICAgICAgIHkyOiB5MSAtIF95LFxuICAgICAgICAgICAgICAgICAgICBjeDogY3ggLSBfeCxcbiAgICAgICAgICAgICAgICAgICAgY3k6IGN5IC0gX3lcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBfc3VwZXIgPSBfanAuQ29ubmVjdG9ycy5BYnN0cmFjdENvbm5lY3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICByZXR1cm4gX3N1cGVyO1xuICAgIH07XG4gICAgX2p1LmV4dGVuZChfanAuQ29ubmVjdG9ycy5BYnN0cmFjdEJlemllckNvbm5lY3RvciwgX2pwLkNvbm5lY3RvcnMuQWJzdHJhY3RDb25uZWN0b3IpO1xuXG4gICAgdmFyIEJlemllciA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICAgICAgICB0aGlzLnR5cGUgPSBcIkJlemllclwiO1xuXG4gICAgICAgIHZhciBfc3VwZXIgPSBfanAuQ29ubmVjdG9ycy5BYnN0cmFjdEJlemllckNvbm5lY3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpLFxuICAgICAgICAgICAgbWFqb3JBbmNob3IgPSBwYXJhbXMuY3VydmluZXNzIHx8IDE1MCxcbiAgICAgICAgICAgIG1pbm9yQW5jaG9yID0gMTA7XG5cbiAgICAgICAgdGhpcy5nZXRDdXJ2aW5lc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbWFqb3JBbmNob3I7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5fZmluZENvbnRyb2xQb2ludCA9IGZ1bmN0aW9uIChwb2ludCwgc291cmNlQW5jaG9yUG9zaXRpb24sIHRhcmdldEFuY2hvclBvc2l0aW9uLCBzb3VyY2VFbmRwb2ludCwgdGFyZ2V0RW5kcG9pbnQsIHNvbywgdG9vKSB7XG4gICAgICAgICAgICAvLyBkZXRlcm1pbmUgaWYgdGhlIHR3byBhbmNob3JzIGFyZSBwZXJwZW5kaWN1bGFyIHRvIGVhY2ggb3RoZXIgaW4gdGhlaXIgb3JpZW50YXRpb24uICB3ZSBzd2FwIHRoZSBjb250cm9sXG4gICAgICAgICAgICAvLyBwb2ludHMgYXJvdW5kIGlmIHNvIChjb2RlIGNvdWxkIGJlIHRpZ2h0ZW5lZCB1cClcbiAgICAgICAgICAgIHZhciBwZXJwZW5kaWN1bGFyID0gc29vWzBdICE9PSB0b29bMF0gfHwgc29vWzFdID09PSB0b29bMV0sXG4gICAgICAgICAgICAgICAgcCA9IFtdO1xuXG4gICAgICAgICAgICBpZiAoIXBlcnBlbmRpY3VsYXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoc29vWzBdID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHAucHVzaChzb3VyY2VBbmNob3JQb3NpdGlvblswXSA8IHRhcmdldEFuY2hvclBvc2l0aW9uWzBdID8gcG9pbnRbMF0gKyBtaW5vckFuY2hvciA6IHBvaW50WzBdIC0gbWlub3JBbmNob3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcC5wdXNoKHBvaW50WzBdIC0gKG1ham9yQW5jaG9yICogc29vWzBdKSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHNvb1sxXSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBwLnB1c2goc291cmNlQW5jaG9yUG9zaXRpb25bMV0gPCB0YXJnZXRBbmNob3JQb3NpdGlvblsxXSA/IHBvaW50WzFdICsgbWlub3JBbmNob3IgOiBwb2ludFsxXSAtIG1pbm9yQW5jaG9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHAucHVzaChwb2ludFsxXSArIChtYWpvckFuY2hvciAqIHRvb1sxXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0b29bMF0gPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcC5wdXNoKHRhcmdldEFuY2hvclBvc2l0aW9uWzBdIDwgc291cmNlQW5jaG9yUG9zaXRpb25bMF0gPyBwb2ludFswXSArIG1pbm9yQW5jaG9yIDogcG9pbnRbMF0gLSBtaW5vckFuY2hvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwLnB1c2gocG9pbnRbMF0gKyAobWFqb3JBbmNob3IgKiB0b29bMF0pKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodG9vWzFdID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHAucHVzaCh0YXJnZXRBbmNob3JQb3NpdGlvblsxXSA8IHNvdXJjZUFuY2hvclBvc2l0aW9uWzFdID8gcG9pbnRbMV0gKyBtaW5vckFuY2hvciA6IHBvaW50WzFdIC0gbWlub3JBbmNob3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcC5wdXNoKHBvaW50WzFdICsgKG1ham9yQW5jaG9yICogc29vWzFdKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLl9jb21wdXRlQmV6aWVyID0gZnVuY3Rpb24gKHBhaW50SW5mbywgcCwgc3AsIHRwLCBfdywgX2gpIHtcblxuICAgICAgICAgICAgdmFyIGdlb21ldHJ5ID0gdGhpcy5nZXRHZW9tZXRyeSgpLCBfQ1AsIF9DUDIsXG4gICAgICAgICAgICAgICAgX3N4ID0gc3BbMF0gPCB0cFswXSA/IF93IDogMCxcbiAgICAgICAgICAgICAgICBfc3kgPSBzcFsxXSA8IHRwWzFdID8gX2ggOiAwLFxuICAgICAgICAgICAgICAgIF90eCA9IHNwWzBdIDwgdHBbMF0gPyAwIDogX3csXG4gICAgICAgICAgICAgICAgX3R5ID0gc3BbMV0gPCB0cFsxXSA/IDAgOiBfaDtcblxuICAgICAgICAgICAgaWYgKCh0aGlzLmhhc0JlZW5FZGl0ZWQoKSB8fCB0aGlzLmlzRWRpdGluZygpKSAmJiBnZW9tZXRyeSAhPSBudWxsICYmIGdlb21ldHJ5LmNvbnRyb2xQb2ludHMgIT0gbnVsbCAmJiBnZW9tZXRyeS5jb250cm9sUG9pbnRzWzBdICE9IG51bGwgJiYgZ2VvbWV0cnkuY29udHJvbFBvaW50c1sxXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgX0NQID0gZ2VvbWV0cnkuY29udHJvbFBvaW50c1swXTtcbiAgICAgICAgICAgICAgICBfQ1AyID0gZ2VvbWV0cnkuY29udHJvbFBvaW50c1sxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIF9DUCA9IHRoaXMuX2ZpbmRDb250cm9sUG9pbnQoW19zeCwgX3N5XSwgc3AsIHRwLCBwLnNvdXJjZUVuZHBvaW50LCBwLnRhcmdldEVuZHBvaW50LCBwYWludEluZm8uc28sIHBhaW50SW5mby50byk7XG4gICAgICAgICAgICAgICAgX0NQMiA9IHRoaXMuX2ZpbmRDb250cm9sUG9pbnQoW190eCwgX3R5XSwgdHAsIHNwLCBwLnRhcmdldEVuZHBvaW50LCBwLnNvdXJjZUVuZHBvaW50LCBwYWludEluZm8udG8sIHBhaW50SW5mby5zbyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9zdXBlci5zZXRHZW9tZXRyeSh7Y29udHJvbFBvaW50czpbX0NQLCBfQ1AyXX0sIHRydWUpO1xuXG4gICAgICAgICAgICBfc3VwZXIuYWRkU2VnbWVudCh0aGlzLCBcIkJlemllclwiLCB7XG4gICAgICAgICAgICAgICAgeDE6IF9zeCwgeTE6IF9zeSwgeDI6IF90eCwgeTI6IF90eSxcbiAgICAgICAgICAgICAgICBjcDF4OiBfQ1BbMF0sIGNwMXk6IF9DUFsxXSwgY3AyeDogX0NQMlswXSwgY3AyeTogX0NQMlsxXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cblxuICAgIH07XG5cbiAgICBfanUuZXh0ZW5kKEJlemllciwgX2pwLkNvbm5lY3RvcnMuQWJzdHJhY3RCZXppZXJDb25uZWN0b3IpO1xuICAgIF9qcC5yZWdpc3RlckNvbm5lY3RvclR5cGUoQmV6aWVyLCBcIkJlemllclwiKTtcblxufSkuY2FsbCh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHRoaXMpO1xuLypcbiAqIGpzUGx1bWIgQ29tbXVuaXR5IEVkaXRpb25cbiAqXG4gKiBQcm92aWRlcyBhIHdheSB0byB2aXN1YWxseSBjb25uZWN0IGVsZW1lbnRzIG9uIGFuIEhUTUwgcGFnZSwgdXNpbmcgU1ZHLlxuICpcbiAqIFRoaXMgZmlsZSBjb250YWlucyB0aGUgc3RhdGUgbWFjaGluZSBjb25uZWN0b3JzLCB3aGljaCBleHRlbmQgQWJzdHJhY3RCZXppZXJDb25uZWN0b3IuXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEwIC0gMjAxNyBqc1BsdW1iIChoZWxsb0Bqc3BsdW1idG9vbGtpdC5jb20pXG4gKlxuICogaHR0cHM6Ly9qc3BsdW1idG9vbGtpdC5jb21cbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9qc3BsdW1iL2pzcGx1bWJcbiAqIFxuICogRHVhbCBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGFuZCBHUEwyIGxpY2Vuc2VzLlxuICovXG47XG4oZnVuY3Rpb24gKCkge1xuXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIHJvb3QgPSB0aGlzLCBfanAgPSByb290LmpzUGx1bWIsIF9qdSA9IHJvb3QuanNQbHVtYlV0aWw7XG5cbiAgICB2YXIgX3NlZ21lbnQgPSBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIpIHtcbiAgICAgICAgICAgIGlmICh4MSA8PSB4MiAmJiB5MiA8PSB5MSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoeDEgPD0geDIgJiYgeTEgPD0geTIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHgyIDw9IHgxICYmIHkyID49IHkxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gNDtcbiAgICAgICAgfSxcblxuICAgIC8vIHRoZSBjb250cm9sIHBvaW50IHdlIHdpbGwgdXNlIGRlcGVuZHMgb24gdGhlIGZhY2VzIHRvIHdoaWNoIGVhY2ggZW5kIG9mIHRoZSBjb25uZWN0aW9uIGlzIGFzc2lnbmVkLCBzcGVjaWZpY2FsbHkgd2hldGhlciBvciBub3QgdGhlXG4gICAgLy8gdHdvIGZhY2VzIGFyZSBwYXJhbGxlbCBvciBwZXJwZW5kaWN1bGFyLiAgaWYgdGhleSBhcmUgcGFyYWxsZWwgdGhlbiB0aGUgY29udHJvbCBwb2ludCBsaWVzIG9uIHRoZSBtaWRwb2ludCBvZiB0aGUgYXhpcyBpbiB3aGljaCB0aGV5XG4gICAgLy8gYXJlIHBhcmVsbGVsIGFuZCB2YXJpZXMgb25seSBpbiB0aGUgb3RoZXIgYXhpczsgdGhpcyB2YXJpYXRpb24gaXMgcHJvcG9ydGlvbmFsIHRvIHRoZSBkaXN0YW5jZSB0aGF0IHRoZSBhbmNob3IgcG9pbnRzIGxpZSBmcm9tIHRoZVxuICAgIC8vIGNlbnRlciBvZiB0aGF0IGZhY2UuICBpZiB0aGUgdHdvIGZhY2VzIGFyZSBwZXJwZW5kaWN1bGFyIHRoZW4gdGhlIGNvbnRyb2wgcG9pbnQgaXMgYXQgc29tZSBkaXN0YW5jZSBmcm9tIGJvdGggdGhlIG1pZHBvaW50czsgdGhlIGFtb3VudCBhbmRcbiAgICAvLyBkaXJlY3Rpb24gYXJlIGRlcGVuZGVudCBvbiB0aGUgb3JpZW50YXRpb24gb2YgdGhlIHR3byBlbGVtZW50cy4gJ3NlZycsIHBhc3NlZCBpbiB0byB0aGlzIG1ldGhvZCwgdGVsbHMgeW91IHdoaWNoIHNlZ21lbnQgdGhlIHRhcmdldCBlbGVtZW50XG4gICAgLy8gbGllcyBpbiB3aXRoIHJlc3BlY3QgdG8gdGhlIHNvdXJjZTogMSBpcyB0b3AgcmlnaHQsIDIgaXMgYm90dG9tIHJpZ2h0LCAzIGlzIGJvdHRvbSBsZWZ0LCA0IGlzIHRvcCBsZWZ0LlxuICAgIC8vXG4gICAgLy8gc291cmNlUG9zIGFuZCB0YXJnZXRQb3MgYXJlIGFycmF5cyBvZiBpbmZvIGFib3V0IHdoZXJlIG9uIHRoZSBzb3VyY2UgYW5kIHRhcmdldCBlYWNoIGFuY2hvciBpcyBsb2NhdGVkLiAgdGhlaXIgY29udGVudHMgYXJlOlxuICAgIC8vXG4gICAgLy8gMCAtIGFic29sdXRlIHhcbiAgICAvLyAxIC0gYWJzb2x1dGUgeVxuICAgIC8vIDIgLSBwcm9wb3J0aW9uYWwgeCBpbiBlbGVtZW50ICgwIGlzIGxlZnQgZWRnZSwgMSBpcyByaWdodCBlZGdlKVxuICAgIC8vIDMgLSBwcm9wb3J0aW9uYWwgeSBpbiBlbGVtZW50ICgwIGlzIHRvcCBlZGdlLCAxIGlzIGJvdHRvbSBlZGdlKVxuICAgIC8vXG4gICAgICAgIF9maW5kQ29udHJvbFBvaW50ID0gZnVuY3Rpb24gKG1pZHgsIG1pZHksIHNlZ21lbnQsIHNvdXJjZUVkZ2UsIHRhcmdldEVkZ2UsIGR4LCBkeSwgZGlzdGFuY2UsIHByb3hpbWl0eUxpbWl0KSB7XG4gICAgICAgICAgICAvLyBUT0RPIChtYXliZSlcbiAgICAgICAgICAgIC8vIC0gaWYgYW5jaG9yIHBvcyBpcyAwLjUsIG1ha2UgdGhlIGNvbnRyb2wgcG9pbnQgdGFrZSBpbnRvIGFjY291bnQgdGhlIHJlbGF0aXZlIHBvc2l0aW9uIG9mIHRoZSBlbGVtZW50cy5cbiAgICAgICAgICAgIGlmIChkaXN0YW5jZSA8PSBwcm94aW1pdHlMaW1pdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbbWlkeCwgbWlkeV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzZWdtZW50ID09PSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZUVkZ2VbM10gPD0gMCAmJiB0YXJnZXRFZGdlWzNdID49IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsgbWlkeCArIChzb3VyY2VFZGdlWzJdIDwgMC41ID8gLTEgKiBkeCA6IGR4KSwgbWlkeSBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzb3VyY2VFZGdlWzJdID49IDEgJiYgdGFyZ2V0RWRnZVsyXSA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbIG1pZHgsIG1pZHkgKyAoc291cmNlRWRnZVszXSA8IDAuNSA/IC0xICogZHkgOiBkeSkgXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbIG1pZHggKyAoLTEgKiBkeCkgLCBtaWR5ICsgKC0xICogZHkpIF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc2VnbWVudCA9PT0gMikge1xuICAgICAgICAgICAgICAgIGlmIChzb3VyY2VFZGdlWzNdID49IDEgJiYgdGFyZ2V0RWRnZVszXSA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbIG1pZHggKyAoc291cmNlRWRnZVsyXSA8IDAuNSA/IC0xICogZHggOiBkeCksIG1pZHkgXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc291cmNlRWRnZVsyXSA+PSAxICYmIHRhcmdldEVkZ2VbMl0gPD0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyBtaWR4LCBtaWR5ICsgKHNvdXJjZUVkZ2VbM10gPCAwLjUgPyAtMSAqIGR5IDogZHkpIF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyBtaWR4ICsgZHgsIG1pZHkgKyAoLTEgKiBkeSkgXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzZWdtZW50ID09PSAzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZUVkZ2VbM10gPj0gMSAmJiB0YXJnZXRFZGdlWzNdIDw9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsgbWlkeCArIChzb3VyY2VFZGdlWzJdIDwgMC41ID8gLTEgKiBkeCA6IGR4KSwgbWlkeSBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzb3VyY2VFZGdlWzJdIDw9IDAgJiYgdGFyZ2V0RWRnZVsyXSA+PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbIG1pZHgsIG1pZHkgKyAoc291cmNlRWRnZVszXSA8IDAuNSA/IC0xICogZHkgOiBkeSkgXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbIG1pZHggKyAoLTEgKiBkeCkgLCBtaWR5ICsgKC0xICogZHkpIF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc2VnbWVudCA9PT0gNCkge1xuICAgICAgICAgICAgICAgIGlmIChzb3VyY2VFZGdlWzNdIDw9IDAgJiYgdGFyZ2V0RWRnZVszXSA+PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbIG1pZHggKyAoc291cmNlRWRnZVsyXSA8IDAuNSA/IC0xICogZHggOiBkeCksIG1pZHkgXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc291cmNlRWRnZVsyXSA8PSAwICYmIHRhcmdldEVkZ2VbMl0gPj0gMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyBtaWR4LCBtaWR5ICsgKHNvdXJjZUVkZ2VbM10gPCAwLjUgPyAtMSAqIGR5IDogZHkpIF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyBtaWR4ICsgZHggLCBtaWR5ICsgKC0xICogZHkpIF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH07XG5cbiAgICB2YXIgU3RhdGVNYWNoaW5lID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG4gICAgICAgIHRoaXMudHlwZSA9IFwiU3RhdGVNYWNoaW5lXCI7XG5cbiAgICAgICAgdmFyIF9zdXBlciA9IF9qcC5Db25uZWN0b3JzLkFic3RyYWN0QmV6aWVyQ29ubmVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksXG4gICAgICAgICAgICBjdXJ2aW5lc3MgPSBwYXJhbXMuY3VydmluZXNzIHx8IDEwLFxuICAgICAgICAgICAgbWFyZ2luID0gcGFyYW1zLm1hcmdpbiB8fCA1LFxuICAgICAgICAgICAgcHJveGltaXR5TGltaXQgPSBwYXJhbXMucHJveGltaXR5TGltaXQgfHwgODAsXG4gICAgICAgICAgICBjbG9ja3dpc2UgPSBwYXJhbXMub3JpZW50YXRpb24gJiYgcGFyYW1zLm9yaWVudGF0aW9uID09PSBcImNsb2Nrd2lzZVwiLFxuICAgICAgICAgICAgX2NvbnRyb2xQb2ludDtcblxuICAgICAgICB0aGlzLl9jb21wdXRlQmV6aWVyID0gZnVuY3Rpb24ocGFpbnRJbmZvLCBwYXJhbXMsIHNwLCB0cCwgdywgaCkge1xuICAgICAgICAgICAgdmFyIF9zeCA9IHBhcmFtcy5zb3VyY2VQb3NbMF0gPCBwYXJhbXMudGFyZ2V0UG9zWzBdID8gMCA6IHcsXG4gICAgICAgICAgICAgICAgX3N5ID0gcGFyYW1zLnNvdXJjZVBvc1sxXSA8IHBhcmFtcy50YXJnZXRQb3NbMV0gPyAwIDogaCxcbiAgICAgICAgICAgICAgICBfdHggPSBwYXJhbXMuc291cmNlUG9zWzBdIDwgcGFyYW1zLnRhcmdldFBvc1swXSA/IHcgOiAwLFxuICAgICAgICAgICAgICAgIF90eSA9IHBhcmFtcy5zb3VyY2VQb3NbMV0gPCBwYXJhbXMudGFyZ2V0UG9zWzFdID8gaCA6IDA7XG5cbiAgICAgICAgICAgIC8vIG5vdyBhZGp1c3QgZm9yIHRoZSBtYXJnaW5cbiAgICAgICAgICAgIGlmIChwYXJhbXMuc291cmNlUG9zWzJdID09PSAwKSB7XG4gICAgICAgICAgICAgICAgX3N4IC09IG1hcmdpbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXJhbXMuc291cmNlUG9zWzJdID09PSAxKSB7XG4gICAgICAgICAgICAgICAgX3N4ICs9IG1hcmdpbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXJhbXMuc291cmNlUG9zWzNdID09PSAwKSB7XG4gICAgICAgICAgICAgICAgX3N5IC09IG1hcmdpbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXJhbXMuc291cmNlUG9zWzNdID09PSAxKSB7XG4gICAgICAgICAgICAgICAgX3N5ICs9IG1hcmdpbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXJhbXMudGFyZ2V0UG9zWzJdID09PSAwKSB7XG4gICAgICAgICAgICAgICAgX3R4IC09IG1hcmdpbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXJhbXMudGFyZ2V0UG9zWzJdID09PSAxKSB7XG4gICAgICAgICAgICAgICAgX3R4ICs9IG1hcmdpbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXJhbXMudGFyZ2V0UG9zWzNdID09PSAwKSB7XG4gICAgICAgICAgICAgICAgX3R5IC09IG1hcmdpbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXJhbXMudGFyZ2V0UG9zWzNdID09PSAxKSB7XG4gICAgICAgICAgICAgICAgX3R5ICs9IG1hcmdpbjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIHRoZXNlIGNvbm5lY3RvcnMgYXJlIHF1YWRyYXRpYyBiZXppZXIgY3VydmVzLCBoYXZpbmcgYSBzaW5nbGUgY29udHJvbCBwb2ludC4gaWYgYm90aCBhbmNob3JzXG4gICAgICAgICAgICAvLyBhcmUgbG9jYXRlZCBhdCAwLjUgb24gdGhlaXIgcmVzcGVjdGl2ZSBmYWNlcywgdGhlIGNvbnRyb2wgcG9pbnQgaXMgc2V0IHRvIHRoZSBtaWRwb2ludCBhbmQgeW91XG4gICAgICAgICAgICAvLyBnZXQgYSBzdHJhaWdodCBsaW5lLiAgdGhpcyBpcyBhbHNvIHRoZSBjYXNlIGlmIHRoZSB0d28gYW5jaG9ycyBhcmUgd2l0aGluICdwcm94aW1pdHlMaW1pdCcsIHNpbmNlXG4gICAgICAgICAgICAvLyBpdCBzZWVtcyB0byBtYWtlIGdvb2QgYWVzdGhldGljIHNlbnNlIHRvIGRvIHRoYXQuIG91dHNpZGUgb2YgdGhhdCwgdGhlIGNvbnRyb2wgcG9pbnQgaXMgcG9zaXRpb25lZFxuICAgICAgICAgICAgLy8gYXQgJ2N1cnZpbmVzcycgcGl4ZWxzIGF3YXkgYWxvbmcgdGhlIG5vcm1hbCB0byB0aGUgc3RyYWlnaHQgbGluZSBjb25uZWN0aW5nIHRoZSB0d28gYW5jaG9ycy5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyB0aGVyZSBtYXkgYmUgdHdvIGltcHJvdmVtZW50cyB0byB0aGlzLiAgZmlyc3RseSwgd2UgbWlnaHQgYWN0dWFsbHkgc3VwcG9ydCB0aGUgbm90aW9uIG9mIGF2b2lkaW5nIG5vZGVzXG4gICAgICAgICAgICAvLyBpbiB0aGUgVUksIG9yIGF0IGxlYXN0IG1ha2luZyBhIGdvb2QgZWZmb3J0IGF0IGRvaW5nIHNvLiAgaWYgYSBjb25uZWN0aW9uIHdvdWxkIHBhc3MgdW5kZXJuZWF0aCBzb21lIG5vZGUsXG4gICAgICAgICAgICAvLyBmb3IgZXhhbXBsZSwgd2UgbWlnaHQgaW5jcmVhc2UgdGhlIGRpc3RhbmNlIHRoZSBjb250cm9sIHBvaW50IGlzIGF3YXkgZnJvbSB0aGUgbWlkcG9pbnQgaW4gYSBiaWQgdG9cbiAgICAgICAgICAgIC8vIHN0ZWVyIGl0IGFyb3VuZCB0aGF0IG5vZGUuICB0aGlzIHdpbGwgd29yayB3aXRoaW4gbGltaXRzLCBidXQgaSB0aGluayB0aG9zZSBsaW1pdHMgd291bGQgYWxzbyBiZSB0aGUgbGlrZWx5XG4gICAgICAgICAgICAvLyBsaW1pdHMgZm9yLCBvbmNlIGFnYWluLCBhZXN0aGV0aWMgZ29vZCBzZW5zZSBpbiB0aGUgbGF5b3V0IG9mIGEgY2hhcnQgdXNpbmcgdGhlc2UgY29ubmVjdG9ycy5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyB0aGUgc2Vjb25kIHBvc3NpYmxlIGNoYW5nZSBpcyBhY3R1YWxseSB0d28gcG9zc2libGUgY2hhbmdlczogZmlyc3RseSwgaXQgaXMgcG9zc2libGUgd2Ugc2hvdWxkIGdyYWR1YWxseVxuICAgICAgICAgICAgLy8gZGVjcmVhc2UgdGhlICdjdXJ2aW5lc3MnIGFzIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBhbmNob3JzIGRlY3JlYXNlczsgc3RhcnQgdGFpbGluZyBpdCBvZmYgdG8gMCBhdCBzb21lXG4gICAgICAgICAgICAvLyBwb2ludCAod2hpY2ggc2hvdWxkIGJlIGNvbmZpZ3VyYWJsZSkuICBzZWNvbmRseSwgd2UgbWlnaHQgc2xpZ2h0bHkgaW5jcmVhc2UgdGhlICdjdXJ2aW5lc3MnIGZvciBjb25uZWN0b3JzXG4gICAgICAgICAgICAvLyB3aXRoIHJlc3BlY3QgdG8gaG93IGZhciB0aGVpciBhbmNob3IgaXMgZnJvbSB0aGUgY2VudGVyIG9mIGl0cyByZXNwZWN0aXZlIGZhY2UuIHRoaXMgY291bGQgZWl0aGVyIGxvb2sgY29vbCxcbiAgICAgICAgICAgIC8vIG9yIHN0dXBpZCwgYW5kIG1heSBpbmRlZWQgd29yayBvbmx5IGluIGEgd2F5IHRoYXQgaXMgc28gc3VidGxlIGFzIHRvIGhhdmUgYmVlbiBhIHdhc3RlIG9mIHRpbWUuXG4gICAgICAgICAgICAvL1xuXG4gICAgICAgICAgICB2YXIgX21pZHggPSAoX3N4ICsgX3R4KSAvIDIsXG4gICAgICAgICAgICAgICAgX21pZHkgPSAoX3N5ICsgX3R5KSAvIDIsXG4gICAgICAgICAgICAgICAgc2VnbWVudCA9IF9zZWdtZW50KF9zeCwgX3N5LCBfdHgsIF90eSksXG4gICAgICAgICAgICAgICAgZGlzdGFuY2UgPSBNYXRoLnNxcnQoTWF0aC5wb3coX3R4IC0gX3N4LCAyKSArIE1hdGgucG93KF90eSAtIF9zeSwgMikpLFxuICAgICAgICAgICAgICAgIGNwMXgsIGNwMngsIGNwMXksIGNwMnksXG4gICAgICAgICAgICAgICAgZ2VvbWV0cnkgPSBfc3VwZXIuZ2V0R2VvbWV0cnkoKTtcblxuICAgICAgICAgICAgaWYgKCh0aGlzLmhhc0JlZW5FZGl0ZWQoKSB8fCB0aGlzLmlzRWRpdGluZygpKSAmJiBnZW9tZXRyeSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY3AxeCA9IGdlb21ldHJ5LmNvbnRyb2xQb2ludHNbMF1bMF07XG4gICAgICAgICAgICAgICAgY3AxeSA9IGdlb21ldHJ5LmNvbnRyb2xQb2ludHNbMF1bMV07XG4gICAgICAgICAgICAgICAgY3AyeCA9IGdlb21ldHJ5LmNvbnRyb2xQb2ludHNbMV1bMF07XG4gICAgICAgICAgICAgICAgY3AyeSA9IGdlb21ldHJ5LmNvbnRyb2xQb2ludHNbMV1bMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBjYWxjdWxhdGUgdGhlIGNvbnRyb2wgcG9pbnQuICB0aGlzIGNvZGUgd2lsbCBiZSB3aGVyZSB3ZSdsbCBwdXQgaW4gYSBydWRpbWVudGFyeSBlbGVtZW50IGF2b2lkYW5jZSBzY2hlbWU7IGl0XG4gICAgICAgICAgICAgICAgLy8gd2lsbCB3b3JrIGJ5IGV4dGVuZGluZyB0aGUgY29udHJvbCBwb2ludCB0byBmb3JjZSB0aGUgY3VydmUgdG8gYmUsIHVtLCBjdXJ2aWVyLlxuICAgICAgICAgICAgICAgIF9jb250cm9sUG9pbnQgPSBfZmluZENvbnRyb2xQb2ludChfbWlkeCxcbiAgICAgICAgICAgICAgICAgICAgX21pZHksXG4gICAgICAgICAgICAgICAgICAgIHNlZ21lbnQsXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcy5zb3VyY2VQb3MsXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcy50YXJnZXRQb3MsXG4gICAgICAgICAgICAgICAgICAgIGN1cnZpbmVzcywgY3VydmluZXNzLFxuICAgICAgICAgICAgICAgICAgICBkaXN0YW5jZSxcbiAgICAgICAgICAgICAgICAgICAgcHJveGltaXR5TGltaXQpO1xuXG4gICAgICAgICAgICAgICAgY3AxeCA9IF9jb250cm9sUG9pbnRbMF07XG4gICAgICAgICAgICAgICAgY3AyeCA9IF9jb250cm9sUG9pbnRbMF07XG4gICAgICAgICAgICAgICAgY3AxeSA9IF9jb250cm9sUG9pbnRbMV07XG4gICAgICAgICAgICAgICAgY3AyeSA9IF9jb250cm9sUG9pbnRbMV07XG5cbiAgICAgICAgICAgICAgICBfc3VwZXIuc2V0R2VvbWV0cnkoe2NvbnRyb2xQb2ludHM6W19jb250cm9sUG9pbnQsIF9jb250cm9sUG9pbnRdfSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9zdXBlci5hZGRTZWdtZW50KHRoaXMsIFwiQmV6aWVyXCIsIHtcbiAgICAgICAgICAgICAgICB4MTogX3R4LCB5MTogX3R5LCB4MjogX3N4LCB5MjogX3N5LFxuICAgICAgICAgICAgICAgIGNwMXg6IGNwMXgsIGNwMXk6IGNwMXksXG4gICAgICAgICAgICAgICAgY3AyeDogY3AyeCwgY3AyeTogY3AyeVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIF9qdS5leHRlbmQoU3RhdGVNYWNoaW5lLCBfanAuQ29ubmVjdG9ycy5BYnN0cmFjdEJlemllckNvbm5lY3Rvcik7XG4gICAgX2pwLnJlZ2lzdGVyQ29ubmVjdG9yVHlwZShTdGF0ZU1hY2hpbmUsIFwiU3RhdGVNYWNoaW5lXCIpO1xuXG59KS5jYWxsKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdGhpcyk7XG4vKlxuICoganNQbHVtYiBDb21tdW5pdHkgRWRpdGlvblxuICpcbiAqIFByb3ZpZGVzIGEgd2F5IHRvIHZpc3VhbGx5IGNvbm5lY3QgZWxlbWVudHMgb24gYW4gSFRNTCBwYWdlLCB1c2luZyBTVkcuXG4gKlxuICogVGhpcyBmaWxlIGNvbnRhaW5zIHRoZSAnZmxvd2NoYXJ0JyBjb25uZWN0b3JzLCBjb25zaXN0aW5nIG9mIHZlcnRpY2FsIGFuZCBob3Jpem9udGFsIGxpbmUgc2VnbWVudHMuXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEwIC0gMjAxNyBqc1BsdW1iIChoZWxsb0Bqc3BsdW1idG9vbGtpdC5jb20pXG4gKlxuICogaHR0cHM6Ly9qc3BsdW1idG9vbGtpdC5jb21cbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9qc3BsdW1iL2pzcGx1bWJcbiAqXG4gKiBEdWFsIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgYW5kIEdQTDIgbGljZW5zZXMuXG4gKi9cbjtcbihmdW5jdGlvbiAoKSB7XG5cbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgcm9vdCA9IHRoaXMsIF9qcCA9IHJvb3QuanNQbHVtYiwgX2p1ID0gcm9vdC5qc1BsdW1iVXRpbDtcbiAgICB2YXIgU1RSQUlHSFQgPSBcIlN0cmFpZ2h0XCI7XG5cbiAgICB2YXIgU3RyYWlnaHQgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgIHRoaXMudHlwZSA9IFNUUkFJR0hUO1xuICAgICAgICB2YXIgX3N1cGVyID0gX2pwLkNvbm5lY3RvcnMuQWJzdHJhY3RDb25uZWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgICAgICB0aGlzLl9jb21wdXRlID0gZnVuY3Rpb24gKHBhaW50SW5mbywgXykge1xuICAgICAgICAgICAgX3N1cGVyLmFkZFNlZ21lbnQodGhpcywgU1RSQUlHSFQsIHt4MTogcGFpbnRJbmZvLnN4LCB5MTogcGFpbnRJbmZvLnN5LCB4MjogcGFpbnRJbmZvLnN0YXJ0U3R1YlgsIHkyOiBwYWludEluZm8uc3RhcnRTdHViWX0pO1xuICAgICAgICAgICAgX3N1cGVyLmFkZFNlZ21lbnQodGhpcywgU1RSQUlHSFQsIHt4MTogcGFpbnRJbmZvLnN0YXJ0U3R1YlgsIHkxOiBwYWludEluZm8uc3RhcnRTdHViWSwgeDI6IHBhaW50SW5mby5lbmRTdHViWCwgeTI6IHBhaW50SW5mby5lbmRTdHViWX0pO1xuICAgICAgICAgICAgX3N1cGVyLmFkZFNlZ21lbnQodGhpcywgU1RSQUlHSFQsIHt4MTogcGFpbnRJbmZvLmVuZFN0dWJYLCB5MTogcGFpbnRJbmZvLmVuZFN0dWJZLCB4MjogcGFpbnRJbmZvLnR4LCB5MjogcGFpbnRJbmZvLnR5fSk7XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIF9qdS5leHRlbmQoU3RyYWlnaHQsIF9qcC5Db25uZWN0b3JzLkFic3RyYWN0Q29ubmVjdG9yKTtcbiAgICBfanAucmVnaXN0ZXJDb25uZWN0b3JUeXBlKFN0cmFpZ2h0LCBTVFJBSUdIVCk7XG5cbn0pLmNhbGwodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB0aGlzKTtcbi8qXG4gKiBqc1BsdW1iIENvbW11bml0eSBFZGl0aW9uXG4gKiBcbiAqIFByb3ZpZGVzIGEgd2F5IHRvIHZpc3VhbGx5IGNvbm5lY3QgZWxlbWVudHMgb24gYW4gSFRNTCBwYWdlLCB1c2luZyBTVkcuXG4gKiBcbiAqIFRoaXMgZmlsZSBjb250YWlucyB0aGUgU1ZHIHJlbmRlcmVycy5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTAgLSAyMDE3IGpzUGx1bWIgKGhlbGxvQGpzcGx1bWJ0b29sa2l0LmNvbSlcbiAqIFxuICogaHR0cHM6Ly9qc3BsdW1idG9vbGtpdC5jb21cbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9qc3BsdW1iL2pzcGx1bWJcbiAqIFxuICogRHVhbCBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGFuZCBHUEwyIGxpY2Vuc2VzLlxuICovXG47XG4oZnVuY3Rpb24gKCkge1xuXG4vLyAqKioqKioqKioqKioqKioqKioqKioqKioqKiBTVkcgdXRpbGl0eSBtZXRob2RzICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHRcblxuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciByb290ID0gdGhpcywgX2pwID0gcm9vdC5qc1BsdW1iLCBfanUgPSByb290LmpzUGx1bWJVdGlsO1xuXG4gICAgdmFyIHN2Z0F0dHJpYnV0ZU1hcCA9IHtcbiAgICAgICAgICAgIFwic3Ryb2tlLWxpbmVqb2luXCI6IFwic3Ryb2tlLWxpbmVqb2luXCIsXG4gICAgICAgICAgICBcInN0cm9rZS1kYXNob2Zmc2V0XCI6IFwic3Ryb2tlLWRhc2hvZmZzZXRcIixcbiAgICAgICAgICAgIFwic3Ryb2tlLWxpbmVjYXBcIjogXCJzdHJva2UtbGluZWNhcFwiXG4gICAgICAgIH0sXG4gICAgICAgIFNUUk9LRV9EQVNIQVJSQVkgPSBcInN0cm9rZS1kYXNoYXJyYXlcIixcbiAgICAgICAgREFTSFNUWUxFID0gXCJkYXNoc3R5bGVcIixcbiAgICAgICAgTElORUFSX0dSQURJRU5UID0gXCJsaW5lYXJHcmFkaWVudFwiLFxuICAgICAgICBSQURJQUxfR1JBRElFTlQgPSBcInJhZGlhbEdyYWRpZW50XCIsXG4gICAgICAgIERFRlMgPSBcImRlZnNcIixcbiAgICAgICAgRklMTCA9IFwiZmlsbFwiLFxuICAgICAgICBTVE9QID0gXCJzdG9wXCIsXG4gICAgICAgIFNUUk9LRSA9IFwic3Ryb2tlXCIsXG4gICAgICAgIFNUUk9LRV9XSURUSCA9IFwic3Ryb2tlLXdpZHRoXCIsXG4gICAgICAgIFNUWUxFID0gXCJzdHlsZVwiLFxuICAgICAgICBOT05FID0gXCJub25lXCIsXG4gICAgICAgIEpTUExVTUJfR1JBRElFTlQgPSBcImpzcGx1bWJfZ3JhZGllbnRfXCIsXG4gICAgICAgIExJTkVfV0lEVEggPSBcInN0cm9rZVdpZHRoXCIsXG4gICAgICAgIG5zID0ge1xuICAgICAgICAgICAgc3ZnOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCJcbiAgICAgICAgfSxcbiAgICAgICAgX2F0dHIgPSBmdW5jdGlvbiAobm9kZSwgYXR0cmlidXRlcykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoaSwgXCJcIiArIGF0dHJpYnV0ZXNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBfbm9kZSA9IGZ1bmN0aW9uIChuYW1lLCBhdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICBhdHRyaWJ1dGVzID0gYXR0cmlidXRlcyB8fCB7fTtcbiAgICAgICAgICAgIGF0dHJpYnV0ZXMudmVyc2lvbiA9IFwiMS4xXCI7XG4gICAgICAgICAgICBhdHRyaWJ1dGVzLnhtbG5zID0gbnMuc3ZnO1xuICAgICAgICAgICAgcmV0dXJuIF9qcC5jcmVhdGVFbGVtZW50TlMobnMuc3ZnLCBuYW1lLCBudWxsLCBudWxsLCBhdHRyaWJ1dGVzKTtcbiAgICAgICAgfSxcbiAgICAgICAgX3BvcyA9IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0OlwiICsgZFswXSArIFwicHg7dG9wOlwiICsgZFsxXSArIFwicHhcIjtcbiAgICAgICAgfSxcbiAgICAgICAgX2NsZWFyR3JhZGllbnQgPSBmdW5jdGlvbiAocGFyZW50KSB7XG4gICAgICAgICAgICB2YXIgZWxzID0gcGFyZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIgZGVmcyxsaW5lYXJHcmFkaWVudCxyYWRpYWxHcmFkaWVudFwiKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZWxzW2ldLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWxzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgX3VwZGF0ZUdyYWRpZW50ID0gZnVuY3Rpb24gKHBhcmVudCwgbm9kZSwgc3R5bGUsIGRpbWVuc2lvbnMsIHVpQ29tcG9uZW50KSB7XG4gICAgICAgICAgICB2YXIgaWQgPSBKU1BMVU1CX0dSQURJRU5UICsgdWlDb21wb25lbnQuX2pzUGx1bWIuaW5zdGFuY2UuaWRzdGFtcCgpO1xuICAgICAgICAgICAgLy8gZmlyc3QgY2xlYXIgb3V0IGFueSBleGlzdGluZyBncmFkaWVudFxuICAgICAgICAgICAgX2NsZWFyR3JhZGllbnQocGFyZW50KTtcbiAgICAgICAgICAgIC8vIHRoaXMgY2hlY2tzIGZvciBhbiAnb2Zmc2V0JyBwcm9wZXJ0eSBpbiB0aGUgZ3JhZGllbnQsIGFuZCBpbiB0aGUgYWJzZW5jZSBvZiBpdCwgYXNzdW1lc1xuICAgICAgICAgICAgLy8gd2Ugd2FudCBhIGxpbmVhciBncmFkaWVudC4gaWYgaXQncyB0aGVyZSwgd2UgY3JlYXRlIGEgcmFkaWFsIGdyYWRpZW50LlxuICAgICAgICAgICAgLy8gaXQgaXMgcG9zc2libGUgdGhhdCBhIG1vcmUgZXhwbGljaXQgbWVhbnMgb2YgZGVmaW5pbmcgdGhlIGdyYWRpZW50IHR5cGUgd291bGQgYmVcbiAgICAgICAgICAgIC8vIGJldHRlci4gcmVseWluZyBvbiAnb2Zmc2V0JyBtZWFucyB0aGF0IHdlIGNhbiBuZXZlciBoYXZlIGEgcmFkaWFsIGdyYWRpZW50IHRoYXQgdXNlc1xuICAgICAgICAgICAgLy8gc29tZSBkZWZhdWx0IG9mZnNldCwgZm9yIGluc3RhbmNlLlxuICAgICAgICAgICAgLy8gaXNzdWUgMjQ0IHN1Z2dlc3RlZCB0aGUgJ2dyYWRpZW50VW5pdHMnIGF0dHJpYnV0ZTsgd2l0aG91dCB0aGlzLCBzdHJhaWdodC9mbG93Y2hhcnQgY29ubmVjdG9ycyB3aXRoIGdyYWRpZW50cyB3b3VsZFxuICAgICAgICAgICAgLy8gbm90IHNob3cgZ3JhZGllbnRzIHdoZW4gdGhlIGxpbmUgd2FzIHBlcmZlY3RseSBob3Jpem9udGFsIG9yIHZlcnRpY2FsLlxuICAgICAgICAgICAgdmFyIGc7XG4gICAgICAgICAgICBpZiAoIXN0eWxlLmdyYWRpZW50Lm9mZnNldCkge1xuICAgICAgICAgICAgICAgIGcgPSBfbm9kZShMSU5FQVJfR1JBRElFTlQsIHtpZDogaWQsIGdyYWRpZW50VW5pdHM6IFwidXNlclNwYWNlT25Vc2VcIn0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZyA9IF9ub2RlKFJBRElBTF9HUkFESUVOVCwgeyBpZDogaWQgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBkZWZzID0gX25vZGUoREVGUyk7XG4gICAgICAgICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoZGVmcyk7XG4gICAgICAgICAgICBkZWZzLmFwcGVuZENoaWxkKGcpO1xuXG4gICAgICAgICAgICAvLyB0aGUgc3ZnIHJhZGlhbCBncmFkaWVudCBzZWVtcyB0byB0cmVhdCBzdG9wcyBpbiB0aGUgcmV2ZXJzZVxuICAgICAgICAgICAgLy8gb3JkZXIgdG8gaG93IGNhbnZhcyBkb2VzIGl0LiAgc28gd2Ugd2FudCB0byBrZWVwIGFsbCB0aGUgbWF0aHMgdGhlIHNhbWUsIGJ1dFxuICAgICAgICAgICAgLy8gaXRlcmF0ZSB0aGUgYWN0dWFsIHN0eWxlIGRlY2xhcmF0aW9ucyBpbiByZXZlcnNlIG9yZGVyLCBpZiB0aGUgeCBpbmRleGVzIGFyZSBub3QgaW4gb3JkZXIuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlLmdyYWRpZW50LnN0b3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0eWxlVG9Vc2UgPSB1aUNvbXBvbmVudC5zZWdtZW50ID09PSAxIHx8IHVpQ29tcG9uZW50LnNlZ21lbnQgPT09IDIgPyBpIDogc3R5bGUuZ3JhZGllbnQuc3RvcHMubGVuZ3RoIC0gMSAtIGksXG4gICAgICAgICAgICAgICAgICAgIHN0b3BDb2xvciA9IHN0eWxlLmdyYWRpZW50LnN0b3BzW3N0eWxlVG9Vc2VdWzFdLFxuICAgICAgICAgICAgICAgICAgICBzID0gX25vZGUoU1RPUCwge1wib2Zmc2V0XCI6IE1hdGguZmxvb3Ioc3R5bGUuZ3JhZGllbnQuc3RvcHNbaV1bMF0gKiAxMDApICsgXCIlXCIsIFwic3RvcC1jb2xvclwiOiBzdG9wQ29sb3J9KTtcblxuICAgICAgICAgICAgICAgIGcuYXBwZW5kQ2hpbGQocyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgYXBwbHlHcmFkaWVudFRvID0gc3R5bGUuc3Ryb2tlID8gU1RST0tFIDogRklMTDtcbiAgICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKGFwcGx5R3JhZGllbnRUbywgXCJ1cmwoI1wiICsgaWQgKyBcIilcIik7XG4gICAgICAgIH0sXG4gICAgICAgIF9hcHBseVN0eWxlcyA9IGZ1bmN0aW9uIChwYXJlbnQsIG5vZGUsIHN0eWxlLCBkaW1lbnNpb25zLCB1aUNvbXBvbmVudCkge1xuXG4gICAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShGSUxMLCBzdHlsZS5maWxsID8gc3R5bGUuZmlsbCA6IE5PTkUpO1xuICAgICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoU1RST0tFLCBzdHlsZS5zdHJva2UgPyBzdHlsZS5zdHJva2UgOiBOT05FKTtcblxuICAgICAgICAgICAgaWYgKHN0eWxlLmdyYWRpZW50KSB7XG4gICAgICAgICAgICAgICAgX3VwZGF0ZUdyYWRpZW50KHBhcmVudCwgbm9kZSwgc3R5bGUsIGRpbWVuc2lvbnMsIHVpQ29tcG9uZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSB3ZSBjbGVhciBhbnkgZXhpc3RpbmcgZ3JhZGllbnRcbiAgICAgICAgICAgICAgICBfY2xlYXJHcmFkaWVudChwYXJlbnQpO1xuICAgICAgICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFNUWUxFLCBcIlwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHN0eWxlLnN0cm9rZVdpZHRoKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoU1RST0tFX1dJRFRILCBzdHlsZS5zdHJva2VXaWR0aCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGluIFNWRyB0aGVyZSBpcyBhIHN0cm9rZS1kYXNoYXJyYXkgYXR0cmlidXRlIHdlIGNhbiBzZXQsIGFuZCBpdHMgc3ludGF4IGxvb2tzIGxpa2VcbiAgICAgICAgICAgIC8vIHRoZSBzeW50YXggaW4gVk1MIGJ1dCBpcyBhY3R1YWxseSBraW5kIG9mIG5hc3R5OiB2YWx1ZXMgYXJlIGdpdmVuIGluIHRoZSBwaXhlbFxuICAgICAgICAgICAgLy8gY29vcmRpbmF0ZSBzcGFjZSwgd2hlcmVhcyBpbiBWTUwgdGhleSBhcmUgbXVsdGlwbGVzIG9mIHRoZSB3aWR0aCBvZiB0aGUgc3Ryb2tlZFxuICAgICAgICAgICAgLy8gbGluZSwgd2hpY2ggbWFrZXMgYSBsb3QgbW9yZSBzZW5zZS4gIGZvciB0aGF0IHJlYXNvbiwganNQbHVtYiBpcyBzdXBwb3J0aW5nIGJvdGhcbiAgICAgICAgICAgIC8vIHRoZSBuYXRpdmUgc3ZnICdzdHJva2UtZGFzaGFycmF5JyBhdHRyaWJ1dGUsIGFuZCBhbHNvIHRoZSAnZGFzaHN0eWxlJyBjb25jZXB0IGZyb21cbiAgICAgICAgICAgIC8vIFZNTCwgd2hpY2ggd2lsbCBiZSB0aGUgcHJlZmVycmVkIG1ldGhvZC4gIHRoZSBjb2RlIGJlbG93IHRoaXMgY29udmVydHMgYSBkYXNoc3R5bGVcbiAgICAgICAgICAgIC8vIGF0dHJpYnV0ZSBnaXZlbiBpbiB0ZXJtcyBvZiBzdHJva2Ugd2lkdGggaW50byBhIHBpeGVsIHJlcHJlc2VudGF0aW9uLCBieSB1c2luZyB0aGVcbiAgICAgICAgICAgIC8vIHN0cm9rZSdzIGxpbmVXaWR0aC5cbiAgICAgICAgICAgIGlmIChzdHlsZVtEQVNIU1RZTEVdICYmIHN0eWxlW0xJTkVfV0lEVEhdICYmICFzdHlsZVtTVFJPS0VfREFTSEFSUkFZXSkge1xuICAgICAgICAgICAgICAgIHZhciBzZXAgPSBzdHlsZVtEQVNIU1RZTEVdLmluZGV4T2YoXCIsXCIpID09PSAtMSA/IFwiIFwiIDogXCIsXCIsXG4gICAgICAgICAgICAgICAgICAgIHBhcnRzID0gc3R5bGVbREFTSFNUWUxFXS5zcGxpdChzZXApLFxuICAgICAgICAgICAgICAgICAgICBzdHlsZVRvVXNlID0gXCJcIjtcbiAgICAgICAgICAgICAgICBwYXJ0cy5mb3JFYWNoKGZ1bmN0aW9uIChwKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlVG9Vc2UgKz0gKE1hdGguZmxvb3IocCAqIHN0eWxlLnN0cm9rZVdpZHRoKSArIHNlcCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoU1RST0tFX0RBU0hBUlJBWSwgc3R5bGVUb1VzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzdHlsZVtTVFJPS0VfREFTSEFSUkFZXSkge1xuICAgICAgICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFNUUk9LRV9EQVNIQVJSQVksIHN0eWxlW1NUUk9LRV9EQVNIQVJSQVldKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZXh0cmEgYXR0cmlidXRlcyBzdWNoIGFzIGpvaW4gdHlwZSwgZGFzaCBvZmZzZXQuXG4gICAgICAgICAgICBmb3IgKHZhciBpIGluIHN2Z0F0dHJpYnV0ZU1hcCkge1xuICAgICAgICAgICAgICAgIGlmIChzdHlsZVtpXSkge1xuICAgICAgICAgICAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShzdmdBdHRyaWJ1dGVNYXBbaV0sIHN0eWxlW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIF9hcHBlbmRBdEluZGV4ID0gZnVuY3Rpb24gKHN2ZywgcGF0aCwgaWR4KSB7XG4gICAgICAgICAgICBpZiAoc3ZnLmNoaWxkTm9kZXMubGVuZ3RoID4gaWR4KSB7XG4gICAgICAgICAgICAgICAgc3ZnLmluc2VydEJlZm9yZShwYXRoLCBzdmcuY2hpbGROb2Rlc1tpZHhdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN2Zy5hcHBlbmRDaGlsZChwYXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgIC8qKlxuICAgICB1dGlsaXR5IG1ldGhvZHMgZm9yIG90aGVyIG9iamVjdHMgdG8gdXNlLlxuICAgICAqL1xuICAgIF9qdS5zdmcgPSB7XG4gICAgICAgIG5vZGU6IF9ub2RlLFxuICAgICAgICBhdHRyOiBfYXR0cixcbiAgICAgICAgcG9zOiBfcG9zXG4gICAgfTtcblxuICAgIC8vICoqKioqKioqKioqKioqKioqKioqKioqKioqIC8gU1ZHIHV0aWxpdHkgbWV0aG9kcyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXG4gICAgLypcbiAgICAgKiBCYXNlIGNsYXNzIGZvciBTVkcgY29tcG9uZW50cy5cbiAgICAgKi9cbiAgICB2YXIgU3ZnQ29tcG9uZW50ID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICB2YXIgcG9pbnRlckV2ZW50c1NwZWMgPSBwYXJhbXMucG9pbnRlckV2ZW50c1NwZWMgfHwgXCJhbGxcIiwgcmVuZGVyZXIgPSB7fTtcblxuICAgICAgICBfanAuanNQbHVtYlVJQ29tcG9uZW50LmFwcGx5KHRoaXMsIHBhcmFtcy5vcmlnaW5hbEFyZ3MpO1xuICAgICAgICB0aGlzLmNhbnZhcyA9IG51bGw7XG4gICAgICAgIHRoaXMucGF0aCA9IG51bGw7XG4gICAgICAgIHRoaXMuc3ZnID0gbnVsbDtcbiAgICAgICAgdGhpcy5iZ0NhbnZhcyA9IG51bGw7XG5cbiAgICAgICAgdmFyIGNsYXp6ID0gcGFyYW1zLmNzc0NsYXNzICsgXCIgXCIgKyAocGFyYW1zLm9yaWdpbmFsQXJnc1swXS5jc3NDbGFzcyB8fCBcIlwiKSxcbiAgICAgICAgICAgIHN2Z1BhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBcInN0eWxlXCI6IFwiXCIsXG4gICAgICAgICAgICAgICAgXCJ3aWR0aFwiOiAwLFxuICAgICAgICAgICAgICAgIFwiaGVpZ2h0XCI6IDAsXG4gICAgICAgICAgICAgICAgXCJwb2ludGVyLWV2ZW50c1wiOiBwb2ludGVyRXZlbnRzU3BlYyxcbiAgICAgICAgICAgICAgICBcInBvc2l0aW9uXCI6IFwiYWJzb2x1dGVcIlxuICAgICAgICAgICAgfTtcblxuICAgICAgICB0aGlzLnN2ZyA9IF9ub2RlKFwic3ZnXCIsIHN2Z1BhcmFtcyk7XG5cbiAgICAgICAgaWYgKHBhcmFtcy51c2VEaXZXcmFwcGVyKSB7XG4gICAgICAgICAgICB0aGlzLmNhbnZhcyA9IF9qcC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgcG9zaXRpb24gOiBcImFic29sdXRlXCIgfSk7XG4gICAgICAgICAgICBfanUuc2l6ZUVsZW1lbnQodGhpcy5jYW52YXMsIDAsIDAsIDEsIDEpO1xuICAgICAgICAgICAgdGhpcy5jYW52YXMuY2xhc3NOYW1lID0gY2xheno7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBfYXR0cih0aGlzLnN2ZywgeyBcImNsYXNzXCI6IGNsYXp6IH0pO1xuICAgICAgICAgICAgdGhpcy5jYW52YXMgPSB0aGlzLnN2ZztcbiAgICAgICAgfVxuXG4gICAgICAgIHBhcmFtcy5fanNQbHVtYi5hcHBlbmRFbGVtZW50KHRoaXMuY2FudmFzLCBwYXJhbXMub3JpZ2luYWxBcmdzWzBdLnBhcmVudCk7XG4gICAgICAgIGlmIChwYXJhbXMudXNlRGl2V3JhcHBlcikge1xuICAgICAgICAgICAgdGhpcy5jYW52YXMuYXBwZW5kQ2hpbGQodGhpcy5zdmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRpc3BsYXlFbGVtZW50cyA9IFsgdGhpcy5jYW52YXMgXTtcbiAgICAgICAgdGhpcy5nZXREaXNwbGF5RWxlbWVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gZGlzcGxheUVsZW1lbnRzO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuYXBwZW5kRGlzcGxheUVsZW1lbnQgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIGRpc3BsYXlFbGVtZW50cy5wdXNoKGVsKTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLnBhaW50ID0gZnVuY3Rpb24gKHN0eWxlLCBhbmNob3IsIGV4dGVudHMpIHtcbiAgICAgICAgICAgIGlmIChzdHlsZSAhPSBudWxsKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgeHkgPSBbIHRoaXMueCwgdGhpcy55IF0sIHdoID0gWyB0aGlzLncsIHRoaXMuaCBdLCBwO1xuICAgICAgICAgICAgICAgIGlmIChleHRlbnRzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4dGVudHMueG1pbiA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHh5WzBdICs9IGV4dGVudHMueG1pbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZXh0ZW50cy55bWluIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgeHlbMV0gKz0gZXh0ZW50cy55bWluO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHdoWzBdID0gZXh0ZW50cy54bWF4ICsgKChleHRlbnRzLnhtaW4gPCAwKSA/IC1leHRlbnRzLnhtaW4gOiAwKTtcbiAgICAgICAgICAgICAgICAgICAgd2hbMV0gPSBleHRlbnRzLnltYXggKyAoKGV4dGVudHMueW1pbiA8IDApID8gLWV4dGVudHMueW1pbiA6IDApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChwYXJhbXMudXNlRGl2V3JhcHBlcikge1xuICAgICAgICAgICAgICAgICAgICBfanUuc2l6ZUVsZW1lbnQodGhpcy5jYW52YXMsIHh5WzBdLCB4eVsxXSwgd2hbMF0sIHdoWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgeHlbMF0gPSAwO1xuICAgICAgICAgICAgICAgICAgICB4eVsxXSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHAgPSBfcG9zKFsgMCwgMCBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHAgPSBfcG9zKFsgeHlbMF0sIHh5WzFdIF0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJlbmRlcmVyLnBhaW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgICAgICBfYXR0cih0aGlzLnN2Zywge1xuICAgICAgICAgICAgICAgICAgICBcInN0eWxlXCI6IHAsXG4gICAgICAgICAgICAgICAgICAgIFwid2lkdGhcIjogd2hbMF0gfHwgMCxcbiAgICAgICAgICAgICAgICAgICAgXCJoZWlnaHRcIjogd2hbMV0gfHwgMFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZW5kZXJlcjogcmVuZGVyZXJcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgX2p1LmV4dGVuZChTdmdDb21wb25lbnQsIF9qcC5qc1BsdW1iVUlDb21wb25lbnQsIHtcbiAgICAgICAgY2xlYW51cDogZnVuY3Rpb24gKGZvcmNlKSB7XG4gICAgICAgICAgICBpZiAoZm9yY2UgfHwgdGhpcy50eXBlSWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNhbnZhcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbnZhcy5fanNQbHVtYiA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN2Zykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN2Zy5fanNQbHVtYiA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmJnQ2FudmFzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYmdDYW52YXMuX2pzUGx1bWIgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNhbnZhcyAmJiB0aGlzLmNhbnZhcy5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5jYW52YXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5iZ0NhbnZhcyAmJiB0aGlzLmJnQ2FudmFzLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYW52YXMucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmNhbnZhcyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5zdmcgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLnBhdGggPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXAgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgbm90IGEgZm9yY2VkIGNsZWFudXAsIGp1c3QgZGV0YWNoIGZyb20gRE9NIGZvciBub3cuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2FudmFzICYmIHRoaXMuY2FudmFzLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYW52YXMucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmNhbnZhcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmJnQ2FudmFzICYmIHRoaXMuYmdDYW52YXMucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmJnQ2FudmFzLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5iZ0NhbnZhcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICByZWF0dGFjaDpmdW5jdGlvbihpbnN0YW5jZSkge1xuICAgICAgICAgICAgdmFyIGMgPSBpbnN0YW5jZS5nZXRDb250YWluZXIoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNhbnZhcyAmJiB0aGlzLmNhbnZhcy5wYXJlbnROb2RlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjLmFwcGVuZENoaWxkKHRoaXMuY2FudmFzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmJnQ2FudmFzICYmIHRoaXMuYmdDYW52YXMucGFyZW50Tm9kZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYy5hcHBlbmRDaGlsZCh0aGlzLmJnQ2FudmFzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc2V0VmlzaWJsZTogZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNhbnZhcykge1xuICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzLnN0eWxlLmRpc3BsYXkgPSB2ID8gXCJibG9ja1wiIDogXCJub25lXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qXG4gICAgICogQmFzZSBjbGFzcyBmb3IgU1ZHIGNvbm5lY3RvcnMuXG4gICAgICovXG4gICAgX2pwLkNvbm5lY3RvclJlbmRlcmVycy5zdmcgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgICAgIF9zdXBlciA9IFN2Z0NvbXBvbmVudC5hcHBseSh0aGlzLCBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBjc3NDbGFzczogcGFyYW1zLl9qc1BsdW1iLmNvbm5lY3RvckNsYXNzICsgKHRoaXMuaXNFZGl0YWJsZSgpID8gXCIgXCIgKyBwYXJhbXMuX2pzUGx1bWIuZWRpdGFibGVDb25uZWN0b3JDbGFzcyA6IFwiXCIpLFxuICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbEFyZ3M6IGFyZ3VtZW50cyxcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRlckV2ZW50c1NwZWM6IFwibm9uZVwiLFxuICAgICAgICAgICAgICAgICAgICBfanNQbHVtYjogcGFyYW1zLl9qc1BsdW1iXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXSk7XG5cbiAgICAgICAgdmFyIF9zdXBlclNldEVkaXRhYmxlID0gdGhpcy5zZXRFZGl0YWJsZTtcbiAgICAgICAgdGhpcy5zZXRFZGl0YWJsZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBfc3VwZXJTZXRFZGl0YWJsZS5hcHBseSh0aGlzLCBbZV0pO1xuICAgICAgICAgICAgX2pwW3Jlc3VsdCA/IFwiYWRkQ2xhc3NcIiA6IFwicmVtb3ZlQ2xhc3NcIl0odGhpcy5jYW52YXMsIHRoaXMuX2pzUGx1bWIuaW5zdGFuY2UuZWRpdGFibGVDb25uZWN0b3JDbGFzcyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgX3N1cGVyLnJlbmRlcmVyLnBhaW50ID0gZnVuY3Rpb24gKHN0eWxlLCBhbmNob3IsIGV4dGVudHMpIHtcblxuICAgICAgICAgICAgdmFyIHNlZ21lbnRzID0gc2VsZi5nZXRTZWdtZW50cygpLCBwID0gXCJcIiwgb2Zmc2V0ID0gWzAsIDBdO1xuICAgICAgICAgICAgaWYgKGV4dGVudHMueG1pbiA8IDApIHtcbiAgICAgICAgICAgICAgICBvZmZzZXRbMF0gPSAtZXh0ZW50cy54bWluO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGV4dGVudHMueW1pbiA8IDApIHtcbiAgICAgICAgICAgICAgICBvZmZzZXRbMV0gPSAtZXh0ZW50cy55bWluO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2VnbWVudHMubGVuZ3RoID4gMCkge1xuXG4gICAgICAgICAgICAgICAgcCA9IHNlbGYuZ2V0UGF0aERhdGEoKTtcblxuICAgICAgICAgICAgICAgIHZhciBhID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZDogcCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogXCJ0cmFuc2xhdGUoXCIgKyBvZmZzZXRbMF0gKyBcIixcIiArIG9mZnNldFsxXSArIFwiKVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJwb2ludGVyLWV2ZW50c1wiOiBwYXJhbXNbXCJwb2ludGVyLWV2ZW50c1wiXSB8fCBcInZpc2libGVTdHJva2VcIlxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBvdXRsaW5lU3R5bGUgPSBudWxsLFxuICAgICAgICAgICAgICAgICAgICBkID0gW3NlbGYueCwgc2VsZi55LCBzZWxmLncsIHNlbGYuaF07XG5cbiAgICAgICAgICAgICAgICAvLyBvdXRsaW5lIHN0eWxlLiAgYWN0dWFsbHkgbWVhbnMgZHJhd2luZyBhbiBzdmcgb2JqZWN0IHVuZGVybmVhdGggdGhlIG1haW4gb25lLlxuICAgICAgICAgICAgICAgIGlmIChzdHlsZS5vdXRsaW5lU3Ryb2tlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvdXRsaW5lV2lkdGggPSBzdHlsZS5vdXRsaW5lV2lkdGggfHwgMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dGxpbmVTdHJva2VXaWR0aCA9IHN0eWxlLnN0cm9rZVdpZHRoICsgKDIgKiBvdXRsaW5lV2lkdGgpO1xuICAgICAgICAgICAgICAgICAgICBvdXRsaW5lU3R5bGUgPSBfanAuZXh0ZW5kKHt9LCBzdHlsZSk7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvdXRsaW5lU3R5bGUuZ3JhZGllbnQ7XG4gICAgICAgICAgICAgICAgICAgIG91dGxpbmVTdHlsZS5zdHJva2UgPSBzdHlsZS5vdXRsaW5lU3Ryb2tlO1xuICAgICAgICAgICAgICAgICAgICBvdXRsaW5lU3R5bGUuc3Ryb2tlV2lkdGggPSBvdXRsaW5lU3Ryb2tlV2lkdGg7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuYmdQYXRoID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuYmdQYXRoID0gX25vZGUoXCJwYXRoXCIsIGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2pwLmFkZENsYXNzKHNlbGYuYmdQYXRoLCBfanAuY29ubmVjdG9yT3V0bGluZUNsYXNzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hcHBlbmRBdEluZGV4KHNlbGYuc3ZnLCBzZWxmLmJnUGF0aCwgMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYXR0cihzZWxmLmJnUGF0aCwgYSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBfYXBwbHlTdHlsZXMoc2VsZi5zdmcsIHNlbGYuYmdQYXRoLCBvdXRsaW5lU3R5bGUsIGQsIHNlbGYpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChzZWxmLnBhdGggPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnBhdGggPSBfbm9kZShcInBhdGhcIiwgYSk7XG4gICAgICAgICAgICAgICAgICAgIF9hcHBlbmRBdEluZGV4KHNlbGYuc3ZnLCBzZWxmLnBhdGgsIHN0eWxlLm91dGxpbmVTdHJva2UgPyAxIDogMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBfYXR0cihzZWxmLnBhdGgsIGEpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIF9hcHBseVN0eWxlcyhzZWxmLnN2Zywgc2VsZi5wYXRoLCBzdHlsZSwgZCwgc2VsZik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBfanUuZXh0ZW5kKF9qcC5Db25uZWN0b3JSZW5kZXJlcnMuc3ZnLCBTdmdDb21wb25lbnQpO1xuXG4vLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqIHN2ZyBzZWdtZW50IHJlbmRlcmVyICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHRcblxuXG4vLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqIC9zdmcgc2VnbWVudHMgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblxuICAgIC8qXG4gICAgICogQmFzZSBjbGFzcyBmb3IgU1ZHIGVuZHBvaW50cy5cbiAgICAgKi9cbiAgICB2YXIgU3ZnRW5kcG9pbnQgPSBfanAuU3ZnRW5kcG9pbnQgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgIHZhciBfc3VwZXIgPSBTdmdDb21wb25lbnQuYXBwbHkodGhpcywgW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNzc0NsYXNzOiBwYXJhbXMuX2pzUGx1bWIuZW5kcG9pbnRDbGFzcyxcbiAgICAgICAgICAgICAgICBvcmlnaW5hbEFyZ3M6IGFyZ3VtZW50cyxcbiAgICAgICAgICAgICAgICBwb2ludGVyRXZlbnRzU3BlYzogXCJhbGxcIixcbiAgICAgICAgICAgICAgICB1c2VEaXZXcmFwcGVyOiB0cnVlLFxuICAgICAgICAgICAgICAgIF9qc1BsdW1iOiBwYXJhbXMuX2pzUGx1bWJcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSk7XG5cbiAgICAgICAgX3N1cGVyLnJlbmRlcmVyLnBhaW50ID0gZnVuY3Rpb24gKHN0eWxlKSB7XG4gICAgICAgICAgICB2YXIgcyA9IF9qcC5leHRlbmQoe30sIHN0eWxlKTtcbiAgICAgICAgICAgIGlmIChzLm91dGxpbmVTdHJva2UpIHtcbiAgICAgICAgICAgICAgICBzLnN0cm9rZSA9IHMub3V0bGluZVN0cm9rZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMubm9kZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ub2RlID0gdGhpcy5tYWtlTm9kZShzKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN2Zy5hcHBlbmRDaGlsZCh0aGlzLm5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy51cGRhdGVOb2RlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZU5vZGUodGhpcy5ub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9hcHBseVN0eWxlcyh0aGlzLnN2ZywgdGhpcy5ub2RlLCBzLCBbIHRoaXMueCwgdGhpcy55LCB0aGlzLncsIHRoaXMuaCBdLCB0aGlzKTtcbiAgICAgICAgICAgIF9wb3ModGhpcy5ub2RlLCBbIHRoaXMueCwgdGhpcy55IF0pO1xuICAgICAgICB9LmJpbmQodGhpcyk7XG5cbiAgICB9O1xuICAgIF9qdS5leHRlbmQoU3ZnRW5kcG9pbnQsIFN2Z0NvbXBvbmVudCk7XG5cbiAgICAvKlxuICAgICAqIFNWRyBEb3QgRW5kcG9pbnRcbiAgICAgKi9cbiAgICBfanAuRW5kcG9pbnRzLnN2Zy5Eb3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF9qcC5FbmRwb2ludHMuRG90LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIFN2Z0VuZHBvaW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubWFrZU5vZGUgPSBmdW5jdGlvbiAoc3R5bGUpIHtcbiAgICAgICAgICAgIHJldHVybiBfbm9kZShcImNpcmNsZVwiLCB7XG4gICAgICAgICAgICAgICAgXCJjeFwiOiB0aGlzLncgLyAyLFxuICAgICAgICAgICAgICAgIFwiY3lcIjogdGhpcy5oIC8gMixcbiAgICAgICAgICAgICAgICBcInJcIjogdGhpcy5yYWRpdXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnVwZGF0ZU5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgX2F0dHIobm9kZSwge1xuICAgICAgICAgICAgICAgIFwiY3hcIjogdGhpcy53IC8gMixcbiAgICAgICAgICAgICAgICBcImN5XCI6IHRoaXMuaCAvIDIsXG4gICAgICAgICAgICAgICAgXCJyXCI6IHRoaXMucmFkaXVzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIF9qdS5leHRlbmQoX2pwLkVuZHBvaW50cy5zdmcuRG90LCBbX2pwLkVuZHBvaW50cy5Eb3QsIFN2Z0VuZHBvaW50XSk7XG5cbiAgICAvKlxuICAgICAqIFNWRyBSZWN0YW5nbGUgRW5kcG9pbnRcbiAgICAgKi9cbiAgICBfanAuRW5kcG9pbnRzLnN2Zy5SZWN0YW5nbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF9qcC5FbmRwb2ludHMuUmVjdGFuZ2xlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIFN2Z0VuZHBvaW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubWFrZU5vZGUgPSBmdW5jdGlvbiAoc3R5bGUpIHtcbiAgICAgICAgICAgIHJldHVybiBfbm9kZShcInJlY3RcIiwge1xuICAgICAgICAgICAgICAgIFwid2lkdGhcIjogdGhpcy53LFxuICAgICAgICAgICAgICAgIFwiaGVpZ2h0XCI6IHRoaXMuaFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudXBkYXRlTm9kZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICBfYXR0cihub2RlLCB7XG4gICAgICAgICAgICAgICAgXCJ3aWR0aFwiOiB0aGlzLncsXG4gICAgICAgICAgICAgICAgXCJoZWlnaHRcIjogdGhpcy5oXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIF9qdS5leHRlbmQoX2pwLkVuZHBvaW50cy5zdmcuUmVjdGFuZ2xlLCBbX2pwLkVuZHBvaW50cy5SZWN0YW5nbGUsIFN2Z0VuZHBvaW50XSk7XG5cbiAgICAvKlxuICAgICAqIFNWRyBJbWFnZSBFbmRwb2ludCBpcyB0aGUgZGVmYXVsdCBpbWFnZSBlbmRwb2ludC5cbiAgICAgKi9cbiAgICBfanAuRW5kcG9pbnRzLnN2Zy5JbWFnZSA9IF9qcC5FbmRwb2ludHMuSW1hZ2U7XG4gICAgLypcbiAgICAgKiBCbGFuayBlbmRwb2ludCBpbiBzdmcgcmVuZGVyZXIgaXMgdGhlIGRlZmF1bHQgQmxhbmsgZW5kcG9pbnQuXG4gICAgICovXG4gICAgX2pwLkVuZHBvaW50cy5zdmcuQmxhbmsgPSBfanAuRW5kcG9pbnRzLkJsYW5rO1xuICAgIC8qXG4gICAgICogTGFiZWwgb3ZlcmxheSBpbiBzdmcgcmVuZGVyZXIgaXMgdGhlIGRlZmF1bHQgTGFiZWwgb3ZlcmxheS5cbiAgICAgKi9cbiAgICBfanAuT3ZlcmxheXMuc3ZnLkxhYmVsID0gX2pwLk92ZXJsYXlzLkxhYmVsO1xuICAgIC8qXG4gICAgICogQ3VzdG9tIG92ZXJsYXkgaW4gc3ZnIHJlbmRlcmVyIGlzIHRoZSBkZWZhdWx0IEN1c3RvbSBvdmVybGF5LlxuICAgICAqL1xuICAgIF9qcC5PdmVybGF5cy5zdmcuQ3VzdG9tID0gX2pwLk92ZXJsYXlzLkN1c3RvbTtcblxuICAgIHZhciBBYnN0cmFjdFN2Z0Fycm93T3ZlcmxheSA9IGZ1bmN0aW9uIChzdXBlcmNsYXNzLCBvcmlnaW5hbEFyZ3MpIHtcbiAgICAgICAgc3VwZXJjbGFzcy5hcHBseSh0aGlzLCBvcmlnaW5hbEFyZ3MpO1xuICAgICAgICBfanAuanNQbHVtYlVJQ29tcG9uZW50LmFwcGx5KHRoaXMsIG9yaWdpbmFsQXJncyk7XG4gICAgICAgIHRoaXMuaXNBcHBlbmRlZEF0VG9wTGV2ZWwgPSBmYWxzZTtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB0aGlzLnBhdGggPSBudWxsO1xuICAgICAgICB0aGlzLnBhaW50ID0gZnVuY3Rpb24gKHBhcmFtcywgY29udGFpbmVyRXh0ZW50cykge1xuICAgICAgICAgICAgLy8gb25seSBkcmF3cyBvbiBjb25uZWN0aW9ucywgbm90IGVuZHBvaW50cy5cbiAgICAgICAgICAgIGlmIChwYXJhbXMuY29tcG9uZW50LnN2ZyAmJiBjb250YWluZXJFeHRlbnRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGF0aCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGF0aCA9IF9ub2RlKFwicGF0aFwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcInBvaW50ZXItZXZlbnRzXCI6IFwiYWxsXCJcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcy5jb21wb25lbnQuc3ZnLmFwcGVuZENoaWxkKHRoaXMucGF0aCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmVsZW1lbnRDcmVhdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnRDcmVhdGVkKHRoaXMucGF0aCwgcGFyYW1zLmNvbXBvbmVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbnZhcyA9IHBhcmFtcy5jb21wb25lbnQuc3ZnOyAvLyBmb3IgdGhlIHNha2Ugb2YgY29tcGxldGVuZXNzOyB0aGlzIGJlaGF2ZXMgdGhlIHNhbWUgYXMgb3RoZXIgb3ZlcmxheXNcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGNsYXp6ID0gb3JpZ2luYWxBcmdzICYmIChvcmlnaW5hbEFyZ3MubGVuZ3RoID09PSAxKSA/IChvcmlnaW5hbEFyZ3NbMF0uY3NzQ2xhc3MgfHwgXCJcIikgOiBcIlwiLFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSBbMCwgMF07XG5cbiAgICAgICAgICAgICAgICBpZiAoY29udGFpbmVyRXh0ZW50cy54bWluIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXRbMF0gPSAtY29udGFpbmVyRXh0ZW50cy54bWluO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY29udGFpbmVyRXh0ZW50cy55bWluIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXRbMV0gPSAtY29udGFpbmVyRXh0ZW50cy55bWluO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIF9hdHRyKHRoaXMucGF0aCwge1xuICAgICAgICAgICAgICAgICAgICBcImRcIjogbWFrZVBhdGgocGFyYW1zLmQpLFxuICAgICAgICAgICAgICAgICAgICBcImNsYXNzXCI6IGNsYXp6LFxuICAgICAgICAgICAgICAgICAgICBzdHJva2U6IHBhcmFtcy5zdHJva2UgPyBwYXJhbXMuc3Ryb2tlIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgZmlsbDogcGFyYW1zLmZpbGwgPyBwYXJhbXMuZmlsbCA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogXCJ0cmFuc2xhdGUoXCIgKyBvZmZzZXRbMF0gKyBcIixcIiArIG9mZnNldFsxXSArIFwiKVwiXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciBtYWtlUGF0aCA9IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICByZXR1cm4gKGlzTmFOKGQuY3h5LngpIHx8IGlzTmFOKGQuY3h5LnkpKSA/IFwiXCIgOiBcIk1cIiArIGQuaHh5LnggKyBcIixcIiArIGQuaHh5LnkgK1xuICAgICAgICAgICAgICAgIFwiIExcIiArIGQudGFpbFswXS54ICsgXCIsXCIgKyBkLnRhaWxbMF0ueSArXG4gICAgICAgICAgICAgICAgXCIgTFwiICsgZC5jeHkueCArIFwiLFwiICsgZC5jeHkueSArXG4gICAgICAgICAgICAgICAgXCIgTFwiICsgZC50YWlsWzFdLnggKyBcIixcIiArIGQudGFpbFsxXS55ICtcbiAgICAgICAgICAgICAgICBcIiBMXCIgKyBkLmh4eS54ICsgXCIsXCIgKyBkLmh4eS55O1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnRyYW5zZmVyID0gZnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgICAgICAgICBpZiAodGFyZ2V0LmNhbnZhcyAmJiB0aGlzLnBhdGggJiYgdGhpcy5wYXRoLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhdGgucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLnBhdGgpO1xuICAgICAgICAgICAgICAgIHRhcmdldC5jYW52YXMuYXBwZW5kQ2hpbGQodGhpcy5wYXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIF9qdS5leHRlbmQoQWJzdHJhY3RTdmdBcnJvd092ZXJsYXksIFtfanAuanNQbHVtYlVJQ29tcG9uZW50LCBfanAuT3ZlcmxheXMuQWJzdHJhY3RPdmVybGF5XSwge1xuICAgICAgICBjbGVhbnVwOiBmdW5jdGlvbiAoZm9yY2UpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBhdGggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChmb3JjZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9qc1BsdW1iLmluc3RhbmNlLnJlbW92ZUVsZW1lbnQodGhpcy5wYXRoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnBhdGgucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXRoLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5wYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcmVhdHRhY2g6ZnVuY3Rpb24oaW5zdGFuY2UsIGNvbXBvbmVudCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucGF0aCAmJiBjb21wb25lbnQuY2FudmFzKSB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50LmNhbnZhcy5hcHBlbmRDaGlsZCh0aGlzLnBhdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzZXRWaXNpYmxlOiBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgaWYgKHRoaXMucGF0aCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgKHRoaXMucGF0aC5zdHlsZS5kaXNwbGF5ID0gKHYgPyBcImJsb2NrXCIgOiBcIm5vbmVcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBfanAuT3ZlcmxheXMuc3ZnLkFycm93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBBYnN0cmFjdFN2Z0Fycm93T3ZlcmxheS5hcHBseSh0aGlzLCBbX2pwLk92ZXJsYXlzLkFycm93LCBhcmd1bWVudHNdKTtcbiAgICB9O1xuICAgIF9qdS5leHRlbmQoX2pwLk92ZXJsYXlzLnN2Zy5BcnJvdywgWyBfanAuT3ZlcmxheXMuQXJyb3csIEFic3RyYWN0U3ZnQXJyb3dPdmVybGF5IF0pO1xuXG4gICAgX2pwLk92ZXJsYXlzLnN2Zy5QbGFpbkFycm93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBBYnN0cmFjdFN2Z0Fycm93T3ZlcmxheS5hcHBseSh0aGlzLCBbX2pwLk92ZXJsYXlzLlBsYWluQXJyb3csIGFyZ3VtZW50c10pO1xuICAgIH07XG4gICAgX2p1LmV4dGVuZChfanAuT3ZlcmxheXMuc3ZnLlBsYWluQXJyb3csIFsgX2pwLk92ZXJsYXlzLlBsYWluQXJyb3csIEFic3RyYWN0U3ZnQXJyb3dPdmVybGF5IF0pO1xuXG4gICAgX2pwLk92ZXJsYXlzLnN2Zy5EaWFtb25kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBBYnN0cmFjdFN2Z0Fycm93T3ZlcmxheS5hcHBseSh0aGlzLCBbX2pwLk92ZXJsYXlzLkRpYW1vbmQsIGFyZ3VtZW50c10pO1xuICAgIH07XG4gICAgX2p1LmV4dGVuZChfanAuT3ZlcmxheXMuc3ZnLkRpYW1vbmQsIFsgX2pwLk92ZXJsYXlzLkRpYW1vbmQsIEFic3RyYWN0U3ZnQXJyb3dPdmVybGF5IF0pO1xuXG4gICAgLy8gYSB0ZXN0XG4gICAgX2pwLk92ZXJsYXlzLnN2Zy5HdWlkZUxpbmVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcGF0aCA9IG51bGwsIHNlbGYgPSB0aGlzLCBwMV8xLCBwMV8yO1xuICAgICAgICBfanAuT3ZlcmxheXMuR3VpZGVMaW5lcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnBhaW50ID0gZnVuY3Rpb24gKHBhcmFtcywgY29udGFpbmVyRXh0ZW50cykge1xuICAgICAgICAgICAgaWYgKHBhdGggPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHBhdGggPSBfbm9kZShcInBhdGhcIik7XG4gICAgICAgICAgICAgICAgcGFyYW1zLmNvbm5lY3Rvci5zdmcuYXBwZW5kQ2hpbGQocGF0aCk7XG4gICAgICAgICAgICAgICAgc2VsZi5hdHRhY2hMaXN0ZW5lcnMocGF0aCwgcGFyYW1zLmNvbm5lY3Rvcik7XG4gICAgICAgICAgICAgICAgc2VsZi5hdHRhY2hMaXN0ZW5lcnMocGF0aCwgc2VsZik7XG5cbiAgICAgICAgICAgICAgICBwMV8xID0gX25vZGUoXCJwYXRoXCIpO1xuICAgICAgICAgICAgICAgIHBhcmFtcy5jb25uZWN0b3Iuc3ZnLmFwcGVuZENoaWxkKHAxXzEpO1xuICAgICAgICAgICAgICAgIHNlbGYuYXR0YWNoTGlzdGVuZXJzKHAxXzEsIHBhcmFtcy5jb25uZWN0b3IpO1xuICAgICAgICAgICAgICAgIHNlbGYuYXR0YWNoTGlzdGVuZXJzKHAxXzEsIHNlbGYpO1xuXG4gICAgICAgICAgICAgICAgcDFfMiA9IF9ub2RlKFwicGF0aFwiKTtcbiAgICAgICAgICAgICAgICBwYXJhbXMuY29ubmVjdG9yLnN2Zy5hcHBlbmRDaGlsZChwMV8yKTtcbiAgICAgICAgICAgICAgICBzZWxmLmF0dGFjaExpc3RlbmVycyhwMV8yLCBwYXJhbXMuY29ubmVjdG9yKTtcbiAgICAgICAgICAgICAgICBzZWxmLmF0dGFjaExpc3RlbmVycyhwMV8yLCBzZWxmKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG9mZnNldCA9IFswLCAwXTtcbiAgICAgICAgICAgIGlmIChjb250YWluZXJFeHRlbnRzLnhtaW4gPCAwKSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0WzBdID0gLWNvbnRhaW5lckV4dGVudHMueG1pbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb250YWluZXJFeHRlbnRzLnltaW4gPCAwKSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0WzFdID0gLWNvbnRhaW5lckV4dGVudHMueW1pbjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2F0dHIocGF0aCwge1xuICAgICAgICAgICAgICAgIFwiZFwiOiBtYWtlUGF0aChwYXJhbXMuaGVhZCwgcGFyYW1zLnRhaWwpLFxuICAgICAgICAgICAgICAgIHN0cm9rZTogXCJyZWRcIixcbiAgICAgICAgICAgICAgICBmaWxsOiBudWxsLFxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogXCJ0cmFuc2xhdGUoXCIgKyBvZmZzZXRbMF0gKyBcIixcIiArIG9mZnNldFsxXSArIFwiKVwiXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgX2F0dHIocDFfMSwge1xuICAgICAgICAgICAgICAgIFwiZFwiOiBtYWtlUGF0aChwYXJhbXMudGFpbExpbmVbMF0sIHBhcmFtcy50YWlsTGluZVsxXSksXG4gICAgICAgICAgICAgICAgc3Ryb2tlOiBcImJsdWVcIixcbiAgICAgICAgICAgICAgICBmaWxsOiBudWxsLFxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogXCJ0cmFuc2xhdGUoXCIgKyBvZmZzZXRbMF0gKyBcIixcIiArIG9mZnNldFsxXSArIFwiKVwiXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgX2F0dHIocDFfMiwge1xuICAgICAgICAgICAgICAgIFwiZFwiOiBtYWtlUGF0aChwYXJhbXMuaGVhZExpbmVbMF0sIHBhcmFtcy5oZWFkTGluZVsxXSksXG4gICAgICAgICAgICAgICAgc3Ryb2tlOiBcImdyZWVuXCIsXG4gICAgICAgICAgICAgICAgZmlsbDogbnVsbCxcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IFwidHJhbnNsYXRlKFwiICsgb2Zmc2V0WzBdICsgXCIsXCIgKyBvZmZzZXRbMV0gKyBcIilcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIG1ha2VQYXRoID0gZnVuY3Rpb24gKGQxLCBkMikge1xuICAgICAgICAgICAgcmV0dXJuIFwiTSBcIiArIGQxLnggKyBcIixcIiArIGQxLnkgK1xuICAgICAgICAgICAgICAgIFwiIExcIiArIGQyLnggKyBcIixcIiArIGQyLnk7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBfanUuZXh0ZW5kKF9qcC5PdmVybGF5cy5zdmcuR3VpZGVMaW5lcywgX2pwLk92ZXJsYXlzLkd1aWRlTGluZXMpO1xufSkuY2FsbCh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHRoaXMpO1xuXG4vKlxuICoganNQbHVtYiBDb21tdW5pdHkgRWRpdGlvblxuICpcbiAqIFByb3ZpZGVzIGEgd2F5IHRvIHZpc3VhbGx5IGNvbm5lY3QgZWxlbWVudHMgb24gYW4gSFRNTCBwYWdlLCB1c2luZyBTVkcuXG4gKiBcbiAqIFRoaXMgZmlsZSBjb250YWlucyB0aGUgJ3ZhbmlsbGEnIGFkYXB0ZXIgLSBoYXZpbmcgbm8gZXh0ZXJuYWwgZGVwZW5kZW5jaWVzIG90aGVyIHRoYW4gYnVuZGxlZCBsaWJzLlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMCAtIDIwMTcganNQbHVtYiAoaGVsbG9AanNwbHVtYnRvb2xraXQuY29tKVxuICogXG4gKiBodHRwczovL2pzcGx1bWJ0b29sa2l0LmNvbVxuICogaHR0cHM6Ly9naXRodWIuY29tL2pzcGx1bWIvanNwbHVtYlxuICogXG4gKiBEdWFsIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgYW5kIEdQTDIgbGljZW5zZXMuXG4gKi9cbjtcbihmdW5jdGlvbiAoKSB7XG5cbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgcm9vdCA9IHRoaXMsIF9qcCA9IHJvb3QuanNQbHVtYiwgX2p1ID0gcm9vdC5qc1BsdW1iVXRpbCxcbiAgICAgICAgX2prID0gcm9vdC5LYXRhdm9yaW8sIF9qZyA9IHJvb3QuQmlsdG9uZztcblxuICAgIHZhciBfZ2V0RHJhZ01hbmFnZXIgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIGNhdGVnb3J5KSB7XG5cbiAgICAgICAgY2F0ZWdvcnkgPSBjYXRlZ29yeSB8fCBcIm1haW5cIjtcbiAgICAgICAgdmFyIGtleSA9IFwiX2thdGF2b3Jpb19cIiArIGNhdGVnb3J5O1xuICAgICAgICB2YXIgayA9IGluc3RhbmNlW2tleV0sXG4gICAgICAgICAgICBlID0gaW5zdGFuY2UuZ2V0RXZlbnRNYW5hZ2VyKCk7XG5cbiAgICAgICAgaWYgKCFrKSB7XG4gICAgICAgICAgICBrID0gbmV3IF9qayh7XG4gICAgICAgICAgICAgICAgYmluZDogZS5vbixcbiAgICAgICAgICAgICAgICB1bmJpbmQ6IGUub2ZmLFxuICAgICAgICAgICAgICAgIGdldFNpemU6IF9qcC5nZXRTaXplLFxuICAgICAgICAgICAgICAgIGdldFBvc2l0aW9uOiBmdW5jdGlvbiAoZWwsIHJlbGF0aXZlVG9Sb290KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoaXMgaXMgYSBuZXN0ZWQgZHJhZ2dhYmxlIHRoZW4gY29tcHV0ZSB0aGUgb2Zmc2V0IGFnYWluc3QgaXRzIG93biBvZmZzZXRQYXJlbnQsIG90aGVyd2lzZVxuICAgICAgICAgICAgICAgICAgICAvLyBjb21wdXRlIGFnYWluc3QgdGhlIENvbnRhaW5lcidzIG9yaWdpbi4gc2VlIGFsc28gdGhlIGdldFVJUG9zaXRpb24gbWV0aG9kIGJlbG93LlxuICAgICAgICAgICAgICAgICAgICB2YXIgbyA9IGluc3RhbmNlLmdldE9mZnNldChlbCwgcmVsYXRpdmVUb1Jvb3QsIGVsLl9rYXRhdm9yaW9EcmFnID8gZWwub2Zmc2V0UGFyZW50IDogbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbby5sZWZ0LCBvLnRvcF07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXRQb3NpdGlvbjogZnVuY3Rpb24gKGVsLCB4eSkge1xuICAgICAgICAgICAgICAgICAgICBlbC5zdHlsZS5sZWZ0ID0geHlbMF0gKyBcInB4XCI7XG4gICAgICAgICAgICAgICAgICAgIGVsLnN0eWxlLnRvcCA9IHh5WzFdICsgXCJweFwiO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYWRkQ2xhc3M6IF9qcC5hZGRDbGFzcyxcbiAgICAgICAgICAgICAgICByZW1vdmVDbGFzczogX2pwLnJlbW92ZUNsYXNzLFxuICAgICAgICAgICAgICAgIGludGVyc2VjdHM6IF9qZy5pbnRlcnNlY3RzLFxuICAgICAgICAgICAgICAgIGluZGV4T2Y6IGZ1bmN0aW9uKGwsIGkpIHsgcmV0dXJuIGwuaW5kZXhPZihpKTsgfSxcbiAgICAgICAgICAgICAgICBzY29wZTppbnN0YW5jZS5nZXREZWZhdWx0U2NvcGUoKSxcbiAgICAgICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgICAgICAgbm9TZWxlY3Q6IGluc3RhbmNlLmRyYWdTZWxlY3RDbGFzcyxcbiAgICAgICAgICAgICAgICAgICAgZHJvcHBhYmxlOiBcImp0ay1kcm9wcGFibGVcIixcbiAgICAgICAgICAgICAgICAgICAgZHJhZ2dhYmxlOiBcImp0ay1kcmFnZ2FibGVcIixcbiAgICAgICAgICAgICAgICAgICAgZHJhZzogXCJqdGstZHJhZ1wiLFxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZDogXCJqdGstZHJhZy1zZWxlY3RlZFwiLFxuICAgICAgICAgICAgICAgICAgICBhY3RpdmU6IFwianRrLWRyYWctYWN0aXZlXCIsXG4gICAgICAgICAgICAgICAgICAgIGhvdmVyOiBcImp0ay1kcmFnLWhvdmVyXCIsXG4gICAgICAgICAgICAgICAgICAgIGdob3N0UHJveHk6XCJqdGstZ2hvc3QtcHJveHlcIlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgay5zZXRab29tKGluc3RhbmNlLmdldFpvb20oKSk7XG4gICAgICAgICAgICBpbnN0YW5jZVtrZXldID0gaztcbiAgICAgICAgICAgIGluc3RhbmNlLmJpbmQoXCJ6b29tXCIsIGsuc2V0Wm9vbSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGs7XG4gICAgfTtcblxuICAgIHZhciBfYW5pbVByb3BzID0gZnVuY3Rpb24gKG8sIHApIHtcbiAgICAgICAgdmFyIF9vbmUgPSBmdW5jdGlvbiAocE5hbWUpIHtcbiAgICAgICAgICAgIGlmIChwW3BOYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKF9qdS5pc1N0cmluZyhwW3BOYW1lXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG0gPSBwW3BOYW1lXS5tYXRjaCgvLT0vKSA/IC0xIDogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHYgPSBwW3BOYW1lXS5zdWJzdHJpbmcoMik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvW3BOYW1lXSArIChtICogdik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcFtwTmFtZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9bcE5hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gWyBfb25lKFwibGVmdFwiKSwgX29uZShcInRvcFwiKSBdO1xuICAgIH07XG5cbiAgICBfanAuZXh0ZW5kKHJvb3QuanNQbHVtYkluc3RhbmNlLnByb3RvdHlwZSwge1xuXG4gICAgICAgIGFuaW1hdGlvblN1cHBvcnRlZDp0cnVlLFxuICAgICAgICBnZXRFbGVtZW50OiBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIGlmIChlbCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBoZXJlIHdlIHBsdWNrIHRoZSBmaXJzdCBlbnRyeSBpZiBlbCB3YXMgYSBsaXN0IG9mIGVudHJpZXMuXG4gICAgICAgICAgICAvLyB0aGlzIGlzIG5vdCBteSBmYXZvdXJpdGUgdGhpbmcgdG8gZG8sIGJ1dCBwcmV2aW91cyB2ZXJzaW9ucyBvZlxuICAgICAgICAgICAgLy8ganNwbHVtYiBzdXBwb3J0ZWQganF1ZXJ5IHNlbGVjdG9ycywgYW5kIGl0IGlzIHBvc3NpYmxlIGEgc2VsZWN0b3JcbiAgICAgICAgICAgIC8vIHdpbGwgYmUgcGFzc2VkIGluIGhlcmUuXG4gICAgICAgICAgICBlbCA9IHR5cGVvZiBlbCA9PT0gXCJzdHJpbmdcIiA/IGVsIDogZWwubGVuZ3RoICE9IG51bGwgJiYgZWwuZW5jdHlwZSA9PSBudWxsID8gZWxbMF0gOiBlbDtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgZWwgPT09IFwic3RyaW5nXCIgPyBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlbCkgOiBlbDtcbiAgICAgICAgfSxcbiAgICAgICAgcmVtb3ZlRWxlbWVudDogZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIF9nZXREcmFnTWFuYWdlcih0aGlzKS5lbGVtZW50UmVtb3ZlZChlbGVtZW50KTtcbiAgICAgICAgICAgIHRoaXMuZ2V0RXZlbnRNYW5hZ2VyKCkucmVtb3ZlKGVsZW1lbnQpO1xuICAgICAgICB9LFxuICAgICAgICAvL1xuICAgICAgICAvLyB0aGlzIGFkYXB0ZXIgc3VwcG9ydHMgYSBydWRpbWVudGFyeSBhbmltYXRpb24gZnVuY3Rpb24uIG5vIGVhc2luZyBpcyBzdXBwb3J0ZWQuICBvbmx5XG4gICAgICAgIC8vIGxlZnQvdG9wIHByb3BlcnRpZXMgYXJlIHN1cHBvcnRlZC4gcHJvcGVydHkgZGVsdGEgYXJncyBhcmUgZXhwZWN0ZWQgdG8gYmUgaW4gdGhlIGZvcm1cbiAgICAgICAgLy9cbiAgICAgICAgLy8gKz14Lnh4eHhcbiAgICAgICAgLy9cbiAgICAgICAgLy8gb3JcbiAgICAgICAgLy9cbiAgICAgICAgLy8gLT14Lnh4eHhcbiAgICAgICAgLy9cbiAgICAgICAgZG9BbmltYXRlOiBmdW5jdGlvbiAoZWwsIHByb3BlcnRpZXMsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICAgICAgdmFyIG8gPSB0aGlzLmdldE9mZnNldChlbCksXG4gICAgICAgICAgICAgICAgYXAgPSBfYW5pbVByb3BzKG8sIHByb3BlcnRpZXMpLFxuICAgICAgICAgICAgICAgIGxkaXN0ID0gYXBbMF0gLSBvLmxlZnQsXG4gICAgICAgICAgICAgICAgdGRpc3QgPSBhcFsxXSAtIG8udG9wLFxuICAgICAgICAgICAgICAgIGQgPSBvcHRpb25zLmR1cmF0aW9uIHx8IDI1MCxcbiAgICAgICAgICAgICAgICBzdGVwID0gMTUsIHN0ZXBzID0gZCAvIHN0ZXAsXG4gICAgICAgICAgICAgICAgbGluYyA9IChzdGVwIC8gZCkgKiBsZGlzdCxcbiAgICAgICAgICAgICAgICB0aW5jID0gKHN0ZXAgLyBkKSAqIHRkaXN0LFxuICAgICAgICAgICAgICAgIGlkeCA9IDAsXG4gICAgICAgICAgICAgICAgX2ludCA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgX2pwLnNldFBvc2l0aW9uKGVsLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiBvLmxlZnQgKyAobGluYyAqIChpZHggKyAxKSksXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3A6IG8udG9wICsgKHRpbmMgKiAoaWR4ICsgMSkpXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5zdGVwICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuc3RlcChpZHgsIE1hdGguY2VpbChzdGVwcykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlkeCsrO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaWR4ID49IHN0ZXBzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cuY2xlYXJJbnRlcnZhbChfaW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmNvbXBsZXRlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBzdGVwKTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gRFJBRy9EUk9QXG4gICAgICAgIGRlc3Ryb3lEcmFnZ2FibGU6IGZ1bmN0aW9uIChlbCwgY2F0ZWdvcnkpIHtcbiAgICAgICAgICAgIF9nZXREcmFnTWFuYWdlcih0aGlzLCBjYXRlZ29yeSkuZGVzdHJveURyYWdnYWJsZShlbCk7XG4gICAgICAgIH0sXG4gICAgICAgIGRlc3Ryb3lEcm9wcGFibGU6IGZ1bmN0aW9uIChlbCwgY2F0ZWdvcnkpIHtcbiAgICAgICAgICAgIF9nZXREcmFnTWFuYWdlcih0aGlzLCBjYXRlZ29yeSkuZGVzdHJveURyb3BwYWJsZShlbCk7XG4gICAgICAgIH0sXG4gICAgICAgIGluaXREcmFnZ2FibGU6IGZ1bmN0aW9uIChlbCwgb3B0aW9ucywgY2F0ZWdvcnkpIHtcbiAgICAgICAgICAgIF9nZXREcmFnTWFuYWdlcih0aGlzLCBjYXRlZ29yeSkuZHJhZ2dhYmxlKGVsLCBvcHRpb25zKTtcbiAgICAgICAgfSxcbiAgICAgICAgaW5pdERyb3BwYWJsZTogZnVuY3Rpb24gKGVsLCBvcHRpb25zLCBjYXRlZ29yeSkge1xuICAgICAgICAgICAgX2dldERyYWdNYW5hZ2VyKHRoaXMsIGNhdGVnb3J5KS5kcm9wcGFibGUoZWwsIG9wdGlvbnMpO1xuICAgICAgICB9LFxuICAgICAgICBpc0FscmVhZHlEcmFnZ2FibGU6IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgcmV0dXJuIGVsLl9rYXRhdm9yaW9EcmFnICE9IG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIGlzRHJhZ1N1cHBvcnRlZDogZnVuY3Rpb24gKGVsLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgaXNEcm9wU3VwcG9ydGVkOiBmdW5jdGlvbiAoZWwsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9LFxuICAgICAgICBpc0VsZW1lbnREcmFnZ2FibGU6IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgZWwgPSBfanAuZ2V0RWxlbWVudChlbCk7XG4gICAgICAgICAgICByZXR1cm4gZWwuX2thdGF2b3Jpb0RyYWcgJiYgZWwuX2thdGF2b3Jpb0RyYWcuaXNFbmFibGVkKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldERyYWdPYmplY3Q6IGZ1bmN0aW9uIChldmVudEFyZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiBldmVudEFyZ3NbMF0uZHJhZy5nZXREcmFnRWxlbWVudCgpO1xuICAgICAgICB9LFxuICAgICAgICBnZXREcmFnU2NvcGU6IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgcmV0dXJuIGVsLl9rYXRhdm9yaW9EcmFnICYmIGVsLl9rYXRhdm9yaW9EcmFnLnNjb3Blcy5qb2luKFwiIFwiKSB8fCBcIlwiO1xuICAgICAgICB9LFxuICAgICAgICBnZXREcm9wRXZlbnQ6IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJnc1swXS5lO1xuICAgICAgICB9LFxuICAgICAgICBnZXRVSVBvc2l0aW9uOiBmdW5jdGlvbiAoZXZlbnRBcmdzLCB6b29tKSB7XG4gICAgICAgICAgICAvLyBoZXJlIHRoZSBwb3NpdGlvbiByZXBvcnRlZCB0byB1cyBieSBLYXRhdm9yaW8gaXMgcmVsYXRpdmUgdG8gdGhlIGVsZW1lbnQncyBvZmZzZXRQYXJlbnQuIEZvciB0b3BcbiAgICAgICAgICAgIC8vIGxldmVsIG5vZGVzIHRoYXQgaXMgZmluZSwgYnV0IGlmIHdlIGhhdmUgYSBuZXN0ZWQgZHJhZ2dhYmxlIHRoZW4gaXRzIG9mZnNldFBhcmVudCBpcyBhY3R1YWxseVxuICAgICAgICAgICAgLy8gbm90IGdvaW5nIHRvIGJlIHRoZSBqc3BsdW1iIGNvbnRhaW5lcjsgaXQncyBnb2luZyB0byBiZSBzb21lIGNoaWxkIG9mIHRoYXQgZWxlbWVudC4gSW4gdGhhdCBjYXNlXG4gICAgICAgICAgICAvLyB3ZSB3YW50IHRvIGFkanVzdCB0aGUgVUkgcG9zaXRpb24gdG8gYWNjb3VudCBmb3IgdGhlIG9mZnNldFBhcmVudCdzIHBvc2l0aW9uIHJlbGF0aXZlIHRvIHRoZSBDb250YWluZXJcbiAgICAgICAgICAgIC8vIG9yaWdpbi5cbiAgICAgICAgICAgIHZhciBlbCA9IGV2ZW50QXJnc1swXS5lbDtcbiAgICAgICAgICAgIGlmIChlbC5vZmZzZXRQYXJlbnQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGZpbmFsUG9zID0gZXZlbnRBcmdzWzBdLmZpbmFsUG9zIHx8IGV2ZW50QXJnc1swXS5wb3M7XG4gICAgICAgICAgICB2YXIgcCA9IHsgbGVmdDpmaW5hbFBvc1swXSwgdG9wOmZpbmFsUG9zWzFdIH07XG4gICAgICAgICAgICBpZiAoZWwuX2thdGF2b3Jpb0RyYWcgJiYgZWwub2Zmc2V0UGFyZW50ICE9PSB0aGlzLmdldENvbnRhaW5lcigpKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9jID0gdGhpcy5nZXRPZmZzZXQoZWwub2Zmc2V0UGFyZW50KTtcbiAgICAgICAgICAgICAgICBwLmxlZnQgKz0gb2MubGVmdDtcbiAgICAgICAgICAgICAgICBwLnRvcCArPSBvYy50b3A7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0RHJhZ0ZpbHRlcjogZnVuY3Rpb24gKGVsLCBmaWx0ZXIsIF9leGNsdWRlKSB7XG4gICAgICAgICAgICBpZiAoZWwuX2thdGF2b3Jpb0RyYWcpIHtcbiAgICAgICAgICAgICAgICBlbC5fa2F0YXZvcmlvRHJhZy5zZXRGaWx0ZXIoZmlsdGVyLCBfZXhjbHVkZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHNldEVsZW1lbnREcmFnZ2FibGU6IGZ1bmN0aW9uIChlbCwgZHJhZ2dhYmxlKSB7XG4gICAgICAgICAgICBlbCA9IF9qcC5nZXRFbGVtZW50KGVsKTtcbiAgICAgICAgICAgIGlmIChlbC5fa2F0YXZvcmlvRHJhZykge1xuICAgICAgICAgICAgICAgIGVsLl9rYXRhdm9yaW9EcmFnLnNldEVuYWJsZWQoZHJhZ2dhYmxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc2V0RHJhZ1Njb3BlOiBmdW5jdGlvbiAoZWwsIHNjb3BlKSB7XG4gICAgICAgICAgICBpZiAoZWwuX2thdGF2b3Jpb0RyYWcpIHtcbiAgICAgICAgICAgICAgICBlbC5fa2F0YXZvcmlvRHJhZy5rLnNldERyYWdTY29wZShlbCwgc2NvcGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzZXREcm9wU2NvcGU6ZnVuY3Rpb24oZWwsIHNjb3BlKSB7XG4gICAgICAgICAgICBpZiAoZWwuX2thdGF2b3Jpb0Ryb3AgJiYgZWwuX2thdGF2b3Jpb0Ryb3AubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGVsLl9rYXRhdm9yaW9Ecm9wWzBdLmsuc2V0RHJvcFNjb3BlKGVsLCBzY29wZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGFkZFRvUG9zc2U6ZnVuY3Rpb24oZWwsIHNwZWMpIHtcbiAgICAgICAgICAgIHZhciBzcGVjcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgICAgICB2YXIgZG0gPSBfZ2V0RHJhZ01hbmFnZXIodGhpcyk7XG4gICAgICAgICAgICBfanAuZWFjaChlbCwgZnVuY3Rpb24oX2VsKSB7XG4gICAgICAgICAgICAgICAgX2VsID0gWyBfanAuZ2V0RWxlbWVudChfZWwpIF07XG4gICAgICAgICAgICAgICAgX2VsLnB1c2guYXBwbHkoX2VsLCBzcGVjcyApO1xuICAgICAgICAgICAgICAgIGRtLmFkZFRvUG9zc2UuYXBwbHkoZG0sIF9lbCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0UG9zc2U6ZnVuY3Rpb24oZWwsIHNwZWMpIHtcbiAgICAgICAgICAgIHZhciBzcGVjcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgICAgICB2YXIgZG0gPSBfZ2V0RHJhZ01hbmFnZXIodGhpcyk7XG4gICAgICAgICAgICBfanAuZWFjaChlbCwgZnVuY3Rpb24oX2VsKSB7XG4gICAgICAgICAgICAgICAgX2VsID0gWyBfanAuZ2V0RWxlbWVudChfZWwpIF07XG4gICAgICAgICAgICAgICAgX2VsLnB1c2guYXBwbHkoX2VsLCBzcGVjcyApO1xuICAgICAgICAgICAgICAgIGRtLnNldFBvc3NlLmFwcGx5KGRtLCBfZWwpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZUZyb21Qb3NzZTpmdW5jdGlvbihlbCwgcG9zc2VJZCkge1xuICAgICAgICAgICAgdmFyIHNwZWNzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgICAgIHZhciBkbSA9IF9nZXREcmFnTWFuYWdlcih0aGlzKTtcbiAgICAgICAgICAgIF9qcC5lYWNoKGVsLCBmdW5jdGlvbihfZWwpIHtcbiAgICAgICAgICAgICAgICBfZWwgPSBbIF9qcC5nZXRFbGVtZW50KF9lbCkgXTtcbiAgICAgICAgICAgICAgICBfZWwucHVzaC5hcHBseShfZWwsIHNwZWNzICk7XG4gICAgICAgICAgICAgICAgZG0ucmVtb3ZlRnJvbVBvc3NlLmFwcGx5KGRtLCBfZWwpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZUZyb21BbGxQb3NzZXM6ZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgICAgIHZhciBkbSA9IF9nZXREcmFnTWFuYWdlcih0aGlzKTtcbiAgICAgICAgICAgIF9qcC5lYWNoKGVsLCBmdW5jdGlvbihfZWwpIHsgZG0ucmVtb3ZlRnJvbUFsbFBvc3NlcyhfanAuZ2V0RWxlbWVudChfZWwpKTsgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldFBvc3NlU3RhdGU6ZnVuY3Rpb24oZWwsIHBvc3NlSWQsIHN0YXRlKSB7XG4gICAgICAgICAgICB2YXIgZG0gPSBfZ2V0RHJhZ01hbmFnZXIodGhpcyk7XG4gICAgICAgICAgICBfanAuZWFjaChlbCwgZnVuY3Rpb24oX2VsKSB7IGRtLnNldFBvc3NlU3RhdGUoX2pwLmdldEVsZW1lbnQoX2VsKSwgcG9zc2VJZCwgc3RhdGUpOyB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZHJhZ0V2ZW50czoge1xuICAgICAgICAgICAgJ3N0YXJ0JzogJ3N0YXJ0JywgJ3N0b3AnOiAnc3RvcCcsICdkcmFnJzogJ2RyYWcnLCAnc3RlcCc6ICdzdGVwJyxcbiAgICAgICAgICAgICdvdmVyJzogJ292ZXInLCAnb3V0JzogJ291dCcsICdkcm9wJzogJ2Ryb3AnLCAnY29tcGxldGUnOiAnY29tcGxldGUnLFxuICAgICAgICAgICAgJ2JlZm9yZVN0YXJ0JzonYmVmb3JlU3RhcnQnXG4gICAgICAgIH0sXG4gICAgICAgIGFuaW1FdmVudHM6IHtcbiAgICAgICAgICAgICdzdGVwJzogXCJzdGVwXCIsICdjb21wbGV0ZSc6ICdjb21wbGV0ZSdcbiAgICAgICAgfSxcbiAgICAgICAgc3RvcERyYWc6IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgaWYgKGVsLl9rYXRhdm9yaW9EcmFnKSB7XG4gICAgICAgICAgICAgICAgZWwuX2thdGF2b3Jpb0RyYWcuYWJvcnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgYWRkVG9EcmFnU2VsZWN0aW9uOiBmdW5jdGlvbiAoc3BlYykge1xuICAgICAgICAgICAgX2dldERyYWdNYW5hZ2VyKHRoaXMpLnNlbGVjdChzcGVjKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVtb3ZlRnJvbURyYWdTZWxlY3Rpb246IGZ1bmN0aW9uIChzcGVjKSB7XG4gICAgICAgICAgICBfZ2V0RHJhZ01hbmFnZXIodGhpcykuZGVzZWxlY3Qoc3BlYyk7XG4gICAgICAgIH0sXG4gICAgICAgIGNsZWFyRHJhZ1NlbGVjdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX2dldERyYWdNYW5hZ2VyKHRoaXMpLmRlc2VsZWN0QWxsKCk7XG4gICAgICAgIH0sXG4gICAgICAgIHRyaWdnZXI6IGZ1bmN0aW9uIChlbCwgZXZlbnQsIG9yaWdpbmFsRXZlbnQsIHBheWxvYWQpIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0RXZlbnRNYW5hZ2VyKCkudHJpZ2dlcihlbCwgZXZlbnQsIG9yaWdpbmFsRXZlbnQsIHBheWxvYWQpO1xuICAgICAgICB9LFxuICAgICAgICBkb1Jlc2V0OmZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gbG9vayBmb3Iga2F0YXZvcmlvIGluc3RhbmNlcyBhbmQgcmVzZXQgZWFjaCBvbmUgaWYgZm91bmQuXG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcykge1xuICAgICAgICAgICAgICAgIGlmIChrZXkuaW5kZXhPZihcIl9rYXRhdm9yaW9fXCIpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNba2V5XS5yZXNldCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIHJlYWR5ID0gZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgdmFyIF9kbyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICgvY29tcGxldGV8bG9hZGVkfGludGVyYWN0aXZlLy50ZXN0KGRvY3VtZW50LnJlYWR5U3RhdGUpICYmIHR5cGVvZihkb2N1bWVudC5ib2R5KSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudC5ib2R5ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBmKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KF9kbywgOSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgX2RvKCk7XG4gICAgfTtcbiAgICByZWFkeShfanAuaW5pdCk7XG5cbn0pLmNhbGwodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB0aGlzKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIFo6L3dlYi9wcm9qZWN0cy9scGsvfi9qc3BsdW1iL2Rpc3QvanMvanNwbHVtYi5qc1xuLy8gbW9kdWxlIGlkID0gNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIE1haW4gVUkgbW9kdWxlXG4gKi9cbmltcG9ydCB1dWlkIGZyb20gJ3V1aWQvdjQnO1xuXG5pbXBvcnQgeyBqc1BsdW1iIH0gZnJvbSAnanNwbHVtYic7XG5pbXBvcnQgcHVic3ViIGZyb20gJy4uLy4uL3V0aWxzL3B1YnN1Yic7XG5pbXBvcnQgY3JlYXRlU3RhdGUgZnJvbSAnLi9VSUZhY3Rvcnkvc3RhdGUnO1xuXG5pbXBvcnQgTW9kZWxNZW51IGZyb20gJy4vbW9kZWxfbWVudSc7XG5pbXBvcnQgU3RhdGVNZW51IGZyb20gJy4vc3RhdGVfbWVudSc7XG5cbmNvbnN0ICRzdGF0ZVBhbmVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI25ldy1zdGF0ZS1wYW5lbCcpO1xuY29uc3QgJHByb3BzUGFuZWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjbW9kZWwtcHJvcHMtcGFuZWwnKTtcbmNvbnN0ICRjYWRQYW5lID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI2NhZC1wYW5lJyk7XG5qc1BsdW1iLnNldENvbnRhaW5lcigkY2FkUGFuZSk7XG5cbi8qKlxuICogTGlzdGVuIHRvIHN0YXRlIG5hbWUgY2hhbmdlIGluIHNjaGVtZVxuICogYW5kIHNldCBhcHByb3ByaWF0ZSBub2RlIHRleHRcbiAqL1xucHVic3ViLnN1YnNjcmliZSgnc3RhdGVOYW1lU2V0JywgKHsgaWQsIG5hbWUgfSkgPT4ge1xuICBjb25zdCAkbmFtZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYCNzdGF0ZS0ke2lkfSAuY2FkLXN0YXRlLW5hbWVgKTtcbiAgJG5hbWUudGV4dENvbnRlbnQgPSBuYW1lO1xufSk7XG5cbnB1YnN1Yi5zdWJzY3JpYmUoJ2N1cnJlbnRTdGF0ZVNldCcsIChzdGF0ZSkgPT4ge1xuICBTdGF0ZU1lbnUuc2V0KHN0YXRlKTtcbn0pO1xuXG5jb25zdCBTY2VuZSA9IHtcbiAgLy8gSGFuZGxlcyBtZW51LWJ1dHRvbnMgY2xpY2tzXG4gIGFkZFN0YXRlKCkge1xuICAgIGNvbnN0IGlkID0gdXVpZCgpO1xuICAgIGNvbnN0ICRzdGF0ZU5vZGUgPSBjcmVhdGVTdGF0ZShpZCk7XG4gICAgJHN0YXRlTm9kZS5hZGRFdmVudExpc3RlbmVyKCdjb250ZXh0bWVudScsIChlKSA9PiB7XG4gICAgICBwdWJzdWIucHVibGlzaCgnc3RhdGVTZWxlY3RlZCcsIGlkKTtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHRoaXMuc2hvd1N0YXRlUGFuZWwoKTtcbiAgICB9KTtcbiAgICBqc1BsdW1iLmRyYWdnYWJsZSgkc3RhdGVOb2RlLCB7IGNvbnRhaW5tZW50OiB0cnVlIH0pO1xuICAgICRjYWRQYW5lLmFwcGVuZENoaWxkKCRzdGF0ZU5vZGUpO1xuICAgIHB1YnN1Yi5wdWJsaXNoKCdzdGF0ZUNyZWF0ZWQnLCBpZCk7XG4gIH0sXG5cbiAgc2hvd1N0YXRlUGFuZWwoKSB7XG4gICAgdGhpcy5oaWRlUHJvcHNQYW5lbCgpO1xuICAgICRzdGF0ZVBhbmVsLmNsYXNzTGlzdC5yZW1vdmUoJ2lzLWhpZGRlbicpO1xuICB9LFxuXG4gIHNob3dQcm9wc1BhbmVsKCkge1xuICAgIHRoaXMuaGlkZVN0YXRlUGFuZWwoKTtcbiAgICAkcHJvcHNQYW5lbC5jbGFzc0xpc3QucmVtb3ZlKCdpcy1oaWRkZW4nKTtcbiAgfSxcblxuICAvLyBIYW5kbGUgY2xvc2UtaWNvbnMgY2xpY2tzXG4gIGhpZGVTdGF0ZVBhbmVsKCkge1xuICAgICRzdGF0ZVBhbmVsLmNsYXNzTGlzdC5hZGQoJ2lzLWhpZGRlbicpO1xuICB9LFxuXG4gIGhpZGVQcm9wc1BhbmVsKCkge1xuICAgICRwcm9wc1BhbmVsLmNsYXNzTGlzdC5hZGQoJ2lzLWhpZGRlbicpO1xuICB9LFxuXG4gIC8vIHNldCBpbml0aWFsIFVJIGRhdGFcbiAgaW5pdChzY2hlbWUpIHtcbiAgICBNb2RlbE1lbnUuaW5pdChzY2hlbWUpO1xuICB9LFxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTY2VuZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NhZC9zY2VuZS9pbmRleC5qcyIsIi8qKlxuICogTWFpbiBDQUQgZGF0YSBoYW5kbGVyXG4gKi9cbmltcG9ydCBwdWJzdWIgZnJvbSAnLi4vLi4vdXRpbHMvcHVic3ViJztcbmltcG9ydCB7XG4gIERFRkFVTFRfU1RBVEVfTkFNRSxcbiAgREVGQVVMVF9UT09MX05BTUUsXG4gIERFRkFVTFRfVE9PTF9UWVBFLFxuICBERUZBVUxUX0lNQUdFX0lELFxufSBmcm9tICcuLi9jb25maWcnO1xuaW1wb3J0IG5vcm1hbGl6ZSBmcm9tICcuL25vcm1hbGl6ZSc7XG5cbmNsYXNzIFNjaGVtZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIC8vIG1vZGVsIGRhdGFcbiAgICB0aGlzLm5hbWUgPSAnJztcbiAgICB0aGlzLmluaXRpYWxTdGF0ZSA9ICcnO1xuICAgIHRoaXMuYnJlYWtUaW1lID0gNTtcbiAgICB0aGlzLnN0ZXBzID0gMTA7XG4gICAgdGhpcy50b29scyA9IHt9O1xuICAgIHRoaXMuc3RhdGVzID0ge307XG4gICAgdGhpcy5wYXJhbWV0ZXJzID0ge307XG4gICAgdGhpcy5hY3Rpb25zID0ge307XG5cbiAgICAvLyB1dGlsIHByb3BzXG4gICAgdGhpcy5fY3MgPSBudWxsOyAvLyBDdXJyZW50IHN0YXRlXG5cbiAgICAvLyBub24gbWVudSBldmVudHNcbiAgICBwdWJzdWIuc3Vic2NyaWJlKCdzdGF0ZUNyZWF0ZWQnLCB0aGlzLmFkZFN0YXRlLmJpbmQodGhpcykpO1xuICAgIHB1YnN1Yi5zdWJzY3JpYmUoJ3N0YXRlU2VsZWN0ZWQnLCB0aGlzLnNldEN1cnJlbnRTdGF0ZS5iaW5kKHRoaXMpKTtcblxuICAgIC8vIG1vZGVsIG1lbnUgZXZlbnRzXG4gICAgcHVic3ViLnN1YnNjcmliZSgnbmFtZUNoYW5nZWQnLCB0aGlzLnNldE5hbWUuYmluZCh0aGlzKSk7XG4gICAgcHVic3ViLnN1YnNjcmliZSgnYnJlYWtDaGFuZ2VkJywgdGhpcy5zZXRCcmVha1RpbWUuYmluZCh0aGlzKSk7XG4gICAgcHVic3ViLnN1YnNjcmliZSgnc3RlcHNDaGFuZ2VkJywgdGhpcy5zZXRTdGVwcy5iaW5kKHRoaXMpKTtcblxuICAgIC8vIHRvb2wgbWVudSBldmVudHNcbiAgICBwdWJzdWIuc3Vic2NyaWJlKCd0b29sQ3JlYXRlZCcsIHRoaXMuYWRkVG9vbC5iaW5kKHRoaXMpKTtcbiAgICBwdWJzdWIuc3Vic2NyaWJlKCd0b29sTmFtZUNoYW5nZWQnLCB0aGlzLnNldFRvb2xOYW1lLmJpbmQodGhpcykpO1xuICAgIHB1YnN1Yi5zdWJzY3JpYmUoJ3Rvb2xUeXBlQ2hhbmdlZCcsIHRoaXMuc2V0VG9vbFR5cGUuYmluZCh0aGlzKSk7XG4gICAgcHVic3ViLnN1YnNjcmliZSgndG9vbFJhbmdlQ2hhbmdlZCcsIHRoaXMuc2V0VG9vbFJhbmdlLmJpbmQodGhpcykpO1xuXG4gICAgLy8gc3RhdGUgbWVudSBldmVudHNcbiAgICBwdWJzdWIuc3Vic2NyaWJlKCdzdGF0ZU5hbWVDaGFuZ2VkJywgdGhpcy5zZXRTdGF0ZU5hbWUuYmluZCh0aGlzKSk7XG4gICAgcHVic3ViLnN1YnNjcmliZSgnc3RhdGVJbWFnZUNoYW5nZWQnLCB0aGlzLnNldFN0YXRlSW1hZ2UuYmluZCh0aGlzKSk7XG4gICAgcHVic3ViLnN1YnNjcmliZSgnaW5pdGlhbFN0YXRlQ2hhbmdlZCcsIHRoaXMuc2V0SW5pdGlhbFN0YXRlLmJpbmQodGhpcykpO1xuXG4gICAgLy8gZXZlbnQgbWVudSBldmVudHNcbiAgICBwdWJzdWIuc3Vic2NyaWJlKCdldmVudE5hbWVDaGFuZ2VkJywgdGhpcy5zZXRFdmVudE5hbWUuYmluZCh0aGlzKSk7XG4gICAgcHVic3ViLnN1YnNjcmliZSgnZXZlbnREZXNjQ2hhbmdlZCcsIHRoaXMuc2V0RXZlbnREZXNjLmJpbmQodGhpcykpO1xuXG4gICAgLy8gcGFyYW1ldGVycyBtZW51IGV2ZW50c1xuICAgIHB1YnN1Yi5zdWJzY3JpYmUoJ3BhcmFtZXRlckNyZWF0ZWQnLCB0aGlzLmFkZFBhcmFtZXRlci5iaW5kKHRoaXMpKTtcbiAgICBwdWJzdWIuc3Vic2NyaWJlKCdwYXJhbWV0ZXJOYW1lQ2hhbmdlZCcsIHRoaXMuc2V0UGFyYW1ldGVyTmFtZS5iaW5kKHRoaXMpKTtcbiAgICBwdWJzdWIuc3Vic2NyaWJlKCdwYXJhbWV0ZXJWYWx1ZUNoYW5nZWQnLCB0aGlzLnNldFBhcmFtZXRlclZhbHVlLmJpbmQodGhpcykpO1xuXG4gICAgLy8gYWN0aW9ucyBtZW51IGV2ZW50c1xuICAgIHB1YnN1Yi5zdWJzY3JpYmUoJ2FjdGlvbkNyZWF0ZWQnLCB0aGlzLmFkZEFjdGlvbi5iaW5kKHRoaXMpKTtcbiAgICBwdWJzdWIuc3Vic2NyaWJlKCdhY3Rpb25OZXh0U3RhdGVDaGFuZ2VkJywgdGhpcy5zZXRBY3Rpb25OZXh0U3RhdGUuYmluZCh0aGlzKSk7XG4gICAgcHVic3ViLnN1YnNjcmliZSgnYWN0aW9uVGltZUNoYW5nZWQnLCB0aGlzLnNldEFjdGlvblRpbWUuYmluZCh0aGlzKSk7XG4gICAgcHVic3ViLnN1YnNjcmliZSgnYWN0aW9uVG9vbENoYW5nZWQnLCB0aGlzLnNldEFjdGlvblRvb2wuYmluZCh0aGlzKSk7XG4gICAgcHVic3ViLnN1YnNjcmliZSgnYWN0aW9uVG9vbFZhbHVlQ2hhbmdlZCcsIHRoaXMuc2V0QWN0aW9uVG9vbFZhbHVlLmJpbmQodGhpcykpO1xuICAgIHB1YnN1Yi5zdWJzY3JpYmUoJ2luYWN0aXZlQWN0aW9uU2V0JywgdGhpcy5zZXRJbmFjdGl2ZUFjdGlvbi5iaW5kKHRoaXMpKTtcblxuICAgIC8vIHNlbmQgc3RhdGVzIGRhdGEgdG8gYWN0aW9uIGNyZWF0b3JcbiAgICAvLyByZWNlaXZlIGFueSBwYXlsb2FkIGFuZCByZXR1cm4gaXQgYmFjayB3aXRoIHN0YXRlcyBhcnJheVxuICAgIC8vIGFuZCBjdXJyZW50IHN0YXRlIHV1aWRcbiAgICBwdWJzdWIuc3Vic2NyaWJlKCdzY2hlbWVEYXRhUmVxdWVzdGVkJywgKHBheWxvYWQpID0+IHtcbiAgICAgIGNvbnN0IHN0YXRlcyA9IE9iamVjdC52YWx1ZXModGhpcy5zdGF0ZXMpO1xuICAgICAgY29uc3QgdG9vbHMgPSBPYmplY3QudmFsdWVzKHRoaXMudG9vbHMpO1xuICAgICAgcHVic3ViLnB1Ymxpc2goJ3NjaGVtZURhdGFTZW50JywgT2JqZWN0LmFzc2lnbih7IHN0YXRlcywgdG9vbHMsIGN1cnJlbnRTdGF0ZTogdGhpcy5fY3MgfSwgcGF5bG9hZCkpO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gUmV0dXJucyBub3JtYWxpemVkIGN1cnJlbnQgc2NoZW1lIGRhdGFcbiAgZ2V0Tm9ybWFsaXplZCgpIHtcbiAgICByZXR1cm4gbm9ybWFsaXplKHRoaXMpO1xuICB9XG5cbiAgLy8gTm9uIG1lbnUgZXZlbnQtbGlzdGVuZXJzXG4gIGFkZFN0YXRlKGlkKSB7XG4gICAgdGhpcy5zdGF0ZXNbaWRdID0ge1xuICAgICAgdXVpZDogaWQsXG4gICAgICBuYW1lOiBERUZBVUxUX1NUQVRFX05BTUUsXG4gICAgICBpbWc6IERFRkFVTFRfSU1BR0VfSUQsXG4gICAgICBwYXJhbWV0ZXJzOiBbXSxcbiAgICAgIGV2ZW50OiB7IG5hbWU6ICcnLCBkZXNjOiAnJyB9LFxuICAgICAgYWN0aW9uczogW10sXG4gICAgfTtcbiAgfVxuXG4gIHNldEN1cnJlbnRTdGF0ZShpZCkge1xuICAgIHRoaXMuX2NzID0gaWQ7XG4gICAgY29uc3QgY3MgPSB0aGlzLnN0YXRlc1tpZF07XG4gICAgY29uc3QgcGFyYW1ldGVycyA9IGNzLnBhcmFtZXRlcnMubWFwKHBJZCA9PiB0aGlzLnBhcmFtZXRlcnNbcElkXSk7XG4gICAgY29uc3QgYWN0aW9ucyA9IGNzLmFjdGlvbnMubWFwKGFJZCA9PiB0aGlzLmFjdGlvbnNbYUlkXSk7XG4gICAgcHVic3ViLnB1Ymxpc2goJ2N1cnJlbnRTdGF0ZVNldCcsIE9iamVjdC5hc3NpZ24oe30sXG4gICAgICB0aGlzLnN0YXRlc1t0aGlzLl9jc10sXG4gICAgICB7IHBhcmFtZXRlcnMgfSxcbiAgICAgIHsgYWN0aW9ucyB9LFxuICAgICkpO1xuICB9XG5cbiAgLy8gTW9kZWwgbWVudSBldmVudC1saXN0ZW5lcnNcbiAgc2V0TmFtZShuYW1lKSB7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgfVxuXG4gIHNldEJyZWFrVGltZSh0aW1lKSB7XG4gICAgdGhpcy5icmVha1RpbWUgPSB0aW1lO1xuICB9XG5cbiAgc2V0U3RlcHMoc3RlcHMpIHtcbiAgICB0aGlzLnN0ZXBzID0gc3RlcHM7XG4gIH1cblxuICAvLyBUb29sIG1lbnUgZXZlbnQtbGlzdGVuZXJzXG4gIGFkZFRvb2woaWQpIHtcbiAgICB0aGlzLnRvb2xzW2lkXSA9IHtcbiAgICAgIHV1aWQ6IGlkLFxuICAgICAgbmFtZTogREVGQVVMVF9UT09MX05BTUUsXG4gICAgICB0eXBlOiBERUZBVUxUX1RPT0xfVFlQRSxcbiAgICAgIHJhbmdlVmFsdWVzOiB7fSxcbiAgICB9O1xuICB9XG5cbiAgc2V0VG9vbE5hbWUoeyBpZCwgbmFtZSB9KSB7XG4gICAgdGhpcy50b29sc1tpZF0ubmFtZSA9IG5hbWU7XG4gIH1cblxuICBzZXRUb29sVHlwZSh7IGlkLCB0eXBlIH0pIHtcbiAgICB0aGlzLnRvb2xzW2lkXS50eXBlID0gdHlwZTtcbiAgfVxuXG4gIHNldFRvb2xSYW5nZSh7IGlkLCB2YWx1ZXMgfSkge1xuICAgIHRoaXMudG9vbHNbaWRdLnJhbmdlVmFsdWVzID0gdmFsdWVzO1xuICB9XG5cbiAgLy8gU3RhdGUgbWVudSBldmVudC1saXN0ZW5lcnNcbiAgc2V0U3RhdGVOYW1lKG5hbWUpIHtcbiAgICB0aGlzLnN0YXRlc1t0aGlzLl9jc10ubmFtZSA9IG5hbWU7XG4gICAgcHVic3ViLnB1Ymxpc2goJ3N0YXRlTmFtZVNldCcsIHsgaWQ6IHRoaXMuX2NzLCBuYW1lIH0pO1xuICB9XG5cbiAgc2V0U3RhdGVJbWFnZShpbWcpIHtcbiAgICB0aGlzLnN0YXRlc1t0aGlzLl9jc10uaW1nID0gaW1nO1xuICB9XG5cbiAgc2V0SW5pdGlhbFN0YXRlKHN0YXRlSWQpIHtcbiAgICB0aGlzLmluaXRpYWxTdGF0ZSA9IHN0YXRlSWQ7XG4gIH1cblxuICAvLyBFdmVudCBtZW51IGV2ZW50LWxpc3RlbmVyc1xuICBzZXRFdmVudE5hbWUobmFtZSkge1xuICAgIHRoaXMuc3RhdGVzW3RoaXMuX2NzXS5ldmVudC5uYW1lID0gbmFtZTtcbiAgfVxuXG4gIHNldEV2ZW50RGVzYyhkZXNjKSB7XG4gICAgdGhpcy5zdGF0ZXNbdGhpcy5fY3NdLmV2ZW50LmRlc2MgPSBkZXNjO1xuICB9XG5cbiAgLy8gUGFyYW1ldGVycyBtZW51IGV2ZW50LWxpc3RlbmVyc1xuICBhZGRQYXJhbWV0ZXIoaWQpIHtcbiAgICB0aGlzLnBhcmFtZXRlcnNbaWRdID0ge1xuICAgICAgaWQsXG4gICAgICBuYW1lOiAnJyxcbiAgICAgIHZhbHVlOiAnJyxcbiAgICB9O1xuICAgIHRoaXMuc3RhdGVzW3RoaXMuX2NzXS5wYXJhbWV0ZXJzLnB1c2goaWQpO1xuICB9XG5cbiAgc2V0UGFyYW1ldGVyTmFtZSh7IGlkLCBuYW1lIH0pIHtcbiAgICB0aGlzLnBhcmFtZXRlcnNbaWRdLm5hbWUgPSBuYW1lO1xuICB9XG5cbiAgc2V0UGFyYW1ldGVyVmFsdWUoeyBpZCwgdmFsdWUgfSkge1xuICAgIHRoaXMucGFyYW1ldGVyc1tpZF0udmFsdWUgPSB2YWx1ZTtcbiAgfVxuXG4gIC8vIEFjdGlvbiBtZW51IGV2ZW50LWxpc3RlbmVyc1xuICBhZGRBY3Rpb24oaWQpIHtcbiAgICB0aGlzLmFjdGlvbnNbaWRdID0ge1xuICAgICAgaWQsXG4gICAgICBuZXh0U3RhdGU6ICcnLFxuICAgICAgdGltZTogeyBtaW46IDAsIG1heDogMCB9LFxuICAgICAgdG9vbHM6IHt9LFxuICAgIH07XG4gICAgdGhpcy5zdGF0ZXNbdGhpcy5fY3NdLmFjdGlvbnMucHVzaChpZCk7XG4gIH1cblxuICBzZXRBY3Rpb25OZXh0U3RhdGUoeyBpZCwgc3RhdGVJZCB9KSB7XG4gICAgdGhpcy5hY3Rpb25zW2lkXS5uZXh0U3RhdGUgPSBzdGF0ZUlkO1xuICB9XG5cbiAgc2V0QWN0aW9uVGltZSh7IGlkLCB0aW1lIH0pIHtcbiAgICB0aGlzLmFjdGlvbnNbaWRdLnRpbWUgPSB0aW1lO1xuICB9XG5cbiAgc2V0QWN0aW9uVG9vbCh7IGlkLCB0b29sSWQgfSkge1xuICAgIGxldCB2YWx1ZSA9IG51bGw7XG4gICAgc3dpdGNoICh0aGlzLnRvb2xzW3Rvb2xJZF0udHlwZSkge1xuICAgICAgY2FzZSAnc3dpdGNoJzpcbiAgICAgICAgdmFsdWUgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdyYW5nZSc6XG4gICAgICAgIHZhbHVlID0gWyAwLCAwIF07XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgY29uc29sZS53YXJuKCdJbnZhbGlkIHRvb2wgdHlwZScpO1xuICAgICAgICB2YWx1ZSA9IG51bGw7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB0aGlzLmFjdGlvbnNbaWRdLnRvb2xzW3Rvb2xJZF0gPSB7XG4gICAgICB2YWx1ZSxcbiAgICAgIGlkOiB0b29sSWQsXG4gICAgfTtcbiAgfVxuXG4gIHNldEFjdGlvblRvb2xWYWx1ZSh7IGlkLCB0b29sSWQsIHZhbHVlIH0pIHtcbiAgICB0aGlzLmFjdGlvbnNbaWRdLnRvb2xzW3Rvb2xJZF0udmFsdWUgPSB2YWx1ZTtcbiAgfVxuXG4gIHNldEluYWN0aXZlQWN0aW9uKHsgaWQsIG5leHRTdGF0ZSB9KSB7XG4gICAgdGhpcy5hY3Rpb25zW2lkXSA9IHtcbiAgICAgIGlkLFxuICAgICAgbmV4dFN0YXRlLFxuICAgICAgaW5hY3RpdmU6IHRydWUsXG4gICAgfTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBTY2hlbWU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9jYWQvc2NoZW1lL2luZGV4LmpzIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbm9ybWFsaXplKHNvdXJjZSkge1xuICBjb25zdCByZXN1bHQgPSB7fTtcblxuICByZXN1bHQubmFtZSA9IHNvdXJjZS5uYW1lO1xuICByZXN1bHQuaW5pdGlhbFN0YXRlID0gc291cmNlLmluaXRpYWxTdGF0ZTtcbiAgcmVzdWx0LnN0ZXBzID0gc291cmNlLnN0ZXBzO1xuICByZXN1bHQuYnJlYWtUaW1lID0gc291cmNlLmJyZWFrVGltZSAqIDEwMDA7XG4gIHJlc3VsdC50b29scyA9IE9iamVjdC52YWx1ZXMoc291cmNlLnRvb2xzKTtcblxuICByZXN1bHQuc3RhdGVzID0gT2JqZWN0LnZhbHVlcyhzb3VyY2Uuc3RhdGVzKS5tYXAoKHNvdXJjZVN0YXRlKSA9PiB7XG4gICAgY29uc3QgYWN0aW9ucyA9IGV4dHJhY3RBY3Rpb25zKHNvdXJjZVN0YXRlLmFjdGlvbnMsIHNvdXJjZSk7XG4gICAgY29uc3QgcGFyYW1ldGVycyA9IGV4dHJhY3RQYXJhbWV0ZXJzKHNvdXJjZVN0YXRlLnBhcmFtZXRlcnMsIHNvdXJjZSk7XG4gICAgY29uc3QgbGFzdCA9IGFjdGlvbnMubGVuZ3RoID09PSAwO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBzb3VyY2VTdGF0ZSwgeyBhY3Rpb25zLCBwYXJhbWV0ZXJzLCBsYXN0IH0pO1xuICB9KTtcblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBleHRyYWN0QWN0aW9ucyhhY3Rpb25JZHMsIHNjaGVtZSkge1xuICByZXR1cm4gYWN0aW9uSWRzLm1hcCgoYUlkKSA9PiB7XG4gICAgY29uc3QgYWN0aW9uID0gc2NoZW1lLmFjdGlvbnNbYUlkXTtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICByZXN1bHQubmV4dFN0YXRlID0gYWN0aW9uLm5leHRTdGF0ZTtcbiAgICByZXN1bHQuaW5hY3RpdmUgPSBhY3Rpb24uaW5hY3RpdmUgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogYWN0aW9uLmluYWN0aXZlO1xuXG4gICAgaWYgKCFhY3Rpb24udG9vbHMpIHsgcmV0dXJuIHJlc3VsdDsgfVxuXG4gICAgcmVzdWx0LnRpbWUgPSB7XG4gICAgICBtaW46IGFjdGlvbi50aW1lLm1pbiAqIDEwMDAsXG4gICAgICBtYXg6IGFjdGlvbi50aW1lLm1heCAqIDEwMDAsXG4gICAgfTtcblxuICAgIHJlc3VsdC50b29scyA9IE9iamVjdC52YWx1ZXMoYWN0aW9uLnRvb2xzKS5tYXAoKHsgaWQsIHZhbHVlIH0pID0+IHtcbiAgICAgIGNvbnN0IHRvb2wgPSBzY2hlbWUudG9vbHNbaWRdO1xuICAgICAgY29uc3QgcmVzID0ge307XG5cbiAgICAgIHJlcy50eXBlID0gdG9vbC50eXBlO1xuICAgICAgcmVzLnV1aWQgPSB0b29sLnV1aWQ7XG5cbiAgICAgIHN3aXRjaCAodG9vbC50eXBlKSB7XG4gICAgICAgIGNhc2UgJ3N3aXRjaCc6XG4gICAgICAgICAgcmVzLnN3aXRjaFZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3JhbmdlJzpcbiAgICAgICAgICByZXMucmFuZ2VWYWx1ZXMgPSB2YWx1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ0ludmFsaWQgdG9vbCB0eXBlJyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBleHRyYWN0UGFyYW1ldGVycyhwYXJhbWV0ZXJJZHMsIHNjaGVtZSkge1xuICByZXR1cm4gcGFyYW1ldGVySWRzLm1hcChwSWQgPT4gc2NoZW1lLnBhcmFtZXRlcnNbcElkXSk7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9jYWQvc2NoZW1lL25vcm1hbGl6ZS5qcyIsIi8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vc2Fzcy9jYWQuc2Nzc1xuLy8gbW9kdWxlIGlkID0gMTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0ICcuLi8uLi9zYXNzL2NhZC5zY3NzJztcclxuaW1wb3J0IFNjZW5lIGZyb20gJy4vc2NlbmUnO1xyXG5pbXBvcnQgU2NoZW1lIGZyb20gJy4vc2NoZW1lJztcclxuaW1wb3J0IEFQSSBmcm9tICcuL2FwaSc7XHJcblxyXG5jb25zdCAkbmV3U3RhdGVCdXR0b24gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjbmV3LXN0YXRlLWJ0bicpO1xyXG5jb25zdCAkbW9kZWxQcm9wc0J1dHRvbiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNtb2RlbC1wcm9wcy1idG4nKTtcclxuXHJcbiRuZXdTdGF0ZUJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IFNjZW5lLmFkZFN0YXRlKCkpO1xyXG4kbW9kZWxQcm9wc0J1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IFNjZW5lLnNob3dQcm9wc1BhbmVsKCkpO1xyXG5cclxuY29uc3QgJHN0YXRlQ2xvc2VCdXR0b24gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjbmV3LXN0YXRlLXBhbmVsIC5pY29uLWNsb3NlJyk7XHJcbmNvbnN0ICRwcm9wc0Nsb3NlQnV0dG9uID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI21vZGVsLXByb3BzLXBhbmVsIC5pY29uLWNsb3NlJyk7XHJcblxyXG4kc3RhdGVDbG9zZUJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IFNjZW5lLmhpZGVTdGF0ZVBhbmVsKCkpO1xyXG4kcHJvcHNDbG9zZUJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IFNjZW5lLmhpZGVQcm9wc1BhbmVsKCkpO1xyXG5cclxuY29uc3Qgc2NoZW1lID0gbmV3IFNjaGVtZSgpO1xyXG5TY2VuZS5pbml0KHNjaGVtZSk7XHJcblxyXG5jb25zdCAkc2F2ZU1vZGVsQnRuID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NhdmUtbW9kZWwtYnRuJyk7XHJcblxyXG4kc2F2ZU1vZGVsQnRuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xyXG4gIGNvbnN0IG1vZGVsID0gc2NoZW1lLmdldE5vcm1hbGl6ZWQoKTtcclxuICBBUEkuc2VuZE1vZGVsKEpTT04uc3RyaW5naWZ5KG1vZGVsKSlcclxuICAgIC50aGVuKCgpID0+IHtcclxuICAgICAgY29uc29sZS5sb2coJ01vZGVsIHNhdmVkJyk7XHJcbiAgICB9KVxyXG4gICAgLmNhdGNoKChlcnIpID0+IHtcclxuICAgICAgY29uc29sZS5sb2coZXJyKTtcclxuICAgIH0pO1xyXG59KTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vY2FkL2luZGV4LmpzIiwiaW1wb3J0IHsganNQbHVtYiB9IGZyb20gJ2pzcGx1bWInO1xuaW1wb3J0IG5vZGVGYWN0b3J5IGZyb20gJy4uLy4uLy4uL3V0aWxzL25vZGVGYWN0b3J5JztcbmltcG9ydCBwdWJzdWIgZnJvbSAnLi4vLi4vLi4vdXRpbHMvcHVic3ViJztcblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUFjdGlvbihpZCwgeyBzdGF0ZXMsIHRvb2xzLCBjdXJyZW50U3RhdGUgfSwgYWN0aW9uKSB7XG4gIGNvbnN0ICRhY3Rpb25XcmFwcGVyID0gbm9kZUZhY3RvcnkoJ2RpdicsIHsgY2xhc3NMaXN0OiBbICdwYW5lbC1hY3Rpb24nIF0gfSk7XG5cbiAgLyoqXG4gICAqIE5leHQgc3RhdGVcbiAgICovXG4gIGNvbnN0ICRuZXh0U3RhdGVMYWJlbCA9IG5vZGVGYWN0b3J5KCdsYWJlbCcsIHsgdGV4dENvbnRlbnQ6ICfQodC70LXQtNGD0Y7RidC10LUg0YHQvtGB0YLQvtGP0L3QuNC1JyB9KTtcbiAgY29uc3QgJG5leHRTdGF0ZVNlbGVjdCA9IG5vZGVGYWN0b3J5KCdzZWxlY3QnLCB7IGNsYXNzTGlzdDogWyAnbmV4dC1zdGF0ZS1zZWxlY3QnIF0gfSk7XG4gIGlmICghYWN0aW9uKSB7XG4gICAgY29uc3QgJGRlZmF1bHRPcHRpb24gPSBub2RlRmFjdG9yeSgnb3B0aW9uJywge1xuICAgICAgdGV4dENvbnRlbnQ6ICfQodC70LXQtNGD0Y7RidC10LUg0YHQvtGB0YLQvtGP0L3QuNC1JyxcbiAgICAgIGF0dHJzOiB7IHNlbGVjdGVkOiB0cnVlLCBkaXNhYmxlZDogdHJ1ZSwgaGlkZGVuOiB0cnVlIH0sXG4gICAgfSk7XG4gICAgJG5leHRTdGF0ZVNlbGVjdC5hcHBlbmRDaGlsZCgkZGVmYXVsdE9wdGlvbik7XG4gIH1cbiAgc3RhdGVzLmZvckVhY2goKHsgbmFtZSwgdXVpZCB9KSA9PiB7XG4gICAgLy8gc2tpcCBjdXJyZW50IHN0YXRlXG4gICAgaWYgKHV1aWQgPT09IGN1cnJlbnRTdGF0ZSkgeyByZXR1cm47IH1cbiAgICBjb25zdCAkb3B0aW9uID0gbm9kZUZhY3RvcnkoJ29wdGlvbicsIHsgYXR0cnM6IHsgdmFsdWU6IHV1aWQgfSwgdGV4dENvbnRlbnQ6IG5hbWUgfSk7XG4gICAgJG5leHRTdGF0ZVNlbGVjdC5hcHBlbmRDaGlsZCgkb3B0aW9uKTtcbiAgfSk7XG4gICRuZXh0U3RhdGVTZWxlY3QuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgKCkgPT4gc2V0TmV4dFN0YXRlKGN1cnJlbnRTdGF0ZSwgJG5leHRTdGF0ZVNlbGVjdC52YWx1ZSwgaWQpKTtcbiAgJGFjdGlvbldyYXBwZXIuYXBwZW5kQ2hpbGQoJG5leHRTdGF0ZUxhYmVsKTtcbiAgJGFjdGlvbldyYXBwZXIuYXBwZW5kQ2hpbGQoJG5leHRTdGF0ZVNlbGVjdCk7XG5cbiAgLyoqXG4gICAqIEFjdGlvbiB0aW1lXG4gICAqL1xuICBjb25zdCAkdGltZSA9IG5vZGVGYWN0b3J5KCdkaXYnLCB7IGNsYXNzTGlzdDogWyAncGFuZWwtYWN0aW9uLXRpbWUnIF0gfSk7XG4gIGNyZWF0ZUFjdGlvblRpbWVOb2RlKCR0aW1lLCBpZCk7XG4gICRhY3Rpb25XcmFwcGVyLmFwcGVuZENoaWxkKCR0aW1lKTtcblxuICAvKipcbiAgICogVG9vbHNcbiAgICovXG4gIGNvbnN0ICR0b29sc0hlYWRlciA9IG5vZGVGYWN0b3J5KCdkaXYnLCB7IGNsYXNzTGlzdDogWyAncGFuZWwtYWN0aW9uLXRvb2xzLWhlYWRlcicgXSB9KTtcbiAgY29uc3QgJHRvb2xzSGVhZGVyTGFiZWwgPSBub2RlRmFjdG9yeSgnbGFiZWwnLCB7IHRleHRDb250ZW50OiAn0JfQvdCw0YfQtdC90LjRjyDQv9GA0LjQsdC+0YDQvtCyJyB9KTtcbiAgY29uc3QgJHRvb2xzSGVhZGVySWNvbiA9IG5vZGVGYWN0b3J5KCdpJywgeyBjbGFzc0xpc3Q6IFsgJ2ljb24nLCAnaWNvbi1hZGQnIF0gfSk7XG4gICR0b29sc0hlYWRlckljb24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgaWYgKHRvb2xzLmxlbmd0aCA9PT0gMCkgeyByZXR1cm47IH1cbiAgICBhZGRBY3Rpb25Ub29sKHRvb2xzLCAkYWN0aW9uV3JhcHBlciwgaWQpO1xuICB9KTtcbiAgJHRvb2xzSGVhZGVyLmFwcGVuZENoaWxkKCR0b29sc0hlYWRlckxhYmVsKTtcbiAgJHRvb2xzSGVhZGVyLmFwcGVuZENoaWxkKCR0b29sc0hlYWRlckljb24pO1xuICAkYWN0aW9uV3JhcHBlci5hcHBlbmRDaGlsZCgkdG9vbHNIZWFkZXIpO1xuXG4gIHJldHVybiAkYWN0aW9uV3JhcHBlcjtcbn1cblxuZnVuY3Rpb24gc2V0TmV4dFN0YXRlKHNvdXJjZSwgdGFyZ2V0LCBpZCwgaW5hY3RpdmUpIHtcbiAgaWYgKHNvdXJjZSA9PT0gdGFyZ2V0KSB7XG4gICAgY29uc29sZS53YXJuKCdUcnlpbmcgdG8gY29ubmVjdCB3aXRoIGl0c2VsZicpO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25uZWN0KHNvdXJjZSwgdGFyZ2V0KTtcbiAgcHVic3ViLnB1Ymxpc2goJ2FjdGlvbk5leHRTdGF0ZUNoYW5nZWQnLCB7IGlkLCBzdGF0ZUlkOiB0YXJnZXQgfSk7XG59XG5cbmZ1bmN0aW9uIGNvbm5lY3Qoc291cmNlLCB0YXJnZXQpIHtcbiAganNQbHVtYi5jb25uZWN0KHtcbiAgICBzb3VyY2U6IGBzdGF0ZS0ke3NvdXJjZX1gLFxuICAgIHRhcmdldDogYHN0YXRlLSR7dGFyZ2V0fWAsXG4gICAgYW5jaG9yOiBbICdQZXJpbWV0ZXInLCB7IHNoYXBlOiAnUmVjdGFuZ2xlJyB9XSxcbiAgICBlbmRwb2ludDogJ0JsYW5rJyxcbiAgICBjb25uZWN0b3I6IFsgJ0Zsb3djaGFydCcsIHsgc3R1YjogMCwgZ2FwOiAxMCwgY29ybmVyUmFkaXVzOiA1IH1dLFxuICAgIG92ZXJsYXlzOiBbXG4gICAgICBbICdBcnJvdycsIHsgd2lkdGg6IDEwLCBsZW5ndGg6IDEwLCBmb2xkYmFjazogMC43LCBsb2NhdGlvbjogMSB9XSxcbiAgICBdLFxuICAgIGRldGFjaGFibGU6IGZhbHNlLFxuICB9KTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQWN0aW9uVGltZU5vZGUoJHBhcmVudCwgaWQpIHtcbiAgY29uc3QgJGxhYmVsID0gbm9kZUZhY3RvcnkoJ2xhYmVsJywgeyB0ZXh0Q29udGVudDogJ9CS0YDQtdC80Y8g0LTQtdC50YHRgtCy0LjRjycgfSk7XG5cbiAgY29uc3QgJGlucHV0cyA9IG5vZGVGYWN0b3J5KCdkaXYnLCB7IGNsYXNzTGlzdDogWyAncGFuZWwtYWN0aW9uLXRpbWUtY29udHJvbHMnIF0gfSk7XG4gIGNvbnN0ICRpbnB1dE1pbiA9IG5vZGVGYWN0b3J5KCdpbnB1dCcsIHsgYXR0cnM6IHsgcGxhY2Vob2xkZXI6ICdtaW4nIH0gfSk7XG4gIGNvbnN0ICRpbnB1dE1heCA9IG5vZGVGYWN0b3J5KCdpbnB1dCcsIHsgYXR0cnM6IHsgcGxhY2Vob2xkZXI6ICdtYXgnIH0gfSk7XG5cbiAgY29uc3QgaGFuZGxlQ2hhbmdlID0gKCkgPT4ge1xuICAgIHB1YnN1Yi5wdWJsaXNoKCdhY3Rpb25UaW1lQ2hhbmdlZCcsIHtcbiAgICAgIGlkLFxuICAgICAgdGltZToge1xuICAgICAgICBtaW46IHBhcnNlSW50KCRpbnB1dE1pbi52YWx1ZSwgMTApLFxuICAgICAgICBtYXg6IHBhcnNlSW50KCRpbnB1dE1heC52YWx1ZSwgMTApLFxuICAgICAgfSxcbiAgICB9KTtcbiAgfTtcbiAgJGlucHV0TWluLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsICgpID0+IGhhbmRsZUNoYW5nZSgpKTtcbiAgJGlucHV0TWF4LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsICgpID0+IGhhbmRsZUNoYW5nZSgpKTtcblxuICAkaW5wdXRzLmFwcGVuZENoaWxkKCRpbnB1dE1pbik7XG4gICRpbnB1dHMuYXBwZW5kQ2hpbGQoJGlucHV0TWF4KTtcblxuICAkcGFyZW50LmFwcGVuZENoaWxkKCRsYWJlbCk7XG4gICRwYXJlbnQuYXBwZW5kQ2hpbGQoJGlucHV0cyk7XG59XG5cbi8qKlxuICogQWN0aW9uIHRvb2xzIERPTVxuICovXG5mdW5jdGlvbiBhZGRBY3Rpb25Ub29sKHRvb2xzLCAkcGFyZW50LCBpZCkge1xuICBjb25zdCAkd3JhcHBlciA9IG5vZGVGYWN0b3J5KCdkaXYnLCB7IGNsYXNzTGlzdDogWyAncGFuZWwtYWN0aW9uLXRvb2wnIF0gfSk7XG4gIGNvbnN0ICRzZWxlY3QgPSBub2RlRmFjdG9yeSgnc2VsZWN0Jyk7XG4gIGNvbnN0ICRkZWZhdWx0T3B0aW9uID0gbm9kZUZhY3RvcnkoJ29wdGlvbicsIHsgdGV4dENvbnRlbnQ6ICfQn9GA0LjQsdC+0YAnLCBhdHRyczogeyBzZWxlY3RlZDogdHJ1ZSwgZGlzYWJsZWQ6IHRydWUsIGhpZGRlbjogdHJ1ZSB9IH0pO1xuICAkc2VsZWN0LmFwcGVuZENoaWxkKCRkZWZhdWx0T3B0aW9uKTtcbiAgZmlsbFRvb2xzU2VsZWN0KCRzZWxlY3QsIHRvb2xzKTtcblxuICBjb25zdCAkaW5wdXRXcmFwcGVyID0gbm9kZUZhY3RvcnkoJ2RpdicsIHsgY2xhc3NMaXN0OiBbICdwYW5lbC1hY3Rpb24tdG9vbC12YWx1ZScgXSB9KTtcbiAgJHNlbGVjdC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCAoZSkgPT4ge1xuICAgIHB1YnN1Yi5wdWJsaXNoKCdhY3Rpb25Ub29sQ2hhbmdlZCcsIHsgaWQsIHRvb2xJZDogZS50YXJnZXQudmFsdWUgfSk7XG4gICAgY29uc3QgY3VycmVudE9wdGlvbiA9ICRzZWxlY3Qub3B0aW9uc1skc2VsZWN0LnNlbGVjdGVkSW5kZXhdO1xuICAgIGNvbnN0IHsgZGF0YXNldDogeyB0eXBlIH0sIHZhbHVlOiB0b29sSWQgfSA9IGN1cnJlbnRPcHRpb247XG4gICAgY29uc3QgJGlucHV0ID0gY3JlYXRlQWN0aW9uVG9vbElucHV0KHR5cGUsIHsgaWQsIHRvb2xJZCB9KTtcbiAgICAkaW5wdXRXcmFwcGVyLmlubmVySFRNTCA9ICcnO1xuICAgICRpbnB1dFdyYXBwZXIuYXBwZW5kQ2hpbGQoJGlucHV0KTtcbiAgfSk7XG5cbiAgJHdyYXBwZXIuYXBwZW5kQ2hpbGQoJHNlbGVjdCk7XG4gICR3cmFwcGVyLmFwcGVuZENoaWxkKCRpbnB1dFdyYXBwZXIpO1xuXG4gICRwYXJlbnQuYXBwZW5kQ2hpbGQoJHdyYXBwZXIpO1xufVxuXG5mdW5jdGlvbiBmaWxsVG9vbHNTZWxlY3QoJHNlbCwgdG9vbHMpIHtcbiAgdG9vbHMuZm9yRWFjaCgoeyB1dWlkLCBuYW1lLCB0eXBlIH0pID0+IHtcbiAgICBjb25zdCAkb3B0ID0gbm9kZUZhY3RvcnkoJ29wdGlvbicsIHsgYXR0cnM6IHsgdmFsdWU6IHV1aWQsICdkYXRhLXR5cGUnOiB0eXBlIH0sIHRleHRDb250ZW50OiBuYW1lIH0pO1xuICAgICRzZWwuYXBwZW5kQ2hpbGQoJG9wdCk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVBY3Rpb25Ub29sSW5wdXQodHlwZSwgaWRzKSB7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ3N3aXRjaCc6XG4gICAgICByZXR1cm4gY3JlYXRlU3dpdGNoSW5wdXQoaWRzKTtcbiAgICBjYXNlICdyYW5nZSc6XG4gICAgICByZXR1cm4gY3JlYXRlUmFuZ2VJbnB1dChpZHMpO1xuICAgIGRlZmF1bHQ6XG4gICAgICBjb25zb2xlLndhcm4oJ0ludmFsaWQgY3VycmVudCB0b29sIG9wdGlvbiBpbiBhY3Rpb24gY3JlYXRvcicpO1xuICAgICAgcmV0dXJuIG5vZGVGYWN0b3J5KCdkaXYnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVTd2l0Y2hJbnB1dCh7IGlkLCB0b29sSWQgfSkge1xuICAvLyB0b2RvIG1ha2UgSUQncyB1bmlxdWVcbiAgY29uc3QgJGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICBjb25zdCAkbGFiZWwgPSBub2RlRmFjdG9yeSgnbGFiZWwnLCB7IGF0dHJzOiB7IGZvcjogJ2FjdGlvbi10b29sLWNoZWNrYm94JyB9LCB0ZXh0Q29udGVudDogJ9CS0LrQu9GO0YfQtdC9PycgfSk7XG4gIGNvbnN0ICRpbnB1dCA9IG5vZGVGYWN0b3J5KCdpbnB1dCcsIHsgYXR0cnM6IHsgdHlwZTogJ2NoZWNrYm94JywgaWQ6ICdhY3Rpb24tdG9vbC1jaGVja2JveCcgfSB9KTtcblxuICAkaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgKCkgPT4ge1xuICAgIHB1YnN1Yi5wdWJsaXNoKCdhY3Rpb25Ub29sVmFsdWVDaGFuZ2VkJywgeyBpZCwgdG9vbElkLCB2YWx1ZTogJGlucHV0LmNoZWNrZWQgfSk7XG4gIH0pO1xuXG4gICRmcmFnbWVudC5hcHBlbmRDaGlsZCgkbGFiZWwpO1xuICAkZnJhZ21lbnQuYXBwZW5kQ2hpbGQoJGlucHV0KTtcblxuICByZXR1cm4gJGZyYWdtZW50O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVSYW5nZUlucHV0KHsgaWQsIHRvb2xJZCB9KSB7XG4gIGNvbnN0ICRmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgY29uc3QgJGlucHV0TWluID0gbm9kZUZhY3RvcnkoJ2lucHV0Jywge1xuICAgIGF0dHJzOiB7XG4gICAgICB0eXBlOiAndGV4dCcsXG4gICAgICBwbGFjZWhvbGRlcjogJ9Cc0LjQvdC40LzRg9C8JyxcbiAgICB9LFxuICB9KTtcblxuICBjb25zdCAkaW5wdXRNYXggPSBub2RlRmFjdG9yeSgnaW5wdXQnLCB7XG4gICAgYXR0cnM6IHtcbiAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgIHBsYWNlaG9sZGVyOiAn0JzQsNC60YHQuNC80YPQvCcsXG4gICAgfSxcbiAgfSk7XG5cbiAgY29uc3QgaGFuZGxlQ2hhbmdlID0gKCkgPT4ge1xuICAgIHB1YnN1Yi5wdWJsaXNoKCdhY3Rpb25Ub29sVmFsdWVDaGFuZ2VkJywge1xuICAgICAgaWQsXG4gICAgICB0b29sSWQsXG4gICAgICB2YWx1ZTogW1xuICAgICAgICBwYXJzZUludCgkaW5wdXRNaW4udmFsdWUsIDEwKSxcbiAgICAgICAgcGFyc2VJbnQoJGlucHV0TWF4LnZhbHVlLCAxMCksXG4gICAgICBdLFxuICAgIH0pO1xuICB9O1xuXG4gICRpbnB1dE1pbi5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCAoKSA9PiBoYW5kbGVDaGFuZ2UoKSk7XG4gICRpbnB1dE1heC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCAoKSA9PiBoYW5kbGVDaGFuZ2UoKSk7XG5cbiAgJGZyYWdtZW50LmFwcGVuZENoaWxkKCRpbnB1dE1pbik7XG4gICRmcmFnbWVudC5hcHBlbmRDaGlsZCgkaW5wdXRNYXgpO1xuXG4gIHJldHVybiAkZnJhZ21lbnQ7XG59XG5cbi8qKlxuICogSW5hY3RpdmUgYWN0aW9uIGNvbnN0cnVjdG9yXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVJbmFjdGl2ZUFjdGlvbihpZCwgeyBjdXJyZW50U3RhdGUsIHN0YXRlcyB9KSB7XG4gIGNvbnN0ICR3cmFwcGVyID0gbm9kZUZhY3RvcnkoJ2RpdicsIHsgY2xhc3NMaXN0OiBbICdwYW5lbC1hY3Rpb24nIF0gfSk7XG5cbiAgY29uc3QgJGxhYmVsID0gbm9kZUZhY3RvcnkoJ2xhYmVsJywgeyB0ZXh0Q29udGVudDogJ9Cf0LXRgNC10YXQvtC0INC/0YDQuCDQsdC10LfQtNC10LnRgdGC0LLQuNC4JyB9KTtcbiAgY29uc3QgJHNlbGVjdCA9IG5vZGVGYWN0b3J5KCdzZWxlY3QnLCB7IGNsYXNzTGlzdDogWyAnbmV4dC1zdGF0ZS1zZWxlY3QnIF0gfSk7XG4gIGNvbnN0ICRkZWZhdWx0T3B0aW9uID0gbm9kZUZhY3RvcnkoJ29wdGlvbicsIHtcbiAgICB0ZXh0Q29udGVudDogJ9Ch0L7RgdGC0L7Rj9C90LjQtScsXG4gICAgYXR0cnM6IHsgZGlzYWJsZWQ6IHRydWUsIGhpZGRlbjogdHJ1ZSwgc2VsZWN0ZWQ6IHRydWUgfSxcbiAgfSk7XG4gICRzZWxlY3QuYXBwZW5kQ2hpbGQoJGRlZmF1bHRPcHRpb24pO1xuXG4gIHN0YXRlcy5mb3JFYWNoKCh7IHV1aWQsIG5hbWUgfSkgPT4ge1xuICAgIGlmICh1dWlkID09PSBjdXJyZW50U3RhdGUpIHsgcmV0dXJuOyB9XG4gICAgY29uc3QgJG9wdGlvbiA9IG5vZGVGYWN0b3J5KCdvcHRpb24nLCB7IGF0dHJzOiB7IHZhbHVlOiB1dWlkIH0sIHRleHRDb250ZW50OiBuYW1lIH0pO1xuICAgICRzZWxlY3QuYXBwZW5kQ2hpbGQoJG9wdGlvbik7XG4gIH0pO1xuXG4gICRzZWxlY3QuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgKCkgPT4ge1xuICAgIGNvbnN0IG5leHRTdGF0ZSA9ICRzZWxlY3QudmFsdWU7XG4gICAgY29ubmVjdChjdXJyZW50U3RhdGUsIG5leHRTdGF0ZSk7XG4gICAgcHVic3ViLnB1Ymxpc2goJ2luYWN0aXZlQWN0aW9uU2V0JywgeyBpZCwgbmV4dFN0YXRlIH0pO1xuICB9KTtcblxuICAkd3JhcHBlci5hcHBlbmRDaGlsZCgkbGFiZWwpO1xuICAkd3JhcHBlci5hcHBlbmRDaGlsZCgkc2VsZWN0KTtcblxuICByZXR1cm4gJHdyYXBwZXI7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9jYWQvc2NlbmUvVUlGYWN0b3J5L2FjdGlvbi5qcyIsImltcG9ydCBwdWJzdWIgZnJvbSAnLi4vLi4vLi4vdXRpbHMvcHVic3ViJztcbmltcG9ydCBub2RlRmFjdG9yeSBmcm9tICcuLi8uLi8uLi91dGlscy9ub2RlRmFjdG9yeSc7XG5cbmZ1bmN0aW9uIGNyZWF0ZVBhcmFtZXRlcihpZCwgZGF0YSA9IHt9KSB7XG4gIGNvbnN0ICRwYXJhbVdyYXBwZXIgPSBub2RlRmFjdG9yeSgnZGl2JywgeyBjbGFzc0xpc3Q6IFsgJ3BhbmVsLXBhcmFtJyBdIH0pO1xuXG4gIGNvbnN0ICRuYW1lSW5wdXQgPSBub2RlRmFjdG9yeSgnaW5wdXQnLCB7XG4gICAgYXR0cnM6IHtcbiAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgIHBsYWNlaG9sZGVyOiAnTmFtZScsXG4gICAgICB2YWx1ZTogZGF0YS5uYW1lIHx8ICcnLFxuICAgIH0sXG4gIH0pO1xuICAkbmFtZUlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIChlKSA9PiB7XG4gICAgcHVic3ViLnB1Ymxpc2goJ3BhcmFtZXRlck5hbWVDaGFuZ2VkJywgeyBpZCwgbmFtZTogZS50YXJnZXQudmFsdWUgfSk7XG4gIH0pO1xuXG4gIGNvbnN0ICR2YWx1ZUlucHV0ID0gbm9kZUZhY3RvcnkoJ2lucHV0Jywge1xuICAgIGF0dHJzOiB7XG4gICAgICB0eXBlOiAndGV4dCcsXG4gICAgICBwbGFjZWhvbGRlcjogJ1ZhbHVlJyxcbiAgICAgIHZhbHVlOiBkYXRhLnZhbHVlIHx8ICcnLFxuICAgIH0sXG4gIH0pO1xuICAkdmFsdWVJbnB1dC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCAoZSkgPT4ge1xuICAgIHB1YnN1Yi5wdWJsaXNoKCdwYXJhbWV0ZXJWYWx1ZUNoYW5nZWQnLCB7IGlkLCB2YWx1ZTogcGFyc2VJbnQoZS50YXJnZXQudmFsdWUsIDEwKSB9KTtcbiAgfSk7XG5cbiAgJHBhcmFtV3JhcHBlci5hcHBlbmRDaGlsZCgkbmFtZUlucHV0KTtcbiAgJHBhcmFtV3JhcHBlci5hcHBlbmRDaGlsZCgkdmFsdWVJbnB1dCk7XG4gIHJldHVybiAkcGFyYW1XcmFwcGVyO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjcmVhdGVQYXJhbWV0ZXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9jYWQvc2NlbmUvVUlGYWN0b3J5L3BhcmFtZXRlci5qcyIsImltcG9ydCBub2RlRmFjdG9yeSBmcm9tICcuLi8uLi8uLi91dGlscy9ub2RlRmFjdG9yeSc7XG5pbXBvcnQgeyBERUZBVUxUX1NUQVRFX05BTUUgfSBmcm9tICcuLi8uLi9jb25maWcnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjcmVhdGVTdGF0ZShpZCkge1xuICBjb25zdCBub2RlSWQgPSBgc3RhdGUtJHtpZH1gO1xuICBjb25zdCAkbm9kZSA9IG5vZGVGYWN0b3J5KCdkaXYnLCB7IGNsYXNzTGlzdDogWyAnY2FkLXN0YXRlJyBdLCBhdHRyczogeyBpZDogbm9kZUlkIH0gfSk7XG4gIGNvbnN0ICRzdGF0ZU5hbWUgPSBub2RlRmFjdG9yeSgnaDUnLCB7IGNsYXNzTGlzdDogWyAnY2FkLXN0YXRlLW5hbWUnIF0sIHRleHRDb250ZW50OiBERUZBVUxUX1NUQVRFX05BTUUgfSk7XG4gICRub2RlLmFwcGVuZENoaWxkKCRzdGF0ZU5hbWUpO1xuICByZXR1cm4gJG5vZGU7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9jYWQvc2NlbmUvVUlGYWN0b3J5L3N0YXRlLmpzIiwiaW1wb3J0IHB1YnN1YiBmcm9tICcuLi8uLi8uLi91dGlscy9wdWJzdWInO1xuaW1wb3J0IG5vZGVGYWN0b3J5IGZyb20gJy4uLy4uLy4uL3V0aWxzL25vZGVGYWN0b3J5JztcblxuaW1wb3J0IHtcbiAgREVGQVVMVF9UT09MX05BTUUsXG4gIFRPT0xfVFlQRVMsXG4gIERFRkFVTFRfVE9PTF9UWVBFLFxufSBmcm9tICcuLi8uLi9jb25maWcnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjcmVhdGVUb29sKGlkKSB7XG4gIGNvbnN0ICR0b29sV3JhcHBlciA9IG5vZGVGYWN0b3J5KCdkaXYnLCB7IGNsYXNzTGlzdDogWyAncGFuZWwtdG9vbCcgXSB9KTtcbiAgY29uc3QgJG5hbWVMYWJlbCA9IG5vZGVGYWN0b3J5KCdsYWJlbCcsIHsgY2xhc3NMaXN0OiBbICdwYW5lbC10b29sLW5hbWUnIF0sIHRleHRDb250ZW50OiAn0J3QsNC30LLQsNC90LjQtSDQv9GA0LjQsdC+0YDQsCcgfSk7XG4gIGNvbnN0ICRuYW1lSW5wdXQgPSBub2RlRmFjdG9yeSgnaW5wdXQnLCB7IGF0dHJzOiB7IHR5cGU6ICd0ZXh0JywgdmFsdWU6IERFRkFVTFRfVE9PTF9OQU1FIH0gfSk7XG4gICRuYW1lSW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgKCkgPT4ge1xuICAgIHB1YnN1Yi5wdWJsaXNoKCd0b29sTmFtZUNoYW5nZWQnLCB7IGlkLCBuYW1lOiAkbmFtZUlucHV0LnZhbHVlIH0pO1xuICB9KTtcblxuICBjb25zdCAkdG9vbFR5cGVXcmFwcGVyID0gbm9kZUZhY3RvcnkoJ2RpdicsIHsgY2xhc3NMaXN0OiBbICdwYW5lbC10b29sLXR5cGUnIF0gfSk7XG4gIGNvbnN0ICR0b29sVHlwZUxhYmVsID0gbm9kZUZhY3RvcnkoJ2xhYmVsJywgeyB0ZXh0Q29udGVudDogJ9Ci0LjQvyDQv9GA0LjQsdC+0YDQsCcgfSk7XG4gIGNvbnN0ICR0b29sVHlwZVNlbGVjdCA9IG5vZGVGYWN0b3J5KCdzZWxlY3QnKTtcbiAgVE9PTF9UWVBFUy5mb3JFYWNoKCh0b29sVHlwZSkgPT4ge1xuICAgIGNvbnN0ICRvcHRpb24gPSBjcmVhdGVPcHRpb24odG9vbFR5cGUpO1xuICAgICR0b29sVHlwZVNlbGVjdC5hcHBlbmRDaGlsZCgkb3B0aW9uKTtcbiAgICBpZiAodG9vbFR5cGUgPT09IERFRkFVTFRfVE9PTF9UWVBFKSB7ICRvcHRpb24uc2VsZWN0ZWQgPSB0cnVlOyB9XG4gIH0pO1xuICBjb25zdCAkcmFuZ2VWYWx1ZXMgPSBjcmVhdGVSYW5nZVZhbHVlcyhpZCk7XG5cbiAgJHRvb2xUeXBlU2VsZWN0LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIChlKSA9PiB7XG4gICAgY29uc3QgdHlwZSA9IGUudGFyZ2V0LnZhbHVlO1xuICAgIHB1YnN1Yi5wdWJsaXNoKCd0b29sVHlwZUNoYW5nZWQnLCB7IGlkLCB0eXBlIH0pO1xuICAgIGlmICh0eXBlID09PSAncmFuZ2UnKSB7XG4gICAgICAkcmFuZ2VWYWx1ZXMuc3R5bGUuZGlzcGxheSA9ICdmbGV4JztcbiAgICB9IGVsc2Uge1xuICAgICAgJHJhbmdlVmFsdWVzLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgfVxuICB9KTtcbiAgJHRvb2xUeXBlV3JhcHBlci5hcHBlbmRDaGlsZCgkdG9vbFR5cGVMYWJlbCk7XG4gICR0b29sVHlwZVdyYXBwZXIuYXBwZW5kQ2hpbGQoJHRvb2xUeXBlU2VsZWN0KTtcblxuICAkdG9vbFdyYXBwZXIuYXBwZW5kQ2hpbGQoJG5hbWVMYWJlbCk7XG4gICR0b29sV3JhcHBlci5hcHBlbmRDaGlsZCgkbmFtZUlucHV0KTtcbiAgJHRvb2xXcmFwcGVyLmFwcGVuZENoaWxkKCR0b29sVHlwZVdyYXBwZXIpO1xuICAkdG9vbFdyYXBwZXIuYXBwZW5kQ2hpbGQoJHJhbmdlVmFsdWVzKTtcblxuICByZXR1cm4gJHRvb2xXcmFwcGVyO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVPcHRpb24odmFsdWUsIG5hbWUpIHtcbiAgcmV0dXJuIG5vZGVGYWN0b3J5KCdvcHRpb24nLCB7XG4gICAgdGV4dENvbnRlbnQ6IHZhbHVlLFxuICAgIGF0dHJzOiB7IG5hbWU6IG5hbWUgfHwgdmFsdWUgfSxcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVJhbmdlVmFsdWVzKGlkKSB7XG4gIGNvbnN0ICR3cmFwcGVyID0gbm9kZUZhY3RvcnkoJ2RpdicsIHsgY2xhc3NMaXN0OiBbICdwYW5lbC10b29sLXJhbmdlLXZhbHVlcycgXSB9KTtcblxuICBjb25zdCAkbWluSW5wdXQgPSBjcmVhdGVSYW5nZUlucHV0KCfQnNC40L3QuNC80YPQvCcpO1xuICAkd3JhcHBlci5hcHBlbmRDaGlsZCgkbWluSW5wdXQpO1xuXG4gIGNvbnN0ICRtYXhJbnB1dCA9IGNyZWF0ZVJhbmdlSW5wdXQoJ9Cc0LDQutGB0LjQvNGD0LwnKTtcbiAgJHdyYXBwZXIuYXBwZW5kQ2hpbGQoJG1heElucHV0KTtcblxuICBjb25zdCBoYW5kbGVWYWx1ZUNoYW5nZSA9ICgpID0+IHtcbiAgICBjb25zdCB2YWx1ZXMgPSB7XG4gICAgICBtaW46IHBhcnNlSW50KCRtaW5JbnB1dC5xdWVyeVNlbGVjdG9yKCdpbnB1dCcpLnZhbHVlLCAxMCksXG4gICAgICBtYXg6IHBhcnNlSW50KCRtYXhJbnB1dC5xdWVyeVNlbGVjdG9yKCdpbnB1dCcpLnZhbHVlLCAxMCksXG4gICAgfTtcbiAgICBwdWJzdWIucHVibGlzaCgndG9vbFJhbmdlQ2hhbmdlZCcsIHsgaWQsIHZhbHVlcyB9KTtcbiAgfTtcblxuICAkbWluSW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgKCkgPT4geyBoYW5kbGVWYWx1ZUNoYW5nZSgpOyB9KTtcbiAgJG1heElucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsICgpID0+IHsgaGFuZGxlVmFsdWVDaGFuZ2UoKTsgfSk7XG5cbiAgcmV0dXJuICR3cmFwcGVyO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVSYW5nZUlucHV0KG5hbWUpIHtcbiAgY29uc3QgJGRpdiA9IG5vZGVGYWN0b3J5KCdkaXYnKTtcbiAgY29uc3QgJGxhYmVsID0gbm9kZUZhY3RvcnkoJ2xhYmVsJywgeyB0ZXh0Q29udGVudDogbmFtZSB9KTtcbiAgY29uc3QgJGlucHV0ID0gbm9kZUZhY3RvcnkoJ2lucHV0JywgeyBhdHRyczogeyB0eXBlOiAndGV4dCcgfSB9KTtcblxuICAkZGl2LmFwcGVuZENoaWxkKCRsYWJlbCk7XG4gICRkaXYuYXBwZW5kQ2hpbGQoJGlucHV0KTtcblxuICByZXR1cm4gJGRpdjtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NhZC9zY2VuZS9VSUZhY3RvcnkvdG9vbC5qcyIsImltcG9ydCBwdWJzdWIgZnJvbSAnLi4vLi4vLi4vdXRpbHMvcHVic3ViJztcbmltcG9ydCBUb29sc01lbnUgZnJvbSAnLi90b29sc01lbnUnO1xuXG5jb25zdCAkbW9kZWxOYW1lID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI21vZGVsLW5hbWUtaW5wdXQnKTtcbmNvbnN0ICRicmVha1RpbWUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjYnJlYWstdGltZS1pbnB1dCcpO1xuY29uc3QgJHN0ZXBzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3N0ZXBzLWlucHV0Jyk7XG5cbiRtb2RlbE5hbWUuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgKCkgPT4geyBwdWJzdWIucHVibGlzaCgnbmFtZUNoYW5nZWQnLCAkbW9kZWxOYW1lLnZhbHVlKTsgfSk7XG4kYnJlYWtUaW1lLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsICgpID0+IHsgcHVic3ViLnB1Ymxpc2goJ2JyZWFrQ2hhbmdlZCcsIHBhcnNlSW50KCRicmVha1RpbWUudmFsdWUsIDEwKSk7IH0pO1xuJHN0ZXBzLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsICgpID0+IHsgcHVic3ViLnB1Ymxpc2goJ3N0ZXBzQ2hhbmdlZCcsIHBhcnNlSW50KCRzdGVwcy52YWx1ZSwgMTApKTsgfSk7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgaW5pdCh7IG5hbWUsIGJyZWFrVGltZSwgc3RlcHMgfSkge1xuICAgICRtb2RlbE5hbWUudmFsdWUgPSBuYW1lO1xuICAgICRicmVha1RpbWUudmFsdWUgPSBicmVha1RpbWU7XG4gICAgJHN0ZXBzLnZhbHVlID0gc3RlcHM7XG4gIH0sXG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vY2FkL3NjZW5lL21vZGVsX21lbnUvaW5kZXguanMiLCJpbXBvcnQgY3JlYXRlVG9vbCBmcm9tICcuLi9VSUZhY3RvcnkvdG9vbCc7XG5pbXBvcnQge1xuICBoYW5kbGVIZWFkZXJDbGljayxcbiAgaGFuZGxlQWRkQnRuQ2xpY2ssXG59IGZyb20gJy4uL3V0aWxzJztcblxuY29uc3QgJGhlYWRlciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwYW5lbC10b29scy1vcGVuJyk7XG5jb25zdCAkYWRkQnRuID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2FkZC10b29sLWJ0bicpO1xuY29uc3QgJHRvb2xzTGlzdCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwYW5lbC10b29scy1saXN0Jyk7XG5cbiRoZWFkZXIuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiBoYW5kbGVIZWFkZXJDbGljaygkaGVhZGVyLCAkdG9vbHNMaXN0KSk7XG4kYWRkQnRuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4gaGFuZGxlQWRkQnRuQ2xpY2soJGhlYWRlciwgJHRvb2xzTGlzdCwgY3JlYXRlVG9vbCwgJ3Rvb2xDcmVhdGVkJykpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vY2FkL3NjZW5lL21vZGVsX21lbnUvdG9vbHNNZW51LmpzIiwiaW1wb3J0IHV1aWQgZnJvbSAndXVpZC92NCc7XG5cbmltcG9ydCBwdWJzdWIgZnJvbSAnLi4vLi4vLi4vdXRpbHMvcHVic3ViJztcbmltcG9ydCB7IGNyZWF0ZUFjdGlvbiwgY3JlYXRlSW5hY3RpdmVBY3Rpb24gfSBmcm9tICcuLi9VSUZhY3RvcnkvYWN0aW9uJztcbmltcG9ydCB7XG4gIGhhbmRsZUhlYWRlckNsaWNrLFxufSBmcm9tICcuLi91dGlscyc7XG5cbmNvbnN0ICRoZWFkZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncGFuZWwtYWN0aW9ucy1vcGVuJyk7XG5jb25zdCAkYWRkQnRuID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2FkZC1hY3Rpb24tYnRuJyk7XG5jb25zdCAkYWN0aW9uc0xpc3QgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncGFuZWwtYWN0aW9ucy1saXN0Jyk7XG5cbiRoZWFkZXIuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiBoYW5kbGVIZWFkZXJDbGljaygkaGVhZGVyLCAkYWN0aW9uc0xpc3QpKTtcbiRhZGRCdG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gIHB1YnN1Yi5wdWJsaXNoKCdzY2hlbWVEYXRhUmVxdWVzdGVkJywgeyBuZXdBY3Rpb246IHRydWUgfSk7XG4gICRhY3Rpb25zTGlzdC5jbGFzc0xpc3QucmVtb3ZlKCdpcy1oaWRkZW4nKTtcbiAgJGhlYWRlci5xdWVyeVNlbGVjdG9yKCcuaWNvbicpLnN0eWxlLnRyYW5zZm9ybSA9ICdyb3RhdGUoOTBkZWcpJztcbn0pO1xuXG5wdWJzdWIuc3Vic2NyaWJlKCdzY2hlbWVEYXRhU2VudCcsIChkYXRhKSA9PiB7XG4gIGlmIChkYXRhLm5ld0FjdGlvbikge1xuICAgIGNvbnN0IGlkID0gdXVpZCgpO1xuICAgIGNvbnN0ICRhY3Rpb25Ob2RlID0gY3JlYXRlQWN0aW9uKGlkLCBkYXRhKTtcbiAgICAkYWN0aW9uc0xpc3QuYXBwZW5kQ2hpbGQoJGFjdGlvbk5vZGUpO1xuICAgIHB1YnN1Yi5wdWJsaXNoKCdhY3Rpb25DcmVhdGVkJywgaWQpO1xuXG4gICAgY29uc3QgaW5hY3RpdmVJZCA9IHV1aWQoKTtcbiAgICAkYWN0aW9uc0xpc3QuYXBwZW5kQ2hpbGQoY3JlYXRlSW5hY3RpdmVBY3Rpb24oaW5hY3RpdmVJZCwgZGF0YSkpO1xuICAgIHB1YnN1Yi5wdWJsaXNoKCdhY3Rpb25DcmVhdGVkJywgaW5hY3RpdmVJZCk7XG4gIH0gZWxzZSB7XG4gICAgZGF0YS5hY3Rpb25zLmZvckVhY2goKGFjdGlvbikgPT4ge1xuICAgICAgY29uc3QgJGFjdGlvbk5vZGUgPSBjcmVhdGVBY3Rpb24oYWN0aW9uLmlkLCBkYXRhKTtcbiAgICAgICRhY3Rpb25zTGlzdC5hcHBlbmRDaGlsZCgkYWN0aW9uTm9kZSk7XG4gICAgfSk7XG4gIH1cbn0pO1xuXG5jb25zdCBBY3Rpb25zTWVudSA9IHtcbiAgc2V0KGFjdGlvbnMpIHtcbiAgICAkYWN0aW9uc0xpc3QuaW5uZXJIVE1MID0gJyc7XG4gICAgcHVic3ViLnB1Ymxpc2goJ3NjaGVtZURhdGFSZXF1ZXN0ZWQnLCB7IG5ld0FjdGlvbjogZmFsc2UsIGFjdGlvbnMgfSk7XG4gIH0sXG59O1xuXG5leHBvcnQgZGVmYXVsdCBBY3Rpb25zTWVudTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NhZC9zY2VuZS9zdGF0ZV9tZW51L2FjdGlvbnNNZW51LmpzIiwiaW1wb3J0IHB1YnN1YiBmcm9tICcuLi8uLi8uLi91dGlscy9wdWJzdWInO1xuXG5jb25zdCAkbmFtZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdldmVudC1uYW1lLWlucHV0Jyk7XG5jb25zdCAkZGVzYyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdldmVudC1kZXNjcmlwdGlvbi1pbnB1dCcpO1xuXG4kbmFtZS5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCAoKSA9PiB7XG4gIHB1YnN1Yi5wdWJsaXNoKCdldmVudE5hbWVDaGFuZ2VkJywgJG5hbWUudmFsdWUpO1xufSk7XG5cbiRkZXNjLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsICgpID0+IHtcbiAgcHVic3ViLnB1Ymxpc2goJ2V2ZW50RGVzY0NoYW5nZWQnLCAkZGVzYy52YWx1ZSk7XG59KTtcblxuY29uc3QgRXZlbnRNZW51ID0ge1xuICBzZXQoeyBuYW1lLCBkZXNjIH0pIHtcbiAgICAkbmFtZS52YWx1ZSA9IG5hbWU7XG4gICAgJGRlc2MudmFsdWUgPSBkZXNjO1xuICB9LFxufTtcblxuZXhwb3J0IGRlZmF1bHQgRXZlbnRNZW51O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vY2FkL3NjZW5lL3N0YXRlX21lbnUvZXZlbnRNZW51LmpzIiwiaW1wb3J0IHB1YnN1YiBmcm9tICcuLi8uLi8uLi91dGlscy9wdWJzdWInO1xuXG5pbXBvcnQgRXZlbnRNZW51IGZyb20gJy4vZXZlbnRNZW51JztcbmltcG9ydCBQYXJhbWV0ZXJzTWVudSBmcm9tICcuL3BhcmFtZXRlcnNNZW51JztcbmltcG9ydCBBY3Rpb25zTWVudSBmcm9tICcuL2FjdGlvbnNNZW51JztcblxuY29uc3QgJG5hbWVJbnB1dCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzdGF0ZS1uYW1lLWlucHV0Jyk7XG4kbmFtZUlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsICgpID0+IHtcbiAgcHVic3ViLnB1Ymxpc2goJ3N0YXRlTmFtZUNoYW5nZWQnLCAkbmFtZUlucHV0LnZhbHVlKTtcbn0pO1xuXG5jb25zdCAkaW1hZ2VTZWxlY3QgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnaW1hZ2Utc2VsZWN0Jyk7XG4kaW1hZ2VTZWxlY3QuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgKCkgPT4ge1xuICBwdWJzdWIucHVibGlzaCgnc3RhdGVJbWFnZUNoYW5nZWQnLCAkaW1hZ2VTZWxlY3QudmFsdWUpO1xufSk7XG5cbmNvbnN0ICRpbml0aWFsU3RhdGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnaW5pdGlhbC1zdGF0ZS1jaGVja2JveCcpO1xuXG5cbmNvbnN0IFN0YXRlTWVudSA9IHtcbiAgc2V0KHN0YXRlKSB7XG4gICAgJG5hbWVJbnB1dC52YWx1ZSA9IHN0YXRlLm5hbWU7XG4gICAgJGltYWdlU2VsZWN0LnZhbHVlID0gc3RhdGUuaW1nO1xuICAgICRpbml0aWFsU3RhdGUuY2hlY2tlZCA9IGZhbHNlO1xuICAgICRpbml0aWFsU3RhdGUub25jbGljayA9ICgpID0+IHtcbiAgICAgIGlmICgkaW5pdGlhbFN0YXRlLmNoZWNrZWQpIHsgcHVic3ViLnB1Ymxpc2goJ2luaXRpYWxTdGF0ZUNoYW5nZWQnLCBzdGF0ZS51dWlkKTsgfVxuICAgIH07XG4gICAgRXZlbnRNZW51LnNldChzdGF0ZS5ldmVudCk7XG4gICAgUGFyYW1ldGVyc01lbnUuc2V0KHN0YXRlLnBhcmFtZXRlcnMpO1xuICAgIEFjdGlvbnNNZW51LnNldChzdGF0ZS5hY3Rpb25zKTtcbiAgfSxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFN0YXRlTWVudTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NhZC9zY2VuZS9zdGF0ZV9tZW51L2luZGV4LmpzIiwiaW1wb3J0IGNyZWF0ZVBhcmFtZXRlciBmcm9tICcuLi9VSUZhY3RvcnkvcGFyYW1ldGVyJztcbmltcG9ydCB7XG4gIGhhbmRsZUhlYWRlckNsaWNrLFxuICBoYW5kbGVBZGRCdG5DbGljayxcbn0gZnJvbSAnLi4vdXRpbHMnO1xuXG5jb25zdCAkaGVhZGVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3BhbmVsLXBhcmFtcy1vcGVuJyk7XG5jb25zdCAkYWRkQnRuID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2FkZC1wYXJhbS1idG4nKTtcbmNvbnN0ICRwYXJhbWV0ZXJzTGlzdCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwYW5lbC1wYXJhbXMtbGlzdCcpO1xuXG4kaGVhZGVyLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4gaGFuZGxlSGVhZGVyQ2xpY2soJGhlYWRlciwgJHBhcmFtZXRlcnNMaXN0KSk7XG4kYWRkQnRuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4gaGFuZGxlQWRkQnRuQ2xpY2soJGhlYWRlciwgJHBhcmFtZXRlcnNMaXN0LCBjcmVhdGVQYXJhbWV0ZXIsICdwYXJhbWV0ZXJDcmVhdGVkJykpO1xuXG5jb25zdCBQYXJhbWV0ZXJzTWVudSA9IHtcbiAgc2V0KHBhcmFtZXRlcnMpIHtcbiAgICAkcGFyYW1ldGVyc0xpc3QuaW5uZXJIVE1MID0gJyc7XG4gICAgcGFyYW1ldGVycy5mb3JFYWNoKHAgPT4gJHBhcmFtZXRlcnNMaXN0LmFwcGVuZENoaWxkKGNyZWF0ZVBhcmFtZXRlcihwLmlkLCBwKSkpO1xuICB9LFxufTtcblxuZXhwb3J0IGRlZmF1bHQgUGFyYW1ldGVyc01lbnU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9jYWQvc2NlbmUvc3RhdGVfbWVudS9wYXJhbWV0ZXJzTWVudS5qcyIsIi8qKlxuICogQ29udmVydCBhcnJheSBvZiAxNiBieXRlIHZhbHVlcyB0byBVVUlEIHN0cmluZyBmb3JtYXQgb2YgdGhlIGZvcm06XG4gKiBYWFhYWFhYWC1YWFhYLVhYWFgtWFhYWC1YWFhYWFhYWFhYWFhcbiAqL1xudmFyIGJ5dGVUb0hleCA9IFtdO1xuZm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7ICsraSkge1xuICBieXRlVG9IZXhbaV0gPSAoaSArIDB4MTAwKS50b1N0cmluZygxNikuc3Vic3RyKDEpO1xufVxuXG5mdW5jdGlvbiBieXRlc1RvVXVpZChidWYsIG9mZnNldCkge1xuICB2YXIgaSA9IG9mZnNldCB8fCAwO1xuICB2YXIgYnRoID0gYnl0ZVRvSGV4O1xuICByZXR1cm4gYnRoW2J1ZltpKytdXSArIGJ0aFtidWZbaSsrXV0gK1xuICAgICAgICAgIGJ0aFtidWZbaSsrXV0gKyBidGhbYnVmW2krK11dICsgJy0nICtcbiAgICAgICAgICBidGhbYnVmW2krK11dICsgYnRoW2J1ZltpKytdXSArICctJyArXG4gICAgICAgICAgYnRoW2J1ZltpKytdXSArIGJ0aFtidWZbaSsrXV0gKyAnLScgK1xuICAgICAgICAgIGJ0aFtidWZbaSsrXV0gKyBidGhbYnVmW2krK11dICsgJy0nICtcbiAgICAgICAgICBidGhbYnVmW2krK11dICsgYnRoW2J1ZltpKytdXSArXG4gICAgICAgICAgYnRoW2J1ZltpKytdXSArIGJ0aFtidWZbaSsrXV0gK1xuICAgICAgICAgIGJ0aFtidWZbaSsrXV0gKyBidGhbYnVmW2krK11dO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJ5dGVzVG9VdWlkO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gWjovd2ViL3Byb2plY3RzL2xway9+L3V1aWQvbGliL2J5dGVzVG9VdWlkLmpzXG4vLyBtb2R1bGUgaWQgPSA0NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBVbmlxdWUgSUQgY3JlYXRpb24gcmVxdWlyZXMgYSBoaWdoIHF1YWxpdHkgcmFuZG9tICMgZ2VuZXJhdG9yLiAgSW4gdGhlXG4vLyBicm93c2VyIHRoaXMgaXMgYSBsaXR0bGUgY29tcGxpY2F0ZWQgZHVlIHRvIHVua25vd24gcXVhbGl0eSBvZiBNYXRoLnJhbmRvbSgpXG4vLyBhbmQgaW5jb25zaXN0ZW50IHN1cHBvcnQgZm9yIHRoZSBgY3J5cHRvYCBBUEkuICBXZSBkbyB0aGUgYmVzdCB3ZSBjYW4gdmlhXG4vLyBmZWF0dXJlLWRldGVjdGlvblxudmFyIHJuZztcblxudmFyIGNyeXB0byA9IGdsb2JhbC5jcnlwdG8gfHwgZ2xvYmFsLm1zQ3J5cHRvOyAvLyBmb3IgSUUgMTFcbmlmIChjcnlwdG8gJiYgY3J5cHRvLmdldFJhbmRvbVZhbHVlcykge1xuICAvLyBXSEFUV0cgY3J5cHRvIFJORyAtIGh0dHA6Ly93aWtpLndoYXR3Zy5vcmcvd2lraS9DcnlwdG9cbiAgdmFyIHJuZHM4ID0gbmV3IFVpbnQ4QXJyYXkoMTYpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4gIHJuZyA9IGZ1bmN0aW9uIHdoYXR3Z1JORygpIHtcbiAgICBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKHJuZHM4KTtcbiAgICByZXR1cm4gcm5kczg7XG4gIH07XG59XG5cbmlmICghcm5nKSB7XG4gIC8vIE1hdGgucmFuZG9tKCktYmFzZWQgKFJORylcbiAgLy9cbiAgLy8gSWYgYWxsIGVsc2UgZmFpbHMsIHVzZSBNYXRoLnJhbmRvbSgpLiAgSXQncyBmYXN0LCBidXQgaXMgb2YgdW5zcGVjaWZpZWRcbiAgLy8gcXVhbGl0eS5cbiAgdmFyIHJuZHMgPSBuZXcgQXJyYXkoMTYpO1xuICBybmcgPSBmdW5jdGlvbigpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgcjsgaSA8IDE2OyBpKyspIHtcbiAgICAgIGlmICgoaSAmIDB4MDMpID09PSAwKSByID0gTWF0aC5yYW5kb20oKSAqIDB4MTAwMDAwMDAwO1xuICAgICAgcm5kc1tpXSA9IHIgPj4+ICgoaSAmIDB4MDMpIDw8IDMpICYgMHhmZjtcbiAgICB9XG5cbiAgICByZXR1cm4gcm5kcztcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBybmc7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBaOi93ZWIvcHJvamVjdHMvbHBrL34vdXVpZC9saWIvcm5nLWJyb3dzZXIuanNcbi8vIG1vZHVsZSBpZCA9IDQ2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBnO1xyXG5cclxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcclxuZyA9IChmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpcztcclxufSkoKTtcclxuXHJcbnRyeSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXHJcblx0ZyA9IGcgfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpIHx8ICgxLGV2YWwpKFwidGhpc1wiKTtcclxufSBjYXRjaChlKSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcclxuXHRpZih0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKVxyXG5cdFx0ZyA9IHdpbmRvdztcclxufVxyXG5cclxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxyXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xyXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGc7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qc1xuLy8gbW9kdWxlIGlkID0gNDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IGFqYXggZnJvbSAnLi4vdXRpbHMvYWpheCc7XG5cbmNvbnN0IEFQSSA9IHtcbiAgc2VuZE1vZGVsKG1vZGVsKSB7XG4gICAgcmV0dXJuIGFqYXgoJy9jYWQvbW9kZWxzLycsIHtcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgZGF0YTogbW9kZWwsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgICdDb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICB9LFxuICAgIH0pO1xuICB9LFxufTtcblxuZXhwb3J0IGRlZmF1bHQgQVBJO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vY2FkL2FwaS5qcyJdLCJzb3VyY2VSb290IjoiIn0=